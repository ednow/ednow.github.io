<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ednow">
<meta property="og:url" content="http://ednow.github.io/index/page/8/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ednow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ednow.github.io/index/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch6-%E6%80%BB%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch6-%E6%80%BB%E7%BA%BF/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch6-总线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 10:00:19" itemprop="dateCreated datePublished" datetime="2021-06-30T10:00:19+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 20:24:13" itemprop="dateModified" datetime="2021-07-18T20:24:13+08:00">2021-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>【考纲内容】</p>
<p>(一）总线概述</p>
<p>总线的基本概念;总线的分类;总线的组成及性能指标</p>
<p>(二）总线操作和定时</p>
<p>同步定时方式;异步定时方式</p>
<p>(三)总线标准</p>
<p>【复习提示】</p>
<p>本章的知识点较少，其中总线仲裁及总线操作和定时方式是难点。本章内容通常以选择题的形式出现，特别是系统总线的特点、性能指标、各种仲裁方式的特点、异步定时方式及常见的总线标准和特点等。总线带宽的计算也可能结合其他章节出综合题。</p>
<p>在学习本章时，请读者思考以下问题:</p>
<p>1)引入总线结构有什么好处?</p>
<p>2）引入总线结构会导致什么问题?如何解决?</p>
<p>请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。</p>
<h3 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h3><p>随着计算机的发展和应用领域的不断扩大，IO 设备的种类和数量也越来越多。为了更好地解决IO设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。为了进一步简化设计，又提出了各类总线标准。</p>
<h4 id="总线基本概念"><a href="#总线基本概念" class="headerlink" title="总线基本概念"></a>总线基本概念</h4><h5 id="总线的定义"><a href="#总线的定义" class="headerlink" title="总线的定义"></a>总线的定义</h5><p>总线是一组能为多个部件分时共享的公共信息传送线路。分时和共享是总线的两个特点。</p>
<p>分时是指同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息。</p>
<p>共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享。在某一时刻只允许有一个部件向总线发送信息，但多个部件可同时从总线上接收相同的信息。</p>
<h5 id="总线设备"><a href="#总线设备" class="headerlink" title="总线设备"></a>总线设备</h5><p>总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种。</p>
<p>主设备:总线的主设备是指获得总线控制权的设备。</p>
<p>从设备:总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。</p>
<h5 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h5><p>总线特性是指机械特性（尺寸、形状)、电气特性（传输方向和有效的电平范围)、功能特性（每根传输线的功能）和时间特性（信号和时序的关系)。</p>
<h5 id="总线的猝发传输方式"><a href="#总线的猝发传输方式" class="headerlink" title="总线的猝发传输方式"></a>总线的猝发传输方式</h5><p>在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为猝发传送。.</p>
<h4 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h4><p>计算机系统中的总线，按功能划分为以下3类。</p>
<h5 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h5><p>片内总线是芯片内部的总线，它是CPU 芯片内部寄存器与寄存器之间、寄存器与ALU 之间的公共连接线。</p>
<h5 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h5><p>系统总线是计算机系统内各功能部件(CPU、主存、I/O接口)之间相互连接的总线。按系统总线传输信息内容的不同，又可分为3类:数据总线、地址总线和控制总线。</p>
<p>1）数据总线用来传输各功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关。</p>
<p>2）地址总线用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址，它是单向传输总线，地址总线的位数与主存地址空间的大小有关。</p>
<p>3)控制总线传输的是控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信号。</p>
<blockquote>
<p>注意区分数据通路和数据总线:各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流经的路径，而数据总线是承载的媒介。</p>
</blockquote>
<h5 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h5><p>通信总线是在计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。</p>
<p>此外，按时序控制方式可将总线划分为同步总线和异步总线，还可按数据传输格式将总线划分为并行总线和串行总线。</p>
<h4 id="系统总线的结构"><a href="#系统总线的结构" class="headerlink" title="系统总线的结构"></a>系统总线的结构</h4><p>总线结构通常分为单总线结构、双总线结构和三总线结构等。</p>
<h5 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h5><p>单总线结构将CPU、主存、IO设备（通过IO接口）都挂在一组总线上，允许IO设备之间、IO设备与主存之间直接交换信息，如图6.1所示。CPU与主存、CPU与外设之间可直接进行信息交换，而无须经过中间设备的干预。</p>
<p>注意，单总线并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。</p>
<p>优点:结构简单，成本低，易于接入新的设备;缺点:带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。</p>
<h5 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h5><p>双总线结构有两条总线:一条是主存总线，用于在CPU、主存和通道之间传送数据;另一条是IO总线，用于在多个外部设备与通道之间传送数据，如图6.2所示。</p>
<p>优点:将低速IO设备从单总线上分离出来，实现了存储器总线和IO总线分离。缺点:需要增加通道等硬件设备。</p>
<h5 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h5><p>三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为主存总线、IO总线和直接内存访问（DMA)总线，如图6.3所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716190047.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716190047.png';" /></details>

<p>主存总线用于在CPU和内存之间传送地址、数据和控制信息。IO总线用于在CPU和各类外设之间通信。DMA总线用于在内存和高速外设之间直接传送数据。</p>
<p>优点:提高了IO设备的性能，使其更快地响应命令，提高系统吞吐量。缺点:系统工作效率较低。</p>
<h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4><p>1）总线的传输周期。指一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段)，简称总线周期。总线传输周期通常由若干总线时钟周期构成。</p>
<p>2）总线时钟周期。即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。</p>
<p>3）总线的工作频率。总线上各种操作的频率，为总线周期的倒数。实际上指1秒内传送几次数据。若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。</p>
<p>4）总线的时钟频率。即机器的时钟频率，它为时钟周期的倒数。</p>
<p>5）总线宽度。又称总线位宽，它是总线上同时能够传输的数据位数，通常指数据总线的根数，如32根称为32位总线。</p>
<p>6）总线带宽。可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。总线带宽=总线工作频率×(总线宽度/8)。</p>
<blockquote>
<p>注意:总线带宽和总线宽度应加以区别。</p>
</blockquote>
<p>7)总线复用。总线复用是指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。</p>
<p>8）信号线数。地址总线、数据总线和控制总线3种总线数的总和称为信号线数。其中，总线的最主要性能指标为总线宽度、总线（工作）频率、总线带宽，总线带宽是指总线本身所能达到的最高传输速率，它是衡量总线性能的重要指标。</p>
<p>三者关系:总线带宽=总线宽度×总线频率。</p>
<p>例如，总线工作频率为22MHz，总线宽度为16位，则总线带宽=22×(16/8)=44MB/s。</p>
<h3 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="*总线仲裁"></a>*总线仲裁</h3><p>为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权。只有获得了总线控制权的设备，才能开始传送数据。</p>
<p>总线仲裁方式按其仲裁控制机构的设置可分为集中仲裁方式和分布仲裁方式两种。</p>
<h4 id="集中仲裁方式"><a href="#集中仲裁方式" class="headerlink" title="集中仲裁方式"></a>集中仲裁方式</h4><p>总线控制逻辑基本上集中于一个设备（如CPU)中。将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决，称为集中仲裁方式。集中仲裁方式有链式查询方式、计数器定时查询方式和独立请求方式三种。</p>
<h5 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h5><p>链式查询方式如图6.4所示。总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器。由总线控制器检查总线是否忙，若总线不忙，则立即发总线响应信号，经总线响应线BG串行地从一个部件传送到下一个部件，依次查询。若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件;若响应信号到达的部件有总线请求，则信号被截住，不再传下去。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716190533.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716190533.png';" /></details>

<p>在链式查询中，部件离总线控制器越近，其优先级越高;部件离总线控制器越远，其优先级越低。</p>
<p>优点:链式查询方式优先级固定。此外，只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。</p>
<p>缺点:对硬件电路的故障敏感，且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线。</p>
<h5 id="计数器定时查询方式"><a href="#计数器定时查询方式" class="headerlink" title="计数器定时查询方式"></a>计数器定时查询方式</h5><p>计数器定时查询方式如图6.5所示。它采用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线，少了一根总线响应线BG。它仍共用一根总线请求线，当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时中止计数器的计数及查询。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716190741.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716190741.png';" /></details>

<p>优点:计数可从“0”开始，此时一旦设备的优先次序被固定，设备的优先级就按0,1,$\cdots$,n的顺序降序排列，而且固定不变;计数也可从上一次的终点开始，即采用一种循环方法，此时设备使用总线的优先级相等;计数器的初值还可由程序设置，因此优先次序可以改变，且这种方式对电路的故障没有链式查询方式敏感。</p>
<p>缺点:增加了控制线数（若设备有n个，则大致需要 $\lceil log_2n \rceil$+2条控制线)，控制也比相对链式查询要复杂。</p>
<h5 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h5><p>独立请求方式如图6.6所示。每个设备均有一对总线请求线BR,和总线允许线BG;。当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队，当总线控制器按一定的优先次序决定批准某个部件的请求时，给该部件发送总线响应信号，该部件接到此信号后就获得了总线使用权，开始传送数据。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716191554.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716191554.png';" /></details>

<p>优点:响应速度快，总线允许信号BG直接从控制器发送到有关设备，而不必在设备间传递或查询,而且对优先次序的控制相当灵活。</p>
<p>缺点:控制线数量多（设备有n个，需要2n+1条控制线，其中加的那条控制线为BS线，基作用是让设备向总线控制部件反馈已使用完总线)，总线控制逻辑更复杂。<br>为方便记忆，下面归纳了3种集中仲裁方式的区别与联系（假设设备有n 个)，如表6.1所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716191643.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716191643.png';" /></details>

<h4 id="分布仲裁方式"><a href="#分布仲裁方式" class="headerlink" title="分布仲裁方式"></a>分布仲裁方式</h4><p>分布仲裁方式不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器。当它们有总线请求时，就会把它们各自唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较。若仲裁总线上的仲裁号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。</p>
<h3 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h3><p>总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则，主要有同步和异步两种基本定时方式。</p>
<h4 id="总线传输的4个阶段"><a href="#总线传输的4个阶段" class="headerlink" title="总线传输的4个阶段"></a>总线传输的4个阶段</h4><p>一个总线周期通常可分为以下4个阶段:</p>
<p>1）申请分配阶段。由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为传输请求和总线仲裁两个阶段。</p>
<p>2）寻址阶段。取得使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。</p>
<p>3）传输阶段。主模块和从模块进行数据交换，可单向或双向进行数据传送。</p>
<p>4）结束阶段。主模块的有关信息均从系统总线上撤除，让出总线使用权。</p>
<h4 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h4><p>所谓同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。</p>
<p>优点:传送速度快，具有较高的传输速率;总线控制逻辑简单。</p>
<p>缺点:主从设备属于强制性同步;不能及时进行数据通信的有效性检验，可靠性较差。</p>
<p>同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。</p>
<h4 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h4><p>在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备;从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</p>
<p>优点:总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。</p>
<p>缺点:比同步控制方式稍复杂一些，速度比同步定时方式慢。</p>
<p>根据“请求”和“回答”信号的撤销是否互锁，异步定时方式又分为以下3种类型。</p>
<p>1)不互锁方式。主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间后自动撤销“回答”信号。双方不存在互锁关系，如图6.7(a)所示。</p>
<p>2）半互锁方式。主设备发出“请求”信号后，必须在接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。半互锁方式如图6.7(b)所示。</p>
<p>3）全互锁方式。主设备发出“请求”信号后，必须在从设备“回答”后才撤销“请求”信号;从设备发出“回答”信号后，必须在获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系，如图6.7(c)所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716191950.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716191950.png';" /></details>

<h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><p>总线标准是国际上公布或推荐的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范。按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。</p>
<h4 id="常见的总线标准"><a href="#常见的总线标准" class="headerlink" title="常见的总线标准"></a>常见的总线标准</h4><p>目前，典型的总线标准有ISA、EISA、VESA、PCI、PCI-Express、AGP、RS-232C、USB等。它们的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。</p>
<p>1)ISA。ISA (Industry Standard Architecture，工业标准体系结构）总线是最早出现的微型计算机的系统总线，应用在IBM的AT机上。</p>
<p>2）EISA。EISA (Extended Industry Standard Architecture，扩展的ISA）总线是为配合32位CPU而设计的扩展总线，EISA对ISA完全兼容。</p>
<p>3）VESA。VESA (Video Electronics Standards Association，视频电子标准协会）总线是一个32位标准的计算机局部总线，是针对多媒体PC要求高速传送活动图像的大量数据应运而生的。</p>
<ol start="4">
<li>PCI。PCI (Peripheral Component Interconnect，外部设备互连）总线是高性能的32位或64 位总线，是专为高度集成的外围部件、扩充插板和处理器/存储器系统设计的互连机制。目前常用的PCI适配器有显卡、声卡、网卡等。PCI总线支持即插即用。PCI总线是一个与处理器时钟频率无关的高速外围总线，属于局部总线。PCI总线可通过桥连接实现多层PCI总线。</li>
</ol>
<p>5)PCI-Express (PCI-E)。PCI-Express是最新的总线和接口标准，它将全面取代现行的PCI和AGP，最终统一总线标准。</p>
<p>6）AGP。AGP (Accelerated Graphics Port，加速图形接口）是一种视频接口标准，专用于连接主存和图形存储器，属于局部总线。AGP技术为传输视频和三维图形数据提供了切实可行的解决方案。</p>
<ol start="7">
<li>RS-232C。RS-232C (Recommended Standard，RS）是由美国电子工业协会（EIA）推荐的一种串行通信总线，是应用于串行二进制交换的数据终端设备（DTE）和数据通信设备(DCE）之间的标准接口。</li>
</ol>
<p>8）USB。USB (Universal Serial Bus，通用串行总线）是一种连接外部设备的IO总线，属于设备总线。具有即插即用、热插拔等优点，有很强的连接能力。</p>
<p>9)PCMCIA。PCMCIA (Personal Computer Memory Card International Association）是广泛应用于笔记本电脑的一种接口标准，是一个用于扩展功能的小型插槽。PCMCIA具有即插即用功能。</p>
<p>10）IDE。IDE (Integrated Drive Electronics，集成设备电路)，更准确地称为ATA，是一种IDE接口磁盘驱动器接口类型，硬盘和光驱通过IDE接口与主板连接。</p>
<p>11)SCSI。SCSI (Small Computer System Interface，小型计算机系统接口）是一种用于计算机和智能设备之间（硬盘、软驱、光驱、打印机等）系统级接口的独立处理器标准。SCSI是一种智能的通用接口标准。</p>
<p>12)SATA。SATA (Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和 Seagate公司共同提出的硬盘接口规范。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch5-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch5-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch5-中央处理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 10:00:10" itemprop="dateCreated datePublished" datetime="2021-06-30T10:00:10+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-18 20:24:12" itemprop="dateModified" datetime="2021-07-18T20:24:12+08:00">2021-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><p>p202</p>
<p>【考纲内容】</p>
<p>(一）CPU的功能和基本结构</p>
<p>(二）指令执行过程</p>
<p>(三）数据通路的功能和基本结构</p>
<p>(四）控制器的功能和工作原理</p>
<p>硬布线控制器</p>
<p>微程序控制器:微程序、微指令和微命令，微指令格式，微命令的编码方式，微地址的形成方式</p>
<p>(五）指令流水线</p>
<p>指令流水线的基本概念;指令流水线的基本实现</p>
<p>超标量和动态流水线的基本概念</p>
<p>【复习提示】</p>
<p>中央处理器是计算机的中心，也是本书的难点。其中，数据通路的分析、指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题。</p>
<p>在学习本章时，请读者思考以下问题;</p>
<p>1)CPU分为哪几部分?分别实现什么功能?</p>
<p>2）指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据?3）什么是指令周期、机器周期和时钟周期?它们之间有何关系?</p>
<p>4）指令周期是否有一个固定值?为什么?</p>
<p>5）什么是微指令﹖它和第4章谈到的指令有什么关系?</p>
<p>6）什么是指令流水线?指令流水线相对于传统计算机体系结构的优势是什么?如何计算指令流水线的加速比?</p>
<p>请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。</p>
<h3 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h3><h4 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h4><p>中央处理器（CPU）由运算器和控制器组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令;运算器的功能是对数据进行加工。CPU的具体功能包括:</p>
<p>1）指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。</p>
<p>2）操作控制。一条指令的功能往往由若干操作信号的组合来实现。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。</p>
<p>3）时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。</p>
<p>4）数据加工。对数据进行算术和逻辑运算。</p>
<p>5）中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。</p>
<h4 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h4><p>在计算机系统中，中央处理器主要由运算器和控制器两大部分组成，如图5.1所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715140209.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715140209.png';" /></details>

<h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><p>运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。运算器是计算机对数据进行加工处理的中心，它主要由算术逻辑单元(ALU)、暂存寄存器、累加寄存器(ACC)、通用寄存器组、程序状态字寄存器(PSW)、移位器、计数器（CT)等组成。</p>
<p>1)算术逻辑单元。主要功能是进行算术/逻辑运算。</p>
<p>2）暂存寄存器。用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的。</p>
<p>3）累加寄存器。它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。</p>
<p>4）通用寄存器组。如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。</p>
<p>5）程序状态字寄存器。保留田昇个之西界R标志(ZF)、进位标志（CF）等。PSW 中息，如溢出标志（OF)、符号标志（SF)、零标志（ZF)、进位标志（CF）等。PSW中的这些位参与并决定微操作的形成。</p>
<p>6）移位器。对操作数或运算结果进行移位运算。</p>
<p>7）计数器。控制乘除运算的操作步数。</p>
<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。控制器的基本功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。</p>
<p>控制器有硬布线控制器和微程序控制器两种类型（见5.4节)。</p>
<p>控制器由程序计数器（PC)、指令寄存器（IR)、指令译码器、存储器地址寄存器(MAR)、存储器数据寄存器(MDR)、时序系统和微操作信号发生器等组成。</p>
<p>1）程序计数器。用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令（通常）是顺序执行的，所以PC有自增功能。</p>
<p>2）指令寄存器。用于保存当前正在执行的那条指令。</p>
<p>3）指令译码器。仅对操作码字段进行译码，向控制器提供特定的操作信号。</p>
<p>4）存储器地址寄存器。用于存放要访问的主存单元的地址。</p>
<p>5).存储器数据寄存器。用于存放向主存写入的信息或从主存读出的信息。</p>
<p>6）时序系统。用于产生各种时序信号，它们都由统一时钟(CLOCK）分频得到。</p>
<p>7）微操作信号发生器。根据R的内容（指令)、PSW的内容（状态信息）及时序信号产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。</p>
<p>控制器的工作原理是，根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果。</p>
<blockquote>
<p>注意:CPU内部寄存器大致可分为两类:一类是用户可见的寄存器，可对这类寄存器编程，如通用寄存器组、程序状态字寄存器;另一类是用户不可见的寄存器，对用户是透明的，不可对这类寄存器编程，如存储器地址寄存器、存储器数据寄存器、指令寄存器。</p>
</blockquote>
<h3 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h3><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>CPU从主存中取出并执行一条指令的时间称为指令周期，不同指令的指令周期可能不同。指令周期常用若干机器周期来表示，一个机器周期又包含若干时钟周期（也称节拍或T周期，它是CPU操作的最基本单位)。每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。图5.2反映了上述关系。图5.2(a)为定长的机器周期，每个机器周期包含4个节拍（T);图5.2(b)所示为不定长的机器周期，每个机器周期包含的节拍数可以为4个，也可以为3个。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715140540.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715140540.png';" /></details>

<p>对于无条件转移指令JMP X，在执行时不需要访问主存，只包含取指阶段（包括取指和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。</p>
<p>对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后访问主存，取出操作数，所以还需包括间址周期。间址周期介于取指周期和执行周期之间。</p>
<p>当CPU采用中断方式实现主机和I/O设备的信息交换时，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段，又称中断周期。这样，一个完整的指令周期应包括取指、间址、执行和中断4个周期，如图5.3所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715140642.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715140642.png';" /></details>

<p>上述4个工作周期都有CPU访存操作，只是访存的目的不同。取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。</p>
<p>为了区别不同的工作周期，在CPU内设置4个标志触发器FE、IND、EX和 INT，它们分别对应取指、间址、执行和中断周期，并以“1”状态表示有效，分别由1→FE、1→ND、1→EX和1→INT这4个信号控制。</p>
<blockquote>
<p>注意:中断周期中的进栈操作是将SP减1，这和传统意义上的进栈操作相反，原因是计算机的堆栈中都是向低地址增加，所以进栈操作是减1而不是加1。</p>
</blockquote>
<h4 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h4><p>数据流是根据指令要求依次访问的数据序列。在指令执行的不同阶段，要求依次访问的数据序列是不同的。而且对于不同的指令，它们的数据流往往也是不同的。</p>
<h5 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h5><p>取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中。</p>
<p>取指周期的数据流如图5.4所示。PC 中存放的是指令的地址，根据此地址从内存单元中取出的是指令，并放在指令寄存器IR中，取指令的同时，PC加1。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715140835.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715140835.png';" /></details>

<p>取指周期的数据流向如下:</p>
<ol>
<li>PC①MAR②地址总线 ${\textstyle\unicode{x2462}}$   主存。</li>
</ol>
<p>2)CU 发出控制信号④控制总线主存。</p>
<p>3）主存⑥数据总线⑦MDR⑧IR（存放指令)。</p>
<p>4)CU发出读命令⑨PC内容加1。</p>
<h5 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h5><p>间址周期的任务是取操作数有效地址。以一次间址为例（见图5.5)，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR.</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715141007.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715141007.png';" /></details>


<p>间址周期的数据流向如下:</p>
<p>1 )Ad(IR)（或MDR）${\textstyle\unicode{x2460}}$  MAR②地址总线③主存。</p>
<p>2)CU 发出读命令④控制总线⑤主存。</p>
<p>3）主存⑥数据总线⑦MDR（存放有效地址)。</p>
<p>其中，Ad(IR)表示取出IR中存放的指令字的地址字段。</p>
<h5 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h5><p>执行周期的任务是根据IR中的指令字的操作码和操作数通过 ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。</p>
<h5 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h5><p>中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据，数据流如图5.6所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715141143.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715141143.png';" /></details>

<p>中断周期的数据流向如下:</p>
<p>1)CU控制将SP减1，SP ${\textstyle\unicode{x2460}}$  MAR②地址总线③主存。</p>
<p>2)CU发出写命令④控制总线主存。</p>
<p>3)PC⑥ MDR⑦数据总线⑧主存（程序断点存入主存)。</p>
<p>4)CU(中断服务程序的入口地址）⑨PC。</p>
<h4 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h4><p>一个指令周期通常要包括几个时间段(执行步骤)，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。出于性能和硬件成本等考虑，可以选用3种不同的方案来安排指令的执行步骤。</p>
<h5 id="单指令周期"><a href="#单指令周期" class="headerlink" title="单指令周期"></a>单指令周期</h5><p>对所有指令都选用相同的执行时间来完成，称为单指令周期方案。此时每条指令都在固定的时钟周期内完成，指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。因此，指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。</p>
<h5 id="多指令周期"><a href="#多指令周期" class="headerlink" title="多指令周期"></a>多指令周期</h5><p>对不同类型的指令选用不同的执行步骤来完成，称为多指令周期方案。指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。但可选用不同个数的时钟周期来完成不同指令的执行过程，指令需要几个周期就为其分配几个周期，而不再要求所有指令占用相同的执行时间。</p>
<h5 id="流水线方案"><a href="#流水线方案" class="headerlink" title="流水线方案"></a>流水线方案</h5><p>指令之间可以并行执行的方案，称为流水线方案，其追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程（只在理想情况下才能达到该效果)。这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。</p>
<h3 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h3><h4 id="数据通路的功能"><a href="#数据通路的功能" class="headerlink" title="数据通路的功能"></a>数据通路的功能</h4><p>数据在功能部件之间传送的路径称为数据通路。路径上的部件称为数据通路部件，如ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制。</p>
<p>数据通路中专门进行数据运算的部件称为执行部件或功能部件。数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号，并正确控制指令的执行流程。数据通路的功能是实现CPU内部的运算器与寄存器及寄存器之间的数据交换。</p>
<h4 id="数据通路的基本结构"><a href="#数据通路的基本结构" class="headerlink" title="数据通路的基本结构"></a>数据通路的基本结构</h4><p>数据通路的基本结构主要有以下几种:</p>
<ol>
<li><p>CPU 内部单总线方式。将所有寄存器的输入端和输出端都连接到一条公共通路上，这种结构比较简单，但数据传输存在较多的冲突现象，性能较低。连接各部件的总线只有一条时，称为单总线结构;CPU中有两条或更多的总线时，构成双总线结构或多总线结构。图5.7所示为CPU内部总线的数据通路和控制信号。</p>
</li>
<li><p>CPU内部三总线方式。将所有寄存器的输入端和输出端都连接到多条公共通路上，相比之下单总线中一个时钟内只允许传一个数据，因而指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。</p>
</li>
</ol>
<p>3)专用数据通路方式。根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大。</p>
<p>在图5.7中，规定各部件用大写字母表示，字母加“in”表示该部件的允许输入控制信号;字母加“out”表示该部件的允许输出控制信号。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715141630.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715141630.png';" /></details>


<blockquote>
<p>注意:内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线;<br>线是指同一台计算机系统的各部件，如CPU、内存、通道和各类IO接口间互相连接的总线。</p>
</blockquote>
<h5 id="寄存器之间的数据传送"><a href="#寄存器之间的数据传送" class="headerlink" title="寄存器之间的数据传送"></a>寄存器之间的数据传送</h5><p>寄存器之间的数据传送可通过CPU内部总线完成。在图5.7中，某寄存器AX的输出和输入分别由AXout 和AXin控制。这里以PC寄存器为例，把PC内容送至MAR，实现传送操作的流程及控制信号为</p>
<p>PC→Bus   PCout有效，PC内容送总线</p>
<p>Bus→MAR  MARin有效，总线内容送MAR</p>
<h5 id="主存与CPU之间的数据传送"><a href="#主存与CPU之间的数据传送" class="headerlink" title="主存与CPU之间的数据传送"></a>主存与CPU之间的数据传送</h5><p>主存与CPU之间的数据传送也要借助CPU内部总线完成。现以CPU 从主存读取指令为例说明数据在数据通路中的传送过程。实现传送操作的流程及控制信号为</p>
<p>PC→Bus→MAR       PCout 和 MARin有效，现行指令地址→MAR<br>1→R              CU发读命令<br>MEM(MAR)→MDR     MDRin有效<br>MDR→BuS→IR       MDRout和 IRin有效，现行指令→IR</p>
<h5 id="执行算术或逻辑运算"><a href="#执行算术或逻辑运算" class="headerlink" title="执行算术或逻辑运算"></a>执行算术或逻辑运算</h5><p>执行算术或逻辑操作时，由于ALU本身是没有内部存储功能的组合电路，因此如要执行加法运算，相加的两个数必须在 ALU的两个输入端同时有效。图5.7中的暂存器Y即用于该目的。先将一个操作数经CPU内部总线送入暂存器Y保存，Y的内容在 ALU的左输入端始终有效，再将另一个操作数经总线直接送到ALU的右输入端。这样两个操作数都送入了ALU，运算结果暂存在暂存器Z中。</p>
<p>Ad(IR)→Bus→MAR        MDRout和 MARin有效<br>1→R                   CU发读命令<br>MEM→数据线→MDR         操作数从存储器→数据线→MDR<br>MDR→Bus→Y             MDRout 和 Yin有效，操作数→Y<br>(ACC)+(Y)→Z           ACCout 和 ALUin有效，CU向ALU发加命令，结果→Z<br>Z→ACC                 Zout和 ACCin有效，结果→ACC</p>
<p>数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它关系着微操作信号形成部件的设计。</p>
<h3 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h3><h4 id="控制器的结构和功能"><a href="#控制器的结构和功能" class="headerlink" title="控制器的结构和功能"></a>控制器的结构和功能</h4><p>从图5.8可以看到计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起，其中点画线框内的是控制器部件。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715150655.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715150655.png';" /></details>

<p>现对其主要连接关系简单说明如下:</p>
<p>1）运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据。2）输入设备和输出设备通过接口电路与总线相连接。</p>
<p>3）内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据。</p>
<p>4）控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号。控制器是计算机系统的指挥中心，控制器的主要功能有:</p>
<p>1)从主存中取出一条指令，并指出下一条指令在主存中的位置。</p>
<p>2）对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</p>
<p>3）指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。</p>
<p>根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器，两类控制器中的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的。</p>
<h4 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h4><p>硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。它由复杂的组合逻辑门电路和一些触发器构成，因此又称组合逻辑控制器。</p>
<h5 id="硬布线控制单元图"><a href="#硬布线控制单元图" class="headerlink" title="硬布线控制单元图"></a>硬布线控制单元图</h5><p>指令的操作码是决定控制单元发出不同操作命令(控制信号）的关键。为了简化控制单元(CU)的逻辑，将指令的操作码译码和节拍发生器从CU分离出来，便可得到简化的控制单元图，如图5.9所示。</p>
<p>CU的输入信号来源如下:</p>
<p>1）经指令译码器译码产生的指令信息。现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，因此指令的操作码字段是控制单元的输入信号，它与时钟配合产生不同的控制信号。</p>
<p>2)时序系统产生的机器周期信号和节拍信号。为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制，即一个时钟脉冲使控制单元发送一个操作命令，或发送一组需要同时执行的操作命令。</p>
<p>3）来自执行单元的反馈信息即标志。控制单元有时需依赖CPU当前所处的状态产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为负来产生不同的控制信号。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715150917.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715150917.png';" /></details>

<p>图5.9 中，节拍发生器产生各机器周期中的节拍信号，使不同的微操作命令$C_i$(控制信号）按时间的先后发出。个别指令的操作不仅受操作码控制，还受状态标志控制，因此CU的输入来自操作码译码电路ID、节拍发生器及状态标志，其输出到CPU内部或外部控制总线上。</p>
<blockquote>
<p>注意:控制单元还接收来自系统总线（控制总线）的控制信号，如中断请求、DMA请求。</p>
</blockquote>
<h5 id="硬布线控制器的时序系统及微操作"><a href="#硬布线控制器的时序系统及微操作" class="headerlink" title="硬布线控制器的时序系统及微操作"></a>硬布线控制器的时序系统及微操作</h5><p>1）时钟周期。用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。在每个节拍内机器可完成一个或几个需同时执行的操作。</p>
<p>2）机器周期。机器周期可视为所有指令执行过程中的一个基准时间。不同指令的操作不同，指令周期也不同。访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期。在存储字长等于指令字长的前提下，取指周期也可视为机器周期。</p>
<p>在一个机器周期里可完成若干微操作，每个微操作都需一定的时间，可用时钟信号来控制产生每个微操作命令。</p>
<p>3）指令周期。指令周期详见5.2.1节。</p>
<p>4）微操作命令分析。控制单元具有发出各种操作命令（控制信号）序列的功能。这些命令与指令有关，而且必须按一定次序发出，才能使机器有序地工作。</p>
<p>执行程序的过程中，对于不同的指令，控制单元需发出各种不同的微操作命令。–条指令分为3个工作周期:取指周期、间址周期和执行周期。下面分析各个子周期的微操作命令。</p>
<p>①取指周期的微操作命令。无论是什么指令，取指周期都需有下列微操作命令:</p>
<p>PC→MAR      现行指令地址→MAR</p>
<p>1→R         命令存储器读</p>
<p>M(MAR)→MDR  现行指令从存储器中读至MDR</p>
<p>MDR→IR      现行指令→IR</p>
<p>OP(IR)→CU   指令的操作码→CU译码</p>
<p>(PC)+1→PC   形成下一条指令的地址</p>
<p>②间址周期的微操作命令。间址周期完成取操作数地址的任务，具体微操作命令如下:</p>
<p>Ad(IR)→MAR   将指令字中的地址码（形式地址）→MAR</p>
<p>1→R          命令存储器读</p>
<p>M(MAR)→MDR   将有效地址从存储器读至MDR</p>
<p>③执行周期的微操作命令。执行周期的微操作命令视不同指令而定。</p>
<p>a．非访存指令。</p>
<p>CLA  清ACC     0→ACC</p>
<p>COM  取反      $\overline{ACC}$→ACC</p>
<p>SHR  算术右移  L(ACC)→R(ACC)，$ACC_0$→$ACC_0$</p>
<p>CSL  循环左移  R(ACC)→L(ACC)，$ACC_0$→$ACC_n$</p>
<p>STP  停机指令  0→G</p>
<p>b.访存指令</p>
<p>ADD X    加法指令  Ad(IR)→MAR</p>
<p>1→R</p>
<p>M(MAR)→MDR</p>
<p>(ACC)+ (MDR)→ACC</p>
<p>STA X    存数指令  Ad(IR)→MAR</p>
<p>1→w</p>
<p>ACC→MDR</p>
<p>MDR→M(MAR)</p>
<p>LDAX     取数指令  Ad(IR)→MAR</p>
<p>1→R</p>
<p>M(MAR)→MDR</p>
<p>MDR→ACC</p>
<p>c.转移指令</p>
<p>JMP X   无条件转移          Ad(IR)→PC</p>
<p>BAN X   条件转移（负则转)   $A_0 \cdot$Ad(IR)+$\overline{A_0} \cdot$(PC)→PC</p>
<h5 id="CPU-的控制方式"><a href="#CPU-的控制方式" class="headerlink" title="CPU 的控制方式"></a>CPU 的控制方式</h5><p>控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程。由于不同指令所对应的微操作数及复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。主要有以下3种控制方式。</p>
<p>1）同步控制方式。所谓同步控制方式，是指系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号。通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。同步控制方式的优点是控制电路简单，缺点是运行速度慢。</p>
<p>2）异步控制方式。异步控制方式不存在基准时标信号，各部件按自身固有的速度工作，通过应答方式进行联络。异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。</p>
<p>3）联合控制方式。联合控制方式是介于同步、异步之间的一种折中。这种方式对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法。</p>
<h5 id="硬布线控制单元设计步骤"><a href="#硬布线控制单元设计步骤" class="headerlink" title="硬布线控制单元设计步骤"></a>硬布线控制单元设计步骤</h5><p>硬布线控制单元设计步骤包括:</p>
<p>1）列出微操作命令的操作时间表。先根据微操作节拍安排，列出微操作命令的操作时间表。操作时间表中包括各个机器周期、节拍下的每条指令完成的微操作控制信号。表5.1列出了CLA、COM、SHR等10条机器指令微操作命令的操作时间表。表中FE、IND 和EX为CPU 工作周期标志，$To～T$,为节拍，Ⅰ为间址标志，在取指周期的$T_2$时刻，若测得I=1，则IND触发器置“1”，标志进入间址周期;若I=0，则EX触发器置“1”，标志进入执行周期。同理，在间址周期的$T_2$时刻，若测得IND=0(表示一次间接寻址)，则EX触发器置“1”，进入执行周期;若测得IND= 1(表示多次间接寻址)，则继续间接寻址。在执行周期的$T_2$时刻，CPU 要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则INT触发器置“1”，标志进入中断周期。表中未列出INT触发器置“1”的操作和中断周期的微操作。表中第一行对应10条指令的操作码，代表不同的指令。若某指令有表中所列出的微操作命令，其对应的单元格内为1。</p>
<p>2）进行微操作信号综合。在列出微操作时间表后，即可对它们进行综合分析、归类，根据<br>微操作时间表可写出各微操作控制信号的逻辑表达式并进行适当的简化。表达式一般包括下列因素:</p>
<p>微操作控制信号=机器周期$\wedge$节拍$\wedge$脉冲$\wedge$操作码$\wedge$机器状态条件</p>
<p>根据表5.1便可列出每个微操作命令的初始逻辑表达式，经化简、整理可获得能用现有门电路实现的微操作命令逻辑表达式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716142423.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716142423.png';" /></details>

<p>例如，根据表5.1可写出 M(MAR)–MDR微操作命令的逻辑表达式:</p>
<p>M(MAR)→MDR</p>
<p>=FE$\cdot T_1$+IND$\cdot T_1$;(ADD + STA + LDA + JMP + BAN)+EX$\cdot T_1$;(ADD +LDA)=$T_1${FE+ IND(ADD + STA+ LDA＋JMP+BAN)+EX(ADD +LDA)}</p>
<p>式中，ADD、STA、LDA、JMP、BAN均来自操作码译码器的输出。</p>
<p>3）画出微操作命令的逻辑图。根据逻辑表达式可画出对应每个微操作信号的逻辑电路图，<br>并用逻辑门电路实现。</p>
<p>例如，M(MAR)-MDR的逻辑表达式所对应的逻辑图如图5.10 所示，图中未考虑门的扇入系数。</p>
<blockquote>
<p>$\color{red}{\text{Q}}$ :什么是扇入系数</p>
</blockquote>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716142756.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716142756.png';" /></details>


<h4 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h4><p>微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。</p>
<h5 id="微程序控制的基本概念"><a href="#微程序控制的基本概念" class="headerlink" title="微程序控制的基本概念"></a>微程序控制的基本概念</h5><p>微程序设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。目前，大多数计算机都采用微程序设计技术。</p>
<p>微程序设计技术涉及的基本术语如下:</p>
<p>1）微命令与微操作。一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作。在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。</p>
<p>微命令有相容性和互斥性之分。相容性微命令是指那些可以同时产生、共同完成某一些微操作的微命令;而互斥性微命令是指在机器中不允许同时出现的微命令。相容和互斥都是相对的，一个微命令可以和一些微命令相容，和另一些微命令互斥。</p>
<p>注意:在组合逻辑控制器中也存在微命令与微操作这两个概念，它们并非只是微程序控制器的专有概念。</p>
<p>2）微指令与微周期。微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称<br>为微地址。一条微指令通常至少包含两大部分信息:</p>
<p>①操作控制字段，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。</p>
<p>${\textstyle\unicode{x2461}}$  顺序控制字段，又称微地址码字段，用于控制产生下一条要执行的微指令地址。微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p>
<p>3）主存储器与控制存储器。主存储器用于存放程序和数据，在CPU外部，用RAM 实现;控制存储器（CM）用于存放微程序，在CPU内部，用ROM实现。</p>
<p>4）程序与微程序。程序是指令的有序集合，用于完成特定的功能;微程序是微指令的有序集合，一条指令的功能由一段微程序来实现。</p>
<p>微程序和程序是两个不同的概念。微程序是由微指令组成的，用于描述机器指令。微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，计算机系统中微程序的结构和功能是透明的，无须知道。而程序最终由机器指令组成，是由软件设计人员事先编制好并存放在主存或辅存中的。</p>
<p>读者应注意区分以下寄存器:</p>
<p>①地址寄存器(MAR)。用于存放主存的读/写地址。</p>
<p>${\textstyle\unicode{x2461}}$  微地址寄存器(CMAR)。用于存放控制存储器的读/写微指令的地址。</p>
<p>③指令寄存器（IR)。用于存放从主存中读出的指令。</p>
<p>④微指令寄存器（CMDR或uIR)。用于存放从控制存储器中读出的微指令。</p>
<h5 id="微程序控制器组成和工作过程"><a href="#微程序控制器组成和工作过程" class="headerlink" title="微程序控制器组成和工作过程"></a>微程序控制器组成和工作过程</h5><h6 id="微程序控制器的基本组成"><a href="#微程序控制器的基本组成" class="headerlink" title="微程序控制器的基本组成"></a>微程序控制器的基本组成</h6><p>图5.11所示为一个微程序控制器的基本结构，主要画出了微程序控制器比组合逻辑控制器多出的部件，包括:</p>
<p>${\textstyle\unicode{x2460}}$  控制存储器。它是微程序控制器的核心部件，用于存放各指令对应的微程序，控制存储器可用只读存储器ROM构成。</p>
<p>${\textstyle\unicode{x2461}}$ 微指令寄存器。用于存放从CM中取出的微指令，它的位数同微指令字长相等。</p>
<p>${\textstyle\unicode{x2462}}$ 微地址形成部件。用于产生初始微地址和后继微地址,以保证微指令的连续执行。</p>
<p>${\textstyle\unicode{x2463}}$ 微地址寄存器。接收微地址形成部件送来的微地址，为在CM中读取微指令作准备。</p>
<h6 id="微程序控制器的工作过程"><a href="#微程序控制器的工作过程" class="headerlink" title="微程序控制器的工作过程"></a>微程序控制器的工作过程</h6><p>微程序控制器的工作过程实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可以描述如下:</p>
<p>${\textstyle\unicode{x2460}}$  执行取微指令公共操作。具体的执行是:在机器开始运行时，自动将取指微程序的入口地址送入CMAR，并从CM 中读出相应的微指令送入CMDR。取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。</p>
<p>${\textstyle\unicode{x2461}}$  由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地<br>址，并送入CMAR。</p>
<p>③从CM中逐条取出对应的微指令并执行。</p>
<p>④执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第①<br>步，以完成取下一条机器指令的公共操作。</p>
<p>以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕。</p>
<h6 id="微程序和机器指令"><a href="#微程序和机器指令" class="headerlink" title="微程序和机器指令"></a>微程序和机器指令</h6><p>通常，一条机器指令对应一个微程序。由于任何一条机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。</p>
<p>此外，也可编出对应间址周期的微程序和中断周期的微程序。这样，控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等共用的微程序数。</p>
<blockquote>
<p>注意:若指令系统中具有$n$种机器指令，则控制存储器中的微程序数至少是$n +1 $(1为公共的取指微程序)。</p>
</blockquote>
<h5 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h5><p>微指令的编码方式又称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。</p>
<h6 id="直接编码（直接控制）方式"><a href="#直接编码（直接控制）方式" class="headerlink" title="直接编码（直接控制）方式"></a>直接编码（直接控制）方式</h6><p>微指令的直接编码方式如图5.12所示。直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0即可。每个微命令对应并控制数据通路中的一个微操作。</p>
<p>这种编码的优点是简单、直观，执行速度快，操作并行性好;缺点是微指令字长过长，$n$个微命令就要求微指令的操作字段有$n$位，造成控制存储器容量极大。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716143824.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716143824.png';" /></details>


<h6 id="字段直接编码方式"><a href="#字段直接编码方式" class="headerlink" title="字段直接编码方式"></a>字段直接编码方式</h6><p>将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式，如图5.13所示。</p>
<p>这种方式可以缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢。</p>
<p>微命令字段分段的原则:</p>
<p>${\textstyle\unicode{x2460}}$  互斥性微命令分在同一段内，相容性微命令分在不同段内。</p>
<p>${\textstyle\unicode{x2461}}$ 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。</p>
<p>${\textstyle\unicode{x2462}}$  一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。</p>
<h6 id="字段间接编码方式"><a href="#字段间接编码方式" class="headerlink" title="字段间接编码方式"></a>字段间接编码方式</h6><p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐式编码。这种方式可进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。</p>
<h5 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h5><p>后继微地址的形成主要有以下两大基本类型:</p>
<p>1)直接由微指令的下地址字段指出。微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称断定方式。</p>
<p>2）根据机器指令的操作码形成。机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</p>
<p>实际上，微指令序列地址的形成方式还有以下几种:</p>
<p>①增量计数器法，即(CMAR)+1→CMAR，适用于后继微指令的地址连续的情况。</p>
<p>${\textstyle\unicode{x2461}}$  根据各种标志决定微指令分支转移的地址。</p>
<p>③通过网络测试形成。</p>
<p>④由硬件直接产生微程序入口地址。</p>
<p>电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向CMAR输入微指令的地址，这个地址即为取指周期微程序的入口地址。</p>
<h5 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h5><p>微指令格式与微指令的编码方式有关，通常分水平型微指令和垂直型微指令两种。</p>
<p>1)水平型微指令。从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令。水平型微指令的基本指令格式如图5.14所示，指令字中的一位对应-一个控制信号，有输出时为1，否则为0。一条水平型微指令定义并执行几种并行的基本操作。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716144416.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716144416.png';" /></details>

<p>水平型微指令的优点是微程序短，执行速度快;缺点是微指令长，编写微程序较麻烦。</p>
<p>2）垂直型微指令。垂直型微指令的特点是采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能，其基本的指令格式如图5.15所示。一条垂直型微指令只能定义并执行一种基本操作。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716144502.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716144502.png';" /></details>

<p>垂直型微指令格式的优点是微指令短、简单、规整，便于编写微程序;缺点是微程序长，执行速度慢，工作效率低。</p>
<p>3）混合型微指令。在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写;微程序也不长，执行速度加快。</p>
<p>4）水平型微指令和垂直型微指令的比较如下:</p>
<p>${\textstyle\unicode{x2460}}$  水平型微指令并行操作能力强、效率高、灵活性强;垂直型微指令则较差。</p>
<p>${\textstyle\unicode{x2461}}$ 水平型微指令执行一条指令的时间短;垂直型微指令执行的时间长。</p>
<p>${\textstyle\unicode{x2462}}$ 由水平型微指令解释指令的微程序，具有微指令字较长但微程序短的特点;垂直型<br>微指令则与之相反，其微指令字较短而微程序长。</p>
<p>④水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对容易掌握。</p>
<h5 id="微程序控制单元的设计步骤"><a href="#微程序控制单元的设计步骤" class="headerlink" title="微程序控制单元的设计步骤"></a>微程序控制单元的设计步骤</h5><p>微程序控制单元设计的主要任务是编写各条机器指令所对应的微程序。具体的设计步骤如下:</p>
<p>1）写出对应机器指令的微操作命令及节拍安排。无论是组合逻辑设计还是微程序设计，对应相同的CPU 结构，两种控制单元的微操作命令和节拍安排都是极相似的。如微程序控制单元在取指阶段发出的微操作命令及节拍安排如下:</p>
<p>$T_0$    PC→MAR，1→R<br>$T_1$    M(MAR)→MDR，(PC)+1-→PC<br>$T_2$    MDR→IR，OP(IR)→微地址形成部件</p>
<p>与硬布线控制单元相比，只在$T_2$节拍内的微操作命令不同。微程序控制单元在$T_2$节拍内要将指令的操作码送至微地址形成部件，即OP(IR)→微地址形成部件，以形成该条机器指令的微程序首地址。而硬布线控制单元在$T_2$,节拍内要将指令的操作码送至指令译码器，以控制CU 发出相应的微命令，即 OP(IR)→ID。</p>
<p>若把一个节拍T内的微操作安排在一条微指令中完成，上述微操作对应3条微指令。但由于微程序控制的所有控制信号都来自微指令，而微指令又存在控制存储器中，因此欲完成上述这些微操作，必须先将微指令从控制存储器中读出，即必须先给出这些微指令的地址。在取指微程序中，除第一条微指令外，其余微指令的地址均由上一条微指令的下地址字段直接给出，因此上述每条微指令都需增加一个将微指令下地址字段送至CMAR 的微操作，记为 Ad(CMDR)→CMAR。取指微程序的最后一条微指令，其后继微指令的地址是由微地址形成部件形成的，即微地址形成部件→CMAR。为了反映该地址与操作码有关，因此记为OP(IR)→微地址形成部件→CMAR。</p>
<p>综上所述，考虑到需要形成后继微指令地址，上述分析的取指操作共需6条微指令完成:</p>
<p>$T_0$   PC→MAR，1→R<br>$T_1$   Ad(CMDR)→CMAR<br>$T_2$   M(MAR)→MDR，(PC)+1→PC<br>$T_3$   Ad(CMDR)→CMAR<br>$T_4$   MDR→IR<br>$T_5$   OP(IR)→微地址形成部件→CMAR</p>
<p>执行阶段的微操作命令及节拍安排，分配原则类似。与硬布线控制单元微操作命令的节拍安排相比，多了将下一条微指令地址送至CMAR 的微操作命令，即 Ad(CMDR)→CMAR。其余的微操作命令与硬布线控制单元相同。</p>
<blockquote>
<p>注意:这里为了理解，应将微指令和机器指令相联系，因为每执行完一条微指令后要得到下一条微指令的地址。</p>
</blockquote>
<p>2）确定微指令格式。微指令格式包括微指令的编码方式、后继微指令地址的形成方式和微指令字长等。</p>
<p>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。由微指令数确定微指令的顺序控制字段的位数。最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。</p>
<p>3）编写微指令码点。根据操作控制字段每位代表的微操作命令，编写每条微指令的码点。</p>
<h5 id="动态微程序设计和毫微程序设计"><a href="#动态微程序设计和毫微程序设计" class="headerlink" title="动态微程序设计和毫微程序设计"></a>动态微程序设计和毫微程序设计</h5><p>1）动态微程序设计。在一台微程序控制的计算机中，假如能根据用户的要求改变微程序，则这台机器就具有动态微程序设计功能。</p>
<p>动态微程序的设计需要可写控制寄存器的支持，否则难以改变微程序的内容。实现动态微程序设计可采用可擦除可编程只读存储器（EPROM)。</p>
<p>2）毫微程序设计。在普通的微程序计算机中，从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制。</p>
<p>若硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的，这个第二级控制存储器就称为毫微存储器，直接控制硬件的是毫微微指令。</p>
<h5 id="硬布线和微程序控制器的特点"><a href="#硬布线和微程序控制器的特点" class="headerlink" title="硬布线和微程序控制器的特点"></a>硬布线和微程序控制器的特点</h5><p>1）硬布线控制器的特点。硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快;缺点是由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，一旦设计完成，就不可能通过其他额外修改添加新功能。</p>
<p>2）微程序控制器的特点。微程序控制器的优点是同组合逻辑控制器相比，微程序控制器具有规整性、灵活性、可维护性等一系列优点;缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响速度。</p>
<p>为便于比较，下面以表格的形式对比二者的不同,见表5.2。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716150404.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716150404.png';" /></details>




<h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><h4 id="指令流水线的基本概念"><a href="#指令流水线的基本概念" class="headerlink" title="指令流水线的基本概念"></a>指令流水线的基本概念</h4><p>一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术。</p>
<h5 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a>指令流水的定义</h5><p>根据计算机的不同，具体的分法也不同。例如，图5.16把一条指令的执行过程分为如下三个阶段（或过程)。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716181707.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716181707.png';" /></details>


<p>取指:根据PC内容访问主存储器，取出一条指令送到IR中。</p>
<p>分析:对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA，并从有效地址EA中取出操作数。</p>
<p>执行:根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。</p>
<p>当多条指令在处理器中执行时,可以采用以下两种方式。</p>
<p>1）顺序执行方式。前一条指令执行完后，才启动下一条指令，如图5.17(a)所示。假设取指、分析、执行三个阶段的时间都相等，用t表示，顺序执行n条指令所用时间T为</p>
<p>$$<br>T=3nt<br>$$</p>
<p>传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。其优点是控制简单，硬件代价小;缺点是执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。例如取指时内存是忙碌的，而指令执行部件是空闲的。</p>
<p>2）流水线执行方式。为了提高指令的执行速度，可以把取k＋1条指令提前到分析第k条指令的期间完成，而将分析第k＋1条指令与执行第k条指令同时进行，如图5.17(b)所示。采用此种方式时，执行n条指令所用的时间为</p>
<p>$$<br>T=(2 + n)t<br>$$</p>
<p>与顺序执行方式相比，采用流水线执行方式能使指令的执行时间缩短近2/3，各功能部件的利用率明显提高。但为此需要付出硬件上较大开销的代价，控制过程也更复杂。在理想情况下，每个时钟周期都有一条指令进入流水线，处理机中同时有3条指令在执行，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即 CPI）都为1。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716182135.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716182135.png';" /></details>

<p>为了进一步获得更高的执行速度，还可以将流水段进一步细分。如将一条指令的执行过程分为取指令、指令译码、执行和写回四个阶段，就形成了四级流水;还可进一步分为取指令(IF)、指令译码（ID)、取操作数（OF)、执行(EX）和写回(WB)，就形成了五级流水。</p>
<p>流水线设计的原则是如下:指令流水段个数以最复杂指令所用的功能段个数为准;流水段的长度以最复杂的操作所花的时间为准。假设某条指令的3个阶段所花的时间分别如下。①取指:200ps;分析:100ps;③执行: 150ps。不考虑数据通路中的各种延迟，该指令的总执行时间为450ps。按照流水线设计原则，每个流水段的长度为200ps，所以每条指令的执行时间为600ps，反正比串行执行时增加了150ps。因此，流水线方式并不能缩短一条指令的执行时间，但是，对于整个程序来说，可以大大增加指令执行的吞吐率。</p>
<p>为了利于实现指令流水线，指令集应具有如下特征:</p>
<p>1）指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花时间长短不易，使取指部件极其复杂，且也不利于指令译码。</p>
<p>2）指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。</p>
<p>3）采用Load/Store 指令，其他指令（如运算指令）都不能访问存储器，这样可把Load/Store指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。</p>
<p>4）数据和指令在存储器中“对齐”存放。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。</p>
<h5 id="流水线的表示方法"><a href="#流水线的表示方法" class="headerlink" title="流水线的表示方法"></a>流水线的表示方法</h5><p>通常用时空图来直观地描述流水线的工作过程，如图5.18所示。</p>
<p>在时空图中，横坐标表示时间，即输入流水线中的各个任务在流水线中所经过的时间。流水线中各个流水段的执行时间都相等时，横坐标就被分割成相等长度的时间段。纵坐标表示空间，即流水线的每个流水段（对应各执行部件)。</p>
<p>在图5.18中，第一条指令$\text{I}_1$在时刻$t_0$进入流水线，在时刻$t_4$流出流水线。第二条指令$\text{I}——2$在时刻$t_1$进入流水线，在时刻$t_5$流出流水线。以此类推，每经过一个$\Delta t$时间，便有一条指令进入流水线，从时刻t4开始有一条指令流出流水线。</p>
<p>从图5.18中可以看出，当$t_8$ =$8\Delta t$ 时，流水线上便有5条指令流出。若采用串行方式执行指令，当$t_8$ =$8\Delta t$时，只能执行2条指令，可见使用流水线方式成倍地提高了计算机的速度。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716182718.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716182718.png';" /></details>


<h5 id="流水线方式的特点"><a href="#流水线方式的特点" class="headerlink" title="流水线方式的特点"></a>流水线方式的特点</h5><p>与传统的串行执行方式相比，采用流水线方式具有如下特点:</p>
<p>1）把一个任务（一条指令或一个操作）分解为几个有联系的子任务，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短程序的执行时间。</p>
<p>2）流水线每个功能段部件后面都要有一个缓冲寄存器，或称锁存器，其作用是保存本流水段的执行结果，供给下一流水段使用。</p>
<p>3）流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流。</p>
<p>4)只有连续不断地提供同一种任务时才能发挥流水线的效率，所以在流水线中处理的必须是连续任务。在采用流水线方式工作的处理机中，要在软件和硬件设计等多方面尽量为流水线提供连续的任务。</p>
<p>5）流水线需要有装入时间和排空时间。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。</p>
<h4 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h4><p>按照不同的分类标准，可以把流水线分成多种不同的种类。下面从几个不同的角度介绍流水线的基本分类方法。</p>
<h5 id="部件功能级、处理机级和处理机间级流水线"><a href="#部件功能级、处理机级和处理机间级流水线" class="headerlink" title="部件功能级、处理机级和处理机间级流水线"></a>部件功能级、处理机级和处理机间级流水线</h5><p>根据流水线使用级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。</p>
<p>部件功能级流水将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加及结果规格化等4个子过程。</p>
<p>处理机级流水把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存和写回5个子过程。</p>
<p>处理机间流水是一种宏流水，其中每个处理机完成某一专门任务，各个处理机得到的结果需存放在与下一个处理机共享的存储器中。</p>
<h5 id="单功能流水线和多功能流水线"><a href="#单功能流水线和多功能流水线" class="headerlink" title="单功能流水线和多功能流水线"></a>单功能流水线和多功能流水线</h5><p>按可以完成的功能，流水线可分为单功能流水线和多功能流水线。</p>
<p>单功能流水线是指只能实现一种固定的专门功能的流水线;多功能流水线是指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。</p>
<h5 id="动态流水线和静态流水线"><a href="#动态流水线和静态流水线" class="headerlink" title="动态流水线和静态流水线"></a>动态流水线和静态流水线</h5><p>按同一时间内各段之间的连接方式，流水线可分为静态流水线和动态流水线。</p>
<p>静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</p>
<p>动态流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</p>
<h5 id="线性流水线和非线性流水线"><a href="#线性流水线和非线性流水线" class="headerlink" title="线性流水线和非线性流水线"></a>线性流水线和非线性流水线</h5><p>按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。</p>
<p>线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。非线性流水线存在反馈回路，从输入到输出的过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</p>
<p>流水线的每个子过程由专用的功能段实现，各功能段所需的时间应尽量相等。否则，时间长的功能段将成为流水线的瓶颈。</p>
<h4 id="影响流水线的因素"><a href="#影响流水线的因素" class="headerlink" title="影响流水线的因素"></a>影响流水线的因素</h4><p>在指令流水线中，可能会遇到一些情况使得流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象称为流水线冲突（冒险)。导致流水线冲突的原因主要有3种:资源冲突(结构冒险)、数据冲突（数据冒险）和控制冲突（控制冒险)。</p>
<h5 id="资源冲突"><a href="#资源冲突" class="headerlink" title="资源冲突"></a>资源冲突</h5><p>由于多条指令在同一时刻争用同一资源而形成的冲突称为资源冲突，即由硬件资源竞争造成的冲突，有以下两种解决办法:</p>
<p>1）前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期。</p>
<p>2）单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行。</p>
<p>事实上，现代计算机都引入了Cache机制，而L1 Cache通常采用数据Cache和指令Cache分离的方式，因而也就避免了资源冲突的发生。</p>
<h5 id="数据冲突"><a href="#数据冲突" class="headerlink" title="数据冲突"></a>数据冲突</h5><p>在一个程序中，下一条指令会用到当前指令计算出的结果，此时这两条指令即为数据冲突。当多条指令重叠处理时就会发生冲突，数据冲突可分为三类（结合综合题3理解):</p>
<p>1）写后读(Read After Write，RAW)相关:表示当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据。否则，先读后写，读到的就是错误（旧）数据。</p>
<p>2）读后写(Write After Read，WAR）相关:表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误（新）数据。</p>
<p>3）写后写(Write After Write，WAW)相关:表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值。解决的办法有以下几种:</p>
<p>1）把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为硬件阻塞(stall）和软件插入“NOP”指令两种方法。</p>
<p>2）设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令的 ALU的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这称为数据旁路技术。</p>
<p>3）通过编译器对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关。</p>
<p>解决的办法有以下几种:</p>
<p>1）把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为硬件阻塞(stall）和软件插入“NOP”指令两种方法。</p>
<p>2）设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令的 ALU的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这称为数据旁路技术。</p>
<p>3）通过编译器对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关。</p>
<h5 id="控制冲突"><a href="#控制冲突" class="headerlink" title="控制冲突"></a>控制冲突</h5><p>一条指令要确定下一条指令的位置，例如在执行转移、调用或返回等指令时会改变PC值，而造成断流,会引起控制冒险。解决的办法有以下几种:</p>
<p>1）对转移指令进行分支预测，尽早生成转移目标地址。分支预测分为简单（静态）预测和动态预测。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率。</p>
<p>2）预取转移成功和不成功两个控制流方向上的目标指令。</p>
<p>3）加快和提前形成条件码。</p>
<p>4）提高转移方向的猜准率。</p>
<blockquote>
<p>注意:Cache缺失的处理过程也会引起流水线阻塞。在不过多增加硬件成本的情况下，如何尽可能地提高指令流水线的运行效率是选用指令流水线技术必须解决的关键问题。</p>
</blockquote>
<h4 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h4><p>衡量流水线性能的主要指标有吞吐率、加速比和效率。下面以线性流水线为例分析流水线的主要性能指标，其分析方法和有关公式也适用于非线性流水线。</p>
<p>$$<br>TP=\dfrac{n}{T_k}<br>$$</p>
<p>式中，$n$是任务数，$T_k$是处理完$n$个任务所用的时间。下面以流水线中各段执行时间都相等为例来讨论流水线的吞吐率。</p>
<p>图5.19所示为各段执行时间均相等的流水线时空图。在输入流水线中的任务连续的理想情况下，一条k段线性流水线能够在k+n-1个时钟周期内完成n个任务。在图5.19中，k为流水线的段数，△t为时钟周期。得出流水线的实际吞吐率为</p>
<p>$$<br>TP = \dfrac{n}{k+n-1} \Delta t<br>$$</p>
<p>连续输入的任务数$n\to \infty$时，得最大吞吐率为$TP_{max}= 1/\Delta t$ 。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716183823.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716183823.png';" /></details>

<p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比，称为流水线的加速比。</p>
<p>设$T_0$表示不使用流水线时的执行时间，即顺序执行所用的时间;$T_k$表示使用流水线时的执行时间，则计算流水线加速比(S)的基本公式为</p>
<p>$$<br>S=\dfrac{T_0}{T_k}<br>$$</p>
<p>若流水线各段执行的时间都相等，则一条k段流水线完成n个任务所需的时间为$T_k=(k + n-1)\Delta t$。而不使用流水线，即顺序执行$n$个任务时，所需的时间为$T_0= kn\Delta t$。将$T_0$和$T_k$值代入上式，得实际加速比为</p>
<p>$$<br>S=\dfrac{kn\Delta t}{(k+n-1)\Delta t}=\dfrac{kn}{(k+n-1)}<br>$$</p>
<h5 id="流水线的效率"><a href="#流水线的效率" class="headerlink" title="流水线的效率"></a>流水线的效率</h5><p>流水线的设备利用率称为流水线的效率。在时空图上，流水线的效率定义为完成$n$个任务占用的时空区有效面积，与$n$ 个任务所用的时间及$k$ 个流水段所围成的时空区总面积之比。因此，流水线的效率包含了时间和空间两个因素。</p>
<p>$n$个任务占用的时空区有效面积就是顺序执行n个任务所使用的总时间$T_0$，而n 个任务所用的时间与k个流水段所围成的时空区总面积为 $kT_k$，其中$T_k$是流水线完成n个任务所使用的总时间，因此计算流水线效率（E)的一般公式为</p>
<p>$$<br>E = \dfrac{n\text{个任务占用的时空区有效面积}}{n个任务所用的时间与k个流水段所围成的时空区总面积} = \dfrac{T_0}{kT_k}<br>$$</p>
<p>若流水线的各段执行时间相等，上式中的分子部分是n 个任务实际占用的有效面积，分母部分是完成n个任务所用的时间与k个流水段所围成的总面积。因此，通过时空图来计算流水线的效率非常方便。</p>
<p>流水线的各段执行时间均相等，当连续输入的任务数$n \to \infty$时，最高效率为$E_{max}=1$。</p>
<h4 id="超标量流水线的基本概念"><a href="#超标量流水线的基本概念" class="headerlink" title="超标量流水线的基本概念"></a>超标量流水线的基本概念</h4><h5 id="超标量流水线技术"><a href="#超标量流水线技术" class="headerlink" title="超标量流水线技术"></a>超标量流水线技术</h5><p>每个时钟周期内可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件。</p>
<p>超标量计算机不能调整指令的执行顺序，因此通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性，如图5.20所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716184812.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716184812.png';" /></details>

<h5 id="超流水线技术"><a href="#超流水线技术" class="headerlink" title="超流水线技术"></a>超流水线技术</h5><p>在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次。</p>
<p>不能调整指令的执行顺序，靠编译程序解决优化问题，如图5.21所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716184857.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716184857.png';" /></details>

<h5 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h5><p>由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位)，为此需要采用多个处理部件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch4-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch4-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch4-指令系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 09:59:59" itemprop="dateCreated datePublished" datetime="2021-06-30T09:59:59+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 13:59:48" itemprop="dateModified" datetime="2021-07-15T13:59:48+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>p165</p>
<p>【考纲内容】</p>
<p>(一）指令格式</p>
<p>指令的基本格式</p>
<p>定长操作码指令格式</p>
<p>扩展操作码指令格式</p>
<p>(二)指令的寻址方式</p>
<p>有效地址的概念</p>
<p>数据寻址和指令寻址</p>
<p>常见寻址方式</p>
<p>(三)CISC和 RISC的基本概念</p>
<p>【复习提示】<br>指令系统是表征一台计算机性能的重要因素。读者应注意扩展操作码技术，各种寻址方式的特点及有效地址的计算，相对寻址有关的计算，CISC与RISC 的特点与区别。本章知识点出选择题的概率较大，但也有可能结合其他章节出有关指令的综合题。2014年、2015年已连续两次出现指令系统和指令流水线的大题。指令系统格式和指令寻址方式与CPU指令执行过程部分紧密结合，希望读者引起重视。</p>
<p>在学习本章时，请读者思考以下问题:</p>
<p>1）什么是指令﹖什么是指令系统?为什么要引入指令系统?</p>
<p>2）一般来说，指令分为哪些部分?每部分有什么用处?</p>
<p>3）对于一个指令系统来说，寻址方式多和少有什么影响?</p>
<p>请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。</p>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p>指令（机器指令）是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。指令系统是计算机的主要属性，位于硬件和软件的交界面上。</p>
<h4 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h4><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常包括操作码字段和地址码字段两部分:</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713161448.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713161448.png';" /></details>

<p>其中，操作码指出指令中该指令应该执行什么性质的操作以及具有何种功能。操作码是识别指令、了解指令功能及区分操作数地址内容的组成和使用方法等的关键信息。例如，指出是算术加运算还是算术减运算，是程序转移还是返回操作。</p>
<p>地址码给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。</p>
<p>指令的长度是指一条指令中所包含的二进制代码的位数。指令字长取决丁操作码的长度、操作数地址码的长度和操作数地址的个数。指令长度与机器字长没有固定的关系，它可以等于机器字长，也可以大于或小于机器字长。通常，把指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令。</p>
<p>在一个指令系统中，若所有指令的长度都是相等的，则称为定长指令字结构。定字长指令的执行速度快，控制简单。若各种指令的长度随指令功能而异，则称为变长指令字结构。然而，因为主存一般是按字节编址的，所以指令字长多为字节的整数倍。</p>
<p>根据指令中操作数地址码的数目的不同，可将指令分成以下几种格式。</p>
<h5 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715111354.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715111354.png';" /></details>

<p>只给出操作码OP，没有显式地址。这种指令有两种可能:</p>
<p>1)不需要操作数的指令，如空操作指令、停机指令、关中断指令等。</p>
<p>2）零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。</p>
<h5 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715111432.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715111432.png';" /></details>

<p>这种指令也有两种常见的形态，要根据操作码的含义确定究竟是哪一种。</p>
<p>1)只有目的操作数的单操作数指令，按Ay地址读取操作数，进行OP操作后，结果存回原地址。</p>
<p>指令含义：$\text{OP}(\text{A}_1) \to \text{A}_1$</p>
<p>如操作码含义是加1、减1、求反、求补等。</p>
<p>2）隐含约定目的地址的双操作数指令，按指令地址A、可读取源操作数，指令可隐含约定另一个操作数由ACC（累加器）提供，运算结果也将存放在ACC中。</p>
<p>指令含义：$\text{(ACC)OP}(\text{A}_1) \to \text{ACC}$</p>
<p>若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为$2^{24}=16\text{M}$</p>
<h5 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715111737.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715111737.png';" /></details>


<p>指令含义：$(\text{A}_1)\text{OP}(\text{A}_2)\to \text{A}_1$</p>
<p>若指令字长为32位，操作码占8位，两个地址码字段各占12位，则指令操作数的直接寻址范围为$2^{12}=4\text{K}$</p>
<h5 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715112026.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715112026.png';" /></details>

<p>指令含义：$(\text{A}_1)\text{OP}(\text{A}_2) \to \text{A}_3$</p>
<p>若指令字长为32位，操作码占8位，3个地址码字段各占8位，则指令操作数的直接寻址范围为$2^8=256$若地址字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令1次，取两个操作数2次，存放结果1次)。</p>
<h5 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715112155.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715112155.png';" /></details>

<p>指令含义：$(\text{A}_1)\text{OP}(\text{A}_2) \to \text{A}_3, \text{A}_4$=下一条将要执行指令的地址。</p>
<p>若指令字长为32位，操作码占8位，4个地址码字段各占6位，则指令操作数的直接寻址范围为$2^6=64$</p>
<h4 id="定长操作码指令格式"><a href="#定长操作码指令格式" class="headerlink" title="定长操作码指令格式"></a>定长操作码指令格式</h4><p>定长操作码指令在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般$n$位操作码字段的指令系统最大能够表示$2^n$条指令。定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。当计算机字长为32位或更长时，这是常规用法。</p>
<h4 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h4><p>为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。</p>
<p>最常见的变长操作码方法是扩展操作码，它使操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。图4.1所示即为一种扩展操作码的安排方式。</p>
<p>再图4.1中，指令字长为16位，其中4位为基本操作码字段$\text{OP}$，另有3个4位长的地址字段$A_1,A_2\text{和}A_3$。四位操作码若全部用于三地址指令，则有16条。图4.1中所示的三地址指令为15条，1111留作扩展操作码之用;二地址指令为15条，1111 1111留作扩展操作码之用;一地址指令为15条，1111 1111 1111留作扩展操作码之用;零地址指令为16条。</p>
<p>除这种安排外，还有其他多种扩展方法，如形成15条三地址指令、12条二地址指令、63条一地址指令和16条零地址指令，共106条指令，请读者自行分析。</p>
<p>在设计扩展操作码指令格式时，必须注意以下两点:</p>
<p>1)不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。</p>
<p>2）各指令的操作码一定不能重复。通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。</p>
<details><summary>图4.1 扩展操作码技术</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715112513.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715112513.png';" /></details>

<h4 id="指令的操作类型"><a href="#指令的操作类型" class="headerlink" title="指令的操作类型"></a>指令的操作类型</h4><p>设计指令系统时必须考虑应提供哪些操作类型，指令操作类型按功能可分为以下几种。</p>
<h5 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h5><p>传送指令通常有寄存器之间的传送（MOV)、从内存单元读取数据到CPU寄存器(LOAD)、从CPU寄存器写数据到内存单元(STORE)）等。</p>
<h5 id="算术和逻辑运算"><a href="#算术和逻辑运算" class="headerlink" title="算术和逻辑运算"></a>算术和逻辑运算</h5><p>这类指令主要有加（ADD)、减(SUB)、比较（CMP)、乘(MUL)、除（DIV)、加1(INC)、减1 (DEC)、与(AND)、或（OR)、取反(NOT)、异或(XOR）等。</p>
<h5 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h5><p>移位指令主要有算法移位、逻辑移位、循环移位等。</p>
<h5 id="转移操作"><a href="#转移操作" class="headerlink" title="转移操作"></a>转移操作</h5><p>转移指令主要有无条件转移(JMP)、条件转移（BRANCH)、调用(CALL )、返回(RET)、陷阱（TRAP)等。无条件转移指令在任何情况下都执行转移操作，而条件转移指令仅在特定条件满足时才执行转移操作，转移条件一般是某个标志位的值，或两个或两个以上的标志位组合。</p>
<p>调用指令和转移指令的区别:执行调用指令时必须保存下一条指令的地址（返回地址)，当子程序执行结束时，根据返回地址返回到主程序继续执行;而转移指令则不返回执行。</p>
<h5 id="输入输出操作"><a href="#输入输出操作" class="headerlink" title="输入输出操作"></a>输入输出操作</h5><p>这类指令用于完成CPU 与外部设备交换数据或传送控制命令及状态信息。</p>
<h3 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h3><p>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为指令寻址和数据寻址两大类。</p>
<p>指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址(A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址（EA)。</p>
<p>注意，(A)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。对应的(A)就是寄存器中的数值，或相应内存单元的数值。例如，EA=(A)意思是有效地址是地址A中的数值。</p>
<h4 id="指令寻址和数据寻址"><a href="#指令寻址和数据寻址" class="headerlink" title="指令寻址和数据寻址"></a>指令寻址和数据寻址</h4><p>寻址方式分为指令寻址和数据寻址两大类。寻找下一条将要执行的指令地址称为指令寻址;寻找操作数的地址称为数据寻址。</p>
<h5 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h5><p>指令寻址方式有两种:一种是顺序寻址方式，另一种是跳跃寻址方式。</p>
<p>1）顺序寻址可通过程序计数器（PC)加1(1个指令字长)，自动形成下一条指令的地址。</p>
<p>2）跳跃寻址通过转移类指令实现。所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。注意，是否跳跃可能受到状态寄存器和操作数的控制，而跳跃到的地址分为绝对地址（由标记符直接得到)和相对地址（相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过程序计数器（PC）给出。</p>
<h5 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h5><p>数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。</p>
<p>数据寻址的方式较多，为区别各种方式，通常在指令字中设一个字段，用来指明属于哪种寻址方式，由此可得指令的格式如下所示:</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113222.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113222.png';" /></details>


<h4 id="常见的数据寻址方式"><a href="#常见的数据寻址方式" class="headerlink" title="常见的数据寻址方式"></a>常见的数据寻址方式</h4><h5 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h5><p>这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。例如，单地址的指令格式就不明显地在地址字段中指出第二操作数的地址，而规定累加器（ACC）作为第二操作数地址，指令格式明显指出的仅是第一操作数的地址。因此，累加器(ACC）对单地址指令格式来说是隐含寻址，如图4.2所示。</p>
<p>隐含寻址的优点是有利于缩短指令字长;缺点是需增加存储操作数或隐含地址的硬件。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113315.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113315.png';" /></details>


<h5 id="立即-数-寻址"><a href="#立即-数-寻址" class="headerlink" title="立即(数)寻址"></a>立即(数)寻址</h5><p>这种类型的指令的地址字段指出的不是操作数的地址，而是操作数本身，又称立即数。数据采用补码形式存放。图4.3所示为立即寻址示意图，图中#表示立即寻址特征，A就是操作数本身。</p>
<p>立即寻址的优点是指令在执行阶段不访问主存，指令执行时间最短;缺点是A 的位数限制了立即数的范围。</p>
<details><summary>立即(数)寻址</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113408.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113408.png';" /></details>

<h5 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h5><p>指令字中的形式地址A是操作数的真实地址:EA，即EA=A，如图4.4所示。</p>
<details><summary>直接寻址</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113501.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113501.png';" /></details>

<p>直接寻址的优点是简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址;缺点是A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。</p>
<h5 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h5><p>间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即 EA =(A)，如图4.5所示。间接寻址可以是一次间接寻址，还可以是多次间接寻址。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113543.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113543.png';" /></details>

<p>在图4.5中，主存字第一位为1时，表示取出的仍不是操作数的地址，即多次间址;主存字第一位为0时，表示取得的是操作数的地址。</p>
<p>间接寻址的优点是可扩大寻址范围（有效地址EA 的位数大于形式地址A的位数)，便于编制程序（用间接寻址可方便地完成子程序返回);缺点是指令在执行阶段要多次访存（一次间接寻址需两次访存，多次间接寻址需根据存储字的最高位确定访存次数)。由于访问速度过慢，这种寻址方式并不常用。一般问到扩大寻址范围时，通常指的是寄存器间接寻址。</p>
<h5 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h5><p>寄存器寻址是指在指令字中直接给出操作数所在的寄存器编号，即EA = $R_i$，其操作数在由R;所指的寄存器内，如图4.6所示。</p>
<p>寄存器寻址的优点是指令在执行阶段不访问主存，只访问寄存器，因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量/矩阵运算;缺点是寄存器价格昂贵，计算机中的寄存器个数有限。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113638.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113638.png';" /></details>


<h5 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h5><p>寄存器间接寻址是指在寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址，即 EA=($R_i$)，如图4.7所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113701.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113701.png';" /></details>

<p>寄存器间接寻址的特点是，与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中)。</p>
<h5 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h5><p>相对寻址是把程序计数器(PC)的内容加上指令格式中的形式地址A而形成操作数的有效地址，即 EA= (PC)+A，其中A是相对于当前指令地址的位移量，可正可负，补码表示，如图4.8所示。</p>
<p>在图4.8中，A的位数决定操作数的寻址范围。</p>
<p>相对寻址的优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。相对寻址广泛应用于转移指令。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114009.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114009.png';" /></details>

<p>注意，对于转移指令JMP A，当CPU从存储器中取出一字节时，会自动执行(PC)＋1→PC。若转移指令的地址为X，且占2B，在取出该指令后，PC的值会增2，即$(\text{PC})=X+1$,这样在执行完该指令后，会自动跳转到$\text{X+2+A}$的地址继续执行。</p>
<h5 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h5><p>基址寻址是指将CPU 中基址寄存器（BR）的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA =(BR)+ A。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器，如图4.9所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114333.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114333.png';" /></details>

<p>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。在程序执行过程中，基址寄存器的内容不变（作为基地址)，形式地址可变（作为偏移量)。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。</p>
<p>基址寻址的优点是可扩大寻址范围（基址寄存器的位数大于形式地址A的位数);用户不必考虑自己的程序存于主存的哪个空间区域，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址A）的位数较短。</p>
<h5 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h5><p>变址寻址是指有效地址EA 等于指令字中的形式地址A与变址寄存器IX的内容之和，即EA = (IX)+ A，其中为变址寄存器（专用)，也可用通用寄存器作为变址寄存器。图4.10所示为采用专用寄存器IX的变址寻址示意图。</p>
<p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量)，形式地址A不变(作为基地址)。</p>
<p>变址寻址的优点是可扩大寻址范围（变址寄存器的位数大于形式地址A的位数);在数组处理过程中，可设定A 为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。偏移量（变址寄存器IX）的位数足以表示整个存储空间。</p>
<p>显然，变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上讲，两着有较大区别。基址寻址面向系统，主要用于为多道程序或数据分配仔储空间，内此基址奇什奋以内彷地常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的A是可变的;变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的A是不可变的。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114444.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114444.png';" /></details>

<h5 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h5><p>堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出（LIFO）原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP)。堆栈可分为硬堆栈与软堆栈两种。</p>
<p>寄存器堆栈又称硬堆栈。寄存器堆栈的成本较高，不适合做大容量的堆栈;而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。</p>
<p>在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。</p>
<p>下面简单总结寻址方式、有效地址及访存次数（不包含为了取本条指令而做的访存)，见表4.1。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114703.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114703.png';" /></details>


<h4 id="X86汇编指令入门"><a href="#X86汇编指令入门" class="headerlink" title="X86汇编指令入门"></a>X86汇编指令入门</h4><p>近几年的408真题频繁涉及X86汇编指令和机器代码相关的知识，这部分内容并不在考纲范围内，但如果对汇编知识和程序在机内执行的原理毫无了解，那么解题可能会难以下手。</p>
<h5 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h5><p>X86处理器中有8个32位的通用寄存器，各寄存器及说明如图4.11所示。为了向后兼容，EAX、EBX、ECX和 EDX 的高两位字节和低两位字节可以独立使用，E为Extended，表示32位的寄存器。例如，EAX的低两位字节称为AX，而AX的高低字节又可分别作为两个8位寄存器，分别称为AH和AL。寄存器的名称与大小写无关，既可以用EAX，又可以用eax。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114758.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114758.png';" /></details>

<p>除EBP和 ESP外，其他几个寄存器的用途是比较任意的。</p>
<h5 id="寻址模式和内存分配"><a href="#寻址模式和内存分配" class="headerlink" title="寻址模式和内存分配"></a>寻址模式和内存分配</h5><p>1)寻址模式</p>
<p>X86提供了一种灵活的内存寻址方式，这里以mov指令为例。mov用于在内存和寄存器之间移动数据，它有两个参数:第一个是目的地址，第二个是源地址。</p>
<p>下面的例子是汇编程序中常见的方式:</p>
<details>
  <summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]  <span class="comment">;将ebx值指示的内存地址中的4字节传送到eax</span></span><br><span class="line"><span class="keyword">mov</span> [var],<span class="built_in">ebx</span>  <span class="comment">;将ebx值传送到var的值指示的内存地址中</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>-<span class="number">4</span>]  <span class="comment">;将esi-4值指示的内存地址中的4字节传送到eax</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">esi</span>+<span class="built_in">eax</span>],<span class="built_in">cl</span>  <span class="comment">;将c1值传送到esi+eax值指示的内存地址中</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>,[<span class="built_in">esi</span>+<span class="number">4</span>*<span class="built_in">ebx</span>] <span class="comment">;将esi+4*ebx值指示的内存中的4字节传送到edx</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>



<p>最多只能利用两个32位寄存器和一个32位的有符号常数相加计算出一个内存地址，下面是两个违反规则的例子:</p>
<details>
  <summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>-<span class="built_in">ecx</span>] <span class="comment">;错误,只能用加法</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">eax</span>+<span class="built_in">esi</span>+<span class="built_in">edi</span>], <span class="built_in">ebx</span> <span class="comment">;错误,最多只能有两个寄存器参与运算</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>



<p>2）数据类型长度规定</p>
<p>在汇编语言中声明内存大小时，一般显式地使用DB(字母D表示 Data，字母B表示Byte)、DW(字母W表示Word，2Bytes）和DD(第二个字母D表示Double Word，4Bytes)，这样就能很好地指导编译器分配内存空间，但是对于</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> [<span class="built_in">ebx</span>], <span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</details>

<p>若无特殊标识，则不确定常数⒉是单字节、双字节还是双字。对于这种情况，X86提供了三个指示规则标记，分别为BYTE PTR、WORD PTR和 DWORD PTR，如将上例写成</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>],<span class="number">2</span>  <span class="comment">;将2以单字节形式传送到ebx值指示的内存地址中</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>], <span class="number">2</span>  <span class="comment">;将2以双字节形式传送到ebx值指示的内存地址中</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>],<span class="number">2</span>  <span class="comment">;将2以四字节形式传送到ebx值指示的内存地址中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h5 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h5><p>汇编指令通常可以分为数据传送指令、逻辑计算指令和控制流指令，本节将讲述其中最重要的指令。以下用于操作数的标记分别表示寄存器、内存和常数。</p>
<p><code>&lt;reg&gt;</code>:表示任意寄存器，若其后带有数字，则指定其位数，如<code>&lt;reg32&gt;</code>表示32位寄存器(EAX、EBX、ECX、EDX、ESI、EDI、ESP或EBP);<code>&lt;reg16&gt;</code>表示16位寄存器(AX、 BX、CX或 DX);<code>&lt;reg8&gt;</code>表示8位寄存器(AH、AL、BH、BL、CH、CL、DH、DL )。</p>
<p><code>&lt;mem&gt;</code>:表示内存地址（如[ eax ]、[ var+4 ]或dword ptr [ eax+ebx ])。</p>
<p><code>&lt;con&gt;</code>:表示8位、16位或32位常数。<code>&lt;con8&gt;</code>表示8位常数;<code>&lt;con16&gt;</code>表示16位常数;<code>&lt;con32&gt;</code>表示32位常数。（constant）</p>
<p>X86中的指令机器码长度为1字节，对同一指令的不同用途有多种编码方式，比如 mov指令就有28种机内编码，用于不同操作数类型或用于特定寄存器，例如，</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,&lt;con16&gt;<span class="comment">;机器码为B8H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,&lt;con8&gt;<span class="comment">;机器码为BOH</span></span><br><span class="line"><span class="keyword">mov</span> &lt;reg16&gt;/&lt;mem16&gt;,&lt;reg16&gt;<span class="comment">;机器码为89H</span></span><br><span class="line"><span class="keyword">mov</span> &lt;reg8&gt;, &lt;reg8&gt;/&lt;mem <span class="number">8</span>&gt;<span class="comment">;机器码为8AH</span></span><br><span class="line"><span class="keyword">mov</span> &lt;reg16&gt;,&lt;reg16&gt;/&lt;mem16&gt;  <span class="comment">;机器码为8BH</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h6 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h6><p><strong>mov指令</strong></p>
<p>mov指令将第二个操作数（寄存器的内容、内存中的内容或常数值）复制到第一个操作数(寄存器或内存)。但不能用于直接从内存复制到内存，其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;reg&gt;,mem&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;reg&gt;, &lt;con&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;mem&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure>
</details>

<p>举例:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span><span class="comment">;将ebx值复制到eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [var], <span class="number">5</span><span class="comment">;将5保存到var值指示的内存地址的一字节中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>push指令</strong></p>
<p>push 指令将操作数压入内存的栈，常用于函数调用。ESP是栈顶，压栈前先将ESP值减4(栈增长方向与内存地址增长方向相反)，然后将操作数压入ESP指示的地址。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> &lt;reg32&gt;</span><br><span class="line"><span class="keyword">push</span> &lt;mem&gt;</span><br><span class="line"><span class="keyword">push</span> &lt;con32&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例（注意，栈中元素固定为32位):</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">eax</span><span class="comment">;将eax值压栈</span></span><br><span class="line"><span class="keyword">push</span> [var]<span class="comment">;将var值指示的内存地址的4字节值压栈</span></span><br></pre></td></tr></table></figure>
</details>

<p><strong>pop指令</strong></p>
<p>与push指令相反，pop 指令执行的是出栈工作，出栈前先将ESP指示的地址中的内容出栈，然后将ESP值加4。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">edi</span> <span class="comment">;弹出栈顶元素送到edi</span></span><br><span class="line"><span class="keyword">pop</span> [<span class="built_in">ebx</span>] <span class="comment">;弹出栈顶元素送到ebx值指示的内存地址的4字节中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h6 id="算术和逻辑运算指令"><a href="#算术和逻辑运算指令" class="headerlink" title="算术和逻辑运算指令"></a>算术和逻辑运算指令</h6><p><strong>add/sub指令</strong></p>
<p>add指令将两个操作数相加，相加的结果保存到第一个操作数中。sub指令用于两个操作数相减，相减的结果保存到第一个操作数中。它们的语法格式类似，语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> &lt;reg&gt;,&lt;reg&gt; / <span class="keyword">sub</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;reg&gt;,&lt;mem&gt; / <span class="keyword">sub</span> &lt;reg&gt;,mem&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;mem&gt;,&lt;reg&gt; / <span class="keyword">sub</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;reg&gt;,&lt;con&gt; / <span class="keyword">sub</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;mem&gt;,&lt;con&gt; / <span class="keyword">sub</span> &lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">10</span><span class="comment">;eaxeax-10</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [var],<span class="number">10</span><span class="comment">;10与 var值指示的内存地址的一字节值相加，并将结果保存在var值指示的内存地址的字节中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>inc/dec指令</strong></p>
<p>inc、dec指令分别表示将操作数自加1、自减1，其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inc</span> &lt;reg&gt; / <span class="keyword">dec</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">inc</span> &lt;mem&gt; / <span class="keyword">dec</span> &lt;mem&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dec</span> <span class="built_in">eax</span><span class="comment">; eax值自减1</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [var]<span class="comment">; var值指示的内存地址的4字节值自加1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>imul指令</strong></p>
<p>带符号整数乘法指令，它有两种格式:①两个操作数，将两个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器;②三个操作数，将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,&lt;reg32&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,mem&gt;</span><br><span class="line"><span class="keyword">imul</span>&lt;reg32&gt;, &lt;reg32&gt;, &lt;con&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,&lt;mem&gt;, &lt;con&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">imul</span> <span class="built_in">eax</span>, [var]<span class="comment">;eaxeax*[var]</span></span><br><span class="line"><span class="keyword">imul</span> <span class="built_in">esi</span>, <span class="built_in">edi</span>, <span class="number">25</span><span class="comment">;esi edi *25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>乘法操作结果可能溢出，则编译器置溢出标志OF=1，以使CPU调出溢出异常处理程序。</p>
<p><strong>idiv指令</strong></p>
<p>idiv是带符号整数除法指令，它只有一个操作数，即除数，而被除数则为edx:eax 中的内容(64位整数)，操作结果有两部分:商和余数，商送到eax，余数则送到edx。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">idiv</span> &lt;reg32&gt;</span><br><span class="line"><span class="keyword">idiv</span> &lt;mem&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">idiv</span> <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">idiv</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [var]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>and/or/xor指令</strong></p>
<p>and、or、xor指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> &lt;reg&gt;,&lt;reg&gt; / <span class="keyword">or</span> &lt;reg&gt;,&lt;reg&gt; / <span class="keyword">xor</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;reg&gt;,&lt;mem&gt; / <span class="keyword">or</span> &lt;reg&gt;,&lt;mem&gt; / <span class="keyword">xor</span> &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;mem&gt;,&lt;reg&gt; / <span class="keyword">or</span> &lt;mem&gt;,&lt;reg&gt; / <span class="keyword">xor</span> &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;reg&gt;,&lt;con&gt; / <span class="keyword">or</span> &lt;reg&gt;,&lt;con&gt; / <span class="keyword">xor</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;mem&gt;,&lt;con&gt; / <span class="keyword">or</span> &lt;mem&gt;,&lt;con&gt; / <span class="keyword">xor</span> &lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="built_in">eax</span>,OfH<span class="comment">;将eax中的前28位全部置为0，最后4位保持不变</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span><span class="comment">;置edx中的内容为0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>not指令</strong></p>
<p>not指令是位翻转指令，将操作数中的每一位翻转，即0→1、1→0。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span>&lt;reg&gt;</span><br><span class="line"><span class="keyword">not</span>&lt;mem&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [var]<span class="comment">;将var值指示的内存地址的一字节的所有位翻转</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>neg指令</strong></p>
<p>neg是取负指令。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">neg</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">neg</span> &lt;mem&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">neg</span> <span class="built_in">eax</span> <span class="comment">;eax &lt;- -eax</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>shl/shr指令</strong></p>
<p>shl、shr是逻辑移位指令，shl为逻辑左移，shr为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> &lt;reg&gt;,&lt;con8&gt; / <span class="keyword">shr</span> &lt;reg&gt;,&lt;con8&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;mem&gt;,&lt;con8&gt; / <span class="keyword">shr</span> &lt;mem&gt;,&lt;con8&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;reg&gt;,&lt;<span class="built_in">cl</span>&gt; / <span class="keyword">shr</span> &lt;reg&gt;,&lt;<span class="built_in">cl</span>&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;mem&gt;,&lt;<span class="built_in">cl</span>&gt; / <span class="keyword">shr</span> &lt;mem&gt;,&lt;<span class="built_in">cl</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> <span class="built_in">eax</span>,<span class="number">1</span><span class="comment">;将eax值左移1位，相当于乘以2</span></span><br><span class="line"><span class="keyword">shr</span> <span class="built_in">ebx</span>,<span class="built_in">cl</span><span class="comment">;将 ebx值右移n位（n为c1中的值)，相当于除以2^n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h6 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h6><p>X86 处理器维持着一个指示当前执行指令的指令指针(P)，当一条指令执行后，此指针自动指向下一条指令。IP寄存器不能直接操作，但可以用控制流指令更新。通常用标签（label)指示程序中的指令地址，在X86汇编代码中，可在任何指令前加入标签。例如,</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+<span class="number">8</span>]</span><br><span class="line"><span class="symbol">begin:</span>  <span class="keyword">xor</span> <span class="built_in">ecx</span>, <span class="built_in">ecx</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>这样就用begin指示了第二条指令，控制流指令通过标签就可以实现程序指令的跳转。</p>
<p><strong>jmp指令</strong></p>
<p>jmp指令控制I转移到label所指示的地址（从label中取出指令执行)。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> &lt;label&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> begin <span class="comment">;转跳到begin标记的指令执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>jcondition指令</strong></p>
<p>条件转移指令，它依据处理机状态字中的一系列条件状态转移。处理机状态字中包括指示最后一个算术运算结果是否为0，运算结果是否为负数等。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">je</span>  &lt;label&gt; (jump when equal)</span><br><span class="line"><span class="keyword">jne</span> &lt;label&gt; (jump when <span class="keyword">not</span> equal)</span><br><span class="line"><span class="keyword">jz</span>  &lt;label&gt; (jump when last result was <span class="meta">zero</span>)</span><br><span class="line"><span class="keyword">jg</span>  &lt;label&gt; (jump when greater than)</span><br><span class="line"><span class="keyword">jge</span> &lt;label&gt; (jump when greater than <span class="keyword">or</span> equal to)</span><br><span class="line">j1  &lt;label&gt; jump when less than)</span><br><span class="line"><span class="keyword">jle</span> &lt;label&gt;（jump when less than <span class="keyword">or</span> equal to)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">jle</span> done <span class="comment">;如果eax的值小于等于ebx值，跳转到done指示的指令执行，否则执行下一条指令。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>cmp指令</strong></p>
<p>cmp 指令用于比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;,reg&gt;</span><br><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line"><span class="keyword">cmp</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>cmp指令通常和jcondition指令搭配使用，举例:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [var],<span class="number">10</span></span><br><span class="line"><span class="keyword">jne</span> <span class="keyword">loop</span><span class="comment">;如果var指示的内存地址的4字节内容等于10,则继续执行下一条指令;否则跳转到loop指示的指令执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>call/ret指令</strong></p>
<p>call 和 ret这两条指令分别实现子程序（过程、函数等）的调用及返回。call 指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其他简单的跳转指令不同，call指令保存调用之前的地址信息（当call 指令结束后，返回调用之前的地址)。ret指令实现子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。call和ret是函数调用中最关键的两条指令，其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> &lt;label&gt;</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
</details>

<p>理解上述指令的语法和用途，可以更好地帮助读者解答相关题型。汇编语言虽不在考纲范围，但计算机组成原理是一门和硬件紧密关联的学科，涉及编译、指令、内存、处理机等方方面面。读者在上机调试℃程序代码时，也可以尝试用编译器调试，以便更好地帮助理解机器指令的执行，这也从侧面说明了408真题越来越重视考查学生的综合能力。</p>
<h3 id="CISC和-RISC的基本概念"><a href="#CISC和-RISC的基本概念" class="headerlink" title="CISC和 RISC的基本概念"></a>CISC和 RISC的基本概念</h3><p>指令系统朝两个截然不同的方向的发展:一是增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC)，典型的有采用X86架构的计算机;二是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机（RISC)，典型的有ARM、MIPS 架构的计算机。</p>
<h4 id="复杂指令系统计算机-CISC"><a href="#复杂指令系统计算机-CISC" class="headerlink" title="复杂指令系统计算机(CISC)"></a>复杂指令系统计算机(CISC)</h4><p>随着VLSI 技术的发展，硬件成本不断下降，软件成本不断上升，促使人们在指令系统中增加更多、更复杂的指令，以适应不同的应用领域，这样就构成了复杂指令系统计算机(CISC)。</p>
<p>CISC的主要特点如下:</p>
<p>1）指令系统复杂庞大，指令数目一般为200条以上。2）指令的长度不固定，指令格式多，寻址方式多。</p>
<p>3）可以访存的指令不受限制。</p>
<p>4）各种指令使用频度相差很大。</p>
<p>5）各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。</p>
<p>6）控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。</p>
<p>7）难以用优化编译生成高效的目标代码程序。</p>
<p>如此庞大的指令系统，对指令的设计提出了极高的要求，研制周期变得很长。后来人们发现，一味地追求指令系统的复杂和完备程度不是提高计算机性能的唯一途径。对传统CISC指令系统的测试表明，各种指令的使用频率相差悬殊，大概只有20%的比较简单的指令被反复使用，约占整个程序的80%;而 80%左右的指令则很少使用，约占整个程序的20%。从这一事实出发，人们开始了对指令系统合理性的研究，于是 RISC随之诞生。</p>
<h4 id="精简指令系统计算机-RISC"><a href="#精简指令系统计算机-RISC" class="headerlink" title="精简指令系统计算机(RISC)"></a>精简指令系统计算机(RISC)</h4><p>精简指令系统计算机（RISC）的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。RISC的主要特点如下:</p>
<p>1）选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。</p>
<p>2）指令长度固定，指令格式种类少，寻址方式种类少。</p>
<p>3)只有Load/Store(取数/存数）指令访存，其余指令的操作都在寄存器之间进行。</p>
<p>4)CPU中通用寄存器的数量相当多。</p>
<p>5）RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</p>
<p>6）以硬布线控制为主，不用或少用微程序控制。</p>
<p>7）特别重视编译优化工作，以减少程序执行时间。</p>
<p>值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但KISC间化」令尔有n的咏田性，因此应该是未来处理器的此大多数RISC机不能与老机器兼容。由于 KISC 具有史B的‘名机件松具提据CISC设计的，发展方向。但事实上，当今时代Intel 几乎一统江湖，且早期很多软件都是根据CISC 设计的，单纯的RISC将无法兼容。此外，现代 CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。CISC可以提供更多的功能，这是程序设计所需要的。</p>
<h4 id="CISC和-RISC的比较"><a href="#CISC和-RISC的比较" class="headerlink" title="CISC和 RISC的比较"></a>CISC和 RISC的比较</h4><p>和 CISC相比，RISC的优点主要体现在以下几点:</p>
<p>1)RISC 更能充分利用VLSI芯片的面积。CISC的控制器大多采用微程序控制，其控制存储器在CPU芯片内所占的面积达50%以上，而RISC控制器采用组合逻辑控制，其硬布线逻辑只占CPU芯片面积的10%左右。</p>
<p>2)RISC 更能提高运算速度。RISC 的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成3)RISC便于设计，可降低成本，提高可靠性。RISC指令系统简单，因此机器设计周期短;其逻辑简单，因此可靠性高。</p>
<p>4)RISC有利于编译程序代码优化。RISC 指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化。</p>
<p>CISC和 RISC的对比见表4.2。</p>
<details><summary>4.2 CISC和 RISC的比较</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715135937.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715135937.png';" /></details>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch3-存储系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 09:59:38" itemprop="dateCreated datePublished" datetime="2021-06-30T09:59:38+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-13 16:12:48" itemprop="dateModified" datetime="2021-07-13T16:12:48+08:00">2021-07-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p>p101</p>
<p>(一）存储器的分类</p>
<p>(二）存储器的层次化结构</p>
<p>(三）半导体随机存取存储器</p>
<p>SRAM、DRAM、只读存储器、Flash存储器(四）主存储器与CPU的连接</p>
<p>(五）双口 RAM和多模块存储器</p>
<p>(六）高速缓冲存储器(Cache)</p>
<p>Cache的基本工作原理</p>
<p>Cache和主存之间的映射方式</p>
<p>Cache 中主存块的替换算法</p>
<p>Cache 写策略</p>
<p>(七）虚拟存储器</p>
<p>虚拟存储器的基本概念;页式虚拟存储器</p>
<p>段式虚拟存储器;段页式虚拟存储器;TLB（快表)</p>
<p>【复习提示】</p>
<p>本章是历年命题重点，特别是有关Cache和虚拟存储器的考点容易出综合题。此外，存储器的分类与特点，存储器的扩展（芯片选择、连接方式、地址范围等)，低位交叉存储器，Cache 的相关计算与替换算法，虚拟存储器与快表也容易出选择题。读者应在掌握基本原理和理论的基础上，多结合习题进行反复训练，以加深巩固。另外，读者需掌握存在Cache和TLB的计算机中的地址翻译与Cache 映射问题，也建议结合《操作系统考研复习指导》复习。</p>
<p>本章有两个难点:一是Cache 映射规律、容量计算及替换特性;二是交叉存储器访问时间和访问效率。二者都可与第5章的大题综合，或与第6章总线访问内存时间的计算问题综合。</p>
<p>在学习本章时，请读者思考以下问题:</p>
<p>1）存储器的层次结构主要体现在何处?为何要分这些层次﹖计算机如何管理这些层次?</p>
<p>2）存取周期和存取时间有何区别?</p>
<p>3）在虚拟存储器中，页面是设置得大一些好还是设置得小一些好?请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。</p>
<h3 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h3><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><p>存储器种类繁多，可从不同角度对存储器进行分类。</p>
<h5 id="按在计算机中的作用（层次）分类"><a href="#按在计算机中的作用（层次）分类" class="headerlink" title="按在计算机中的作用（层次）分类"></a>按在计算机中的作用（层次）分类</h5><p>1)）主存储器。简称主存，又称内存储器（内存)，用来存放计算机运行期间所需的大量程序和数据，CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器(Cache）及辅助存储器交换数据。其特点是容量较小、存取速度较快、每位价格较高。</p>
<p>2）辅助存储器。简称辅存，又称外存储器（外存)，是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，它不能与CPU直接交换信息。其特点是容量极大、存取速度较慢、单位成本低。</p>
<p>3）高速缓冲存储器。简称Cache，位于主存和CPU之间，用来存放正在执行的程序段和数据，以便CPU能高速地使用它们。Cache的存取速度可与CPU的速度相匹配，但存储容量小、价格高。现代计算机通常将它们制作在CPU 中。</p>
<h5 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h5><p>按存储介质，存储器可分为磁表面存储器（磁盘、磁带)、磁心存储器半导体存储器（MOS型存储器、双极型存储器）和光存储器（光盘)。</p>
<h5 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h5><p>1）随机存储器(RAM)。存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。其优点是读写方便、使用灵活，主要用作主存或高速缓冲存储器。RAM又分为静态RAM和动态RAM（第3节会详细介绍)。</p>
<p>2）只读存储器（ROM)。存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉字字库等。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。由ROM派生出的存储器也包含可反复重写的类型，ROM和RAM 的存取方式均为随机存取。注意广义上的只读存储器已可通过电擦除等方式进行写入，其“只读”的概念没有保留，但仍保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多。</p>
<p>3）串行访问存储器。对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括.顺序存取存储器（如磁带）与直接存取存储器（如磁盘、光盘)。</p>
<p>顺序存取存储器的内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关，其特点是存取速度慢。直接存取存储器既不像 RAM 那样随机地访问任何一个存储单元，又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。存取信息时通常先寻找整个存储器中的某个小区域(如磁盘上的磁道)，再在小区域内顺序查找。</p>
<h5 id="按信息的可保存性分类"><a href="#按信息的可保存性分类" class="headerlink" title="按信息的可保存性分类"></a>按信息的可保存性分类</h5><p>断电后，存储信息即消失的存储器，称为易失性存储器，如 RAM。断电后信息仍然保持的存储器，称为非易失性存储器，如ROM、磁表面存储器和光存储器。若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出;若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。</p>
<h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><p>存储器有3个主要性能指标，即存储容量、单位成本和存储速度。这3个指标相互制约，设计存储器系统所追求的目标就是大容量、低成本和高速度。</p>
<p>1)存储容量=存储字数×字长（如1M×8位)。单位换算: 1B(Byte，字节)= 8b (bit,位)。存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。</p>
<p>2）单位成本:每位价格=总成本/总容量。</p>
<p>3）存储速度:数据传输率=数据的宽度/存储周期。<br>${\textstyle\unicode{x2460}}$  存取时间($T_a$):存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</p>
<p>${\textstyle\unicode{x2461}}$ 存取周期（$T_m$):存取周期又称读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。</p>
<p>${\textstyle\unicode{x2462}}$ 主存带宽（$B_m$):主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（B/s）或位/秒(b/s)。</p>
<p>存取时间不等于存储周期，通常存储周期大于存取时间。这是因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达$T_m = 2T_a$，因为存储器中的信息读出后需要马上进行再生。</p>
<p>存取时间与存取周期的关系如图3.1所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706191304.png" alt=""></p>
<h3 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h3><h4 id="多级存储系统"><a href="#多级存储系统" class="headerlink" title="多级存储系统"></a>多级存储系统</h4><p>为了解决存储系统大容量、高速度和低成本3个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构，如图3.2所示。在图中由上至下，位价越来越低，速度越来越慢，容量越来越大，CPU 访问的频度也越来越低。</p>
<p>实际上，存储系统层次结构主要体现在“Cache-主存”层次和“主存-辅存”层次。前者主要解决CPU 和主存速度不匹配的问题，后者主要解决存储系统的容量问题。在存储体系中，Cache、主存能与CPU直接交换信息，辅存则要通过主存与CPU交换信息;主存与CPU、Cache、辅存都能交换信息，如图3.3所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706191358.png" alt=""></p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。从 CPU 的角度看，“Cache-主存”层次速度接近于Cache，容量和位价却接近于主存。从“主存-辅存”层次分析，其速度接近于主存，容量和位价却接近于辅存。这就解决了速度、容量、成本这三者之间的矛盾，现代计算机系统几乎都采用这种三级存储系统。需要注意的是，主存和 Cache 之间的数据调动是由硬件自动完成的，对所有程序员均是透明的;而主存和辅存之间的数据调动则是由硬件和操作系统共同完成的，对应用程序员是透明的。</p>
<p>在“主存-辅存”这一层次的不断发展中，逐渐形成了虚拟存储系统，在这个系统中程序员编程的地址范围与虚拟存储器的地址空间相对应。对具有虚拟存储器的计算机系统而言，编程时可用的地址空间远大于主存空间。</p>
<blockquote>
<p>注意:在“Cache-主存”和“主存-辅存”层次中，上一层中的内容都只是下一层中的内容的副本，也即Cache (或主存）中的内容只是主存（或辅存）中的内容的一部分。</p>
</blockquote>
<h3 id="半导体随机存储器"><a href="#半导体随机存储器" class="headerlink" title="半导体随机存储器"></a>半导体随机存储器</h3><p>p107</p>
<p>主存储器由DRAM 实现，靠处理器的那一层(Cache）则由 SRAM 实现它们都属于易失性存储器，只要电源被切断，原来保存的信息便会丢失。DRAM的每比特成本低于SRAM，速度也慢于SRAM，价格差异主要是因为制造DRAM需要更多的硅。而ROM属于非易失性存储器。</p>
<h4 id="SRAM和-DRAM"><a href="#SRAM和-DRAM" class="headerlink" title="SRAM和 DRAM"></a>SRAM和 DRAM</h4><h5 id="SRAM的工作原理"><a href="#SRAM的工作原理" class="headerlink" title="SRAM的工作原理"></a>SRAM的工作原理</h5><p>通常把存放一个二进制位的物理器件称为存储元，它是存储器的最基本的构件。地址码相同的多个存储元构成一个存储单元。若干存储单元的集合构成存储体。</p>
<p>静态随机存储器（SRAM）的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此即使信息被读出后，它仍保持其原状态而不需要再生（非破坏性读出)。</p>
<p>SRAM的存取速度快，但集成度低，功耗较大，所以一般用来组成高速缓冲存储器。</p>
<h5 id="DRAM的工作原理"><a href="#DRAM的工作原理" class="headerlink" title="DRAM的工作原理"></a>DRAM的工作原理</h5><p>与SRAM 的存储原理不同，动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的，DRAM的基本存储元通常只使用一个晶体管，所以它比SRAM 的密度要高很多。DRAM 采用地址复用技术，地址线是原来的1/2，地址信号分行、列两次传送。</p>
<p>相对于SRAM 来说，DRAM具有容易集成、位价低、容量大和功耗低等优点，但 DRAM的存取速度比SRAM的慢，一般用来组成大容量主存系统。</p>
<p>DRAM 电容上的电荷一般只能维持1~2ms，因此即使电源不断电，信息也会自动消失。为此，每隔一定时间必须刷新，通常取2ms，称为刷新周期。常用的刷新方式有3种:</p>
<p>1）集中刷新:指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”。优点是读写操作时不受刷新工作的影响;缺点是在集中刷新期间（死区）不能访问存储器。</p>
<p>2）分散刷新:把对每行的刷新分散到各个工作周期中。这样，一个存储器的系统工作周期分为两部分:前半部分用于正常读、写或保持;后半部分用于刷新。这种刷新方式增加了系统的存取周期，如存储芯片的存取周期为0.5us，则系统的存取周期为1us。优点是没有死区;缺点是加长了系统的存取周期，降低了整机的速度。</p>
<p>3）异步刷新:异步刷新是前两种方法的结合，它既可缩短“死时间”，又能充分利用最大刷新间隔为2ms的特点。具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求。这样可以避免使CPU连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的工作效率。</p>
<p>DRAM 的刷新需注意以下问题:①刷新对CPU是透明的，即刷新不依赖于外部的访问;②动态RAM 的刷新单位是行，由芯片内部自行生成行地址;③刷新操作类似于读操作，但又有所不同。另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。</p>
<p>读者需要注意易失性存储器和刷新的区别，易失性存储器是指断电后数据丢失，SRAM 和DRAM都满足断电内容消失，但需要刷新的只有DRAM，而SRAM不需要刷新。</p>
<h5 id="存储器芯片的内部结构"><a href="#存储器芯片的内部结构" class="headerlink" title="存储器芯片的内部结构"></a>存储器芯片的内部结构</h5><p>如图3.4所示，存储器芯片由存储体、IO读写电路、地址译码和控制电路等部分组成。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192109.png" alt=""></p>
<p>1)存储体（存储矩阵)。存储体是存储单元的集合，它由行选择线(X）和列选择线(Y)来选择所访问单元，存储体的相同行、列上的位同时被读出或写入。</p>
<p>2）地址译码器。用来将地址转换为译码输出线上的高电平，以便驱动相应的读写电路。3)IO控制电路。用以控制被选中的单元的读出或写入，具有放大信息的作用。</p>
<p>4）片选控制信号。单个芯片容量太小，往往满足不了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时，必须“选中”该存储字所在的芯片，而其他芯片不被“选中”，因此需要有片选控制信号。</p>
<p>5）读/写控制信号。根据CPU给出的是读命令还是写命令，控制被选中单元进行读或写。</p>
<h5 id="存储器的读、写周期"><a href="#存储器的读、写周期" class="headerlink" title="存储器的读、写周期"></a>存储器的读、写周期</h5><p>(1) RAM的读周期</p>
<p>从给出有效地址开始，到读出所选中单元的内容并在外部数据总线上稳定地出现所需的时间，称为读出时间($t_A$)。地址片选信号$\bar{CS}$必须保持到数据稳定输出，$t_{CO}$为片选的保持时间，在读周期中$\bar{WE}$为高电平。RAM芯片的读周期时序图如图3.5所示。</p>
<p>读周期与读出时间是两个不同的概念，读周期时间（$t_{RC}$）表示存储芯片进行两次连续读操作时所必须间隔的时间，它总是大于等于读出时间。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192257.png" alt=""></p>
<p>(2）RAM的写周期</p>
<p>要实现写操作，要求片选信号$\bar{CS}$和写命令信号$\bar{WE}$必须都为低电平。为使数据总线上的信息能够可靠地写入存储器，要求$\bar{CS}$信号与$\bar{WE}$信号相“与”的宽度至少为$t_W$</p>
<p>为了保证在地址变化期间不会发生错误写入而破坏存储器的内容，$\bar{WE}$信号在地址变化期间必须为高电平。为了保证有效数据的可靠写入，地址有效的时间至少应为 $t_{WC} = t_{AW} + t_W +t_{WR}$。为了保证在$\bar{WE}$和$\bar{CS}$变为无效前能把数据可靠地写入，要求写入的数据必须在 $t_{DW}$以前在数据总线上已经稳定。RAM芯片的写周期时序图如图3.6所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192339.png" alt=""></p>
<h5 id="SRAM和DRAM的比较"><a href="#SRAM和DRAM的比较" class="headerlink" title="SRAM和DRAM的比较"></a>SRAM和DRAM的比较</h5><p>表3.1详细列出了SRAM 和 DRAM各自的特点。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192659.png" alt=""></p>
<h4 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h4><h5 id="只读存储器-ROM）的特点"><a href="#只读存储器-ROM）的特点" class="headerlink" title="只读存储器(ROM）的特点"></a>只读存储器(ROM）的特点</h5><p>ROM 和 RAM 都是支持随机存取的存储器，其中 SRAM和 DRAM均为易失性半导体存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电也不会丢失，它在计算机系统中是只供读出的存储器。ROM器件有两个显著的优点:</p>
<p>1）结构简单，所以位密度比可读写存储器的高。</p>
<p>2）具有非易失性，所以可靠性高。</p>
<h5 id="ROM的类型"><a href="#ROM的类型" class="headerlink" title="ROM的类型"></a>ROM的类型</h5><p>根据制造工艺的不同，ROM可分为掩模式只读存储器(MROM)、一次可编程只读存储器(PROM)、可擦除可编程只读存储器（EPROM)、闪速存储器（Flash Memory)和固态硬盘(Solid State Drives)。</p>
<p>(1）掩模式只读存储器</p>
<p>MROM 的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，写入以后任何人都无法改变其内容。优点是可靠性高，集成度高，价格便宜;缺点是灵活性差。</p>
<p>(2）一次可编程只读存储器</p>
<p>PROM 是可以实现一次性编程的只读存储器。允许用户利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。</p>
<p>(3）可擦除可编程只读存储器</p>
<p>EPROM不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写。需要修改EPROM 的内容时，先将其全部内容擦除，然后编程。EPROM 又可分为两种，即紫外线擦除(UVEPROM)和电擦除（$E^2PROM$)。EPROM 虽然既可读又可写，但它不能取代 RAM，因为EPROM 的编程次数有限，且写入时间过长。</p>
<p>(4）闪速存储器（Flash Memory)</p>
<p>Flash Memory是在EPROM与$E^2PROM$的基础上发展起来的，其主要特点是既可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写。闪速存储器既有EPROM 的价格便宜、集成度高的优点，又有$E^2PROM$电可擦除重写的特点，且擦除重写的速度快。</p>
<p>(5）固态硬盘(Solid State Drives，SSD)</p>
<p>基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元(FLASH 芯片）组成。保留了Flash Memory长期保存信息、快速擦除与重写的特性。对比传统硬盘也具有读写速度快、低功耗的特性，缺点是价格较高。</p>
<h4 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h4><p>图3.7是主存储器(Main Memory，MM）的基本组成框图，其中由一个个存储0或1的记忆单元（也称存储元件）构成的存储矩阵（也称存储体）是存储器的核心部分。记忆单元是具有两种稳态的能表示二进制0和1的物理器件。为了存取存储体中的信息，必须对存储单元编号（也称编址)。编址单位是指具有相同地址的那些存储元件构成的一个单位，可以按字节编址，也可以按字编址。现代计算机通常采用字节编址方式，此时存储体内的一个地址中有1字节。</p>
<p>指令执行过程中需要访问主存时，CPU 首先把被访问单元的地址送到MAR中，然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码选中相应单元，同时CPU将读写信号通过控制线送到主存的读写控制电路。如果是写操作，那么CPU同时将要写的信息送到 MDR中，在读写控制电路的控制下，经数据线将信号写入选中的单元;如果是读操作，那么主存读出选中单元的内容送到数据线，然后送到 MDR 中。数据线的宽度与MDR的苋度相同，地址线的宽度与 MAR 的宽度相同。图3.6采用64位数据线，所以在按字节编址方式下，每次最多可以存取8个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。例如，36位地址的最大寻址范围为0～$2^{36}$-1，即地址从О开始编号。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713143016.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143016.png';" /></details>


<p>数据线数和地址线数共同反映存储体容量的大小，图3.6中芯片的容量=$2^{36}×64$位。</p>
<h3 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h3><h4 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h4><p>1）主存储器通过数据总线、地址总线和控制总线与CPU连接。</p>
<p>2）数据总线的位数与工作频率的乘积正比于数据传输率。</p>
<p>3）地址总线的位数决定了可寻址的最大内存空间。4）控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻。</p>
<p>主存储器与CPU的连接如图3.8所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713143129.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143129.png';" /></details>

<h4 id="主存容量的扩展"><a href="#主存容量的扩展" class="headerlink" title="主存容量的扩展"></a>主存容量的扩展</h4><p>由于单个存储芯片的容量是有限的，它在字数或字长方面与实际存储器的要求都有差距，因此需要在字和位两方面进行扩充才能满足实际存储器的容量要求。通常采用位扩展法、字扩展法和字位同时扩展法来扩展主存容量。</p>
<h5 id="位扩展法"><a href="#位扩展法" class="headerlink" title="位扩展法"></a>位扩展法</h5><p>CPU 的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位（即进行位扩展，用多个存储器件对字长进行扩充，增加存储字长)，使其数据位数与CPU的数据线数相等。位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。</p>
<p>如图3.9所示，用8片8K×1位的RAM芯片组成8K×8位的存储器。8片RAM芯片的地址线$A_{12}\backsim A_0$、$\bar{CS}$、$\bar{WE}$都分别连在一起，每片的数据线依次作为CPU数据线的一位。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713143317.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143317.png';" /></details>

<blockquote>
<p>注意:仅采用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某一时刻选中所有的芯片，所以片选信号$\bar{CS}$要连接到所有芯片。</p>
</blockquote>
<h5 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h5><p>字扩展是指增加存储器中字的数量，而位数不变。字扩展将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。</p>
<p>如图3.10所示，用4片16K×8位的RAM芯片组成64K×8位的存储器。4片RAM芯片的数据线$D_0\backsim D_7$和$\bar{WE}$都分别连在一起。将$A_{15}A_{14}$用作片选信号，$A_{15}A_{14}$=00时，译码器输出端0有效，选中最左边的1号芯片;$A_{15}A_{14}$= 01时，译码器输出端1有效，选中2号芯片,以此类推（在同一时间内只能有一个芯片被选中)。各芯片的地址分配如下:</p>
<p>第1片，最低地址:$\mathbf{00}$00000000000000;最高地址:$\mathbf{00}$11111111111111 (16位)</p>
<p>第2片，最低地址:$\mathbf{01}$00000000000000;最高地址:$\mathbf{01}$11111111111111</p>
<p>第3片，最低地址:$\mathbf{10}$00000000000000;最高地址:$\mathbf{10}$11111111111111</p>
<p>第4片，最低地址:$\mathbf{11}$00000000000000;最高地址:$\mathbf{11}$11111111111111</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713143507.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143507.png';" /></details>

<blockquote>
<p>注意:仅采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在某一时刻只需选中部分芯片，所以通过片选信号$\overline{CS}$或采用译码器设计连接到相应的芯片。</p>
</blockquote>
<h5 id="字位同时扩展法"><a href="#字位同时扩展法" class="headerlink" title="字位同时扩展法"></a>字位同时扩展法</h5><p>实际上，存储器往往需要同时扩充字和位。字位同时扩展是指既增加存储字的数量，又增加存储字长。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713144506.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713144506.png';" /></details>

<p>如图3.11所示，用8片16K×4位的 RAM芯片组成64K×8位的存储器。每两片构成一组16K×8位的存储器（位扩展)，4组便构成64K×8位的存储器（字扩展)。地址线$A_{15}A_{14}$经译码器得到4个片选信号，$A_{15}A_{14}$ = 00时，输出端0有效，选中第一组的芯片（①和②);$A_{15}A_{14}$ =01时，输出端1有效，选中第二组的芯片（③和④)，以此类推。</p>
<blockquote>
<p>注意:采用字位同时扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号$\overline{CS}$或采用译码器设计连接到相应的芯片。</p>
</blockquote>
<h4 id="存储芯片的地址分配和片选"><a href="#存储芯片的地址分配和片选" class="headerlink" title="存储芯片的地址分配和片选"></a>存储芯片的地址分配和片选</h4><p>CPU 要实现对存储单元的访问，首先要选择存储芯片，即进行片选;然后为选中的芯片依地址码选择相应的存储单元，以进行数据的存取，即进行字选。片内的字选通常是由CPU送出的N条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端(N由片内存储容量$2^N$决定)。片选信号的产生分为线选法和译码片选法。</p>
<h5 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h5><p>线选法用除片内寻址外的高位地址线直接（或经反相器）分别接至各个存储芯片的片选端，当某地址线信息为“0”时，就选中与之对应的存储芯片。这些片选地址线每次寻址时只能有一位有效，不允许同时有多位有效，这样才能保证每次只选中一个芯片（或芯片组)。假设4 片2K×8位存储芯片用线选法构成8K×8位存储器，各芯片的片选信号见表3.2，其中低位地址线$A_{10}～A_0$作为字选线，用于片内寻址。</p>
<p>优点:不需要地址译码器，线路简单。缺点:地址空间不连续，选片的地址线必须分时为低电平（否则不能工作)，不能充分利用系统的存储器空间，造成地址资源的浪费。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713144828.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713144828.png';" /></details>

<h5 id="译码片选法"><a href="#译码片选法" class="headerlink" title="译码片选法"></a>译码片选法</h5><p>译码片选法用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号。如用8片8K×8位的存储芯片组成64K×8位存储器（地址线为16位，数据线为8位)，需要8个片选信号;若采用线选法，除去片内寻址的13位地址线，仅余高3位，不足以产生8个片选信号。因此，采用译码片选法，即用一片74LS138作为地址译码器，则$A_{15}A_{14}A_{13}$ = 000时选中第一片，$A_{15}A_{14}A_{13}$ = 001时选中第二片，以此类推（即3位二进制编码)。</p>
<h4 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h4><h5 id="合理选择存储芯片"><a href="#合理选择存储芯片" class="headerlink" title="合理选择存储芯片"></a>合理选择存储芯片</h5><p>要组成一个主存系统，选择存储芯片是第一步，主要指存储芯片的类型(RAM 或ROM)和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数，RAM 则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单、方便。</p>
<h5 id="地址线的连接"><a href="#地址线的连接" class="headerlink" title="地址线的连接"></a>地址线的连接</h5><p>存储芯片的容量不同，其地址线数也不同，而CPU的地址线数往往比存储芯片的地址线数要多。通常将CPU地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选)，这部分的译码是由芯片的片内逻辑完成的。而CPU地址线的高位则在扩充存储芯片时使用，用来选择存储芯片(片选)，这部分译码由外接译码器逻辑完成。</p>
<p>例如，设CPU地址线为16位，即$A_{15}～$A_0$$，1K×4位的存储芯片仅有10根地址线，此时可将CPU的低位地址$A_9～A_0$与存储芯片的地址线$A_9～A_0$相连。</p>
<h5 id="数据线的连接"><a href="#数据线的连接" class="headerlink" title="数据线的连接"></a>数据线的连接</h5><p>CPU的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连;在不等时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。</p>
<h5 id="读-写命令线的连接"><a href="#读-写命令线的连接" class="headerlink" title="读/写命令线的连接"></a>读/写命令线的连接</h5><p>CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。有些CPU的读/写命令线是分开的（读为$\overline{RD}$，写为$\overline{WE}$，均为低电平有效)，此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。</p>
<h5 id="片选线的连接"><a href="#片选线的连接" class="headerlink" title="片选线的连接"></a>片选线的连接</h5><p>片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端$\overline{CS}$是否能接收到来自CPU的片选有效信号。</p>
<p>片选有效信号与CPU的访存控制信号$\overline{MREQ}$（低电平有效）有关，因为只有当CPU要求访存时，才要求选中存储芯片。若CPU访问I/O，则$\overline{MREQ}$为高，表示不要求存储器工作。</p>
<h3 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h3><p>为了提高CPU 访问存储器的速度，可以采用双端口存储器、多模块存储器等技术,它们同属并行技术，前者为空间并行，后者为时间并行。</p>
<h4 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h4><p>双端口RAM是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元，如图3.12所示。当两个端口的地址不相同时，在两个端口上进行读写操作一定不会发生冲突。</p>
<p>两个端口同时存取存储器的同一地址单元时，会因数据冲突造成数据存储或读取错误。两个端口对同一主存操作有以下4种情况:</p>
<p>1)两个端口不同时对同一地址单元存取数据。</p>
<p>2）两个端口同时对同一地址单元读出数据。</p>
<p>3)两个端口同时对同一地址单元写入数据。</p>
<p>4）两个端口同时对同一地址单元操作，一个写入数据，另一个读出数据。</p>
<p>其中，第1）种和第2）种情况不会出现错误;第3）种情况会出现写入错误;第4)种情况会出现读出错误。</p>
<p>解决方法:置“忙”信号$\overline{BUSY}$为0，由判断逻辑决定暂时关闭一个端口（即被延时)，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713145516.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713145516.png';" /></details>



<h4 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h4><p>为提高访存速度，常采用多模块存储器，常用的有单体多字存储器和多体低位交叉存储器。</p>
<blockquote>
<p>注意:CPU的速度比存储器的快，若同时从存储器中取出$n$条指令，就可充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想提出的。</p>
</blockquote>
<h5 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h5><p>单体多字系统的特点是存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。</p>
<p>单体多字系统在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每隔1/m存取周期，CPU向主存取一条指令。显然，这增大了存储器的带宽，提高了单体存储器的工作速度。</p>
<p>缺点:指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显。</p>
<h5 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h5><p>多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。</p>
<p>多体并行存储器分为高位交叉编址（顺序方式）和低位交叉编址（交叉方式)两种。</p>
<p>1)高位交叉编址:高位地址表示体号，低位地址为体内地址。如图 3.13所示，存储器共有4个模块$M_0～M_3$，每个模块有n个单元，各模块的地址范围如图中所示。</p>
<p>高位交叉编址方式下，总是把低位的体内地址达到出风也佑问完才转到下一个模块访问，问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，存储模块不能被并行访问，因而不能提高存储器的吞吐率。</p>
<blockquote>
<p>注意:模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器。</p>
</blockquote>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713145913.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713145913.png';" /></details>

<p>2）低位交叉编址:低位地址为体号，高位地址为体内地址。如图3.14所示，每个模块按“模m”交叉编址，模块号=单元地址%<br>m，假定m个模块，每个模块有k个单元，则0，m，$\cdots$,$(k-1)m$单元位于$M_0$;第1，m+1，$\cdots$,$(k-1)m+1$单元位于$M_1$；依次类推。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713150108.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150108.png';" /></details>

<p>低位交叉编址方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。采用低位交叉编址后，可在不改变每个模块存取周期的前提下,采用流水线的方式并行存取，提高存储器的带宽。</p>
<p>设模块字长等于数据总线宽度，模块存取一个字的存取周期为$T$，总线传送周期为$r$，为实现流水线方式存取，存储器交叉模块数应大于等于</p>
<script type="math/tex; mode=display">
m=T/r</script><p>式中，m称为交叉存取度。每经过r时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于等于m，以保证启动某模块后经过m×r的时间后再次启动该模块时，其上次的存取操作已经完成（即流水线不间断)。这样，连续存取m个字所需的时间为</p>
<script type="math/tex; mode=display">
t_1 - T + (m-1)r</script><p>而顺序方式连续读取m个字所需的时间为$t_2 = mT$。可见低位交叉存储器的带宽大大提高。模块数为4的流水线方式存取示意图如图3.15所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713150634.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150634.png';" /></details>


<details><summary>例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713150701.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150701.png';" /></details>


<h3 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h3><p>由于程序的转移概率不会很低，数据分布的离散性较大，所以单纯依靠并行主存系统提高主存系统的频宽是有限的。这就必须从系统结构上进行改进，即采用存储体系。通常将存储系统分为“Cache-主存”层次和“主存-辅存”层次。</p>
<h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><p>程序访问的局部性原理包括时间局部性和空间局部性。时间局部性是指在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环。空间局部性是指在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。</p>
<p>高速缓冲技术就是利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的Cache 中，使CPU的访存操作大多数针对Cache进行，从而大大提高程序的执行速度。</p>
<details><summary>局部性比较的例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713150844.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150844.png';" /></details>


<h4 id="Cache-的基本工作原理"><a href="#Cache-的基本工作原理" class="headerlink" title="Cache 的基本工作原理"></a>Cache 的基本工作原理</h4><p>Cache位于存储器层次结构的顶层，通常由SRAM构成，其基本结构如图3.17所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713151122.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713151122.png';" /></details>

<p>为便于Cache和主存之间交换信息，Cache和主存都被划分为相等的块，Cache块又称Cache 行，每块由若干字节组成，块的长度称为块长(Cache行长)。由于Cache 的容量远小于主存的容量，所以Cache 中的块数要远少于主存中的块数，它仅保存主存中最活跃的若干块的副本。因此Cache 按照某种策略，预测CPU在未来一段时间内欲访存的数据，将其装入Cache。</p>
<p>当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关;若Cache不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入Cache。若此时Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。值得注意的是，CPU与Cache之间的数据交换以字为单位，而Cache 与主存之间的数据交换则以Cache块为单位。</p>
<blockquote>
<p>注意:某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则主存访问终止;否则访问主存并替换Cache。</p>
</blockquote>
<p>当CPU发出写请求时，若 Cache命中，有可能会遇到Cache 与主存中的内容不一致的问题。例如，由于CPU 写Cache，把 Cache 某单元中的内容从X修改成了X’，而主存对应单元中的内容仍然是X，没有改变。所以若Cache命中，需要按照一定的写策略处理，常见的处理方法有全写法和写回法，详见本节的Cache 写策略部分。</p>
<p>CPU欲访问的信息已在Cache 中的比率称为Cache的命中率。设一个程序执行期间，Cache的总命中次数为$N_c$，访问主存的总次数为$N_m$，则命中率$H$为</p>
<script type="math/tex; mode=display">
H=N_c/(N_c+N_m)</script><p>可见为提高访问效率，命中率$H$越接近1越好。设$t_c$.为命中时的Cache访问时间，$t_m$为未命中时的访问时间，1-H表示未命中率，则Cache-主存系统的平均访问时间$T_a$为</p>
<script type="math/tex; mode=display">
T_a = Ht_c+(1-H)t_m</script><details><summary>平均访问时间计算的例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713151848.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713151848.png';" /></details>

<blockquote>
<p>这里的平均访问时间可以理解为，整个系统消耗在访存上的时间</p>
</blockquote>
<h4 id="Cache和主存的映射方式"><a href="#Cache和主存的映射方式" class="headerlink" title="Cache和主存的映射方式"></a>Cache和主存的映射方式</h4><p>Cache行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cache。</p>
<p>由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在 Cache 中，因此在Cache 中要为每块加一个标记，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明Cache行中的信息是否有效，每个Cache行需要一个有效位。</p>
<p>地址映射的方法有以下3种。</p>
<h5 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h5><p>主存中的每一块只能装入Cache 中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法)。直接映射实现简单，但不够灵活，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。</p>
<p>直接映射的关系可定义为</p>
<script type="math/tex; mode=display">
j=i mod 2^c</script><p>式中，$j$是Cache的块号（又称Cache行号），$i$是主存的块号，$2^c$是Cache中的总块数。在这种映射方式中，主存的第0块、第$2^c+1$块，第$2^{c+1}+1$块$\cdots$只能映射到Cache的第1行，以此类推。由映射函数可看出，主存块号的低$c$位正好是它要装入的Cache行号。给每个Cache行设置一个长为$t=m-c$的标记(tag),当主存某块调入Cache后，就将其块号的高t位设置在对应Cache行的标记中，如图3.18(a)所示。</p>
<p>直接映射的地址结构为</p>
<details><summary>直接映射的地址结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713152631.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713152631.png';" /></details>

<p>CPU放存过程如图3.18(b)所示。首先根据访存地址中间的c位，找到对应的Cache行，将对应Cache行中的标记和主存地址的高t位标记进行比较，若相等且有效位为1，则访问Cache“命中”，此时根据主存地址中低位的块内地址，在对应的Cache行中存取信息；若不相等或有效位为0，则“不命中”，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache行中，将有效位置1，并将标记设置为地址中的高t位，同时将该地址中的内容送CPU。</p>
<details><summary>图3.18 图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713152658.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713152658.png';" /></details>


<h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>主存中的每一块可以装入Cache 中的任何位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。全相联映射方式的优点是比较灵活，Cache 块的冲突概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射，如图3.19所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713153647.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713153647.png';" /></details>

<p>全相联映射的地址结构为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713153710.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713153710.png';" /></details>


<h5 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h5><p>将Cache 空间分成大小相同的组，主存的一个数据块可以装入一组内的任何一个位置，即组间采取直接映射，而组内采取全相联映射，如图 3.20所示。它是对直接映射和全相联映射的一种折中，当Q= 1时变为全相联映射，当Q = Cache块数时变为直接映射。假设每组有r个Cache行，则称之为r路组相联，图3.20的设置中每组有2个Cache行，因此称为2路组相联。</p>
<p>组相联映射的关系可以定义为</p>
<script type="math/tex; mode=display">
j = i mod  Q</script><p>式中，j式Cache行的组号，i是主存的块号，Q是Cache的组数。</p>
<p>路数越大，即每组 Cache 行的数量越大，发生块冲突的概率越低，但相联比较电路也越复杂。选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。</p>
<p>组相联映射的地址结构为</p>
<details><summary>组相联映射的地址结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154134.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154134.png';" /></details>

<p>CPU 访存过程如下:首先根据访存地址中间的组号找到对应的Cache组;将对应Cache组中每个行的标记与主存地址的高位标记进行比较;若有一个相等且有效位为1，则访问Cache命中，此时根据主存地址中的块内地址，在对应Cache行中存取信息;若都不相等或虽相等但有效位为0，则不命中，此时CPU 从主存中读出该地址所在的一块信息送到对应Cache 组的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154218.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154218.png';" /></details>

<details><summary>例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154314.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154314.png';" /><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154336.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154336.png';" /></details>



<h4 id="Cache-中主存块的替换算法"><a href="#Cache-中主存块的替换算法" class="headerlink" title="Cache 中主存块的替换算法"></a>Cache 中主存块的替换算法</h4><p>在采用全相联映射或组相联映射方式时，从主存向Cache传送一个新块，当Cache或Cache组中的空间已被占满时，就需要使用替换算法置换Cache行。而采用直接映射时，一个给定的主存块只能放到唯一的固定Cache行中，所以在对应 Cache 行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而无须考虑替换算法。</p>
<p>常用的替换算法有随机(RAND)算法、先进先出(FIFO）算法、近期最少使用（LRU)算法和最不经常使用(LFU)算法。其中最常考查的是LRU 算法。</p>
<p>1）随机算法:随机地确定替换的Cache块。它的实现比较简单，但未依据程序访问的局部性原理，因此可能命中率较低。</p>
<p>2）先进先出算法:选择最早调入的行进行替换。它比较容易实现，但也未依据程序访问的局部性原理，因为最早进入的主存块也可能是目前经常要用的。</p>
<p>3）近期最少使用算法:依据程序访问的局部性原理，选择近期内长久未访问过的Cache行作为替换的行，平均命中率要比FIFO的高，是堆栈类算法。</p>
<p>LRU算法对每个Cache行设置一个计数器，用计数值来记录主存块的使用情况，并根据计数值选择淘汰某个块，计数值的位数与Cache组大小有关，2路时有一位LRU位，4路时有两位LRU位。假定采用4路组相联，有5个主存块{1,2,3,4,5}映射到Cache 的同一组，对于主存访问序列{1,2,3,4,1,2,5,1,2,3,4,5}，采用LRU算法的替换过程如图3.23所示。图中左边阴<br>影的数字是对应Cache行的计数值，右边的数字是存放在该行中的主存块号。</p>
<details><summary>图3.23 LRU 算法的替换过程示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154711.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154711.png';" /></details>

<p>计数器的变化规则:①命中时，所命中的行的计数器清零，比其低的计数器加 1，<br>其余不<br>变;②未命中且还有空闲行时，新装入的行的计数器置0，其余全加1;③未命中且无空闲行时，计数值为3的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。<br>当集中访问的存储区超过Cache 组的大小时，命中率可能变得很低，如上例的访问序列变为1,2,3,4,5,1,2,3,4,5,…，而Cache每组只有4行，那么命中率为0，这种现象称为抖动。</p>
<p>4）最不经常使用算法:将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从О开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。这种算法与LRU类似，但不完全相同。</p>
<h4 id="Cache-写策略"><a href="#Cache-写策略" class="headerlink" title="Cache 写策略"></a>Cache 写策略</h4><p>因为Cache 中的内容是主存块副本，当对Cache 中的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保持一致。此时分两种情况。</p>
<p>对于Cache 写命中( write hit)，有两种处理方法。</p>
<p>1）全写法（写直通法、write-through)。当CPU对Cache写命中时，必须把数据同时写入Cache和主存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache 的效率。写缓冲:为减少全写法直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲（Write Buffer )，如下图所示。CPU同时写数据到Cache 和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个 FIFO 队列，写缓冲可以解决速度不兀配的问题。侣若出现频繁写时．会伸写缓冲饱和溢出。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713155910.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713155910.png';" /></details>

<p>2）写回法 ( write-back)。当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。这种方法减少了访存次数，但存在个一致的隐患。采用这种策略时，每个Cache 行必须设置一个标志位（脏位)，以反映此块是否被CPU修改过。</p>
<p>全写法和写回法都对应于Cache写命中（要被修改的单元在Cache中）时的情况。</p>
<p>对于Cache 写不命中，也有两种处理方法。</p>
<p>1)写分配法（write-allocate)。加载主存中的块到Cache 中，然后更新这个Cache 块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。</p>
<p>2）非写分配法(not-write-allocate）法。只写入主存，不进行调块。</p>
<p>非写分配法通常与全写法合用，写分配法通常和写回法合用。</p>
<p>现代计算机的Cache通常设立多级Cache(通常为3级)，假定设3级Cache，按离CPU的远近可各自命名为L1 Cache、L2 Cache、L3 Cache，离CPU越远，访问速度越慢，容量越大。指令Cache 与数据Cache分离一般在L1级，此时通常为写分配法与写回法合用。</p>
<p>下图是一个含有两级Cache的系统，L1 Cache对 L2 Cache 使用全写法，L2 Cache对主存使用写回法，由于L2 Cache 的存在，其访问速度大于主存，因此避免了因频繁写时造成的写缓冲饱和溢出。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160100.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160100.png';" /></details>

<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>主存和联机工作的辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量，提高了存储系统的性价比。</p>
<h4 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h4><p>虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。</p>
<p>用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间。实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。虚地址比实地址要大很多。虚拟存储器的地址空间如图3.24所示。</p>
<p>CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个成地址对应的存储单元内容是否已装入主存。若已在主存中，则通过地址变换，CPU 可直接访问主仔指示的实际单元;若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU 访问。右主存已满，则采用替换算法置换主存中的一页或一段。</p>
<p>在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前运行所需要的部分调入主存，供CPU使用，其余暂不运行的部分则留在磁盘中。</p>
<details><summary>虚拟存储器的3个地址空间</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160354.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160354.png';" /></details>



<h4 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h4><p>以页为基本单位的虚拟存储器称为页式虚拟存储器。虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页。把虚拟地址分为网个子段:应贝勺们贝内地址。虚拟地址到物理地址的转换是由页表实现的。页表是一张存放在主存中的虚页号和实页号的对照表，它记录程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。</p>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><p>图3.25是一个页表示例。有效位也称装入位，用来表示对应页面是否在主存，若为 1，则表示该虚拟页已从外存调入主存，此时页表项存放该页旳物理页号;若为0，则表示没有调入主存，此时页表项可以存放该页的磁盘地址。脏位也称修改位，用来表示页面是否被修改过，虚存机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。引用位也称使用位，用来配合替换策略进行设置，例如是否实现最先调入(FIFO位）或最近最少用(LRU位）策略等。</p>
<details><summary>图3.25 主存中的页表示例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160635.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160635.png';" /></details>

<p>CPU 执行指令时，需要先将虚拟地址转换为主存物理地址。每个进程都有一个页表基址寄存器，存放该进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项，若装入位为1，则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址;若装入位为0，则说明缺页，需要操作系统进行缺页处理。地址变换的过程如图3.26所示。</p>
<p>页式虚拟存储器的优点是，页面的长度固定,页表简单，调入方便。缺点是，由于程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。</p>
<details><summary>图3.26页式虚拟存储器的地址变换过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160731.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160731.png';" /></details>

<h5 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h5><p>由地址转换过程可知，访存时先访问一次主存去查页表，再访问主存才能取得数据。如果缺页，那么还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了。</p>
<p>依据程序执行的局部性原理，在一段时间内总是经常访问某些贝时，若把这些贝对应的贝表项存放在高速缓冲器组成的快表(TLB）中，则可以明显提高效率。相应地把放在主存中的页表称为慢表(Page)。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。</p>
<p>快表通常采用全相联或组相联方式。每个TLB项由页表表项内容加上一个TLB标记字段组成，TLB标记用来表示该表项取自页表中哪个虚页号对应的页表项，因此，TLB标记的内容在全相联方式下就是该页表项对应的虚页号;组相联方式下则是对应虚页号的高位部分，而虚页号的低位部分用于选择TLB组的组索引。</p>
<h5 id="具有TLB和Cache的多级存储系统"><a href="#具有TLB和Cache的多级存储系统" class="headerlink" title="具有TLB和Cache的多级存储系统"></a>具有TLB和Cache的多级存储系统</h5><p>图3.27是一个具有TLB和Cache的多级存储系统，其中Cache 采用二路组相联方式。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较，若有某一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换;若未命中，则TLB缺失，需要访问主存去查贝表。图中所示的定网级页表方式，虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB，若 TLB已满，则还需要采用替换策略。完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的Cache行或组，将对应Cache行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送CPU。</p>
<details><summary>图3.27 TLB和 Cache的访问过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160922.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160922.png';" /></details>

<p>查找时，快表和慢表也可以同步进行，若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。</p>
<p>在一个具有Cache和 TLB的虚拟存储系统中，CPU一次访存操作可能涉及TLB、页表、Cache、主存和磁盘的访问，访问过程如图3.28所示。可以看出，CPU访存过程中存在三种缺失情况:①TLB缺失:要访问的页面对应的页表项不在TLB中:②Cache 缺失:要访问的主存块不在Cache 中:③缺页(Page):要访问的页面不在主存中。这三种缺失的几种可能组合情况如表3.3所示。</p>
<p>最好的情况是第1种组合，此时无须访问主存;第﹖种和第3种组合都需要访问一次主存﹔第4种组合需要访问两次主存;第5种组合发生“缺页异常”，需要访问磁盘，并且至少访问两次主存。Cache 缺失处理由硬件完成;缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现;而TLB缺失既可以用硬件又可以用软件来处理，比如操作系统有专门的“TLB缺失异常处理”程序。</p>
<details><summary>图3.28 带TLB 虚拟存储器的CPU访存过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160956.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160956.png';" /></details>

<details><summary>TLB、Page、Cache三种缺失的可能组合情况
</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713161018.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713161018.png';" /></details>


<h4 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h4><p>段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两部分:段号和段内地址。虚拟地址到实地址乙间的受撰定出纹农术实现的e入仪足卧序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。</p>
<p>CPU 根据虚拟地址访存时，首先根据段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存(装入位为“1”，表示该段已调入主存;装入位为“0”，表示该段不在主存中)。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。段式虚拟存储器的地址变换过程如图3.29所示。</p>
<p>段式虚拟存储器的优点是，段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享;缺点是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</p>
<details><summary>图3.29段式虚拟存储器的地址变换过程
</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713161116.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713161116.png';" /></details>




<h4 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h4><p>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器。在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。</p>
<p>虚地址分为段号、段内页号、页内地址三部分。CPU 根据虚地址访存时，首先根据段号得到段表地址;然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址;最后从页表中取出实页号，与页内地址拼接形成主存实地址。</p>
<p>段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。缺点是在地址变换过程中需要两次查表，系统开销较大。</p>
<h4 id="虚拟存储器与Cache的比较"><a href="#虚拟存储器与Cache的比较" class="headerlink" title="虚拟存储器与Cache的比较"></a>虚拟存储器与Cache的比较</h4><p>虚拟存储器与Cache既有很多相同之处，又有很多不同之处。</p>
<h5 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h5><p>1）最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。</p>
<p>2）都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大。</p>
<p>3）都有地址的映射、替换算法、更新策略等问题。</p>
<p>4)依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中</p>
<h5 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h5><p>1)Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量。</p>
<p>2) Cache 全由硬件实现，是硬件存储器，对所有程序员透明;而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。</p>
<p>3）对于不命中性能影响，因为CPU的速度约为Cache 的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。</p>
<p>4)CPU 与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache;而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch2-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch2-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch2-数据的表示与运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 09:59:25" itemprop="dateCreated datePublished" datetime="2021-06-30T09:59:25+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 15:01:06" itemprop="dateModified" datetime="2021-09-09T15:01:06+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h2><p>(一）数制与编码</p>
<p>进位计数制及其相互转换;真值和机器数;字符与字符串</p>
<p>(二)定点数的表示和运算<br>定点数的表示:无符号数的表示;有符号数的表示</p>
<p>定点数的运算:定点数的移位运算;原码定点数的加减运算;补码定点数的加减运算;定点数的乘/除运算;溢出概念和判别方法</p>
<p>(三）浮点数的表示和运算</p>
<p>浮点数的表示:IEEE 754标准;浮点数的加减运算</p>
<p>(四)算术逻辑单元（ALU)</p>
<p>串行加法器和并行加法器;ALU的功能和结构</p>
<p>本章内容较为繁杂，由于计算机中数的表示和运算方法与人们日常生活中的表示和不同，因此理解也较为困难。纵观近几年的真题，不难发现unsigned、short、int、long、float、double等在C语言中的表示、运算、溢出判断、隐式类型转换、强制类型转换、IEEE 754浮点数的表示，以及浮点数的运算，都是考研考查的重点，需要牢固掌握。<br>在学习本章时，请读者思考以下问题:</p>
<p>1）在计算机中，为什么要采用二进制来表示数据?</p>
<p>2）计算机在字长足够的情况下能够精确地表示每个数吗?若不能，请举例说明。3）字长相同的情况下，浮点数和定点数的表示范围与精度有什么区别?</p>
<p>4）用移码表示浮点数的阶码有什么好处?</p>
<p>请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。</p>
<blockquote>
<p>比较不清晰的知识点：小数的表示(IEEE 754和浮点数)，和加减乘除(原补)</p>
</blockquote>
<h3 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h3><h4 id="进位计数制及其相互转换"><a href="#进位计数制及其相互转换" class="headerlink" title="进位计数制及其相互转换"></a>进位计数制及其相互转换</h4><p>在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点。</p>
<p>1）二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位制造成本比较低，例如用高低电平或电荷的正负极性都可以很方便地表示0和1。</p>
<p>2)二进制位1和О正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。</p>
<p>3）二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。</p>
<h5 id="进位计数法"><a href="#进位计数法" class="headerlink" title="进位计数法"></a>进位计数法</h5><p>进位计数法是一种计数的方法。常用的进位计数法有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数。</p>
<p>在进位计数法中，每个数位所用到的不同数码的个数称为$\color{green}{\text{基数}}$。十进制的基数为10 （0～9)，每个数位计满10就向高位进位，即“逢十进一”。</p>
<p>十进制数101，其个位的1显然与百位的1所表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为$\color{green}{\text{位权}}$。一个进位数的数值大小就是它的各位数码按权相加。</p>
<p>一个$r$进制数（$K_n K_{n-1}\cdots K_0 K_{-1}\cdots K_{-m}$）的数值可表示为</p>
<p>$K_nr^n + K_{n-1}r^{n-1} + \cdots + K_0r^0+\cdots + K_{-m}r^{-m} = \displaystyle \sum_{i=n}^{-m}K_ir^i$</p>
<p>式中，$r$是基数;$r^i$是第$i$位的位权（整数位最低位规定为第$0$位);$K$的取值可以是$0, 1, \cdots ,r-1$共r个数码中的任意一个。</p>
<h6 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h6><p>计算机中用得最多的是基数为2的计数制，即二进制。二进制只有0和1两种数字符号，计数“逢二进一”。它的任意数位的权为2，i为所在位数。</p>
<h6 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h6><p>八进制作为二进制的一种书写形式，其基数为8，有0~7共8个不同的数字符号，计数“逢八进一”。因为r = 8 = $2^3$，所以只要把二进制中的3位数码编为一组就是一位八进制数码，两者之间的转换极为方便。</p>
<h6 id="十六进制。"><a href="#十六进制。" class="headerlink" title="十六进制。"></a>十六进制。</h6><p>十六进制也是二进制的一种常用书写形式，其基数为16,“逢十六进一”。每个数位可取0～9、A、B、C、D、E、F中的任意一个，其中A、B、C、D、E、F分别表示10～15。因为r = 16=$2^4$，因此4位二进制数码与1位十六进制数码相对应。</p>
<h5 id="不同进制数之间的相互转换"><a href="#不同进制数之间的相互转换" class="headerlink" title="不同进制数之间的相互转换"></a>不同进制数之间的相互转换</h5><h6 id="二进制数转换为八进制数和十六进制数"><a href="#二进制数转换为八进制数和十六进制数" class="headerlink" title="二进制数转换为八进制数和十六进制数"></a>二进制数转换为八进制数和十六进制数</h6><p>对于一个二进制混合数（既包含整数部分，又包含小数部分)，在转换时应以小数点为界。其整数部分，从小数点开始往左数，将一串二进制数分为3位(八进制)一组或4位(十六进制）一组，在数的最左边可根据需要加“0”补齐;对于小数部分，从小数户开炬仕石效，也付一串二进制数分为3位一组或4位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为3或4的整数倍，然后分别用对应的八进制数或十六进制数取代。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630211029.png" alt=""></p>
<p>所以，对应的八进制数为$(1702.32)_8$= $(1111000010.01101)_2$。</p>
<p>同样，由八进制数或十六进制数转换成二进制数，只需将每位改为3位或4位二进制数即可(必要时去掉整数最高位或小数最低位的0)。八进制数和十六进制数之间的转换也能方便地实现，十六进数制转换为八进制数（或八进制数转换为十六进制数）时，先将十六进制（八进制）数转换为二进制数，然后由二进制数转换为八进制（十六进制）数较为方便。</p>
<h6 id="任意进制数转换为十进制数"><a href="#任意进制数转换为十进制数" class="headerlink" title="任意进制数转换为十进制数"></a>任意进制数转换为十进制数</h6><p>将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。</p>
<p>例如，$(11011.1)_2= 1×2^4+1×2^3+0×2^2＋1×2^1+1×2^0+1×2^{-1}=27.5。$</p>
<h6 id="十进制数转换为任意进制数"><a href="#十进制数转换为任意进制数" class="headerlink" title="十进制数转换为任意进制数"></a>十进制数转换为任意进制数</h6><p>一个十进制数转换为任意进制数，常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，对整数部分用除基取余法，对小数部分用乘基取整法，最后将整数部分与小数部分的转换结果拼接起来。</p>
<p>除基取余法（整数部分的转换):整数部分除基取余，最先取得的余数为数的最低位最后取得的余数为数的最高位（即除基取余，先余为低，后余为高)，商为0时结束。</p>
<p>整数部分:</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630212706.png" alt=""></p>
<p>小数部分:</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630213424.png" alt=""></p>
<p>因此小数部分0.6875 =$(0.1011)_2$，所以123.6875=$(1111011.1011)_2$。</p>
<blockquote>
<p>注意:在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示。例如0.3，无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示，希望读者引起重视。<br>注意:关于十进制数转换为任意进制数为何采用除基取余法和乘基取整法，以及所取之数放置位置的原理，请结合r进制数的数值表示公式思考，而不应死记硬背。</p>
</blockquote>
<h4 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h4><p>在日常生活中，通常用正号、负号来分别表示正数（正号可省略）和负数，如+15、-8等。这种带“+”或“-”符号的数称为$\color{green}{\text{真值}}$。真值是机器数所代表的实际值。</p>
<p>在计算机中，通常采用数的符号和数值一起编码的方法来表示数据。常用的有原码、补码和反码表示法。这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。如0，101（这里的逗号“,”实际上并不存在，仅为区分符号位与数值位）表示+5。这种把符号“数字化”的数称为机器数。</p>
<h4 id="BCD码"><a href="#BCD码" class="headerlink" title="*BCD码"></a>*BCD码</h4><p>二进制编码的十进制数（Binary-Coded Decimal,BCD)通常采用4位二进制数来表示一位十进制数中的0~9这10个数码。这种编码方法使二进制数和十进制数之间的转换得以快速进行。但4位二进制数可以组合出16种代码，因此必有6种状态为冗余状态。</p>
<h5 id="8421码-最常用"><a href="#8421码-最常用" class="headerlink" title="8421码(最常用)"></a>8421码(最常用)</h5><p>8421码（最常用)。它是一种有权码，设其各位的数值为b;,b，b, bo，则权值从高到低依次为8，4，2，1，它表示的十进制数为D= $8b_3，+ 4b_2+2b_1+ 1b_0$。如8→1000;9→1001。</p>
<p>若两个8421码相加之和小于等于$(1001)_2$。即$(9)_{10}$，则不需要修正;若相加之和大于等于(1010),即(10)10，则要加6修正（从1010到1111这6个为无效码，当运算结果落于这个区间时，需要将运算结果加上 6)，并向高位进位，进位可以在首次相加或修正时产生。</p>
<h5 id="余3码。"><a href="#余3码。" class="headerlink" title="余3码。"></a>余3码。</h5><p>这是一种无权码，是在8421码的基础上加$(0011)_2$形成的，因每个数都多余“3”，因此称为余3码。如8→1011;9→1100。</p>
<h5 id="2421码。"><a href="#2421码。" class="headerlink" title="2421码。"></a>2421码。</h5><p>这也是一种有权码，权值由高到低分别为2,4,2,1，特点是大于等于5的4位二进制数中最高位为1，小于5的最高位为0。如5→1011而非0101。</p>
<h4 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h4><p>由于计算机内部只能识别和处理二进制代码，所以字符都必须按照一定的规则用一组二进制编码来表示。</p>
<h5 id="字符编码ASCII码"><a href="#字符编码ASCII码" class="headerlink" title="字符编码ASCII码"></a>字符编码ASCII码</h5><p>目前，国际上普遍采用的一种字符系统是7位二进制编码的 ASCII 码（每个字节的最高位保持为0，可用于传输时的奇偶校验位)，它可表示10个十进制数码、52个英文大写字母和小写字母(A～Z，a～z)及一定数量的专用符号（如$、%、+、=等)，共128个字符。</p>
<p>在 ASCII 码中，编码值0~31为控制字符，用于通信控制或设备的功能控制;编码值127是DEL码;编码值32是空格SP;编码值32～126共95个字符称为可印刷字符。</p>
<blockquote>
<p>$\color{green}{\text{提示}}$:0<code>~</code>9的 ASCII码值为48（011 0000 ) <code>~</code>57 (011 1001 )，即去掉高3位，只保留低4位，正好是二进制形式的0<code>~</code>9。<br><code>[65,90]</code>=<code>[A,Z]</code>,<code>[97,122]</code>=<code>[a,z]</code></p>
</blockquote>
<h5 id="汉字的表示和编码"><a href="#汉字的表示和编码" class="headerlink" title="汉字的表示和编码"></a>汉字的表示和编码</h5><p>在1981年实施的国家标准GB 2312—1980 中，每个编码用两字节表示，收录了一级汉字3755个、二级汉字3008个、各种符号682个，共计7445个。</p>
<p>目前最新的汉字编码是2000年公布的国家标准GB 18030，它收录了27484个汉字。编码标准采用1B、2B和4B。</p>
<p>汉字的编码包括汉字的输入编码、汉字内码、汉字字形码三种，它们是计算机中用于输入、内部处理和输出三种用途的编码。区位码是国家标准局于1980年颁布、1981年实施的标准，它用两字节表示一个汉字，每字节用七位码，并将汉字和图形符号排列在一个94行94 列的二维代码表中。区位码是4位十进制数，前2位是区码，后2位是位码，所以称为区位码。</p>
<p>国标码将十进制的区位码转换为十六进制数后，再在每字节上加上 20H。国标码两字节的最高位都是0，ASCII 码的最高位也是0。为了方便计算机区分中文字符和英文字符，将国标码两字节的最高位都改为“1”，这就是汉字内码。</p>
<p>区位码和国标码都是输入码，它们和汉字内码的关系（十六进制）如下:</p>
<p>国标码=$\text{(区位码)}_{16}$+2020H</p>
<p>汉字内码=$\text{(国标码)}_{16}$+ 8080H</p>
<blockquote>
<p>这一段话讲了和没讲是一样的</p>
</blockquote>
<h4 id="校验码"><a href="#校验码" class="headerlink" title="*校验码"></a>*校验码</h4><p>校验码是指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来检验或纠错编码。</p>
<p>通常某种编码都由许多码字构成，任意两个合法码字之间最少变化的二进制位数，称为数据校验码的$\color{green}{\text{码距}}$。对于码距不小于2的数据校验码，开始具有检错的能力。码距越大，检错、纠错的能力就越强，而且检错能力总是大于等于纠错能力。下面介绍3种常用的校验码（建议结合《计算机网络考研复习指导》第3章的“差错控制”章节进行综合复习)。</p>
<blockquote>
<p>如1100和1101之间的码距为1，因为只有最低位翻转了。而1001和0010之间的码距则为3，因为只有1位没有变化。</p>
</blockquote>
<h5 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h5><blockquote>
<p>没什么好说的,只需注意奇偶数，中的奇偶指的是“1”的个数<br>码距为2，$\color{red}{\text{Q}}$：那么问题来了，其他校验方式的码距是多少</p>
</blockquote>
<h5 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h5><p>按照书上的例子辅以<a target="_blank" rel="noopener" href="https://blog.csdn.net/Yonggie/article/details/83186280">参考文献</a>记忆</p>
<blockquote>
<p>把握一点:汉明码具有纠错一位的能力,检错两位<br>n为有效信息的位数，k为校验位的位数，n和k需要满足的关系：$n+k \leq 2^k-1$</p>
</blockquote>
<details><summary>汉明码的例子</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210723190124.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210723190124.png';" /></details>



<h5 id="CRC循环冗余校验"><a href="#CRC循环冗余校验" class="headerlink" title="CRC循环冗余校验"></a>CRC循环冗余校验</h5><p>按照书上的例子辅以<a target="_blank" rel="noopener" href="https://www.cnblogs.com/liushui-sky/p/9962123.html">参考文献</a>记忆</p>
<p>需要把握的点</p>
<blockquote>
<p>模2除法相当于做异或运算<br>余数的位数一定要是比除数位数只能少一位，哪怕前面位是0，甚至是全为0（附带好整除时）也都不能省略</p>
</blockquote>
<details><summary>CRC循环冗余校验的例子</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210723190344.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210723190344.png';" /></details>


<h3 id="定点数的表示与运算"><a href="#定点数的表示与运算" class="headerlink" title="定点数的表示与运算"></a>定点数的表示与运算</h3><h4 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h4><h5 id="无符号数和有符号数的表示"><a href="#无符号数和有符号数的表示" class="headerlink" title="无符号数和有符号数的表示"></a>无符号数和有符号数的表示</h5><p>在计算机中参与运算的机器数有两大类:无符号数和有符号数。</p>
<p>1）无符号数。指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。若机器字长为8位，则数的表示范围为0～$2^8-1$，即0～255。</p>
<p>2）有符号数。在机器中，数的“正”“负”号是无法识别的，有符号数用“O”表示“正”号，用“1”表示“负”号，从而将符号也数值化，并通常约定二进制数的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数。</p>
<p>有符号数的机器表示有原码、补码、反码和移码。为了能正确区别真值和各种机器数，约定用X表示真值，用$\lbrack X \rbrack_{\text{原}}$表示原码，$\lbrack X \rbrack_{补}$表示补码，$\lbrack X \rbrack_{反}$表示反码，$\lbrack X \rbrack_{移}$表示移码。</p>
<h5 id="机器数的定点表示"><a href="#机器数的定点表示" class="headerlink" title="机器数的定点表示"></a>机器数的定点表示</h5><p>根据小数点的位置是否固定，在计算机中有两种数据格式:定点表示和浮点表示。本节仅介绍定点表示，浮点表示见2.3节。</p>
<p>定点表示即约定机器数中的小数点位置是固定不变的，小数点不再使用“.”表示,而是约定它的位置。理论上，小数点位置固定在哪一位都可以，但在计算机中通常采用两种简单的约定:将小数点的位置固定在数据的最高位之前，或固定在最低位之后。一般常称前者为定点小数，后者为定点整数。</p>
<h6 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h6><p>定点小数是$\color{green}{\text{纯小数}}$，约定小数点位置在符号位之后、有效数值部分最高位之前。若数据$X$的形式为$X=x_0.x_1x_2$(其中$x_0$为符号位，$x_1\backsim x_n$,是数值的有效部分，也称尾数，$x_1$为最高有效位)，则在计算机中的表示形式如图2.4所示（设机器字长$n+1$位)。</p>
<p>当$x_0$=0，$x_1$～$x_n$均为1时，X为其所能表示的最大正数，真值等于$1-2^{-n}$。</p>
<p>当$x_0$=1，$x_1$～$x_n$,均为1时，X为其（原码）所能表示的最小负数，真值等于-$(1-2^{-n})$。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630215948.png" alt=""></p>
<h6 id="定点整数"><a href="#定点整数" class="headerlink" title="定点整数"></a>定点整数</h6><p>定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。若数据$X$的形式为$X=x_0x_1x_2 \cdots x_n$(其中$x_0$为符号位，$x_1 \backsim x_n$是尾数，$x_n$为最低有效位)，则在计算机中的表示形式如图2.5所示（设机器字长n+1位)。</p>
<p>当$x_0=0, x_1 \backsim x_n$均为1是，$X$为其所能表示的最大正数，真值等于$2^n-1$。</p>
<p>当$x_0=1, x_1 \backsim x_n$均为1时，$X$为其(原码)所能表示的最小负数，真值等于$-(2^n-1)$</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630220315.png" alt=""></p>
<h5 id="原码、补码、反码、移码"><a href="#原码、补码、反码、移码" class="headerlink" title="原码、补码、反码、移码"></a>原码、补码、反码、移码</h5><h6 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h6><p>原码是一种比较简单、直观的机器数表示法，用机器数的最高位表示该数的符号，其余的各位表示数的绝对值。原码的定义如下。</p>
<ul>
<li>纯小数的原码定义</li>
</ul>
<script type="math/tex; mode=display">
\lbrack x \rbrack_\text{原}  = \begin{cases}
  x, & 1 > x \geq 0 \cr
  1-x=1+\lvert x \rvert , & 0 \geq x > -1 
\end{cases}
\quad (\lbrack x \rbrack_\text{原}\text{是原码机器数，} x\text{是真值})</script><p>例如，若$x_1=+0.1101,x2=-0.1101$字长为8位,则其原码表示为：$\lbrack x_1 \rbrack_\text{原}$ = $\color{green}{\text{0}}$.1101000，$\lbrack x_2 \rbrack_\text{原}$ = $\color{green}{\text{1}}$.1101000,其中最高位为符号位，则其原码表示为：$\lbrack x_1 \rbrack_\text{原}$  = $\color{green}{\text{0}}$.1101000,$\lbrack x_2 \rbrack_\text{原}$  = $\color{green}{\text{1}}$.1101000</p>
<p>更一般地，对于正小数$x=+0.x_1x_2\cdots x_n$,有$x_\text{原}=0.x_1x_2\cdots x_n$；对于负小数$x=-0.x_1x_2\cdots x_n$,有$x_\text{原}=1.x_1x_2\cdots x_n$</p>
<p>若字长为$n+1$，则原码小数的表示范围为$-(1-2^{-n}) \leq x \leq 1-2^{-n}$(关于原点对称)</p>
<ul>
<li>纯整数的原码定义</li>
</ul>
<script type="math/tex; mode=display">
\lbrack x \rbrack_\text{原}  = \begin{cases}
  0,x, & 2^n > x \geq 0 \cr
  2^n-x=2^n+\lvert x \rvert , & 0 \geq x > -2^n 
\end{cases}
\quad (x^+\text{是真值},n\text{是整数位数})</script><p>例如，若$x_1=+1110,x2=-1110$字长为8位,则其原码表示为：$\lbrack x_1 \rbrack_\text{原}$ = $\color{green}{\text{0}}$,0001110，$\lbrack x_2 \rbrack_\text{原}$ =$2^7 + 1110$ =$\color{green}{\text{1}}$,0001110,其中最高位为符号位</p>
<p>若字长为$n+1$，则原码小数的表示范围为$-(2^{n} -1) \leq x \leq 2^{n} -1$(关于原点对称)</p>
<blockquote>
<p>真值零的原码表示有正零和负零两种形式，即$\lbrack +0 \rbrack_\text{原}=\color{green}{\text{0}}0000$和$\lbrack -0 \rbrack_\text{原}=\color{green}{\text{1}}0000$。</p>
</blockquote>
<h6 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h6><p>原码表示法的加减法操作比较复杂，对于两个不同符号数的加法（或同符号数的减法)，先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后还要给结果选择合适的符号。而补码表示法中的加减法则统一采用加法操作实现。</p>
<ul>
<li>纯小数的补码定义</li>
</ul>
<script type="math/tex; mode=display">
\lbrack x \rbrack_\text{补}  = \begin{cases}
  x, & 1 > x \geq 0 \cr
  2+x=2-\lvert x \rvert , & 0 \geq x \geq -1
\end{cases}
\quad (mod \quad 2^{n+1 })</script><p>例如，若$x_1=+0.1001,x2=-0.0110$字长为8位,则其补码表示为：$\lbrack x_1 \rbrack_\text{补}$ = $\color{green}{\text{0}}$.1001000，$\lbrack x_2 \rbrack_\text{补}$ = 2- 0.0110= $\color{green}{\text{1}}$.1010000,其中最高位为符号位</p>
<p>更一般地，对于正小数$x=+0.x_1x_2\cdots x_n$,有$x_\text{补}=0.x_1x_2\cdots x_n$；对于负小数$x=-0.x_1x_2\cdots x_n$,有$x_\text{补}=10.00\cdots0 - 0.x_1x_2\cdots x_n$(mod 2)</p>
<blockquote>
<p>这里的mod2是什么意思？</p>
</blockquote>
<p>若字长为$n+1$，则补码小数的表示范围为$-1 \leq x \leq 1-2^{-n}$(比原码多表示-1)</p>
<ul>
<li>纯整数的补码定义</li>
</ul>
<script type="math/tex; mode=display">
\lbrack x \rbrack_\text{补}  = \begin{cases}
  0,x, & 2^n > x \geq 0 \cr
  2^{n+1}+x=2^{n+1}-\lvert x \rvert , & 0 \geq x \geq -2^{n} 
\end{cases}
\quad (mod \quad 2^{n+1 })</script><p>例如，若$x_1=+1010,x2=-1101$字长为8位,则其补码表示为：$\lbrack x_1 \rbrack_\text{补}$ = $\color{green}{\text{0}}$,0001010，$\lbrack x_2 \rbrack_\text{补}$ =$2^8 - 0,0001101$ =$\color{green}{\text{1}}$,1110011。</p>
<p>若字长为$n+1$，则补码小数的表示范围为$-2^{n} \leq x \leq 2^{n} -1$(比原码多表示$-2^n$)</p>
<blockquote>
<p>真值零的补码表示是唯一的。即$\lbrack +0 \rbrack_\text{补} = \lbrack -0 \rbrack_\text{补}=0.0000$,由定义$\lbrack +0 \rbrack_\text{补} = 10.0000 - 1.0000 = 1.0000$，可见对于小数，补码比原码多表示一个“-1”.类似地，对于整数，补码比原码多表示一个“$-2^n$”</p>
</blockquote>
<ul>
<li>由原码求补码、由补码求原码</li>
</ul>
<p>对于正数，补码与原码的表示相同,$\lbrack x \rbrack_\text{补} = \lbrack x \rbrack_\text{原}$。<br>对于负数，原码符号位不变，数值部分按位取反，末位加1(即所谓“取反加1”)，此规则同样适用于由$\lbrack x \rbrack_\text{补}$求$\lbrack x \rbrack_\text{原}$</p>
<ul>
<li>补码的算术移位</li>
</ul>
<p>将$\lbrack x \rbrack_\text{补}$的符号位与数值位一起右移一位并保持原符号位的值不变，可实现除法功能（除以2)。</p>
<p>变形补码，又称模4补码，双符号位的补码小数，其定义为</p>
<script type="math/tex; mode=display">
\lbrack x \rbrack_\text{补}  = \begin{cases}
  x, & 1 > x \geq 0 \cr
  4+x=4-\lvert x \rvert , & 0 > x \geq -1
\end{cases}
\quad (mod \quad 4)</script><p>模4补码双符号位00表示正，11表示负，用在完成算术运算的ALU部件中。</p>
<h6 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h6><!-- ([{]*)补([码|}]*) -->
<!-- $1反$2 -->
<p>反码通常用来作为由原码求补码或由补码求原码的中间过渡。</p>
<ul>
<li>纯小数的补码定义</li>
</ul>
<script type="math/tex; mode=display">
\lbrack x \rbrack_\text{反}  = \begin{cases}
  x, & 1 > x \geq 0 \cr
  2-2^{-n} + x , & 0 \geq x \geq -1
\end{cases}
\quad (mod \quad 2 - 2^{n})</script><p>例如，若$x_1=+0.0110,x2=-0.0110$字长为8位,则其反码表示为：$\lbrack x_1 \rbrack_\text{反}$ = $\color{green}{\text{0}}$.0110000，$\lbrack x_2 \rbrack_\text{反}$ = 1.1111111- 0.0110000= $\color{green}{\text{1}}$.100111。</p>
<p>若字长为$n+1$，则反码小数的表示范围为$-(1-2^{-n}) \leq x \leq 1-2^{-n}$(关于原点对称)。</p>
<blockquote>
<p>真值零的反码表示不唯一，负数的反码符号位为“1”，数值部分求反，$\lbrack +0 \rbrack_\text{反}$ = 0.0000;$\lbrack -0 \rbrack_\text{反}$ = 1.1111。</p>
</blockquote>
<ul>
<li>纯整数的反码定义</li>
</ul>
<script type="math/tex; mode=display">
\lbrack x \rbrack_\text{反}  = \begin{cases}
  0,x, & 2^n > x \geq 0 \cr
  (2^{n+1} - 1)+x, & 0 \geq x > -2^{n} 
\end{cases}
\quad (mod \quad 2^{n+1 } -1)</script><p>例如，若$x_1=+1011,x2=-1011$字长为8位,则其反码表示为：$\lbrack x_1 \rbrack_\text{反}$ = $\color{green}{\text{0}}$,0001011，$\lbrack x_2 \rbrack_\text{反}$ =$1,1111111 - 0,0001011$ =$\color{green}{\text{1}}$,1110100。</p>
<p>若字长为$n+1$，则反码小数的表示范围为$-(2^{n} - 1) \leq x \leq 2^{n} -1$(关于原点对称))</p>
<p>真值、原码、补码、反码及$\lbrack -x \rbrack_\text{反}$的转换规律，如图2.6所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706100902.png" alt=""></p>
<h6 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h6><p>移码常用来表示浮点数的$\color{green}{\text{阶码}}$。它只能表示$\color{green}{\text{整数}}$。</p>
<p>移码就是在真值$X$上加上一个常数（偏置值)，通常这个常数取$2^n$，相当于$X$在数轴上向正方向偏移了若干单位，这就是“移码”一词的由来。移码定义为</p>
<script type="math/tex; mode=display">
\lbrack x \rbrack_\text{移} = 2^n + x \quad(2^n > x \geq - 2^n,\text{其中机器字长为}n+1)</script><p>例如，若整数$x_1 = +10101,x_2=-10101$,字长为8位，则其移码表示为：$\lbrack x_1 \rbrack_\text{移}=2^7 + 10101 = 1,0010101$;$\lbrack x_1 \rbrack_\text{移}=2^7+ (-10101)=0,1101011$</p>
<p>$\color{green}{\text{移码具有以下特点}}$:</p>
<ul>
<li>移码中零的表示唯一,$\lbrack +0 \rbrack_\text{移} = 2^n + 0 = \lbrack -0 \rbrack_\text{移} = 2^n-0=100\cdots0$($n$个“0”)</li>
<li>一个真值的$\color{green}{\text{移码}}$和$\color{green}{\text{补码}}$仅差一个符号位,$\lbrack +0 \rbrack_\text{补}$的符号位取反即得$\lbrack +0 \rbrack_\text{移}$(“1”表示正，“0”表示负，这与其他机器数的符号位取值正好相反)，反之亦然</li>
<li>移码全为0时，对应真值的最小值为$-2^n$;移码全为1时，对应真值的最大值$2^n01$。</li>
<li>移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小</li>
</ul>
<h4 id="定点数的运算"><a href="#定点数的运算" class="headerlink" title="定点数的运算"></a>定点数的运算</h4><h5 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h5><p>移位运算根据操作对象的不同分为算术移位和逻辑移位。有符号数的移位称为算术移位，逻辑移位的操作对象是逻辑代码,可视为无符号数。</p>
<h6 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a>算术移位</h6><p>算术移位的对象是有符号数，在移位过程中$\color{green}{\text{符号位}}$ $\color{green}{\text{保持不变}}$ 。</p>
<p>对于正数，由于$\lbrack x \rbrack_\text{原}$ = $\lbrack x \rbrack_\text{补}$ = $\lbrack x \rbrack_\text{反}$ = 真值，因此移位后出现的空位均以0添之。对于负数，由与原码，补码，反码的表示形式不同，因此当机器数移位时，对其空位的添补规则也不同</p>
<blockquote>
<p>不论是正数还是负数，移位后其符号位均不变，且移位后都相当于对真值补0，根据补码、反码的特性，所以在负数时填补代码有区别。</p>
</blockquote>
<p>对于原码，左移一位若不产生溢出，相当于乘以2(与十进制的左移一位相当于乘以10类似)，右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706102244.png" alt=""></p>
<p>由表2.1可以得出如下结论。</p>
<p>正数的原码、补码与反码都相同，因此移位后出现的空位均以0 添之。对于负数，由于原码、补码和反码的表示形式不同，因此当机器数移位时，对其空位的添补规则也不同。</p>
<ul>
<li>负数的原码数值部分与真值相同，因此在移位时只要使符号位不变，其空位均添0。</li>
<li>负数的反码各位除符号位外与负数的原码正好相反，因此移位后所添的代码应与原码相反，即全部添1。</li>
<li>分析由原码得到补码的过程发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。因此负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0;右移时因空位出现在高位，则添补的代码应与反码相同，即添1。</li>
</ul>
<h6 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h6><p>逻辑移位将操作数视为无符号数，移位规则:逻辑左移时，高位移丢，低位添0;逻辑右移时，低位移丢，高位添0。</p>
<blockquote>
<p>逻辑移位不管是左移还是右移，都添0。</p>
</blockquote>
<p>循环移位分为带进位标志位CF的循环移位(大循环）和不带进位标志位的循环移位（小循环)，过程如图2.7所示。</p>
<p>循环移位的主要特点是，移出的数位又被移入数据中，而是否带进位则要看是否将进位标志位加入循环位移。例如，带进位位的循环左移〔见图2.7(d)]就是数据位连同进位标志位一起左移，数据的最高位移入进位标志位CF，而进位位则依次移入数据的最低位。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706102442.png" alt=""></p>
<p>循环移位操作特别适合将数据的低字节数据和高字节数据互换。</p>
<h5 id="原码定点数的加减法运算"><a href="#原码定点数的加减法运算" class="headerlink" title="原码定点数的加减法运算"></a>原码定点数的加减法运算</h5><p>设$\lbrack X \rbrack_\text{原}= x_s.x_1x_2\cdots x_n$和$\lbrack Y \rbrack_\text{原}= y_s.y_1y_2\cdots y_n$,进行加减运算的规则如下。</p>
<p>$\color{green}{\text{加法规则}}$:先判符号位，若相同，则绝对值相加，结果符号位不变;若不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。</p>
<p>$\color{green}{\text{减法规则}}$:两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。</p>
<blockquote>
<p>运算时注意机器字长，当左边位出现溢出时，将溢出位丢掉。</p>
</blockquote>
<h5 id="补码定点数加减法运算"><a href="#补码定点数加减法运算" class="headerlink" title="补码定点数加减法运算"></a>补码定点数加减法运算</h5><p>补码加减运算规则简单，易于实现，因此计算机系统中普遍采用补码加减运算。补码运算的特点如下（设机器字长为$n+1$)。</p>
<p>1）参与运算的两个操作数均用补码表示。2）按二进制运算规则运算，逢二进一。</p>
<p>3）符号位与数值位按同样规则一起参与运算，符号位运算产生的进位要丢掉，结果的符号<br>位由运算得出。</p>
<p>4）补码加减运算依据下面的公式进行。当参加运算的数是定点小数时，模M= 2;当参加<br>运算的数是定点整数时，模$M=2^n+ 1$。</p>
<script type="math/tex; mode=display">
\begin{cases}
  \lbrack A+B \rbrack_\text{补} = \lbrack A \rbrack_\text{补} + \lbrack B \rbrack_\text{补}, &(mod M)  \cr
  \lbrack A-B \rbrack_\text{补} = \lbrack A \rbrack_\text{补} + \lbrack - B \rbrack_\text{补}, &(mod M), & 
\end{cases}</script><blockquote>
<p>mod M运算是为了将溢出位丢掉。</p>
</blockquote>
<p>也就是说，若做加法，则两数的补码直接相加;若做减法，则将被减数与减数的机器负数相加。</p>
<h6 id="补码运算的结果亦为补码"><a href="#补码运算的结果亦为补码" class="headerlink" title="补码运算的结果亦为补码"></a>补码运算的结果亦为补码</h6><p>设机器字长为8位（含1位符号位)，A= 15，B=24，求$\lbrack A+B \rbrack_\text{补}$和$\lbrack A-B \rbrack_\text{补}$。</p>
<p>解：</p>
<p>A=+15=+0001111，B=+24=+0011000;得$\lbrack A \rbrack_\text{补}$= 00001111，$\lbrack B \rbrack_\text{补}$=00011000。</p>
<p>求得$\lbrack -B \rbrack_\text{补}$ = 11101000。所以</p>
<p>$\lbrack A+B \rbrack_\text{补}$=00001111+ 00011000 = 00100111，其符号位为0，对应真值为+39。</p>
<p>$\lbrack A-B \rbrack_\text{补}$=$\lbrack A \rbrack_\text{补} + \lbrack - B \rbrack_\text{补}$=00001111 + 11101000= 11110111，其符号位为1，对应真值为-9。</p>
<h5 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h5><p>在计算机算术运算中，有时必须把采用给定位数表示的数转换成具有不同位数的某种表示形式。例如，某个程序需要将一个8位数与另外一个32位数相加，要想得到正确的结果，在将8位数与32位数相加之前，必须将8位数转换成32位数形式，这称为“符号扩展”。</p>
<p>正数的符号扩展非常简单，即原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用0进行填充。</p>
<p>负数的符号扩展方法则根据机器数的不同而不同。原码表示负数的符号扩展方法与正数相同，只不过此时符号位为1。补码表示负数的符号扩展方法:原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用1(对于整数）或0(对于小数）进行填充。反码表示负数的符号扩展方法:原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用1进行填充。</p>
<blockquote>
<p>正数相当于位数往左边扩展，负数相当于位数往右边扩展</p>
</blockquote>
<h5 id="溢出概念和判别方法"><a href="#溢出概念和判别方法" class="headerlink" title="溢出概念和判别方法"></a>溢出概念和判别方法</h5><p>溢出是指运算结果超过了数的表示范围。通常，称大于机器所能表示的最大正数为上溢，称小于机器所能表示的最小负数为下溢。定点小数的表示范围为$\lvert x \rvert &lt;1$，如图2.8所示。<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706143612.png" alt=""></p>
<p>仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为1(结果为负);一个负数减去一个正数，结果的符号位却为0(结果为正)。定点数加减运算出现溢出时，运算结果是错误的。</p>
<p>补码定点数加减运算溢出判断的方法有3种。</p>
<p>(1）采用一位符号位</p>
<p>由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出。</p>
<p>设A的符号为$A_s$,B的符号为$B_s$，运算结果的符号为$S_s$,则溢出逻辑表达式为</p>
<script type="math/tex; mode=display">
V = A_sB_s\bar{S_s} + \bar{A_s}\bar{B_s}S_s</script><p>若$V=0$，表示无溢出；若$V=1$，表示有溢出</p>
<p>(2）采用双符号位</p>
<p>双符号位法也称模4补码。运算结果的两个符号位$S_{s1}S_{s2}$相同，表示未溢出;运算结果的两个符号位$S_{s1}S_{s2}$不同，表示溢出，此时最高位符号位代表真正的符号。</p>
<p>符号位$S_{s1}S_{s2}$的各种情况如下：</p>
<ul>
<li>$S_{s1}S_{s2}=00$：表示结果为正数，无溢出。</li>
<li>$S_{s1}S_{s2}=01$：表示结果正溢出。</li>
<li>$S_{s1}S_{s2}=10$：表示结果负溢出。</li>
<li>$S_{s1}S_{s2}=11$：表示结果为负数,无溢出。</li>
</ul>
<blockquote>
<p>Q：运算数的符号位在双符号位中表示是怎么样的？<br>A：正数00，负数11</p>
</blockquote>
<p>溢出逻辑判断表达式为$V=S_{s1}\oplus S_{s2}$,若$V=0$,表示无溢出；若$V=1$表示有溢出。</p>
<p>(3）采用一位符号位根据数据位的进位情况判断溢出</p>
<p>若符号位的进位$C_s$与最高数位的进位$C_1$相同，则说明没有溢出，否则表示发生溢出。溢出逻辑判断表达式为V=$C_s\oplus C_1$，若V=0，表示无溢出;V=1，表示有溢出。</p>
<blockquote>
<p>这是在干什么？？</p>
</blockquote>
<h5 id="定点数的乘法运算"><a href="#定点数的乘法运算" class="headerlink" title="定点数的乘法运算"></a>定点数的乘法运算</h5><p>在计算机中，乘法运算由累加和右移操作实现。根据机器数的不同，可分为原码一位乘法和补码一位乘法。原码一位乘法的规则比补码一位乘法简单。</p>
<h6 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h6><p>原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位“异或”形成，而乘积的数值部分则是两个数的绝对值相乘之积。</p>
<p>设$\lbrack X \rbrack_\text{原}= x_s.x_1x_2\cdots x_n$和$\lbrack Y \rbrack_\text{原}= y_s.y_1y_2\cdots y_n$,则运算规则如下:</p>
<ul>
<li>${\textstyle\unicode{x2460}}$  被乘数和乘数均取绝对值参加运算，符号位为$x_s \oplus y_s$</li>
<li>${\textstyle\unicode{x2461}}$ 部分积的长度同被乘数，取$n +1$位，以便存放乘法过程中绝对值大于等于1的值初值为0。</li>
<li>${\textstyle\unicode{x2462}}$ 从乘数的最低位$y_n$,开始判断:若$y_n = 1$，则部分积加上被乘数$\lvert x \rvert$，然后右移一位;若$y_n$= 0，则部分积加上0，然后右移一位。</li>
<li>${\textstyle\unicode{x2463}}$ 重复步骤${\textstyle\unicode{x2462}}$，判断$n$次</li>
</ul>
<p>由于乘积的数值部分是两数绝对值相乘的结果，因此原码一位乘法运算过程中的右移操作均为逻辑右移。</p>
<blockquote>
<p>注意:考虑到运算时可能出现绝对值大于1的情况（但此刻并非溢出)，所以部分积和被乘数取$\color{green}{\text{双符号位}}$。</p>
</blockquote>
<p>$\color{red}{\text{例}}$：设机器字长为5位（含1位符号位，n=4)，x = —0.1101，y= 0.1011,采用原码一位乘法求x · y。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706145211.png" alt=""></p>
<h6 id="补码一位乘法-Booth-算法"><a href="#补码一位乘法-Booth-算法" class="headerlink" title="补码一位乘法(Booth 算法)"></a>补码一位乘法(Booth 算法)</h6><p>这是一种有符号数的乘法，采用相加和相减操作计算补码数据的乘积。</p>
<p>设$\lbrack X \rbrack_\text{补}= x_s.x_1x_2\cdots x_n$和$\lbrack Y \rbrack_\text{补}= y_s.y_1y_2\cdots y_n$,则运算规则如下:</p>
<ul>
<li>${\textstyle\unicode{x2460}}$  符号位参与运算，运算的数均以补码表示。</li>
<li>${\textstyle\unicode{x2461}}$ 被乘数一般取双符号位参与运算，部分积取双符号位，初值为0，乘数可取单符号位。</li>
<li>${\textstyle\unicode{x2462}}$ 乘数末位增设附加位.$y_{n+1}$，且初值为0。</li>
<li>${\textstyle\unicode{x2463}}$ 根据$(y_n,y_{n+1})$的取值来确定操作，见表2.2。</li>
<li>${\textstyle\unicode{x2464}}$ 移位按补码右移规则进行。</li>
<li>${\textstyle\unicode{x2465}}$ 按照上述算法进行$n+1$步操作，但第$n+1$步不再移位（共进行$n+1$次累加和$n$次右移)，仅根据$y_n$,与$y_{n+1}$的比较结果做相应的运算。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706145534.png" alt=""></p>
<p>【例2.8】设机器字长为5位(含1位符号位，n = 4),x =—0.1101，y = 0.1011，采用Booth算法求x· y。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706145727.png" alt=""></p>
<h5 id="定点数的除法运算"><a href="#定点数的除法运算" class="headerlink" title="定点数的除法运算"></a>定点数的除法运算</h5><p>在计算机中，除法运算可转换成“累加一左移”(逻辑左移)，根据机器数的不同，可分为原码除法和补码除法。</p>
<blockquote>
<p>如果恢复余数法，先减去这个除数，在判断够不够减，不够减需要恢复之前的余数，所以叫恢复余数法<br>不恢复余数法，会比恢复余数法效率高，（少了恢复余数的步骤<br>详见天勤视频</p>
<p>怎么判断一个运算是补码的运算还是原码的运算，只要看符号位参不参与运算，符号位参与运算那么就是补码运算；<br>符号位不参与运算那么就是原码运算，此时结果的符号位由运算数单独运算得到</p>
</blockquote>
<p>(1）原码除法运算（不恢复余数法)</p>
<p>原码除法主要采用原码不恢复余数法，也称原码加减交替除法。特点是商符和商值是分开进行的，商符由两个操作数的符号位“异或”形成。求商值的规则如下。</p>
<p>设被除数$\lbrack X \rbrack_\text{原}= x_s.x_1x_2\cdots x_n$和$\lbrack Y \rbrack_\text{原}= y_s.y_1y_2\cdots y_n$，则</p>
<ul>
<li>${\textstyle\unicode{x2460}}$  商的符号：$Q_s = x_s \oplus y_s$</li>
<li>${\textstyle\unicode{x2461}}$ 商的数值:$\lvert Q \rvert = \lvert X \rvert / \lvert Y \rvert$</li>
</ul>
<p>求$\lvert Q \rvert$的不恢复余数法运算规则如下。</p>
<ul>
<li>${\textstyle\unicode{x2460}}$  符号位不参与运算。</li>
<li>${\textstyle\unicode{x2461}}$ 先用被除数减去除数$\lvert X \rvert - \lvert Y \rvert = \lvert X \rvert + (- \lvert Y \rvert) = \lvert X \rvert +   \lbrack -Y \rbrack_\text{补}$，当余数为正时，商上1，余数和商左移一位，再减去除数；当余数为负时，商上0，余数和商左移一位，再加上除数。</li>
<li>${\textstyle\unicode{x2462}}$ 当第$n+1$步余数为负时，需加上$\lvert Y \rvert$得到第n+1步正确的余数（余数和被除数同号）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706150638.png" alt=""></p>
<blockquote>
<p>数据都用补码表示,符号位参与运算;<br>初始时观察被除数与除数符号，同号做减法,异号做加法;<br>若余数与除数同号，则商1后余数左移一位减去除数,若余数与除数异号，则商0后余数左移一位加上除数;<br>重复上一步操作，直到得到n位商(n为数据位位数);<br>一般在末尾补上一个1。<br>摘自天勤</p>
</blockquote>
<p>（2） 补码除法运算（加减交替法)</p>
<p>补码一位除法的特点是，符号位与数值位一起参加运算，商符自然形成。除法第一步根据被除数和除数的符号决定是做加法还是减法;上商的原则根据余数和除数的符号位共同决定，同号上商“1”，异号上商“0”;最后一步商恒置“1”。<br>加减交替法的规则如下:</p>
<p>${\textstyle\unicode{x2460}}$ 符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。</p>
<p>${\textstyle\unicode{x2461}}$ 若被除数与除数同号，则被除数减去除数;若被除数与除数异号，则被除数加上除数。</p>
<p>${\textstyle\unicode{x2462}}$ 若余数与除数同号，则商上 1，余数左移一位减去除数;若余数与除数异号，则商上0，余数左移一位加上除数。</p>
<p>${\textstyle\unicode{x2463}}$ 重复执行第③步操作n次。</p>
<p>${\textstyle\unicode{x2464}}$ 若对商的精度没有特殊要求，则一般采用“末位恒置1”法。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706150930.png" alt=""></p>
<p>(3）除法运算总结除法运算总结</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706150949.png" alt=""></p>
<h4 id="C语言中的整数类型及类型转换"><a href="#C语言中的整数类型及类型转换" class="headerlink" title="C语言中的整数类型及类型转换"></a>C语言中的整数类型及类型转换</h4><p>统考大纲要求考生具有对高级程序设计语言（如C语言）中相关问题进行分析的能力，而C语言变量之间的类型转换是统考中经常出现的题目，需要读者深入掌握这一内容.</p>
<blockquote>
<p>short 16位<br>char 8 位(一般规定一个字节8位)</p>
</blockquote>
<h5 id="有符号数和无符号数的转换"><a href="#有符号数和无符号数的转换" class="headerlink" title="有符号数和无符号数的转换"></a>有符号数和无符号数的转换</h5><p>C语言允许在不同的数据类型之间做强制类型转换，而从数学的角度来说，可以想到很多不同的转换规则。就用户使用而言，对于两者都能表示的数，当然希望转换过程中数值本身不发生任何变化，而那些转换过后无法表示的数呢?请先观察如下这段程序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">short</span> x=<span class="number">-4321</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> y=(<span class="keyword">unsigned</span> <span class="keyword">short</span>)x;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;x=%d, y=%u\n&quot;</span>, x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有符号数x是一个负数，而无符号数y的表示范围显然不包括x的值。读者可以自己猜想一下这段程序的运行结果，再比较下面给出的运行结果。</p>
<p>在采用补码的机器上，上述代码会输出如下结果:</p>
<script type="math/tex; mode=display">x=—4321,y = 61215</script><p>最后的结果中，得到的y值似乎与原来的x没有一点关系。不过将这两个数化为二进制表示时，我们就会发现其中的规律，如表2.5所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706151226.png" alt=""></p>
<p>其中x为补码表示，y为无符号的二进制真值。观察可知，将short int强制转换为unsigned short只改变数值，而两个变量对应的每位都是一样的。通过这个例子就可以知道强制类型转换的结果保持位值不变，仅改变了解释这些位的方式。</p>
<p>下面再来看一个unsigned short型转换到short型的例子。考虑如下代码;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> x=<span class="number">65535</span>;</span><br><span class="line">  <span class="keyword">short</span> y=(<span class="keyword">short</span>) x;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x=%u,y=%d \n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样在采用补码的机器上，上述代码会输出以下结果:</p>
<script type="math/tex; mode=display">x =65535,y =—1</script><p>同样可以把这两个数用之前的方法写成二进制，然后证实我们之前得出的结论。</p>
<h5 id="不同字长整数之间的转换"><a href="#不同字长整数之间的转换" class="headerlink" title="不同字长整数之间的转换"></a>不同字长整数之间的转换</h5><p>另一种常见的运算是在不同字长的整数之间进行数值转换。先观察如下程序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x=<span class="number">165537</span>，u=<span class="number">-34991</span>;<span class="comment">//int型占用4B</span></span><br><span class="line">  <span class="keyword">short</span> y=(<span class="keyword">short</span>)x, v=(<span class="keyword">short</span>)u; <span class="comment">// short型占用2B</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d\n&quot;</span>, x, y);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;u=%d, v=%d\n&quot;</span>,u, v);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序可以得到如下结果:</p>
<p>x=165537,y =-31071</p>
<p>u=-34991, v= 30545</p>
<p>其中x、y、u、v的十六进制表示分别为0x000286a1、0x86a1、0xff7751、0x7751，观察上述数字很容易得出结论，当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。</p>
<p>最后来看小字长变量向大字长变量转换的情况。先观察下面这段程序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">short</span> x=<span class="number">-4321</span>;</span><br><span class="line">  <span class="keyword">int</span> y=x;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> u= (<span class="keyword">unsigned</span> <span class="keyword">short</span>)x;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v=u;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x-8d, y-%dln&quot;</span>, x,y);<span class="built_in">printf</span> (<span class="string">&quot;u=%u,v=%u\n&quot;</span>,u, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<p>x=-4321,y =—4321</p>
<p>u=61215, v= 61215</p>
<p>x、y、u、v的十六进制表示分别是0xef1f、0xfffef1f、0xef1f、0x0000eflf，由本例可知短字长整数到长字长整数的转换，不仅要使相应的位值相等，高位部分还会扩展为原数字的符号位，这与之前的三个举例都不一样，从位值与数值的角度说，前三个举例的转换规则都是保证相应的位值相等，而短字长到长字长的转换，在位值相等的条件下还要补充高位的符号位，可以理解为数值的相等。注意，char类型为8位ASCII码整数，其转换为int时,在高位部分补0即可。</p>
<h4 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h4><h5 id="数据的“大端方式”和“小端方式”存储"><a href="#数据的“大端方式”和“小端方式”存储" class="headerlink" title="数据的“大端方式”和“小端方式”存储"></a>数据的“大端方式”和“小端方式”存储</h5><p>在存储数据时，数据从低位到高位可以按从左到右排列，也可以按从右到左排列。因此，无法用最左或最右来表征数据的最高位或最低位，通常用最低有效字节（LSB）和最高有效字节(MSB）来分别表示数的低位和高位。例如，在32位计算机中，一个int 型变量i的机器数为0123 4567H，其最高有效字节MSB= 01H，最低有效字节LSB=67H。</p>
<p>现代计算机基本上都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，int和 float型数据占4字节，double型数据占8字节等，而程序中对每个数据只给定一个地址。假设变量i的地址为80 00H，字节01H、23H、45H、67H应该各有一个内存地址，那么地址08 00H对应4字节中哪字节的地址呢?这就是字节排列顺序问题。</p>
<p>多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，可以采用两种排列方式:大端方式(big endian）和小端方式(little endian)，如图2.9所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706152204.png" alt=""></p>
<p>大端方式按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面;小端方式按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面。</p>
<p>在检查底层机器级代码时，需要分清各类型数据字节序列的顺序，例如以下是由反汇编器(汇编的逆过程，即将机器代码转换为汇编代码）生成的一行机器级代码的文本表示:</p>
<p>4004d3:01 05 64 94 04 08   add %eax,0x8049464</p>
<p>其中，“4004d3”是十六进制表示的地址，“01 05 43 0b 20 00”是指令的机器代码，“add %eax，Ox8049464”是指令的汇编形式，该指令的第二个操作数是一个立即数0x8049464，执行该指令时，从指令代码的后4字节中取出该立即数，立即数存放的字节序列为64H、94H、04H、08H，正好与操作数的字节顺序相反，即采用的是小端方式存储，得到08049464H<br>去掉开头的0，得到值0x8049464，在阅读小端方式存储的机器代码时，要注意字节是按相反顺序显示的。</p>
<h5 id="数据按“边界对齐”方式存储"><a href="#数据按“边界对齐”方式存储" class="headerlink" title="数据按“边界对齐”方式存储"></a>数据按“边界对齐”方式存储</h5><p>假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍,这样无论所取的数据是字节、半字还是字，均可一次放存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。</p>
<p>数据不按边界对齐方式存储时，可以充分利用存储空间，但半字长或字长的指令可能会存储在两个存储字中，此时需要两次访存，并且对高低字节的位置进行调整、连接之后才能得到所要的指令或数据，从而影响了指令的执行效率。</p>
<p>例如，“字节1、字节2、字节3、半字1、半字2、半字3、字1”的数据按序存放在存储器中，按边界对齐方式和不对齐方式存放时，格式分别如图2.10和图2.11所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706152754.png" alt=""></p>
<p>边界对齐方式相对边界不对齐方式是一种空间换时间的思想。RISC如ARM 采用边界对齐方式，而CISC如x86对齐和不对齐都支持。因为对齐方式取指令时间相同，因此能适应指令流水。</p>
<h3 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h3><blockquote>
<p>补码运算的特点是符号位参与运算;原码运算的特点是，符号位先异或计算得出</p>
</blockquote>
<h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><p>浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。这样，在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度。例如，用定点数表示电子的质量（$9×10^{-28}$g）或太阳的质量($2×10^{33}g$）是非常不方便的。</p>
<h5 id="浮点数的表示格式"><a href="#浮点数的表示格式" class="headerlink" title="浮点数的表示格式"></a>浮点数的表示格式</h5><p>通常，浮点数表示为</p>
<script type="math/tex; mode=display">
N =r^E\times M</script><p>式中，$r$时浮点数阶码的底，（隐含），与尾数的基数相同，通常$r=2$。$E$和$M$都是有符号的定点数，$E$称为阶码，$M$称为位数。可见浮点数由阶码和尾数两部分组成，如图2.12所示</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706154529.png" alt=""></p>
<p>阶码是整数，阶符$J_f$和阶码的位数$m$共同反映浮点数的表示范围及小数点的实际位置;数符$S_f$代表浮点数的符号;尾数的位数$n$反映浮点数的精度。</p>
<h5 id="规格化浮点数"><a href="#规格化浮点数" class="headerlink" title="规格化浮点数"></a>规格化浮点数</h5><p>为了提高运算的精度，需要充分地利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值。非规格化浮点数需要进行规格化操作才能变成规格化浮点数。所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值。</p>
<p>左规:当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算术左移一位、阶码减1（基数为2时）的方法称为左规，左归可能要进行多次。</p>
<p>右规:当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算术右移一位、阶码加1（基数为2时）的方法称为右规。需要右归时，只需进行一次。</p>
<p>规格化浮点数的尾数$M$的绝对值应满足条件$1/r \leq \lvert M \rvert \leq 1$。</p>
<p>1)原码规格化后。</p>
<p>正数为$0.1xx\cdots x$的形式，其最大值表示为$0.11\cdots1$,最小是表示为$0.100\cdots0$。</p>
<p>尾数表示的范围为$1/2 \leq M \leq (1-2^{-n})$。</p>
<p>负数为$1.1xx\cdots x$的形式，其最大值表示为$1.10\cdots0$,最小值表示为$1.11\cdots1$。</p>
<p>尾数的表示范围为$-(1 -2^{-n}) \leq M \leq -1/2$</p>
<p>2)原码规格化后。</p>
<p>正数为$0.1xx\cdots x$的形式，其最大值表示为$0.11\cdots1$,最小是表示为$0.100\cdots0$。</p>
<p>尾数表示的范围为$1/2 \leq M \leq (1-2^{-n})$。</p>
<p>负数为$1.0xx\cdots x$的形式，其最大值表示为$1.01\cdots1$,最小值表示为$1.00\cdots0$。</p>
<p>尾数的表示范围为$-1 \leq M \leq -(1/2 + 2^{-n})$</p>
<blockquote>
<p>这里补码规格化尾数的最大负数形式为 $1.01\cdots1$，而不是原码的形式$1.10\cdots0$，因为$1.10\cdots0$不是补码规格化数，所以规格化尾数的最大负数时$-(0.10\cdots0 + 0.0\cdots01) = -0.10\cdots01,$而$(-0.10\cdots01)_\text{补}=1.01\cdots1$。<br>为什么$\dfrac{1}{2}$不是规格化浮点数:<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/250144709.html">参考文献</a></p>
</blockquote>
<p>当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定是1，补码规格化数的尾数最高位一定与尾数符号位相反。基数不同，浮点数的规格化形式也不同。当基数为4时，原码规格化形式的尾数最高两位不全为0;当基数为8时，原码规格化形式的尾数最高3位不全为0。</p>
<h5 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="*浮点数的表示范围"></a>*浮点数的表示范围</h5><p>如图2.13所示，运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢。数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。当运算结果在О至最小正数之间时称为正下溢，在0至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢。数据下溢时，浮点数值趋于零，计算机仅将其当作机器零处理。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706155814.png" alt=""></p>
<h5 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h5><p>按照IEEE 754标准,常用的浮点数的格式如图2.14所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706155904.png" alt=""></p>
<p>IEEE 754标准规定常用的浮点数格式有短浮点数（单精度、float型)、长浮点数（双精度、double型)、临时浮点数，见表2.6。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706155919.png" alt=""></p>
<p>IEEE 754标准的浮点数（除临时浮点数外)，是尾数用采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。</p>
<p>以短浮点数为例，最高位为数符位;其后是8位阶码，以2为底，用移码表示，阶码的偏置值为$2^{8-1}= 1$ = 127;其后23位是原码表示的尾数数值位。对于规格化的二进制浮点数，数值的最高位总是“1”，为了能使尾数多表示一位有效位，将这个“1”隐含，因此尾数数值实际上是24位。隐含的“1”是一位整数。在浮点格式中表示的 23位尾数是纯小数。例如，$(12)_{10}$ =$(1100)_2$，将它规格化后结果为$1.1×2^3$，其中整数部分的“1”将不存储在23位尾数内。</p>
<ul>
<li>IEEE 754数值位永远是原码表示</li>
<li>这里应该是说错了,规格化浮点数的结果不可能是$1.1×2^3$,只能说编者思路不清晰,可以理解为IEEE 754数值永远是1.xxx</li>
</ul>
<blockquote>
<p>短浮点数与长浮点数都采用隐含尾数最高数位的方法，因此可多表示一位尾数。临时浮点数又称扩展精度浮点数，无隐含位。</p>
</blockquote>
<p>阶码是以移码形式存储的。对于短浮点数，偏置值为127;对于长浮点数，偏置值为1023。存储浮点数阶码部分之前，偏置值要先加到阶码真值上。上例中，阶码值为3，因此在短浮点数中，移码表示的阶码为127+3=130(82H);在长浮点数中，阶码为1023+3=1026(402H)。</p>
<p>IEEE 754标准中，规格化的短浮点数的真值为</p>
<script type="math/tex; mode=display">
(-1)^s\times 1.M \times 2^{E-127}</script><p>规格化长浮点数的真值为</p>
<script type="math/tex; mode=display">
(-1)^s \times 1.M \times 2^{E-1023}</script><p>式中，$s =0$表示正数，$s =1$表示负数;短浮点数E的取值为$1\backsim254$(8位表示)，$M$为23位，共32位;长浮点数E的取值为1~2046 (11位表示)，M为52位，共64位。IEEE 754标准浮点数的范围见表2.7。</p>
<blockquote>
<p>偏置值为127(而非 128〉时，空出8位全1来表示无穷大（若偏置值选128，则不能区分无穷大)。此外，阶码值E的范围为1～254，空出全0表示非规格化数。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706160736.png" alt=""></p>
<h5 id="定点、浮点表示的区别"><a href="#定点、浮点表示的区别" class="headerlink" title="定点、浮点表示的区别"></a>定点、浮点表示的区别</h5><p>(1）数值的表示范围</p>
<p>若定点数和浮点数的字长相同，则浮点表示法所能表示的数值范围将远远大于定点表示法。</p>
<p>(2）精度</p>
<p>所谓精度，是指一个数所含有效数值位的位数。对于字长相同的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了。</p>
<p>(3）数的运算</p>
<p>浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化，所以浮点运算比定点运算复杂。</p>
<p>(4)溢出问题</p>
<p>在定点运算中，当运算结果超出数的表示范围时，发生溢出;浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出。</p>
<h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><p>浮点数运算的特点是阶码运算和尾数运算分开进行。浮点数的加减运算一律采用补码。浮点数加减运算分为以下几步。</p>
<blockquote>
<p>Q：如何判断浮点数溢出？<br>A：阶码溢出</p>
</blockquote>
<h5 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h5><p>对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。为此，先求阶差，然后以小阶向大阶看齐的原则，将阶码小的尾数右移一位（基数为2)，阶加1，直到两个数的阶码相等为止。尾数右移时，舍弃掉有效位会产生误差，影响精度。</p>
<h5 id="尾数求和"><a href="#尾数求和" class="headerlink" title="尾数求和"></a>尾数求和</h5><p>将对阶后的尾数按定点数加（减）运算规则运算。</p>
<h5 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h5><p>以双符号位为例，当尾数大于0时，其补码规格化形式为</p>
<script type="math/tex; mode=display">
\lbrack S \rbrack_\text{补} = 00.1xxx\cdots x</script><p>当尾数小于0时，其补码规格化形式为</p>
<script type="math/tex; mode=display">
\lbrack S \rbrack_\text{补} = 11.0xxx\cdots x</script><p>可见，当尾数的最高数值位与符号位不同时，即为规格化形式。规格化分为左规与右规两种。</p>
<p>1）左规:当尾数出现$00.0xx\cdots x$或$11.1xx\cdots x$时，需左规，即尾数左移1位，和的阶码减1，直到尾数为$00.1××\cdots ×$或$11.0××\cdots ×$。</p>
<p>2）右规:当尾数求和结果溢出（如尾数为$10.xx \cdots x$或$01.xx\cdots x$)时，需右规，即尾数右移一位，和的阶码加1。</p>
<blockquote>
<p> 1)对于左规和右规，不应死记。考查尾数的大小，左规一次相当于乘2，右规一次相当于除2;2)$\lbrack -1/2 \rbrack_\text{补}$= 1.1000不是规格化数，需左规一次，$\lbrack -1\rbrack_\text{补}$= 1.0000才是规格化数。</p>
</blockquote>
<ul>
<li>讲IEEE 754跟补码有什么关系。？内容编排又出问题了</li>
</ul>
<h5 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h5><p>在对阶和右规的过程中，可能会将尾数低位丢失，引起误差，影响精度。常见的舍入方法有:“0”舍“1”入法和恒置“1”法。</p>
<p>“0”舍“1”入法:类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去;被移去的最高数值位为1，则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。</p>
<p>恒置“1”法:尾数右移时，不论丢掉的最高数值位是“1”还是“O”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。</p>
<h5 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h5><p>与定点数加减法一样，浮点数加减运算最后一步也需判断溢出。</p>
<p>在浮点数规格化中已指出，当尾数之和（差）出现01.×××或10.xxx时，并不表示溢出，只能将此数右规后，再根据阶码来判断浮点数运算结果是否溢出。</p>
<p>浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例，当阶码的符号位出现“01”时，即阶码大于最大阶码时，表示上溢，进入中断处理;当阶码的符号位出现“10”时，即阶码小于最小阶码时，表示下溢，按机器零处理。实际上原理还是阶码符号位不同表示溢出，且真实符号位和高位符号位一致。</p>
<h5 id="C语言中的浮点数类型及类型转换"><a href="#C语言中的浮点数类型及类型转换" class="headerlink" title="C语言中的浮点数类型及类型转换"></a>C语言中的浮点数类型及类型转换</h5><p>C语言中的 float和 double类型分别对应于IEEE 754单精度浮点数和双精度浮点数。longdouble类型对应于扩展双精度浮点数，但long double 的长度和格式随编译器和处理器类型的不同而有所不同。在C程序中等式的赋值和判断中会出现强制类型转换，以char→int→long→double和 float→double最为常见，从前到后范围和精度都从小到大，转换过程没有损失。</p>
<p>1)从int转换为float时，虽然不会发生溢出，但 int可以保留32位，float保留24位，可能有数据舍入，若从int转换为double则不会出现。</p>
<p>2)从int或float转换为double时，因为double的有效位数更多，因此能保留精确值。3）从double转换为float时，因为float 表示范围更小，因此可能发生溢出。此外，由于有效位数变少，因此可能被舍入。</p>
<p>4)从float或double转换为 int 时，因为int没有小数部分，所以数据可能会向0方向被截断(仅保留整数部分)，影响精度。另外，由于int的表示范围更小，因此可能发生溢出。在不同数据类型之间转换时，往往隐藏着一些不容易察觉的错误，编程时要非常小心。</p>
<h3 id="算术逻辑单元（ALU"><a href="#算术逻辑单元（ALU" class="headerlink" title="算术逻辑单元（ALU)"></a>算术逻辑单元（ALU)</h3><p>在计算机中，运算器承担了执行各种算术和逻辑运算的工作，运算器由算术逻辑单元(Arithmetic Logic Unit，ALU)、累加器、状态寄存器和通用寄存器组等组成。ALU的基本功能包括加、减、乘、除四则运算，与、或、非、异或等逻辑运算，以及移位、求补等操作。</p>
<p>计算机运行时，运算器的操作和操作种类由控制器决定。运算器处理的数据来自存储器;处理后的结果数据通常送回存储器，或暂存在运算器中。</p>
<h4 id="串行加法器和并行加法器"><a href="#串行加法器和并行加法器" class="headerlink" title="串行加法器和并行加法器"></a>串行加法器和并行加法器</h4><p>ALU的核心部件是加法器，加法器是由全加器再配以其他必要的逻辑电路组成的，根据组成加法器的全加器个数是单个还是多个，加法器有串行和并行之分。</p>
<h5 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h5><p>全加器（FA）是最基本的加法单元，有加数$A_i$、加数$B_i$与低位传来的进位$C_{i-1}$共三个输入，有本位和$S_i$与向高位的进位$C_i$共两个输出。</p>
<p>全加器的逻辑表达式如下。</p>
<p>和表达式：$S_i = A_i \oplus B_i \oplus C_{i-1}(A_i, B_i, C_{i-1}\text{中有奇数个}1\text{时},S_i = 1;\text{否则}S_i = 0)$</p>
<p>进位表达式:$C_i=A_iB_i+(A_i \oplus B_i)C_i$</p>
<p>一位全加器对应的逻辑结构如图2.15(a)所示，其逻辑符号如图2.15(b)所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706184007.png" alt=""></p>
<h5 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h5><p>在串行加法器中，只有一个全加器，数据逐位串行送入加法器中进行运算。若操作数长n位，则加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器。进位触发器用来寄存进位信号，以便参与下一次运算。</p>
<p>串行加法器具有器件少、成本低的优点，但运算速度慢，多用于某些低速的专用运算器。</p>
<h5 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h5><p>并行加法器由多个全加器组成，其位数与机器的字长相同，各位数据同时运算。并行加法器可同时对数据的各位相加，但存在一个加法的最长运算时间问题，原因是，虽然操作数的各位是同时提供的，但低位运算所产生的进位会影响高位的运算结果。例如，$11\cdots11$和$00 \cdots01$相加，最低位产生的进位将逐位影响至最高位，因此并行加法器的最长运算时间主要是由进位信号的传递时间决定的，而每个全加器本身的求和延迟只是次要因素。</p>
<p>因此，提高并行加法器速度的关键是尽量加快进位产生和传递的速度。并行加法器的进位产生和传递如下:</p>
<p>并行加法器中的每个全加器都有一个从低位送来的进位输入和一个传送给高位的进位输出。通常将传递进位信号的逻辑线路连接起来构成的进位网络称为进位链。</p>
<p>进位表达式为</p>
<script type="math/tex; mode=display">
C_i = G_i + P_iC_{i-1}(G_i=1\text{或}P_iG_{i-1}=1\text{时},C_i=1)</script><p>式中，$G_i$时进位产生函数，$G_i=A_iB_i$;$P_i$时进位传递函数，$P_i= A_i \oplus B_i $。</p>
<blockquote>
<p>当$A_i$与$B_i$都是1时,$C_i = 1$,即有进位信号产生，所以将$A_iB_i$称为进位产生函数或本地进位，并以$G_i$表示。$A_i \oplus B_i =1$且$C_{i-1}=1$时，$C_i=1$。这种情况可视为$A_i \oplus B_i = 1$,第$i-1$位的进位信号$C_{i-1}$可以通过本地向高位传送。因此，把$A_i \oplus B_i$称为进位传递函数（进位传递条件），并以$P_i$表示。</p>
</blockquote>
<p>并行加法器的进位通常分为串行进位与并行进位。</p>
<p>(1）串行进位</p>
<p>把n个全加器串接起来，就可进行两个n位数的相加，这种加法器称为串行进位的并行加法器，如图2.16所示。串行进位又称行波进位，每级进位直接依赖于前一级的进位，即进位信号是逐级形成的。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706185135.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706185305.png" alt=""></p>
<p>可见，低位运算产生进位所需要的时间将可能影响直至最高位运算的时间。因此，并行加法器的最长运算时间主要是由进位信号的传递时间决定的，位数越多延迟时间就越长，而全加器本身的求和延迟只为次要因素，所以加快进位产生和提高传递的速度是关键。</p>
<p>(2）并行进位</p>
<p>并行进位又称先行进位、同时进位，其特点是各级进位信号同时形成。</p>
<p>采用并行进位的方案可以加快进位产生和提高传递的速度，即将各级低位产生的本级G和P信号依次同时送到高位各全加器的输入，以使它们同时形成进位信号，各进位信号表达式如下，可见它们可以同时形成进位信号:</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706185325.png" alt=""></p>
<p>上述各式中所有的进位输出仅由$G_i$、$P_i$,及最低进位输入$C_0$决定，而不依赖于其低位的进位输入$C_{i-1}$，因此各级进位输出可以同时产生。</p>
<p>这种进位方式是快速的，与字长无关。但随着加法器位数的增加,$C_i$的逻辑表达式会变得越来越长，输入变量会越来越多，这会使电路结构变得很复杂，所以完全采用并行进位是不现实的。</p>
<p>分组并行进位方式，实际上通常采用分组并行进位方式。这种方式把n位全加器分为若干小组，小组内的各位之间实行并行快速进位，小组与小组之间可以采用串行进位方式，也可以采用并行快速进位方式，因此有以下两种情况。</p>
<p>${\textstyle\unicode{x2460}}$  单级先行进位方式，又称组内并行、组间串行进位方式。以16位加法器为例，可分为4组，每组4位。第一小组组内的进位逻辑函数$C_1$、$C_2$、$C_3$、$C_4$的表达式与前述相同，$C_1$~$C_4$信号是同时产生的，实现上述进位逻辑函数的电路称为4位先行进位电路(CLA)。</p>
<p>利用4位CLA 电路及进位产生/传递电路和求和电路可以构成4位CLA加法器。用4个这样的CLA加法器构成的16位单级先行进位加法器如图2.17所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706185554.png" alt=""></p>
<p>${\textstyle\unicode{x2461}}$ 多级先行进位方式，又称组内并行、组间并行进位方式。下面仍以16位字长的加法器为例，分析两级先行进位加法器的设计方法。第一小组的进位输出$C_4$可以写为</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706185630.png" alt=""></p>
<p>这种电路称为成组先行进位电路（BCLA)。利用这种4位的 BCLA电路及进位产生与传递电路和求和电路可以构成4位BCLA加法器。16位的两级先行进位加法器可由4个BCLA加法器和1个CLA电路构成，如图2.18所示。</p>
<p>这种方法可以扩展到多于两级的先行进位加法器，如用三级先行进位结构设计64位加法器这种加法器的优点是字长对加法时间影响甚小;缺点是造价较高。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706185701.png" alt=""></p>
<h4 id="算术逻辑单元的功能和结构"><a href="#算术逻辑单元的功能和结构" class="headerlink" title="算术逻辑单元的功能和结构"></a>算术逻辑单元的功能和结构</h4><h5 id="带标志加法器"><a href="#带标志加法器" class="headerlink" title="带标志加法器"></a>带标志加法器</h5><p>无符号数加法器只能用于两个无符号数相加，不能进行带符号整数的加/减运算。为了能进行带符号整数的加/减运算，还需要在无符号数加法器的基础上增加相应的逻辑门电路，使得加法器不仅能计算和/差，还要能生成相应的标志信息。图2.19是带标志加法器的实现电路。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706185727.png" alt=""></p>
<p>在图2.19 中，溢出标志的逻辑表达式为$OF = C_n \oplus C_{n-1}$符号标志就是和的符号，即 SF=$F_{n-1}$﹔零标志$ZF=1$当且仅当$F=0$;进位/借位标志$CF =C_{out} \oplus C_{in}$，即当$C_{in}$=0时，CF为进位$C_{out}$，当$C_{in}=1$时，CF为进位$C_{out}$取反。</p>
<p>值得注意的是，为了加快加法运算的速度，实际电路一定使用多级先行进位方式，图2.19(b)是为了说明如何从加法运算结果中获得标志信息，因而使用全加器简化了加法器电路。</p>
<h5 id="算术逻辑单元-ALU"><a href="#算术逻辑单元-ALU" class="headerlink" title="算术逻辑单元(ALU)"></a>算术逻辑单元(ALU)</h5><p>ALU是一种功能较强的组合逻辑电路，它能进行多种算术运算和逻辑运算。由于加、减、乘、除运算最终都能归结为加法运算，因此 ALU的核心是带标志加法器，同时也能执行“与”“或”“非”等逻辑运算。ALU的基本结构如图2.20所示，其中A和B是两个n位操作数输入端，C是进位输入端，ALUop是操作控制端，用来决定ALU所执行的处理功能。例如，ALUop选择Add运算，ALU就执行加法运算，输出的结果就是A加B之和。ALUop 的位数决定了操作的种类。例如，当位数为3时，ALU最多只有8种操作。</p>
<p>图2.21给出了能够完成3种运算“与”、“或”和“加法”的一位ALU结构图。其中，一位加法用一个全加器实现，在ALUop的控制下，由一个多路选择器(MUX）选择输出3种操作结果之一。这里有3种操作，所以ALUop至少要有两位。</p>
<p>同时，ALU也可以实现左移或右移的移位操作。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706190050.png" alt=""></p>
<h5 id="补码加减运算部件"><a href="#补码加减运算部件" class="headerlink" title="补码加减运算部件"></a>补码加减运算部件</h5><p>假设一个数的补码表示为Y，则这个数的负数的补码为$\bar{Y}$+1，因此，只要在原加法器的Y输入端加n个反向器以实现各位取反的功能，然后加一个2选1多路选择器,用一个控制端Sub来控制，以选择是将原码$Y$输入加法器还是将$\bar{Y}$输入加法器，并将控制端Sub同时作为低位进位送到加法器，如图2.22所示。该电路可实现补码加减运算。当控制端Sub 为 1时，做减法，实现$X+\bar{Y}+1=\lbrack x \rbrack_\text{补}+\lbrack -y \rbrack_\text{补}$;当控制端Sub为0时，做加法，实现$X+ Y=\lbrack x \rbrack_\text{补}+\lbrack y \rbrack_\text{补}$</p>
<p>图2.22中的加法器是带标志加法器。无符号整数的二进制表示相当于正整数的补码表示，因此，该电路同时也能实现无符号整数的加/减运算。对于带符号整数x和y，图中X和Y分别是x和y的补码表示;对于无符号整数x和y，图中X和Y分别是x和y的二进制表示。</p>
<p>可通过标志信息来区分带符号整数运算结果和无符号整数运算结果。</p>
<p>零标志ZF =1表示结果为0。不管是作为无符号数还是作为带符号整数来运算，ZF都有意义。</p>
<p>进/借位标志CF表示无符号数加/减运算时的进位/借位。加法时，CF= 1表示无符号数加法溢出，因此CF等于进位输出$C_{out}$。减法时，CF =1表示有借位，即不够减故将进位输出$C_{out}$取反来作为借位标志。综合可得CF=Sub$\oplus C_{out}$。对于带符号整数运算，CF没有意义。</p>
<p>溢出标志OF = 1表示带符号整数运算时结果发生溢出。对于无符号整数运算，OF没有意义。</p>
<blockquote>
<p>注意:如对电路基础知识不太熟悉，可参阅电路相关教材的基础部分。对此章电路内容亦不必过分深究，目前统考对电路的要求并不高，且本节也不属于重点内容。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706190140.png" alt=""></p>
<h3 id="c语言相关"><a href="#c语言相关" class="headerlink" title="c语言相关"></a>c语言相关</h3><h4 id="基本数据类型所占的字节数"><a href="#基本数据类型所占的字节数" class="headerlink" title="基本数据类型所占的字节数"></a>基本数据类型所占的字节数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>$2^8$ = 256 </p>
<p>$2^{16}$ = 65536</p>
<p>$2^{32}$ = 4294967296</p>
<p>$2^{64}$ = 18446744073709551616</p>
<h4 id="溢出那些事"><a href="#溢出那些事" class="headerlink" title="溢出那些事"></a>溢出那些事</h4><h5 id="unsigned-int-之间做减法产生负数会怎么样"><a href="#unsigned-int-之间做减法产生负数会怎么样" class="headerlink" title="unsigned int 之间做减法产生负数会怎么样"></a>unsigned int 之间做减法产生负数会怎么样</h5><h4 id="边界对齐"><a href="#边界对齐" class="headerlink" title="边界对齐"></a>边界对齐</h4><p>边界对齐：<a target="_blank" rel="noopener" href="https://blog.csdn.net/id145/article/details/104377685">参考文献</a></p>
<h4 id="补码那些事"><a href="#补码那些事" class="headerlink" title="补码那些事"></a>补码那些事</h4><p>使用补码表示时(整数和定点小数都有如下结论)，若符号位相同，则数值位越大码值越大。</p>
<h4 id="移位那些事"><a href="#移位那些事" class="headerlink" title="移位那些事"></a>移位那些事</h4><p>一定要记住符号位不动，变动的是数值位</p>
<h4 id="符号扩展那些事"><a href="#符号扩展那些事" class="headerlink" title="符号扩展那些事"></a><a href="#符号扩展">符号扩展那些事</a></h4><p>需要保证数值不变</p>
<h4 id="关于门电路相关的知识"><a href="#关于门电路相关的知识" class="headerlink" title="关于门电路相关的知识"></a>关于门电路相关的知识</h4><p><a href="/2021/06/17/习题-王道-计算机组成原理-ch2-数据的表示与运算#关于门电路相关的知识">见习题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch1-计算机系统概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 09:59:13" itemprop="dateCreated datePublished" datetime="2021-06-30T09:59:13+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-06 14:57:51" itemprop="dateModified" datetime="2021-08-06T14:57:51+08:00">2021-08-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><p>考纲内容</p>
<p>(一）计算机系统层次结构</p>
<p>计算机系统的基本组成;计算机硬件的基本组成;计算机软件的分类;计算机的工作过程</p>
<p>(二）计算机性能指标</p>
<p>吞吐量、响应时间、CPU时钟周期、主频、CPI、CPU执行时间 </p>
<p>MIPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS</p>
<p>学习本章时，请读者思考以下问题:</p>
<p>1)计算机由哪几部分组成?以哪部分为中心?</p>
<p>2）主频高的CPU 一定比主频低的CPU快吗?为什么?</p>
<p>3）翻译程序、汇编程序、编译程序、解释程序有什么差别?各自的特性是什么?</p>
<p>4）不同级别的语言编写的程序有什么区别?哪种语言编写的程序能被硬件直接执行?请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>中译</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>Central Processing Unit</td>
<td>中央处理机(器)</td>
</tr>
<tr>
<td>IR</td>
<td>Instruction Register</td>
<td>指令寄存器，存放当前正在执行的指令的寄存器;</td>
</tr>
<tr>
<td>CU</td>
<td>Control Unit</td>
<td>控制单元(部件)，控制器中产生微操作命令序列的部件，为控制器的核心部件;</td>
</tr>
<tr>
<td>ALU</td>
<td>Arithmetic Logic Unit</td>
<td>算术逻辑运算单元，运算器中完成算术逻辑运算的逻辑部件;</td>
</tr>
<tr>
<td>ACC</td>
<td>Accumulator</td>
<td>累加器，运算器中运算前存放操作数、运算后存放运算结果的寄存器;</td>
</tr>
<tr>
<td>MAR</td>
<td>Memory Address Register</td>
<td>存储器地址寄存器，内存中用来存放欲访问存储单元地址的寄存器;</td>
</tr>
<tr>
<td>MQ</td>
<td>Multiplier-Quotient Register</td>
<td>乘商寄存器，乘法运算时存放乘数、除法时存放商的寄存器。</td>
</tr>
<tr>
<td>X</td>
<td></td>
<td>此字母没有专指的缩写含义，可以用作任一部件名，在此表示$\color{green}{\text{操作数寄存器}}$，即运算器中工作寄存器之一，用来存放操作数;</td>
</tr>
<tr>
<td>MDR</td>
<td>Memory Data Register</td>
<td>存储器数据缓冲寄存器，主存中用来存放从某单元读出、或写入某存储单元数据的寄存器;</td>
</tr>
<tr>
<td>CPI</td>
<td>Clock cycle Per Instruction</td>
<td>表示每条计算机指令执行所需的时钟周期</td>
</tr>
<tr>
<td>I/O</td>
<td>Input/Output equipment</td>
<td>输入/输出设备，为输入设备和输出设备的总称，用于计算机内部和外界信息的转换与传送;</td>
</tr>
<tr>
<td>PC</td>
<td>Program Counter</td>
<td>程序计数器，存放当前欲执行指令的地址，并可自动计数形成下一条指令地址的计数器;</td>
</tr>
<tr>
<td>FLOPS</td>
<td>floating-point operations per second</td>
<td>每秒所执行的浮点运算次数</td>
</tr>
<tr>
<td>IX</td>
<td>IndexRegister</td>
<td>变址寄存器(也许是为了和IR区分)</td>
</tr>
<tr>
<td>BR</td>
<td>Base Address Registers</td>
<td>基址寄存器</td>
</tr>
<tr>
<td>PSW</td>
<td>Program Status Word</td>
<td>程序状态寄存器(程序状态字)</td>
</tr>
<tr>
<td>GPR</td>
<td>General Purpose Register</td>
<td>通用寄存器组</td>
</tr>
</tbody>
</table>
</div>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangyu4863/article/details/81485323">参考文献</a><br><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/320897706.html">参考文献</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/GPR/786455?fr=aladdin">参考文献</a></p>
<h3 id="计算机发展历程"><a href="#计算机发展历程" class="headerlink" title="*计算机发展历程"></a>*计算机发展历程</h3><h4 id="计算机硬件的发展"><a href="#计算机硬件的发展" class="headerlink" title="计算机硬件的发展"></a>计算机硬件的发展</h4><h5 id="计算机的四代变化"><a href="#计算机的四代变化" class="headerlink" title="计算机的四代变化"></a>计算机的四代变化</h5><p>从1946年世界上第一台电子数字计算机(Electronic Numerical Integrator And Computer,ENIAC)问世以来，计算机的发展已经经历了四代。</p>
<p>1)第一代计算机(1946-1957年)——电子管时代。特点:逻辑元件采用电子管;使用机器语言进行编程;主存用延迟线或磁鼓存储信息，容量极小;体积庞大，成本高;运算速度较低，一般只有几千次到几万次每秒。</p>
<p>2）第二代计算机（1958—1964年)——晶体管时代。特点:逻辑元件采用晶体管;运算速<br>度提高到几万次到几十万次每秒;主存使用磁心存储器;软件开始使用高级语言，如FORTRAN，有了操作系统的雏形。</p>
<p>3）第三代计算机(1965-1971年)——中小规模集成电路时代。特点:逻辑元件采用中小<br>规模集成电路;半导体存储器开始取代磁心存储器;高级语言发展迅速，操作系统也进一步发展，开始有了分时操作系统。</p>
<p>4）第四代计算机(1972年至今)——超大规模集成电路时代。特点:逻辑元件采用大规模<br>集成电路和超大规模集成电路，产生了微处理器;诸如并行、流水线、高速缓存和虚拟存储器等概念用在了这代计算机中。</p>
<h5 id="计算机元件的更新换代"><a href="#计算机元件的更新换代" class="headerlink" title="计算机元件的更新换代"></a>计算机元件的更新换代</h5><p>1）摩尔定律。当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。也就是说，我们现在和 18个月后花同样的钱买到的CPU,后者的性能是前者的两倍。这一定律揭示了信息技术进步的速度。</p>
<p>2）半导体存储器的发展。1970 年，仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11 代:单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB和现在的1GB。</p>
<p>3）微处理器的发展。自1971年Intel公司开发出第一个微处理器Intel 4004至今，微处理器经历了Intel 8008(8位)、Intel 8080 (8位)、Intel 8086 ( 16位)、Intel 8088 ( 16位)、Intel 80286 ( 16位)、Intel 80386 (32位)、Intel 80486 (32位)、Pentium (32位)、Pentium pro (64位)、Pentium II (64位)、Pentium III (64位)、Pentium 4 (64位）等。这里的32位、64位指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。</p>
<h4 id="计算机软件的发展"><a href="#计算机软件的发展" class="headerlink" title="计算机软件的发展"></a>计算机软件的发展</h4><p>计算机软件技术的蓬勃发展，也为计算机系统的发展做出了很大的贡献。</p>
<p>计算机语言的发展经历了$\color{green}{\text{面向机器}}$的机器语言和汇编语言、$\color{green}{\text{面向问题}}$的高级语言。其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的FORTRAN、结构化程序设计的PASCAL 到面向对象的C++和适应网络环境的Java。</p>
<p>与此同时，直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如Windows、UNIX、Linux 等。</p>
<h4 id="计算机的分类与发展方向"><a href="#计算机的分类与发展方向" class="headerlink" title="计算机的分类与发展方向"></a>计算机的分类与发展方向</h4><p>通用计算机又分为巨型机、大型机、中型机、小型机、微型机和单片机6类，它们的体积、功耗、性能、数据存储量、指令系统的复杂程度和价格依次递减。</p>
<p>此外，计算机按指令和数据流还可分为:</p>
<p>1)单指令流和单数据流系统（SISD)，即传统冯·诺依曼体系结构。</p>
<p>2）单指令流和多数据流系统（SIMD)，包括阵列处理器和向量处理器系统。3）多指令流和单数据流系统（MISD)，这种计算机实际上不存在。</p>
<p>4）多指令流和多数据流系统(MIMD)，包括多处理器和多计算机系统。</p>
<p>计算机的发展趋势正向着“两极”分化:一极是微型计算机向更微型化、网络化、高性能、多用途方向发展;另一极是巨型机向更巨型化、超高速、并行处理、智能化方向发展。</p>
<h3 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h3><h4 id="计算机系统的组成"><a href="#计算机系统的组成" class="headerlink" title="计算机系统的组成"></a>计算机系统的组成</h4><p>硬件系统和软件系统共同构成了一个完整的计算机系统。硬件是指有形的物理设备，是计算机系统中实际物理装置的总称。软件是指在硬件上运行的程序和相关的数据及文档。</p>
<p>计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的，而软件性能的发挥又离不开硬件的支持。对某一功能来说，其既可以用软件实现，又可以用硬件实现，则称为软硬件在逻辑上是等效的。在设计计算机系统时，要进行软/硬件的功能分配。通常来说，一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率。而用软件实现可以提高灵活性，但效率往往不如硬件实现高。</p>
<h4 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h4><h5 id="早期的冯·诺依曼机"><a href="#早期的冯·诺依曼机" class="headerlink" title="早期的冯·诺依曼机"></a>早期的冯·诺依曼机</h5><p>冯·诺依曼在研究EDVAC机时提出了“存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯·诺依曼机，其特点如下:</p>
<p>1）计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成。</p>
<p>2）指令和数据以同等地位存储在存储器中，并可按地址寻访。</p>
<p>3）指令和数据均用二进制代码表示。</p>
<p>4）指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址。</p>
<p>5）指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下可根据运算结果或根据设定的条件改变执行顺序。</p>
<p>6)早期的冯·诺依曼机以运算器为中心，输入/输出设备通过运算器与存储器传送数据。典型的冯·诺依曼计算机结构如图1.1所示。</p>
<blockquote>
<p>$\color{red}{\text{注意}}$:“$\color{red}{\text{存储程序}}$”的概念是指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。<br>计算机按照此原理应该具有5大功能:数据传送功能(总线)、数据存储功能(存储器)、数据处理功能(运算器)、操作控制功能(控制器)、操作判断功能（PC）。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630131235.png" alt=""></p>
<h5 id="现代计算机的组织结构"><a href="#现代计算机的组织结构" class="headerlink" title="现代计算机的组织结构"></a>现代计算机的组织结构</h5><p>在微处理器问世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递，如图1.1所示。</p>
<p>而随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量IO设备的速度和CPU的速度差距悬殊，因此以运算器为中心的结构不能够满足计算机发展的要求。现代计算机已发展为以存储器为中心，使IO操作尽可能地绕过CPU，直接在IO设备和存储器之间完成，以提高系统的整体运行效率，其结构如图1.2所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630131314.png" alt=""></p>
<p>目前绝大多数现代计算机仍遵循冯·诺依曼的存储程序的设计思想。</p>
<h5 id="计算机的功能部件"><a href="#计算机的功能部件" class="headerlink" title="计算机的功能部件"></a>计算机的功能部件</h5><p>传统冯·诺依曼计算机和现代计算机的结构虽然有所不同，但功能部件是一致的，它们的功能部件包括如下几种。</p>
<p><strong>(1）输入设备</strong></p>
<p>输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入计算机。最常用也最基本的输入设备是键盘，此外还有鼠标、扫描仪、摄像机等。</p>
<p><strong>(2）输出设备</strong></p>
<p>输出设备的任务是将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。最常用、最基本的输出设备是显示器、打印机。计算机的输入/输出设备（简称IO 设备）是计算机与外界联系的桥梁，是计算机中不可缺少的重要组成部分。</p>
<p><strong>(3）存储器</strong></p>
<p>存储器是计算机的存储部件，用来存放程序和数据。</p>
<p>存储器分为主存储器（简称主存，也称内存储器）和辅助存储器（简称辅存，也称外存储器)。CPU 能够$\color{red}{\text{直接访问}}$的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息，$\color{red}{\text{辅助存储器}}$中的信息必须调入主存后，才能为CPU所访问。</p>
<p>主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式($\color{green}{\text{相联存储器}}$是$\color{green}{\text{按内容}}$访问的)。</p>
<p>存储体的最基本组成如图1.3所示。存储体存放二进制信息，地址寄存器(MAR）存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器(MDR）用于暂存要从存储器中读或写的信息，时序控制逻辑用于产生存储器操作所需的各种时序信号。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630131730.png" alt=""></p>
<p>主存储器由许多存储单元组成，每个存储单元包含若干存储元件,每个存储元件存储一位二进制代码“0”或“1”。因此存储单元可存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长，存储字长可以是1B (8bit）或是字节的偶数倍。</p>
<p>$\color{green}{\text{MAR}}$用于寻址，其$\color{green}{\text{位数}}$对应着$\color{red}{\text{存储单元的个数}}$，如 MAR为10位，则有$2^{10}$= 1024个存储单元，记为1K。MAR的长度与PC的长度相等。</p>
<p>$\color{green}{\text{MDR}}$的$\color{green}{\text{位数}}$和$\color{red}{\text{存储字长}}$相等，一般为字节的二次幂的整数倍。</p>
<blockquote>
<p>注意:MAR 与 MDR虽然是存储器的一部分，但在现代CPU中却是$\color{red}{\text{存在于}}$CPU中的;另外，后文提到的高速缓存(Cache）也存在于CPU 中。</p>
</blockquote>
<p><strong>(4)运算器</strong><br>运算器是计算机的执行部件，用于进行算术运算和逻辑运算。算术运算是按算术运算规则进行的运算，如加、减、乘、除;逻辑运算包括与、或、非、异或、比较、移位等运算。</p>
<p>运算器的核心是算术逻辑单元(Arithmetic and Logical Unit，ALU)。运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（ACC)、乘商寄存器（MQ)、操作数寄存器(X)、变址寄存器(IX)、基址寄存器（BR）等，其中前3个寄存器是必须具备的。</p>
<p>运算器内还有程序状态寄存器(PSW)，也称标志寄存器，用于存放ALU运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等。</p>
<p><strong>(5）控制器</strong><br>控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。控制器由$\color{green}{\text{程序计数器(PC)}}$、$\color{green}{\text{指令寄存器（IR）}}$和$\color{green}{\text{控制单元(CU）}}$组成。</p>
<p>$\color{green}{\text{PC}}$用来存放当前$\color{green}{\text{欲执行指令}}$的$\color{green}{\text{地址}}$，可以自动加1以形成下一条指令的地址，它与主存的$\color{green}{\text{MAR}}$之间有一条直接通路。</p>
<p>$\color{green}{\text{IR}}$用来存放$\color{green}{\text{当前的指令}}$，其内容来自主存的 $\color{green}{\text{MDR}}$。指令中的操作码OP(IR)送至CU，用以分析指令并发出各种微操作命令序列;而地址码Ad(IR)送往MAR，用以取操作数。</p>
<p>一般将运算器和控制器集成到同一个芯片上，称为中央处理器（CPU)。CPU和主存储器共同构成主机，而除主机外的其他硬件装置（外存、I/O设备等）统称为外部设备，简称外设。</p>
<p>图1.4所示为冯·诺依曼结构的模型机。CPU包含ALU、通用寄存器组GPRs、标志寄存器、控制器、指令寄存器IR、程序计数器PC、存储器地址寄存器MAR和存储器数据寄存器MDR。图中从控制器送出的虚线就是控制信号，可以控制如何修改PC 以得到下一条指令的地址，可以控制ALU执行什么运算，可以控制主存是进行读操作还是写操作（读/写控制信号)。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630132300.png" alt=""></p>
<p>CPU和主存之间通过一组总线相连，总线中有地址、控制和数据3组信号线。MAR中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元;控制线中有读/写信号线，指出数据是从CPU 写入主存还是从主存读出到CPU，根据是读操作还是写操作来控制将MDR中的数据是直接送到数据线上还是将数据线上的数据接收到MDR中。</p>
<h4 id="计算机软件的分类"><a href="#计算机软件的分类" class="headerlink" title="计算机软件的分类"></a>计算机软件的分类</h4><h5 id="系统软件和应用软件"><a href="#系统软件和应用软件" class="headerlink" title="系统软件和应用软件"></a>系统软件和应用软件</h5><p>软件按其功能分类，可分为系统软件和应用软件。</p>
<p>系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为$\color{green}{\text{系统资源}}$提供给用户使用。系统软件主要有操作系统（$\color{green}{\text{OS}}$)、数据库管理系统($\color{green}{\text{DBMS}}$)、<strong>语言处理程序</strong>、<strong>分布式软件系统</strong>、<strong>网络软件系统</strong>、<strong>标准库程序</strong>、<strong>服务性程序</strong>等。</p>
<p>应用软件是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等。</p>
<blockquote>
<p>注意:$\color{green}{\text{数据库管理系统}}$（DBMS)和$\color{green}{\text{数据库系统}}$（DBS）是有区别的。DBMS是位于用户和操作系统之间的一层数据管理软件，是系统软件;而 DBS是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA)和应用系统构成。<br>dbs是dbms的超集 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34293246/article/details/94693260">参考文献</a></p>
</blockquote>
<h5 id="三个级别的语言"><a href="#三个级别的语言" class="headerlink" title="三个级别的语言"></a>三个级别的语言</h5><p>1）机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。</p>
<p>2）汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</p>
<p>3）高级语言。高级语言（如C、C++、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</p>
<h4 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h4><p>计算机的工作过程分为以下三个步骤:</p>
<p>1）把程序和数据装入主存储器。</p>
<p>2）将源程序转换成可执行文件。</p>
<p>3）从可执行文件的首地址开始逐条执行指令。</p>
<h5 id="从源程序到可执行文件"><a href="#从源程序到可执行文件" class="headerlink" title="从源程序到可执行文件"></a>从源程序到可执行文件</h5><p>在计算机中编写的C语言程序，都必须被转换为一系列的低级机器指令，这些指令按照一种称为可执行目标文件的格式打好包，并以二进制磁盘文件的形式存放起来。</p>
<p>以UNIX系统中的GCC编译器程序为例，读取源程序文件 hello.c，并把它翻译成一个可执行目标文件hello，整个翻译过程可分为4个阶段完成，如图1.5所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630133519.png" alt=""></p>
<p>1）预处理阶段:预处理器(cpp）对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以.i为扩展名的源文件hello.i.</p>
<p>2）编译阶段:编译器（ ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序hello.s。汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令</p>
<p>3）汇编阶段:汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一个称为可重定位目标文件的hello.o，它是一种二进制文件，因此在文本编辑器中打开它时会显示乱码。</p>
<p>4）链接阶段:链接器（ld）将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，或简称可执行文件。本例中，链接器将hello.o和标准库函数printf 所在的可重定位目标模块printf.o合并，生成可执行文件 hello。最终生成的可执行文件被保存在磁盘上。</p>
<h5 id="指令执行过程的描述"><a href="#指令执行过程的描述" class="headerlink" title="指令执行过程的描述"></a>指令执行过程的描述</h5><p>程序中第一条指令的地址置于PC中，根据PC取出第一条指令，经过译码、执行步骤控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址。用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。</p>
<p>指令的执行过程在第5章中详细描述。下面以取数指令（即将指令地址码指示的存储单元中的操作数取出后送至运算器的ACC中）为例进行说明，其信息流程如下:</p>
<p>1）取指令:PC→MAR→M→MDR→IR</p>
<p>根据PC取指令到IR。将PC的内容送MAR，MAR中的内容直接送地址线，同时控制器将读信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令送到数据线上，MDR从数据线接收指令信息，并传送到IR中。</p>
<p>2）分析指令:OP(IR)→CU</p>
<p>指令译码并送出控制信号。控制器根据R中指令的操作码，生成相应的控制信号送到不同的执行部件。在本例中，R中是取数指令，因此读控制信号被送到总线的控制线上。</p>
<p>3）执行指令:Ad(IR)→MAR→M→MDR→ACC<br>取数操作。将IR中指令的地址码送 MAR，MAR中的内容送地址线，同时控制器将读信号送读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至MDR，再传送到ACC中。</p>
<p>此外，每取完一条指令，还须为取下一条指令做准备，形成下一条指令的地址，即(PC)+1→PC。</p>
<blockquote>
<p>$\color{red}{\text{注意}}$:(PC)指程序计数器PC中存放的内容。PC→MAR应理解为(PC)→MAR，即程序计数器中的值经过数据通路送到MAR，也即$\color{red}{\text{表示数据通路时括号可省略}}$（因为只是表示数据流经的途径，而不强调数据本身的流动)。但$\color{red}{\text{运算时括号}}$不能省略，即(PC)+1→PC不能写为PC+1→PC。当题目中(PC)→MAR的括号未省略时，考生最好也不要省略。</p>
</blockquote>
<h4 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h4><p>现代计算机是一个硬件与软件组成的综合体。由于面对的应用范围越来越广，因此必须有复杂的系统软件和硬件的支持。由于软/硬件的设计者和使用者从不同的角度、用不同的语言来对待同一个计算机系统，因此他们看到的计算机系统的属性对计算机系统提出的要求也就各不相同。</p>
<p>计算机系统的多级层次结构的作用，就是针对上述情况，根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210630134324.png" alt=""></p>
<p>关于计算机系统层次结构的分层方式，目前尚无统一的标准,这里采用如图1.6所示的层次结构。</p>
<p>第1级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令。</p>
<p>第2级是传统机器语言层，它也是一个实际的机器层，由微程序解释机器指令系统。</p>
<p>第3级是操作系统层，它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层。</p>
<p>第4级是汇编语言层，它为用户提供一种符号化的语言，借此可编写汇编语言源程序。这一层由汇编程序支持和执行。</p>
<p>在高级语言层之上，还可以有应用程序层，它由解决实际问题和应用问题的处理程序组成，如文字处理软件、数据库软件、多媒体处理软件和办公自动化软件等。</p>
<p>通常把没有配备软件的纯硬件系统称为“裸机”。第3层～第5层称为虚拟机，简单来说就是软件实现的机器。虚拟机只对该层的观察者存在，这里的分层和计算机网络的分层类似，对于某层的观察者来说，只能通过该层次的语言来了解和使用计算机，而不必关心下层是如何工作的。</p>
<p>层次之间的关系紧密，$\color{green}{\text{下层是上层的基础}}$，$\color{green}{\text{上层是下层的扩展}}$。随着超大规模集成电路技术的不断发展，部分软件功能将由硬件来实现，因而软/硬件交界面的划分也不是绝对的。</p>
<p>本门课程主要讨论传统机器M1和微程序机器MO的组成原理及设计思想。</p>
<h3 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h3><h4 id="计算机的主要性能指标"><a href="#计算机的主要性能指标" class="headerlink" title="计算机的主要性能指标"></a>计算机的主要性能指标</h4><h5 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h5><p>机器字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，通常与CPU 的寄存器位数、加法器有关。因此，机器字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高。计算机字长通常选定为字节(8位）的整数倍。</p>
<blockquote>
<p>$\color{red}{\text{注意}}$:机器字长、指令字长和存储字长的关系（见本章常见问题和易混淆知识点4)。</p>
</blockquote>
<h5 id="数据通路带宽"><a href="#数据通路带宽" class="headerlink" title="数据通路带宽"></a>数据通路带宽</h5><p>数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指$\color{red}{\text{外部数据总线}}$的宽度，它与CPU$\color{green}{\text{内部的数据总线宽度}}$（内部寄存器的大小）有可能不同。</p>
<blockquote>
<p>注意:各个子系统通过数据总线连接形成的数据传送路径称为$\color{green}{\text{数据通路}}$。</p>
</blockquote>
<h5 id="主存容量"><a href="#主存容量" class="headerlink" title="主存容量"></a>主存容量</h5><p>主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数×字长(如512K×16位）来表示存储容量。其中，MAR的位数反映存储单元的个数，MAR的位数反映可寻址范围的最大值（而$\color{red}{\text{不一定是实际存储器的存储容量}}$)。</p>
<p>例如，MAR为16位，表示$2^{16}= 65536$，即此存储体内有65536个存储单元（可称为64K内存，1K=1024)，若MDR为32位，表示存储容量为64K×32位。</p>
<h5 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h5><h6 id="吞吐量和响应时间"><a href="#吞吐量和响应时间" class="headerlink" title="吞吐量和响应时间"></a>吞吐量和响应时间</h6><ul>
<li>吞吐量。指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU 能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。几乎每步都关系到主存，因此系统吞吐量主要取决于主存的存取周期。  </li>
<li>响应时间。指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括CPU时间(运行一个程序所花费的时间）与等待时间(用于磁盘访问、存储器访问、IO操作、操作系统开销等的时间)。</li>
</ul>
<h6 id="主频和CPU时钟周期"><a href="#主频和CPU时钟周期" class="headerlink" title="主频和CPU时钟周期"></a>主频和CPU时钟周期</h6><ul>
<li>CPU时钟周期。通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，执行指令的每个动作至少需要1个时钟周期。</li>
<li>主频（CPU时钟频率)。机器内部$\color{green}{\text{主时钟的频率}}$，是衡量机器速度的重要参数。对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。例如，常用CPU的主频有1.8GHz、2.4GHz、2.8GHz等。</li>
</ul>
<blockquote>
<p>注意:CPU时钟周期=1/主频，主频通常以Hz（赫兹）为单位，1Hz表示每秒1次。</p>
</blockquote>
<h6 id="CPI-Clock-cycle-Per-Instruction-，即执行一条指令所需的时钟周期数。"><a href="#CPI-Clock-cycle-Per-Instruction-，即执行一条指令所需的时钟周期数。" class="headerlink" title="CPI (Clock cycle Per Instruction)，即执行一条指令所需的时钟周期数。"></a>CPI (Clock cycle Per Instruction)，即执行一条指令所需的时钟周期数。</h6><p>不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其CPI 指该程序或该机器指令集中的所有指令执行所需的平均时钟周期数，此时CPI是一个平均值。</p>
<h6 id="CPU执行时间，指运行一个程序所花费的时间"><a href="#CPU执行时间，指运行一个程序所花费的时间" class="headerlink" title="CPU执行时间，指运行一个程序所花费的时间"></a>CPU执行时间，指运行一个程序所花费的时间</h6><p>CPU执行时间= CPU时钟周期数/主频=(指令条数×CPI)/主频</p>
<p>上式表明，CPU 的性能（CPU执行时间）取决于三个要素:①主频（时钟频率);②每条指令执行所用的时钟周期数(CPI);③指令条数。</p>
<p>主频、CPI和指令条数是相互制约的。例如，更改指令集可以减少程序所含指令的条数，但同时可能引起CPU结构的调整，从而可能会增加时钟周期的宽度（降低主频)。</p>
<h6 id="MIPS-Million-Instructions-Per-Second-，即每秒执行多少百万条指令"><a href="#MIPS-Million-Instructions-Per-Second-，即每秒执行多少百万条指令" class="headerlink" title="MIPS (Million Instructions Per Second)，即每秒执行多少百万条指令"></a>MIPS (Million Instructions Per Second)，即每秒执行多少百万条指令</h6><p>MIPS=指令条数(执行时间×$10^6$)=主频/(CPI×$10^6$)。</p>
<p>MIPS 对不同机器进行性能比较是有缺陷的，因为不同机器的指令集不同，指令的功能也就不同，比如在机器M1 上某条指令的功能也许在机器M2上要用多条指令来完成;不同机器的CPI和时钟周期也不同，因而同一条指合在不同机器上所用的时间也不同。</p>
<h6 id="MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS和-ZFLOPS"><a href="#MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS和-ZFLOPS" class="headerlink" title="MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS和 ZFLOPS."></a>MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS和 ZFLOPS.</h6><p>MFLOPS (Mega Floating-point Operations Per Second)，即每秒执行多少百万次浮点运算。MFLOPS=浮点操作次数/(执行时间×$10^6$)。</p>
<p>GFLOPS (Giga Floating-point Operations Per Second)，即每秒执行多少十亿次浮点运算。GFLOPS= 浮点操作次数/(执行时间×$10^9$)。</p>
<p>TFLOPS (Tera Floating-point Operations Per Second)，即每秒执行多少万亿次浮点运算。TFLOPS=浮点操作次数(执行时间×$10^{12}$)。</p>
<p>此外，还有PFLOPS=浮点操作次数(执行时间×$10^{15}$);EFLOPS = 浮点操作次数(执行时间×$10^{18}$);ZFLOPS=浮点操作次数(执行时间×$10^{21}$)。</p>
<blockquote>
<p>注意:在描述$\color{green}{\text{存储容量}}$、文件大小等时，K、M、G、T通常用$\color{green}{\text{2的幂次}}$表示，如 1Kb =210b;在$\color{green}{\text{描述速率}}$、频率等时，k、M、G、T通常用$\color{green}{\text{10的幂次}}$表示，如 1kb/s = 10b/s。通常前者用大写的K，后者用小写的k，但其他前缀均为大写，表示的含义取决于所用的场景。</p>
</blockquote>
<h5 id="基准程序"><a href="#基准程序" class="headerlink" title="基准程序"></a>基准程序</h5><p>基准程序（Benchmarks）是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。对于不同的应用场合，应该选择不同的基准程序。</p>
<p>使用基准程序进行计算机性能评测也存在一些缺陷，因为基准程序的性能可能与某一小段的短代码密切相关，而硬件系统设计人员或编译器开发者可能会针对这些代码片段进行特殊的优化，使得执行这段代码的速度非常快，以至于得不到准确的性能评测结果。</p>
<h4 id="几个专业术语"><a href="#几个专业术语" class="headerlink" title="几个专业术语"></a>几个专业术语</h4><h5 id="系列机"><a href="#系列机" class="headerlink" title="系列机"></a>系列机</h5><p>具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。</p>
<h5 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h5><p>指计算机软件或硬件的通用性，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。</p>
<h5 id="软件可移植性"><a href="#软件可移植性" class="headerlink" title="软件可移植性"></a>软件可移植性</h5><p>指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性。</p>
<h5 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h5><p>将程序固定在ROM中组成的部件称为固件。固件是一种具有软件特性的硬件，固件的性能指标介于硬件与软件之间，吸收了软/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。例如，目前操作系统已实现了部分固化(把软件永恒地存储于只读存储器中)。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><h3 id="计算机由哪几部分组成-以哪部分为中心"><a href="#计算机由哪几部分组成-以哪部分为中心" class="headerlink" title="计算机由哪几部分组成?以哪部分为中心?"></a>计算机由哪几部分组成?以哪部分为中心?</h3><p>计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器。</p>
<p>而在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。</p>
<p>随着微电子技术的进步，同时计算机需要处理、加上的信总重世与口供增，人重o以代社速度和CPU 的速度差距悬殊，因此以运算器为中心的结构个能满足计算机反展的妥水。现1灯算机已经发展为以存储器为中心，使IO操作尽可能地绕过CPU，直接在IO 设备和存储器之间<br>完成，以提高系统的整体运行效率。</p>
<h3 id="主频高的CPU一定比主频低的CPU快吗-为什么"><a href="#主频高的CPU一定比主频低的CPU快吗-为什么" class="headerlink" title="主频高的CPU一定比主频低的CPU快吗?为什么?"></a>主频高的CPU一定比主频低的CPU快吗?为什么?</h3><p>衡量CPU运算速度的指标有很多，不能以单独的某个指标来判断CPU的好坏。CPU的主频，即CPU内核工作的时钟频率。CPU 的主频表示CPU内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU 的运算速度还要看CPU的流水线的各方面的性能指标（架构、缓存、指令集、CPU的位数、Cache 大小等)。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的CPU实际运算速度较低的现象。</p>
<h3 id="翻译程序、汇编程序、编译程序、解释程序有什么差别-各自的特性是什么"><a href="#翻译程序、汇编程序、编译程序、解释程序有什么差别-各自的特性是什么" class="headerlink" title="翻译程序、汇编程序、编译程序、解释程序有什么差别?各自的特性是什么?"></a>翻译程序、汇编程序、编译程序、解释程序有什么差别?各自的特性是什么?</h3><p>见常见问题和易混淆知识点2。</p>
<h3 id="不同级别的语言编写的程序有什么区别-哪种语言编写的程序能被硬件直接执行"><a href="#不同级别的语言编写的程序有什么区别-哪种语言编写的程序能被硬件直接执行" class="headerlink" title="不同级别的语言编写的程序有什么区别?哪种语言编写的程序能被硬件直接执行?"></a>不同级别的语言编写的程序有什么区别?哪种语言编写的程序能被硬件直接执行?</h3><p>机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。其中机器语言可以被硬件直接执行。</p>
<h3 id="常见问题和易混淆知识点"><a href="#常见问题和易混淆知识点" class="headerlink" title="常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h3><h3 id="同一个功能既可以由软件实现又可以由硬件实现吗"><a href="#同一个功能既可以由软件实现又可以由硬件实现吗" class="headerlink" title="同一个功能既可以由软件实现又可以由硬件实现吗?"></a>同一个功能既可以由软件实现又可以由硬件实现吗?</h3><p>软件和硬件是两种完全不同的形态，硬件是实体，是物质基础;软件是一种信息，看不见、摸不到。但在逻辑功能上，软件和硬件是等效的。因此，在计算机系统中，许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。</p>
<p>例如，乘法运算既可用专门的乘法器（主要由加法器和移位器组成）实现，也可用乘法子程序（主要由加法指令和移位指令等组成）来实现。</p>
<h3 id="翻译程序、汇编程序、编译程序、解释程序的区别和联系是什么"><a href="#翻译程序、汇编程序、编译程序、解释程序的区别和联系是什么" class="headerlink" title="翻译程序、汇编程序、编译程序、解释程序的区别和联系是什么?"></a>翻译程序、汇编程序、编译程序、解释程序的区别和联系是什么?</h3><p>翻译程序是指把高级语言源程序翻译成机器语言程序（目标代码）的软件。</p>
<p>翻译程序有两种:一种是编译程序，它将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只需执行目标程序，因此只要源程序不变，就无须重新翻译，请注意同一种高级语言在不同体系结构下，编译成目标程序是不一样的，目标程序与体系结构相关，但仍不是计算机硬件能够直接执行的程序。另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。</p>
<p>汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。汇编语言是一种面向机器的低级语言，是机器语言的符号表示，与机器语言一一对应。</p>
<p>编译程序与汇编程序的区别:若源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。</p>
<h3 id="什么是透明性-透明是指什么都能看见吗"><a href="#什么是透明性-透明是指什么都能看见吗" class="headerlink" title="什么是透明性?透明是指什么都能看见吗?"></a>什么是透明性?透明是指什么都能看见吗?</h3><p>在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念（公开、看得见）正好相反。</p>
<p>例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的;而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。</p>
<p>在CPU中，IR、MAR和 MDR对各类程序员都是透明的。</p>
<h3 id="机器字长、指令字长、存储字长的区别和联系是什么"><a href="#机器字长、指令字长、存储字长的区别和联系是什么" class="headerlink" title="机器字长、指令字长、存储字长的区别和联系是什么?"></a>机器字长、指令字长、存储字长的区别和联系是什么?</h3><p>机器字长:计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。</p>
<p>指令字长:一个指令字中包含的二进制代码的位数。</p>
<p>存储字长:一个存储单元存储的二进制代码的长度。它们都必须是字节的整数倍。</p>
<p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要⒉次访存来取出一条指令，因此取指周期为机器周期的2倍;若指令字长等于存储字长，则取指周期等于机器周期。</p>
<p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p>
<p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p>
<h3 id="计算机体系结构和计算机组成的区别和联系是什么"><a href="#计算机体系结构和计算机组成的区别和联系是什么" class="headerlink" title="计算机体系结构和计算机组成的区别和联系是什么?"></a>计算机体系结构和计算机组成的区别和联系是什么?</h3><p>计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性。</p>
<p>计算机组成是指如何实现计算机体系结构所体现的属性，它包含对许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。</p>
<p>许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。例如，IBM System/370结构就包了多种价位和性能的机型。</p>
<h3 id="基准程序执行得越快说明机器的性能越好吗"><a href="#基准程序执行得越快说明机器的性能越好吗" class="headerlink" title="基准程序执行得越快说明机器的性能越好吗?"></a>基准程序执行得越快说明机器的性能越好吗?</h3><p>一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。</p>
<h3 id="字长总结"><a href="#字长总结" class="headerlink" title="字长总结"></a>字长总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th>字长</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>机器字长</td>
<td>是指数据运算的基本单位长度，是计算机的位数</td>
</tr>
<tr>
<td>存储字长</td>
<td>一个存储单元中的二进制代码的位数，等于MDR的位数，一般情况下可通过寄存器的位数来判断机器字长($\color{red}{\text{Q}}$：如何判断)。</td>
</tr>
<tr>
<td>指令字长</td>
<td></td>
</tr>
<tr>
<td>数据字长</td>
<td>数据总线一次能并行传送信息的位数，它可以不等于MDR的位数</td>
</tr>
<tr>
<td>操作系统的位数</td>
<td>操作系统可寻址的位数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="周期总结"><a href="#周期总结" class="headerlink" title="周期总结"></a>周期总结</h3><div class="table-container">
<table>
<thead>
<tr>
<th>周期</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>时钟周期</td>
<td>是最基本的时间单位，是计算机操作的最小单位时间</td>
</tr>
<tr>
<td>指令周期</td>
<td></td>
</tr>
<tr>
<td>机器周期</td>
<td>CPU 周期又称机器周期，它由多个时钟周期组成</td>
</tr>
<tr>
<td>CPU周期</td>
<td></td>
</tr>
<tr>
<td>中断周期</td>
<td></td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/29/%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/29/%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-29 21:11:07" itemprop="dateCreated datePublished" datetime="2021-06-29T21:11:07+08:00">2021-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-10 23:01:20" itemprop="dateModified" datetime="2021-09-10T23:01:20+08:00">2021-09-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="专业词汇"><a href="#专业词汇" class="headerlink" title="专业词汇"></a>专业词汇</h1><table>
<thead>
<tr>
<th>单词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Orthogonal List</td>
<td>十字链表</td>
</tr>
<tr>
<td>adjacency list</td>
<td>邻接表</td>
</tr>
<tr>
<td>adjacency vertex</td>
<td>邻接顶点，邻接表中的顶点</td>
</tr>
<tr>
<td>AOV</td>
<td>Activity On Vertex Network,     <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/AOV/1020550?fr=aladdin">顶点活动网</a></td>
</tr>
<tr>
<td>AOE</td>
<td>Activity on edge network,<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/AOE/18066#viewPageContent">边活动网</a></td>
</tr>
<tr>
<td>AVL</td>
<td>Adelson-Velsky and Landis Tree，平衡二叉树</td>
</tr>
<tr>
<td>BF</td>
<td>Brute Force(暴力搜索)</td>
</tr>
<tr>
<td>bm</td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/BM%E7%AE%97%E6%B3%95/19457300?fr=aladdin">后缀匹配算法</a></td>
</tr>
<tr>
<td>dp</td>
<td><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoboge/p/10509619.html">动态规划算法</a></td>
</tr>
<tr>
<td>preorder</td>
<td>先序</td>
</tr>
<tr>
<td>inorder</td>
<td>中序</td>
</tr>
<tr>
<td>postorder</td>
<td>后序</td>
</tr>
</tbody></table>
<h1 id="OJ-Online-Judge-状态术语"><a href="#OJ-Online-Judge-状态术语" class="headerlink" title="OJ(Online Judge) 状态术语"></a>OJ(Online Judge) 状态术语</h1><table>
<thead>
<tr>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AC</td>
<td>Accepted ,答案正确</td>
</tr>
<tr>
<td>WA</td>
<td>Wrong Answer, 答案错误</td>
</tr>
<tr>
<td>TLE</td>
<td>Time Limit Exceeded,运⾏超时 / 时间超限</td>
</tr>
<tr>
<td>CE</td>
<td>Compile Error,编译错误</td>
</tr>
<tr>
<td>RE</td>
<td>Runtime Error, 运⾏时出错</td>
</tr>
<tr>
<td>MLE</td>
<td>Memory Limit Exceeded, 内存超限</td>
</tr>
<tr>
<td>PE</td>
<td>Presentation Error, 格式错误</td>
</tr>
</tbody></table>
<h1 id="英文单词"><a href="#英文单词" class="headerlink" title="英文单词"></a>英文单词</h1><table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>permutation</td>
<td>n. [数] 排列；[数] 置换</td>
</tr>
<tr>
<td>intersection</td>
<td>交集</td>
</tr>
<tr>
<td>union set</td>
<td>并集</td>
</tr>
<tr>
<td>complementary set /supplementary set</td>
<td>补集</td>
</tr>
<tr>
<td>Palindromic</td>
<td>adj. 回文的；复发的</td>
</tr>
<tr>
<td>chopping</td>
<td>v.     切碎; 剁碎; 砍; 劈; (大幅度地)削减，降低; 取消; 终止; 向下猛击</td>
</tr>
<tr>
<td>significant digits</td>
<td>有效数字; 有效位数; 有効数字; 有效数字位数; 有效數字;</td>
</tr>
<tr>
<td>notation</td>
<td>n.     (数学、科学和音乐中的)符号，记号，谱号;</td>
</tr>
<tr>
<td>fractional</td>
<td>adj.     很小的; 很少的; 微不足道的; 分数的; 小数的;</td>
</tr>
<tr>
<td>trailing zeros</td>
<td>尾随零;</td>
</tr>
<tr>
<td>notorious</td>
<td>adj.     声名狼藉的; 臭名昭著的</td>
</tr>
<tr>
<td>unit</td>
<td>adj.     单位</td>
</tr>
<tr>
<td>tie</td>
<td>v. （用线、绳等）系；系牢，打结；连接，联合；约束；与……成平局，不分胜负；用连接线连接（音符）<br />n. 领带；鞋带；领结；绳子，金属丝；关系，纽带；束缚；系梁；平局；不分胜负；（英）淘汰赛（尤指足球）；延音线<br />n. (Tie) （美、澳、马来）狄（人名）</td>
</tr>
<tr>
<td>quota</td>
<td>n. 定额；限额；配额；指标；（候选人当选所需的）规定票数，最低票数</td>
</tr>
<tr>
<td>decimal</td>
<td>adj.     十进位的; $\color{red}{\text{小数的}}$;</td>
</tr>
<tr>
<td>consecutive</td>
<td>adj.     连续不断的;</td>
</tr>
<tr>
<td>prime</td>
<td>质数</td>
</tr>
<tr>
<td>transcendental number</td>
<td>超越数</td>
</tr>
<tr>
<td>truncate</td>
<td>v. 截断，删节；把……截成平面<br />adj. （叶、羽毛等）截形的；截短的</td>
</tr>
<tr>
<td>rate</td>
<td>n. 比率，率；速度；价格；等级<br />vt. 认为；估价；责骂<br />vi. 责骂；被评价<br />n. (Rate)人名；(法、塞)拉特</td>
</tr>
<tr>
<td>toll</td>
<td>n. 通行费；代价；钟声；伤亡人数<br />vt. 征收；敲钟<br />vi. 鸣钟；征税</td>
</tr>
<tr>
<td>cents</td>
<td>分</td>
</tr>
<tr>
<td>chronologically</td>
<td>adv. 按年代地</td>
</tr>
<tr>
<td>repetition</td>
<td>n. 重复；背诵；副本</td>
</tr>
<tr>
<td>pedigree</td>
<td>n. 血统；家谱<br />adj. 纯种的</td>
</tr>
<tr>
<td>ZigZag</td>
<td>n. 之字形，锯齿形线条；急转弯<br />v. 曲折前进，作之字形行进<br />adj. 曲折的，之字形的<br />adv. 曲折地，之字形地</td>
</tr>
<tr>
<td>descendant</td>
<td>n. 后裔，子孙；（由过去类似物发展来的）派生物；（机器等）后继型产品<br />adj. 下降的；祖传的</td>
</tr>
<tr>
<td>acyclic</td>
<td>adj. 非循环的；[物] 非周期的</td>
</tr>
<tr>
<td>infix</td>
<td>v. 把……植入；插入（中缀）；用力插入<br />adj. 中缀的<br />n. 中缀</td>
</tr>
<tr>
<td>parentheses</td>
<td>n. 圆括号；插入成分（parenthesis 的复数）</td>
</tr>
<tr>
<td>precedences</td>
<td>n. 优先；居先</td>
</tr>
<tr>
<td>clique</td>
<td>n. 派系；阀；私党；小圈子<br />vi. 结党<br />n. (Clique)人名；(法)克利克</td>
</tr>
<tr>
<td>radix</td>
<td>n. 根；[数] 基数<br />n. (Radix)人名；(法、德、西)拉迪克斯；(英)雷迪克斯</td>
</tr>
</tbody></table>
<h1 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h1><h2 id="Q：为什么using-namespace-std依然找不到vector？"><a href="#Q：为什么using-namespace-std依然找不到vector？" class="headerlink" title="Q：为什么using namespace std依然找不到vector？"></a>Q：为什么using namespace std依然找不到vector？</h2><h1 id="动态规划-p425"><a href="#动态规划-p425" class="headerlink" title="动态规划 p425"></a>动态规划 p425</h1><p>《算法笔记–胡凡》</p>
<blockquote>
<p>一般可以使用递归或者递推的写法来实现动态规划，其中递归写法在此处又称作$\color{green}{\text{记忆化搜索}}$。<br>需要指出，一个问题必须拥有$\color{green}{\text{重子问题}}$和$\color{green}{\text{最优子结构}}$</p>
</blockquote>
<p>①分治与动态规划。分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。例如，归并排序和快速排序都是分别处理左序列和右序列，然后将左右序列的结果合并，过程中不出现重叠子问题，因此它们使用的都是分治法。另外，分治法解决的问题不一定是最优化问题，而动态规划解决的问题一定是最优化问题。</p>
<p>${\textstyle\unicode{x2461}}$  贪心与动态规划。贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似于上面介绍的“自顶向下”，但是并不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是只在上一步选择的基础上继续选择，因此整个过程以一种单链的流水方式进行，显然这种所谓“最优选择”的正确性需要用归纳法证明。例如对数塔问题而言，贪心法从最上层开始，每次选择左下和右下两个数字中较大的一个，一直到最底层得到最后结果，显然这不一定可以得到最优解。而动态规划不管是采用自底向上还是自顶向下的计算方式，都是从边界开始向上得到目标问题的解。也就是说，它总是会考所有子问题，并选择继承能得到最优结果的那个，对暂时没被继承的子问题，由于重叠子问题的存在，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃所以贪心是一种壮士断腕的决策，只要进行了选择，就不后悔;动态规划则要看哪个选择到了最后，暂时的领先说明不了什么。</p>
<p>对动态规划可解的问题来说，总会有很多设计状态的方式，但并不是所有状态都具有无后效性，因此必须设计一个拥有无后效性的状态以及相应的状态转移方程，否则动态规划就没有办法得到正确结果。事实上，如何设计状态和状态转移方程，才是动态规划的核心，而它们也是动态规划最难的地方。</p>
<p>0,1背包可以用$\color{green}{\text{滚动数组}}$降低空间复杂度</p>
<h1 id="贪心-p118"><a href="#贪心-p118" class="headerlink" title="贪心 p118"></a>贪心 p118</h1><h1 id="并查集-p328"><a href="#并查集-p328" class="headerlink" title="并查集 p328"></a>并查集 p328</h1><h1 id="algotithms-p232"><a href="#algotithms-p232" class="headerlink" title="algotithms p232"></a>algotithms p232</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mycd/p/5657145.html">next_permutation()</a>,如果没有下一个了会返回false</p>
<p>lower_bound()和 upper_bound()需要用在一个有序数组或容器中，在4.5.1中已经讨论过它们的实现。</p>
<p>lower_bound(first，last,val)用来寻找在数组或容器的[first，last)范围内第一个值大于等于val的元素的位置，如果是数组，则返回该位置的指针;如果是容器，则返回该位置的迭代器。</p>
<p>upper_bound(first, last, val)用来寻找在数组或容器的[first, last)范围内第一个值大于val的元素的位置，如果是数组，则返回该位置的指针;如果是容器，则返回该位置的迭代器。</p>
<h1 id="PTA"><a href="#PTA" class="headerlink" title="PTA"></a>PTA</h1><h2 id="非技术"><a href="#非技术" class="headerlink" title="非技术"></a>非技术</h2><ul>
<li>注意输出的时候特定长度的占位0一定要输出</li>
<li>注意看清楚题目的排序要求</li>
<li>太多节点的时候慎用dfs,可能会爆栈</li>
</ul>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li>to_string:将int转换为string</li>
<li>读取的时候不需要这么麻烦，用一个char把<code>:</code>吞掉就好了</li>
<li>排序的时候不用重写sort方法,vector的排序内置就是符合逻辑的</li>
<li><code>for (int Time = t1; Time &lt; t2; Time++) fenzhang += danjia[Time % 1440 / 60];//按照当前时间所属小时段，给分账加上一分钟的钱</code>按每一分中来算帐，一行抵百行</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/baishuo8/article/details/84073565">numeric的库函数</a>：accumulate,inner_product(计算两个向量的内积),iota(Store increasing sequence 生成递增数列, 很简单的功能, 很奇怪的名字.)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/17/%E4%B9%A0%E9%A2%98-%E7%8E%8B%E9%81%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/17/%E4%B9%A0%E9%A2%98-%E7%8E%8B%E9%81%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">习题-王道-数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-17 23:01:02" itemprop="dateCreated datePublished" datetime="2021-06-17T23:01:02+08:00">2021-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-21 22:34:26" itemprop="dateModified" datetime="2021-08-21T22:34:26+08:00">2021-08-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="凑数"><a href="#凑数" class="headerlink" title="凑数"></a>凑数</h1><h2 id="凑数-1"><a href="#凑数-1" class="headerlink" title="凑数"></a>凑数</h2><h3 id="凑数-2"><a href="#凑数-2" class="headerlink" title="凑数"></a>凑数</h3><h4 id="凑数-3"><a href="#凑数-3" class="headerlink" title="凑数"></a>凑数</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/17/%E4%B9%A0%E9%A2%98-%E7%8E%8B%E9%81%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/17/%E4%B9%A0%E9%A2%98-%E7%8E%8B%E9%81%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-ch8-%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/17/%E4%B9%A0%E9%A2%98-%E7%8E%8B%E9%81%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-ch8-%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">习题-王道-数据结构-ch8-排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-17 21:29:25" itemprop="dateCreated datePublished" datetime="2021-06-17T21:29:25+08:00">2021-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-05 00:35:14" itemprop="dateModified" datetime="2021-08-05T00:35:14+08:00">2021-08-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="凑数"><a href="#凑数" class="headerlink" title="凑数"></a>凑数</h1><h2 id="凑数-1"><a href="#凑数-1" class="headerlink" title="凑数"></a>凑数</h2><h3 id="凑数-2"><a href="#凑数-2" class="headerlink" title="凑数"></a>凑数</h3><h4 id="凑数-3"><a href="#凑数-3" class="headerlink" title="凑数"></a>凑数</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/17/%E4%B9%A0%E9%A2%98-%E7%8E%8B%E9%81%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-ch8-%E6%8E%92%E5%BA%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/17/%E7%8E%8B%E9%81%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-ch8-%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/17/%E7%8E%8B%E9%81%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-ch8-%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">王道-数据结构-ch8-排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-17 21:29:25" itemprop="dateCreated datePublished" datetime="2021-06-17T21:29:25+08:00">2021-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-10 23:16:57" itemprop="dateModified" datetime="2021-08-10T23:16:57+08:00">2021-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>p306</p>
<p><strong>【考纲内容】</strong></p>
<p>(一）排序的基本概念</p>
<p>(二）插入排序<br>直接插入排序;折半插入排序;希尔排序（shell sort)</p>
<p>(三）交换排序<br>冒泡排序（ bubble sort);快速排序</p>
<p>(四）选择排序<br>简单选择排序;堆排序</p>
<p>(五)2路归并排序（merge sort)</p>
<p>(六）基数排序</p>
<p>(七）外部排序</p>
<p>(八）各种排序算法的比较</p>
<p>(九）排序算法的应用</p>
<p><strong>【知识框架】</strong></p>
<ul>
<li>基本概念<ul>
<li>稳定性</li>
<li>衡量标准:时、空复杂度</li>
</ul>
</li>
<li>内部排序<ul>
<li>插入排序<ul>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>希尔排序</li>
</ul>
</li>
<li>交换排序<ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li>选择排序<ul>
<li>简单选择排序</li>
<li>堆排序</li>
</ul>
</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
</li>
<li>外部排序——多路归并排序</li>
</ul>
<p><strong>【复习提示】</strong></p>
<p>堆排序、快速排序和归并排序是本章的重难点。读者应深入掌握各种排序算法的思想、排序过程（能动手模拟）和特征（初态的影响、复杂度、稳足性、道用性等)，避吊以远开越的1八考查不同算法之间的对比。此外，对于一些常用排序算法的天键代码，要达到热练绸与的住度;看到某特定序列，读者应具有选择最优排序算法（根据排序算法特征）的能力。</p>
<table>
<thead>
<tr>
<th>单词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>LSD,Least Significant Digit first</td>
<td>最低位优先</td>
</tr>
<tr>
<td>MSD,Most Significant Digit first</td>
<td>最高位优先</td>
</tr>
</tbody></table>
<p>$\color{red}{\text{Q}}$：总结每种排序算法的特点</p>
<h3 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h3><h4 id="排序的定义"><a href="#排序的定义" class="headerlink" title="排序的定义"></a>排序的定义</h4><p>排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。为了查找方便，通常希望计算机中的表是按关键字有序的。排序的确切定义如下:</p>
<p>输入:$n$个记录$R_1, R_2, R_n，$对应的关键字为$k_1, k_2,\cdots, k_n$。</p>
<p>输出:输入序列的一个重排$R_1’，R_2’,\cdots,R_n’$，使得$k_1’ \leq k_2’ \leq \cdots \leq k_n’$(其中“$\leq$”可以换成其他的比较大小的符号)。</p>
<p><strong>算法的稳定性</strong>。若待排序表中有两个元素$R_i$和$R_j$，其对应的关键字相同即$key_i= key_j$，且在排序前$R_i$,在$R_j$的前面，若使用某一排序算法排序后，$R_i$仍然在$R_j$的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。如果待排序表中的关键字不允许重复，则排序结果是唯一的，那么选择排序算法时的稳定与否就无关紧要。</p>
<blockquote>
<p>注意:对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。</p>
</blockquote>
<p>在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类:①内部排序，是指在排序期间元素全部存放在内存中的排序;②外部排序，是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。</p>
<p>一般情况下，内部排序算法在执行过程中都要进行两种操作:比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部排序算法都要基于比较操作，事实上，<strong>基数排序</strong>就不基于比较。</p>
<p>每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类，后面几节会分别进行详细介绍。内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法:直接插入排序、折半插入排序和希尔排序。</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>根据上面的插入排序思想，不难得出一种最简单也最直观的直接插入排序算法。假设在排序过程中，待排序表$L  \lbrack 1\cdots n \rbrack$在某次排序过程中的某一时刻状态如下:</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210701215216.png"></p>
<p>要将元素L(i)插入己有序的子序列$L\lbrack  1\cdots i-1 \rbrack$，需要执行以下操作（为避免混淆，下面用$L\lbrack  \rbrack$表示一个表，而用L()表示一个元素):</p>
<p>1)查找出L(i)在$L \lbrack 1\cdots i-1 \rbrack$中的插入位置k。</p>
<p>2）将$L \lbrack  k\cdots i-1 \rbrack$中的所有元素依次后移一个位置。</p>
<p>3）将L(i)复制到L(k)。</p>
<p>为了实现对$L\lbrack  1\cdots n \rbrack$的排序,可以将L(2)~L(n)依次插入前面已排好序的子序列,初始$L\lbrack 1 \rbrack$可以视为是一个已排好序的子序列。上述操作执行n -1次就能得到一个有序的表。插入排序在实现上通常采用就地排序（空间复杂度为O(1))，因而在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。</p>
<p>下面是直接插入排序的代码，其中再次用到了我们前面提到的“哨兵”(作用相同)。</p>
<details><summary>王道书中关于直接插入排序的代码</summary>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 王道辅导书的代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)<span class="comment">//依次将A[2]～A[n]插入前面已排序序列</span></span><br><span class="line">  <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])(  <span class="comment">//若A[i]关键码小于其前驱,将A[i]插入有序表</span></span><br><span class="line">    A[<span class="number">0</span>] = A[i];<span class="comment">//复制为哨兵，A[0]不存放元素</span></span><br><span class="line">    <span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];--j)<span class="comment">//从后往前查找待插入位置 </span></span><br><span class="line">      A[j+<span class="number">1</span>]=A[j];<span class="comment">//向后挪位</span></span><br><span class="line">    A[j+<span class="number">1</span>]=A[<span class="number">0</span>];<span class="comment">//复制到插入位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>



<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210701220610.png"></p>
<details><summary>严书中关于直接插入排序的代码</summary>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 对顺序表L作直接插入排序</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>; i &lt;= L.length; ++i)</span><br><span class="line">    <span class="keyword">if</span>(LT(L.r[i].key, L.r[i<span class="number">-1</span>].key))&#123;  <span class="comment">// &quot;&lt;&quot;,需将L.r[i]插入有序子表</span></span><br><span class="line">      L.r[<span class="number">0</span>] = L.r[i];  <span class="comment">// 复制为哨兵</span></span><br><span class="line">      L.r[i] = L.r[i<span class="number">-1</span>];</span><br><span class="line">      <span class="keyword">for</span>(j=i<span class="number">-2</span>; LT(L.r[<span class="number">0</span>].key, L.r[j].key); --j)</span><br><span class="line">        L.r[j+<span class="number">1</span>] = L.r[j];  <span class="comment">// 记录后移</span></span><br><span class="line">      L.r[j+<span class="number">1</span>] = L.r[<span class="number">0</span>]; <span class="comment">// 插入到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// InsertSort</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>



<blockquote>
<p>哨兵：有和没有都是常熟个辅助单元啊<br>这个算法非常的魔怔<br>更魔怔的是，王道，严，天勤上写的都不一样，版本乱天飞,严的代码也很魔怔，<code>if(LT(L.r[i].key, L.r[i-1].key))&#123;  // &quot;&lt;&quot;,需将L.r[i]插入有序子表</code>为什么要省花括号呢？？第7行写成<code>j=i-1</code>就没有第6行的事了，真的绝了；<br>再次更新，第六行还是有作用的，第六行可以减少一次比较！</p>
</blockquote>
<p>直接插入排序算法的性能分析如下:</p>
<p>空间效率:仅使用了常数个辅助单元，因而空间复杂度为O(1)。</p>
<p>时间效率:在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟,每趟都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。</p>
<p>在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O(n)。</p>
<p>在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序)，总的比较次数达到最大，为$\displaystyle \sum_{i=2}^n i$，总的移动次数也达到最大，为$\displaystyle \sum_{i=2}^n (i+1)$</p>
<blockquote>
<p>$\color{red}{\text{Q}}$：为什么最坏的情况，比较次数不是1次？</p>
</blockquote>
<p>平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均约为$n^2/4$。</p>
<p>因此，直接插入排序算法的时间复杂度为O($n^2$)。</p>
<p>稳定性:由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法。</p>
<p>适用性:直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。</p>
<blockquote>
<p>注意:大部分排序算法都仅适用于顺序存储的线性表。</p>
</blockquote>
<h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作: ${\textstyle\unicode{x2460}}$ 从前面的有序子表中查找出待插入元素应该被插入的位置; ${\textstyle\unicode{x2461}}$  给抽入位置腾出空间，将待插入元素复制到表中的插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，可以对直接插入排序算法做如下改进:由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。算法代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span> <span class="params">(ElemType A[] ,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,low, high, mid;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=n;i++)&#123; <span class="comment">//依次将A[2]～A[n]插入前面的已排序序列</span></span><br><span class="line">  A[<span class="number">0</span>]=A[i];<span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">  low=<span class="number">1</span>;high=i<span class="number">-1</span>;<span class="comment">//设置折半查找的范围</span></span><br><span class="line">  <span class="keyword">while</span>(low&lt;=high)&#123;<span class="comment">//折半查找(默认递增有序)</span></span><br><span class="line">    mid=(low+high) /<span class="number">2</span>;<span class="comment">//取中间点</span></span><br><span class="line">  <span class="keyword">if</span>(A[mid] &gt;A[<span class="number">0</span>]) high-mid<span class="number">-1</span>;<span class="comment">//查找左半子表</span></span><br><span class="line">    <span class="keyword">else</span> low=mid+<span class="number">1</span>;<span class="comment">//查找右半子表</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(j-i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">    A[j+<span class="number">1</span>]=A[j];<span class="comment">//统一后移元素,空出插入位置</span></span><br><span class="line">  A[high+<span class="number">1</span>]=A[<span class="number">0</span>]; <span class="comment">//插入操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details><summary>严书关于折半插入排序的代码</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210801135353.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210801135353.png';" /></details>

<p>从上述算法中，不难看出折半插入排序仅减少了比较元素的次数，约为$O(nlog_2n)$，该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数$n$;而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为$O(n^2)$，但对于数据量不很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序方法。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>从前面的分析可知，直接插入排序算法的时间复杂度为$O(n^2)$，但若待排序列为“正序”时，其时间复杂度可提高至$O(n)$，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称<strong>缩小增量排序</strong>。</p>
<blockquote>
<p>所谓增量就是增加的量，所以算的时候,比如$\color{green}{\text{1}}$,<u>2,$\color{green}{\text{3}}$</u>，1，3被分到了一组，那么增量就是2，下划线的长度为2</p>
</blockquote>
<p>希尔排序的基本思想是:先将待排序表分割成若干形如$L\lbrack i, i + d, i+ 2d,\cdots, i + kd \rbrack$的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。</p>
<p>希尔排序的过程如下:先取一个小于$n$的步长$d_1$，把表中的全部记录分成$d_1$ 组，所有距离为$d_1$的倍数的记录放在同一组，在各组内进行直接插入排序;然后取第二个步长$d_2 &lt; d_1$过程，直到所取到的$d_t = 1$，即所有记录已放在同一组中，再进行直接插入排序，由于此已经具有较好的局部有序性，故可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列,</p>
<p>希尔提出的方法是$d_1=n/2，d_{i+1} = \lfloor d_i /2 \rfloor$，并且最后一个增量等于1。仍以8.2.1节的关键字为例，</p>
<p>第一趟取增量$d_1 = 5$，将该序列分成5个子序列，即图中第2行至第6行，分别对各子序列进行直接插入排序，结果如第7行所示;第二趟取增量$d_2=3$，分别对3个子序列进行直接插入排序，结果如第11行所示;最后对整个序列进行一趟直接插入排序，整个排序过程如图8.2所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210701223816.png"></p>
<p>希尔排序算法的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(El emType A[I],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//A[0]只是暂存单元，不是哨兵,当j&lt;=0时，插入位置已到</span></span><br><span class="line"><span class="keyword">for</span> (dk=n /<span class="number">2</span>;dk&gt;=<span class="number">1</span>;dk=dk /<span class="number">2</span>)<span class="comment">//步长变化</span></span><br><span class="line">  <span class="keyword">for</span>(i-dk+<span class="number">1</span>;i&lt;-n;++i)</span><br><span class="line">  <span class="keyword">if</span>(A[i]&lt;A[i-dk])&#123;<span class="comment">//需将A[i]插入有序增量子表</span></span><br><span class="line">    A [O]=A[i];<span class="comment">//暂存在A[0]</span></span><br><span class="line">    <span class="keyword">for</span>(j-i-dk;j&gt;<span class="number">0</span>&amp;&amp;A[O]&lt;A[j];j--dk)</span><br><span class="line">      A[j+dk]=A[j]; <span class="comment">//记录后移,查找插入的位置</span></span><br><span class="line">    A[j+dk]=A[<span class="number">0</span>];<span class="comment">//插入</span></span><br><span class="line">  &#125;<span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details><summary>严书希尔排序的过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210801135744.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210801135744.png';" /></details>


<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210723163312.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210723163312.png';" /></details>

<blockquote>
<p>$\color{red}{\text{Q}}$:暂存元素和哨兵的区别</p>
</blockquote>
<p>希尔排序算法的性能分析如下:</p>
<p>空间效率:仅使用了常数个辅助单元，因而空间复杂度为O(1)。</p>
<p>时间效率:由于希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题,所以其时间复杂度分析比较困难。当n在某个特定范围时,希尔排序的时间复杂度约为$O(n^{1.3}$。在最坏情况下希尔排序的时间复杂度为$O(n^2)$。</p>
<blockquote>
<p>跟增量的选取有关，某个特定的增量的时间复杂度为$O(n^{3/2})$</p>
</blockquote>
<p>稳定性:当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序方法。例如，图8.2中49与$\bar{49}$的相对次序已发生了变化</p>
<p>适用性:希尔排序算法仅适用于线性表为$\color{red}{\text{顺序存储}}$的情况。</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。基于交换的排序算法很多，本书主要介绍冒泡排序和快速排序，其中冒泡排序算法比较简单，一般不会单独考查，通常会重点考查快速排序算法的相关内容。</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><details><summary>严书冒泡排序的描述</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210801140100.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210801140100.png';" /></details>


<p>冒泡排序的基本思想是:从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即$A[i-1]&gt;A[i]$)，则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置)，关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”(或关键字最大的元素如石头一般下沉至水底)。下一趟冒泡时，前一趟确定的最小元素不再参与比较,每趟冒泡的结果是把序列中的最小元素(或最大元素）放到了序列的最终位置……这样最多做$n-1$趟冒泡就能把所有元素排好序。</p>
<p>图8.3所示为冒泡排序的过程，第一趟冒泡时:27&lt;$\bar{49}$，不交换;13&lt;27，不交换;76&gt;13，交换;97&gt;13，交换;65&gt;13，交换;38&gt;13，交换;49&gt;13，交换。通过第一趟冒泡后，最小元素已交换到第一个位置，也是它的最终位置。第二趟冒泡时对剩余子序列采用同样方法进行排序，以此类推，到第五趟结束后没有发生交换，说明表已有序，冒泡排序结束。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210701224719.png"></p>
<p>冒泡排序算法的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubblesort</span> <span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(i<span class="number">-0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    flag=<span class="literal">false</span>;<span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">    <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)<span class="comment">//一趟冒泡过程</span></span><br><span class="line">    <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;<span class="comment">//若为逆序</span></span><br><span class="line">      swap(A[j<span class="number">-1</span>],A[j]);<span class="comment">//交换</span></span><br><span class="line">      flag=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//本趟遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序的性能分析如下:</p>
<p>空间效率:仅使用了常数个辅助单元，因而空间复杂度为O(1)。</p>
<p>时间效率:当初始序列有序时，显然第一趟冒泡后flag依然为false(本趟冒泡没有元素交换)，从而直接跳出循环，比较次数为n-1，移动次数为0，从而最好情况下的时间复杂度为$O(n)$;当初始序列为逆序时，需要进行n-1趟排序，第i趟排序要进行n-i次关键字的比较，而且每次比较后都必须移动元素三次来交换元素位置，这种情况下，</p>
<p>比较次数=$\displaystyle \sum_{i=1}^{n-1}=\dfrac{n(n-1)}{2}$,移动次数=$\displaystyle \sum_{i=1}^{n-1}3(n-i)=\dfrac{3n(n-1)}{2}$</p>
<p>从而，最坏情况下的时间复杂度为$O(n^2)$,其平均时间复杂度也为$O(n^2)$</p>
<p>稳定性:由于i&gt;j且$A\lbrack i \rbrack = A\lbrack j \rbrack$时，不会发生交换，因此冒泡排序是一种稳定的排序方法。</p>
<blockquote>
<p>注意:冒泡排序中所产生的有序子序列一定是<strong>全局有序的</strong>.(不同于直接插入排序)，也就是说，有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。<br>为什么要强调这个</p>
</blockquote>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><details><summary>严书快速排序的代码pp.286</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210801140202.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210801140202.png';" /></details>

<details><summary>严书快速排序的代码pp.287</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210801140326.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210801140326.png';" /></details>

<blockquote>
<p>快速排序之所以叫快速排序就是因为他是最快的算法（笑</p>
</blockquote>
<p>快速排序的基本思想是基于分治法的:在待排序表$L \lbrack 1\cdots n \rbrack$中任取一个元素 pivot 作为枢轴（或基准，通常取首元素)，通过一趟排序将待排序表划分为独立的两部分 L[ 1…k-1]和[ k+1…n]，使得L[ 1…k-1]中的所有元素小于 pivot，L[ k+1..n ]中的所有元素大于等于pivot，则 pivot放在了其最终位置L(k)上，这个过程称为一趟快速排序（或一次划分)。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p>
<p>一趟快速排序的过程是一个交替搜索和交换的过程，下面通过实例来介绍，附设两个指针i和j，初值分别为low和 high，取第一个元素49为枢轴赋值到变量pivot。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210701231127.png"></p>
<p>对算法的最好理解方式是手动地模拟一遍这些算法。</p>
<p>假设划分算法已知，记为Partition ( )，返回的是上述的k，注意到工(k)已在最终的位置，因此可以先对表进行划分，而后对两个表调用同样的排序操作。因此可以递归地调用快速排序算法进行排序，具体的程序结构如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span> <span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> l</span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(low&lt;high)</span></span>&#123;<span class="comment">//递归跳出的条件</span></span><br><span class="line">  <span class="comment">//Partition()就是划分操作，将表A[low…high]划分为满足上述条件的两个子表</span></span><br><span class="line">    <span class="keyword">int</span> pivotpos-Partition (A,low, high);<span class="comment">//划分</span></span><br><span class="line">    QuickSort (A, low, pivotpos<span class="number">-1</span>);<span class="comment">//依次对两个子表进行递归排序</span></span><br><span class="line">    Quicksort (A, pivotpos+<span class="number">1</span>, high);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码不难看出快速排序算法的关键在于划分操作，同时快速排序算法的性能也主要取决于划分操作的好坏。从快速排序算法提出至今，巴有叶多个P的刘万你1I以队半丰中第一个查的快速排序的划分操作基本以严蔚敏的教材《数据结构》为土。假仅母队芯以表衣动元素作为枢轴来对表进行划分，则将表中比枢轴大的元素向右移动,将比枢轴小的元素向左移动,使得一趟Partition ()操作后，表中的元素被枢轴值一分为二。代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span> <span class="params">(ElemType A[], <span class="keyword">int</span> low,<span class="keyword">int</span> high)</span><span class="params">(<span class="comment">//一趟划分</span></span></span></span><br><span class="line"><span class="function"><span class="params">ElemType pivot=A[low];<span class="comment">//将当前表中第一个元素设为枢轴,对表进行划分</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">while</span>(low&lt;high)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">//循环跳出条件</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">while</span>( low&lt;high&amp; &amp;A [high] &gt;=pivot) --high;</span></span></span><br><span class="line"><span class="function"><span class="params">    A[low]=A [high];<span class="comment">//将比枢轴小的元素移动到左端</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;=pivot) ++low;</span></span></span><br><span class="line"><span class="function"><span class="params">    A[high] =A[low];<span class="comment">//将比枢轴大的元素移动到右端</span></span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  A[low]=pivot;<span class="comment">//枢轴元素存放到最终位置</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> <span class="number">1</span>ow;<span class="comment">//返回存放枢轴的最终位置</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>快速排序算法的性能分析如下:</p>
<p>空间效率:由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量应与递归调用的最大深度一致。$\color{green}{\text{最好情况}}$下为$O(log_2n)$;$\color{green}{\text{最坏情况}}$下，因为要进行$n—1$次递归调用，所以栈的深度为O(n);平均情况下，栈的深度为$O(log_2n)$。</p>
<p>时间效率:快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含$n-1$个元素和0个元素时，这种最大限度的不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为$O(n^2)$。</p>
<blockquote>
<p>Q：为什么有序不是$O(0)$,不会发生交换啊，虽然这时候比较的次数是$O(n^2)$:第一个工作栈第一个while执行了n次，第二个while不执行，第一个工作栈第一个while执行了n-1次，第二个while不执行….<br>A：每次递归栈都是n次比较，但是枢纽越中心，递归栈越短，总的比较次数越小<br><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/65223594.html">参考文献</a></p>
</blockquote>
<p>有很多方法可以提高算法的效率:-一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素;或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。</p>
<p>在最理想的状态下，即 Partition ()可能做到最平衡的划分，得到的两个子问题的大小都不可能大于n/2,在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为$O(nlog_2n)$。好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。<strong>快速排序是所有内部排序算法中平均性能最优的排序算法</strong>。</p>
<blockquote>
<p>快排最优</p>
</blockquote>
<p>稳定性:在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录则在交到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方法。{3,2,2}，经过一趟排序后L={2,2,3}，最终排序序列也是L={2,2,3}，显然，2与2的相对次序已发生了变化。</p>
<blockquote>
<p>注意:在快速排序算法中，并不产生有序子序列，但每趟排序后会将枢轴（基准)元素放到其最终的位置上。</p>
</blockquote>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>p313</p>
<p>选择排序的基本思想是:每一趟（如第i趟）在后$n-i+1(i=1, 2,\cdots,n-1)$个待排序元素中选取关键字最小的元素，作为有序子序列的第$i$个元素，直到第$n-1$趟做完，待排序元素只剩下1个，就不用再选了。选择排序中的堆排序算法是历年考查的重点。</p>
<h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><details><summary>严书中关于简单选择排序的描述</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210801130427.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210801130427.png';" /></details>


<p>根据上面选择排序的思想，可以很直观地得出简单选择排序算法的思想:假设排序表为L[ 1…n]，第i趟排序即从L[ i…n ]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。</p>
<p>简单选择排序算法的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span> <span class="params">(ElemType A[] ,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//一共进行n-1趟</span></span><br><span class="line">    min=i;<span class="comment">//记录最小元素位置</span></span><br><span class="line">    <span class="keyword">for</span>(j-i+<span class="number">1</span>;j&lt;n;j++)<span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">      <span class="keyword">if</span>(A[j]&lt;A[min])min=j;<span class="comment">//更新最小元素位置</span></span><br><span class="line">    <span class="keyword">if</span>(min!=i) swap (A[i],A[min]);<span class="comment">//封装的swap()函数共移动元素3次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单选择排序算法的性能分析如下:</p>
<p>空间效率:仅使用常数个辅助单元，故空间效率为O(1)。</p>
<p>时间效率:从上述伪码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不会超过3(n-1)次，最好的情况是移动О次，此时对应的表已经有序;但元素间比较的次数与序列的初始状态无关，始终是n(n- 1)/2 次，因此时间复杂度始终是$O(n^2)$。</p>
<p>稳定性:在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同关键字元素的相对位置发生改变。例如，表L= {$\color{green}{\text{2}}$,$\color{red}{\text{2}}$,1}，经过一趟排序后L= {1,$\color{red}{\text{2}}$,$\color{green}{\text{2}}$}，最终排序序列也是L= {1,$\color{red}{\text{2}}$,$\color{green}{\text{2}}$}，显然，$\color{red}{\text{2}}$与$\color{green}{\text{2}}$的相对次序已发生变化。因此，简单选择排序是一种不稳定的排序方法。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>Q：堆和平衡二叉树的区别<br>A：堆只保证父子(两层)之间的大小关系，而平衡二叉树需要保证所有层间的大小关系，而且大顶堆一定不是平衡二叉树</p>
</blockquote>
<p>堆的定义如下，n个关键字序列L[ 1…n]称为堆，当且仅当该序列满足:</p>
<p>${\textstyle\unicode{x2460}}$  L(i) &gt;=L(2i)且L(i) &gt;=L (2i+1)或</p>
<p>${\textstyle\unicode{x2461}}$ L(i)&lt;=L(2i)且L(i)&lt;=L(2i+1)（$1\leq i \leq \lfloor n/2 \rfloor$)</p>
<p>可以将该一维数组视为一棵完全二叉树，满足条件①的堆称为大根堆（大顶堆)，大根堆的最大元素存放在根结点，且其任一非根结点的值小于等于其双亲结点值。满足条件②的堆称为小根堆（小顶堆)，小根堆的定义刚好相反，根结点是最小元素。图8.4所示为一个大根堆。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702153240.png"></p>
<p>堆排序的思路很简单:首先将存放在L[ 1…n ]中的n个元素建成初始堆,由于堆本身的特点(以大顶堆为例)，堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见堆排序需要解决$\color{green}{\text{两个问题}}$:</p>
<blockquote>
<p>①如何将无序序列构造成初始堆?<br>②输出堆顶元素后，如何将剩余元素调整成新的堆?</p>
</blockquote>
<p>堆排序的关键是构造初始堆。n 个结点的完全二叉树，最后一个结点是第$\lfloor n/2 \rfloor$个结点的孩子。对第$\lfloor n/2 \rfloor$个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换)，使该子树成为堆。之后向前依次对各结点$(\lfloor n/2 \rfloor -1\backsim 1)$为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。</p>
<p>如图8.5所示，初始时调整L(4)子树，09&lt; 32，交换，交换后满足堆的定义;向前继续调整L(3)子树，78&lt;左右孩子的较大者87，交换，交换后满足堆的定义;向前调整L(2)子树，17&lt;左右孩子的较大者45，交换后满足堆的定义;向前调整至根结点L(1)，53&lt;左右孩子的较大者87，交换，交换后破坏了L(3)子树的堆，采用上述方法对L(3)进行调整，53&lt;左右孩子的较大者78，交换，至此该完全二叉树满足堆的定义。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702153844.png"></p>
<p>输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，此时堆的性质被破坏，需要向下进行筛选。将09和左右孩子的较大者78交换，交换后破坏了L(3)子树的堆，继续对L(3)子树向下筛选，将09和左右孩子的较大者65交换，交换后得到了新堆，调整过程如图8.6所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702154033.png"></p>
<p>下面是建立大根堆的算法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span> <span class="params">(ElemType A[] ,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--) <span class="comment">//从 i-[n/2]～1,反复调整堆</span></span><br><span class="line">    HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span> <span class="params">(ElemType A[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="comment">//函数HeadAdjust将元素k为根的子树进行调整</span></span><br><span class="line">  A[<span class="number">0</span>]=A[k]; <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123; <span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;len&amp; &amp;A[i]&lt;A[i+<span class="number">1</span>])</span><br><span class="line">      i++;<span class="comment">//取key 较大的子结点的下标</span></span><br><span class="line">    <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i]) <span class="keyword">break</span>;<span class="comment">//筛选结束</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      A[k]=A[i];<span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">      k=i;<span class="comment">//修改k值,以便继续向下筛选</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  A[k]=A[<span class="number">0</span>];<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整的时间与树高有关，为O(h)。在建含n个元素的堆时，关键字的比较总次数不超过4n，时间复杂度为O(n)，这说明可以在线性时间内将一个无序数组建成一个堆。</p>
<blockquote>
<p>关键字比较次数的推导，$\color{red}{\text{Q}}$：为什么是4n，还是没搞明白</p>
</blockquote>
<details><summary>严书关键字比较次数的推导</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210728162114.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210728162114.png';" /></details>

<details><summary>严书堆排序的算法</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210728162229.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210728162229.png';" /></details>

<details><summary>代码详情:严书堆排序的算法</summary>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<blockquote>
<p>通过对堆排序的基本了解，首先发现堆排序有两个过程刚开始得到一个待排序序列时候的$\color{green}{\text{建堆}}$和输出了一个元素之后的$\color{green}{\text{堆重建}}$  </p>
</blockquote>
<blockquote>
<p>这两个步骤，都有一个$\color{green}{\text{共同的步骤}}$，「需要为$\color{red}{\text{工作指针}}$指向的元素的找到正确位置」 ，我们把这步叫做$\color{yellow}{\text{调整元素}}$</p>
</blockquote>
<blockquote>
<p>这个共同步骤的核心是按照大根堆还是小根堆(热知识：想得到一个升序序列那么使用大根堆，降序用小根堆)的需求，将$\color{red}{\text{工作指针}}$指向的元素“$\color{green}{\text{不断}}$向下层调整”,直到满足堆的定义  </p>
</blockquote>
<blockquote>
<p>$\color{green}{\text{建堆}}$的关键:$\color{red}{\text{工作指针}}$从$\lfloor n/2 \rfloor$开始不断往前$\color{yellow}{\text{调整元素}}$   </p>
</blockquote>
<blockquote>
<p>$\color{green}{\text{堆重建}}$的关键:将对堆顶元素输出（就是和最后一个元素交换），之后对堆顶元素进行$\color{yellow}{\text{调整元素}}$   </p>
</blockquote>
<p>下面是堆排序算法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 王道</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span> <span class="params">(ElemType A[] ,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  BuildMaxHeap (A,len);<span class="comment">//初始建堆</span></span><br><span class="line">  <span class="keyword">for</span>(i=len;i&gt;<span class="number">1</span>;i--)&#123;<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">    Swap (A[i],A[<span class="number">1</span>]);<span class="comment">//输出堆顶元素（和堆底元素交换)</span></span><br><span class="line">    HeadAdjust(A, <span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//调整，把剩余的i-1个元素整理成堆</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，堆也支持插入操作。对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作。大根堆的插入操作示例如图8.7所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702154957.png"></p>
<blockquote>
<p>堆排序适合关键字较多的情况。例如，在1亿个数中选出前100个最大值?首先使用一个大小为100的数组，读入前100个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数即为所求。</p>
</blockquote>
<p>堆排序算法的性能分析如下:</p>
<p>空间效率:仅使用了常数个辅助单元，所以空间复杂度为O(1)。</p>
<p>时间效率:建堆时间为O(n)，之后有n-1次向下调整操作，每次调整的时间复杂度为O(h),故在最好、最坏和平均情况下，堆排序的时间复杂度为$O(nlog_2n)$。</p>
<p>稳定性:进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序方法。例如,表L={1,$\color{green}{\text{2}}$,$\color{red}{\text{2}}$}，构造初始堆时可能将$\color{green}{\text{2}}$交换到堆顶，此时L={$\color{green}{\text{2}}$,1,$\color{red}{\text{2}}$}，最终排序序列为L={1,$\color{red}{\text{2}}$,$\color{green}{\text{2}}$}，显然，$\color{red}{\text{2}}$与$\color{green}{\text{2}}$的相对次序已发生变化。</p>
<h3 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><details><summary>严书中归并排序的代码pp.296</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210801140439.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210801140439.png';" /></details>

<p>归并排序与上述基于交换、选择等排序的思想不一样，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假定待排序表含有$n$个记录，则可将其视为$n$个有序的子表，每个子表的长度为1，然后两两归并，得到$\lceil n/2 \rceil$个长度为2或1的有序表;继续两两归并……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2路归并排序。</p>
<p>图8.8所示为2路归并排序的一个例子，经过三趟归并后合并成了有序序列。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702155517.png"></p>
<p>Merge()的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表A[ low..mid ]、A[ mid+1…high ]存放在同一顺序表中的相邻位置，先将它们复制到辅助数组B中。每次从对应B中的两个段取出一个记录进行关键字的比较，将较小者放入A中，当数组B中有一段的下标超出其对应的表长(即该段的所有元素都已复制到A中）时，将另一段中的剩余部分直接复制到A中。算法如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ElemType *B=(Elemype *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="keyword">sizeof</span> (ElemType));<span class="comment">//辅助数组B</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span> <span class="params">(ElemtType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="comment">//表A的两段A[low..mid]和A[mid+1..high]各自有序,将它们合并成一个有序表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k=low;k&lt;=high;k++)</span><br><span class="line">    B[k]=A[k];<span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">  <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high; k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(B[i]&lt;=B[j)<span class="comment">//比较B的左右两段中的元素</span></span><br><span class="line">      A[k]=B[i++];<span class="comment">//将较小值复制到A中</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      A[k]=B[j++];</span><br><span class="line">  &#125;<span class="comment">//for</span></span><br><span class="line">  <span class="keyword">while</span> (i&lt;=mid) A[k++]=B[i++];<span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">  <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];<span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:上面的代码中，最后两个while循环只有一个会执行。</p>
</blockquote>
<p>一趟归并排序的操作是，调用$\lceil n/2h \rceil$次算法merge ()，将L[ 1…n]中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为2h的有序段，整个归并排序需要进行$log_2n$趟。</p>
<p>递归形式的2路归并排序算法是基于分治的,其过程如下。</p>
<p>分解:将含有n个元素的待排序表分成各含n/2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span> <span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">  <span class="keyword">int</span> mid=(low+high) /<span class="number">2</span>;<span class="comment">//从中间划分两个子序列</span></span><br><span class="line">  MergeSort (A,low, mid);<span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">  MergeSort (A, mid+l,high);<span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">  Merge (A, low,mid,high);<span class="comment">//归并</span></span><br><span class="line">  &#125;<span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2路归并排序算法的性能分析如下:</p>
<p>空间效率:Merge ()操作中，辅助空间刚好为n个单元，所以算法的空间复杂度为O(n)。时间效率:每趟归并的时间复杂度为O(n)，共需进行$\lceil log_2n \rceil$趟归并，所以算法的时间复杂度为$O(nlog_2n)$。</p>
<blockquote>
<p>为什么每趟归并的时间复杂度是$O(n)$</p>
</blockquote>
<p>稳定性:由于 Merge ()操作不会改变相同关键字记录的相对次序，所以2路归并排序算法是一种稳定的排序方法。</p>
<p>注意:一般而言，对于$N$个元素进行$k$路归并排序时，排序的趟数m满足$k^m=N$，从而$m =log_kN$，又考虑到$m$为整数，所以$m =\lceil log_k N \rceil$。这和前面的2路归并是一致的。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><details><summary>严书中基数排序的数据结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210801140717.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210801140717.png';" /></details>

<details><summary>严书中基数排序的代码</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210801140644.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210801140644.png';" /></details>

<p>基数排序是一种很特别的排序方法，它不基于比较和移动进行排序，而基于关键字各位的大小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p>
<p>假设长度为$n$的线性表中每个结点$a_j$的关键字由$d$元组$(k_j^{d-1} , k_j^{d-2} ,\cdots ,k_j^{1},k_j^{0}$组成,满足$0 \leq k_j^i \leq r-1(0\leq j &lt; n, 0 \leq i \leq d-1)$。其中$k_j^{d-1}$为最主位关键字，$k_j^0$为最次位关键字</p>
<p>为实现多关键字排序，通常有两种方法:第一种是最高位优先($\color{green}{\text{MSD}}$）法，按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列。第二种是最低位优先（$\color{green}{\text{LSD}}$）法，按关键字权重递增依次进行排序，最后形成一个有序序列。</p>
<p>下面描述以r为基数的最低位优先基数排序的过程，在排序过程中，使用r个队列$Q_0，Q_1,\cdots,Q_{r-1}$。基数排序的过程如下：</p>
<p>对$i=0,1,\cdots,d-1$,一次做一次“分配”和“收集”（其实是一次稳定的排序过程）</p>
<p>分配：开始时，把$Q_0，Q_1,\cdots,Q_{r-1}$各个队列置成空队列，然后一次考察线性表中的每个节点$a_j(j=0,1,\cdots,n-1)$，若$a_j$的关键字$k_j^i=k$，就把$a_j$放进$Q_k$队列中</p>
<p>通常采用链式基数排序，假设对如下10个记录进行排序:</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702161715.png"></p>
<p>每个关键字是1000以下的正整数，基数r= 10，在排序过程中需要借助10个链队列，每个关键字由3位子关键字构成$K^1K^2K^3$，分别代表百位、十位和个位，一共需要进行三趟“分配”和“收集”操作。第一趟分配用最低位子关键字$K^3$进行，将所有最低位子关键字（个位)相等的记录分配到同一个队列，如图 8.9(a)所示，然后进行收集操作，第一趟收集后的结果如图8.9(b)所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702161813.png"></p>
<p>第二趟分配用次低位子关键字$K^2$进行，将所有次低位子关键字(十位）相等的记录分配到同一个队列，如图8.10(a)所示，第二趟收集后的结果如图8.10(b)所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702161837.png"></p>
<p>第三趟分配用最高位子关键字$K^1$进行，将所有最高位子关键字（百位）相等的记录分配到同一个队列，如图8.11(a)所示，第三趟收集后的结果如图8.11(b)所示，至此整个排序结束</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702161858.png"></p>
<p>基数排序算法的性能分析如下。<br>空间效率:一趟排序需要的辅助存储空间为r(r个队列:r个队头指针和r个队尾指针)，但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为O(r)。</p>
<p>时间效率:基数排序需要进行d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)，所以基数排序的时间复杂度为O(d(n +r))，它与序列的初始状态无关。</p>
<p>稳定性:对于基数排序算法而言，很重要一点就是按位排序时必须是稳定的。因此.这也保证了基数排序的稳定性。</p>
<h3 id="各种内部排序算法的比较及应用"><a href="#各种内部排序算法的比较及应用" class="headerlink" title="各种内部排序算法的比较及应用"></a>各种内部排序算法的比较及应用</h3><h4 id="内部排序算法的比较"><a href="#内部排序算法的比较" class="headerlink" title="内部排序算法的比较"></a>内部排序算法的比较</h4><p>前面讨论的排序算法很多，对各算法的比较是考研中必考的内容。一般基于三个因素进行对比:时空复杂度、算法的稳定性、算法的过程特征。</p>
<p>从时间复杂度看:简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为$O(n^2)$,且实现过程也较简单,但直接插入排序和冒泡排序最好情况下的时间复杂度可以达到O(n)，而简单选择排序则与序列的初始状态无关。希尔排序作为插入排序的拓展，对较大规模的排序都可以达到很高的效率，但目前未得出其精确的渐近时间。堆排序利用了一种称为堆的数据结构，可在线性时间内完成建堆，且在$O(nlog_2n)$内完成排序过程。快速排序基于分治的思想，虽然最坏的情况下快速排序时间会达到$O(n^2)$，但快速排序平均性能可以达到$O(nlog_2n)$与初始序列的排列无关，优于其他排序算法。归并排序同样基于分治的思想，但由于其分割子序列与初始序列的排序无关，因此它的最好、最坏和平均时间复杂度均为$O(nlog_2n)$。</p>
<p>从空间复杂度看:简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需要常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况下大小位$O(log_2n)$，当然在最坏情况下可能会增长到$O(n)$。2路归并排序在合并操作中需要借助较多的空间用于元素复制，大小为$O(n)$，虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。</p>
<p>从稳定性看:插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。对于排序方法的稳定性，读者应能从算法本身的原理上去理解，而不应拘泥于死记硬背。</p>
<p>从过程特征看:采用不同的排序算法，在一次循环或几次循环后的排序结果可能是不同的，考研题中经常出现给出一个待排序的初始序列和已经部分排序的序列，问其采用何种排序算法。这就要对各类排序算法的过程特征十分熟悉，如冒泡排序和堆排序在每趟处理后都能产生当前的最大值或最小值，而快速排序一趟处理就能确定一个元素的最终位置等。</p>
<p>表8.1列出了各种排序算法的时空复杂度和稳定性情况，其中空间复杂度仅列举了平均情况的复杂度，由于希尔排序的时间复杂度依赖于增量函数，所以无法准确给出其时间复杂度。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702162505.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jj1106/p/11106101.html">数组排序的方式</a>：</p>
<table>
<thead>
<tr>
<th>排序方式</th>
<th>时间复杂度(最好/平均/最坏)</th>
<th>空间复杂度(最好/平均/最坏)</th>
<th>稳定性</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">直接插入排序</a></td>
<td>$O(n)$/$O(n^2)$/$O(n^2)$</td>
<td>$O(1)$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
</tr>
<tr>
<td><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></td>
<td>$O(nlogn), O(n^{1.3})$/None/$O(n^2)$</td>
<td>$O(1)$</td>
<td>$\color{red}{\times}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{red}{\times}$</td>
</tr>
<tr>
<td><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></td>
<td>$O(n)$/$O(n^2)$/$O(n^2)$</td>
<td>$O(1)$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
</tr>
<tr>
<td><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></td>
<td>$O(nlogn)$/$O(nlogn)$/$O(n^2)$</td>
<td>$O(logn) \backsim O(n)$</td>
<td>$\color{red}{\times}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{red}{\times}$</td>
</tr>
<tr>
<td><a href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">简单选择选择排序</a></td>
<td>$O(n^2)$/$O(n^2)$/$O(n^2)$</td>
<td>$O(1)$</td>
<td>$\color{red}{\times}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
</tr>
<tr>
<td><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></td>
<td>$O(nlogn)$/$O(nlogn)$/$O(nlogn)$</td>
<td>$O(1)$</td>
<td>$\color{red}{\times}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{red}{\times}$</td>
</tr>
<tr>
<td><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></td>
<td>$O(nlogn)$/$O(nlogn)$/$O(nlogn)$</td>
<td>$O(n)$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
</tr>
<tr>
<td><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></td>
<td>$O(d(n+r))$/$O(d(n+r))$/$O(d(n+r))$</td>
<td>$O(r)$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
</tr>
</tbody></table>
<ul>
<li>关于为什么$\color{green}{\text{直接插入排序}}$可以用于$\color{green}{\text{链表}}$,直接插入排序将遍历有序表的插入位置变成指针的移动实现和<code>for i</code>一样的操作</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/a-cat/p/13152956.html">可视化参考文献</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiayinggudeng/article/details/105991738">三种方法解决链表排序问题</a></p>
<h4 id="内部排序算法的应用"><a href="#内部排序算法的应用" class="headerlink" title="内部排序算法的应用"></a>内部排序算法的应用</h4><p>通常情况，对排序算法的比较和应用应考虑以下情况。</p>
<p>1）选取排序方法需要考虑的因素</p>
<p>${\textstyle\unicode{x2460}}$  待排序的元素数目n。</p>
<p>${\textstyle\unicode{x2461}}$元素本身信息量的大小。</p>
<p>${\textstyle\unicode{x2462}}$ 关键字的结构及其分布情况。</p>
<p>${\textstyle\unicode{x2463}}$ 稳定性的要求。</p>
<p>${\textstyle\unicode{x2464}}$ 语言工具的条件,存储结构及辅助空间的大小等。</p>
<p>2）排序算法小结</p>
<p>${\textstyle\unicode{x2460}}$  若n较小，可采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，因而当记录本身信息量较大时，用简单选择排序较好。</p>
<p>②若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。</p>
<p>③若n较大，则应采用时间复杂度为$O(nlog_2n)$的排序方法:快速排序、堆排序或归并排序。快速排序被认为是目前基于比较的内部排序方法中最好的方法，当待排序的关键字随机分布时，快速排序的平均时间最短。堆排序所需的辅助全间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。若要求排序稳定且时间复杂度为$O(nlog_2n)$，则可选用归并排序。但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用，利用直接插入排序求得较长的有序子文件，然后两两归并。直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。</p>
<p>④在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，因此可以用一棵二叉树来描述比较判定过程，由此可以证明:当文件的n个关键字随机分布时，任何借助于“比较”的排序算法，至少需要$O(nlog_2n)$的时间。</p>
<p>⑤若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。</p>
<p>⑥当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。</p>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><p>外部排序可能会考查相关概念、方法和排序过程，外部排序的算法比较复杂,不会在算法去设计上进行考查。本节的主要内容有:</p>
<p>${\textstyle\unicode{x2460}}$ 外部排序指待排序文件较大，内存一次放不下，需存放在外存的文件的排序</p>
<p>②为减少平衡归并中外存读写次数所采取的方法:增大归并路数和减少归并段个数。</p>
<p>③利用败者树增大归并路数。</p>
<p>④利用置换-选择排序增大归并段长度来减少归并段个数。</p>
<p>${\textstyle\unicode{x2464}}$  由长度不等的归并段，进行多路平衡归并，需要构造最佳归并树。</p>
<h4 id="外部排序的基本概念"><a href="#外部排序的基本概念" class="headerlink" title="外部排序的基本概念"></a>外部排序的基本概念</h4><p>前面介绍过的排序方法都是在内存中进行的（称为内部排序)。而在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多、信息量庞大，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为外部排序。</p>
<h4 id="外部排序的方法"><a href="#外部排序的方法" class="headerlink" title="外部排序的方法"></a>外部排序的方法</h4><p>文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读写的。因为磁盘读/写的机械动作所需的时间远远超过内存运算的时间（相比而言可以忽略不计)，因此在外部排序过程中的时间代价主要考虑访问磁盘的次数，即I/O次数。</p>
<p>外部排序通常采用归并排序法。它包括两个相对独立的阶段:①根据内存缓冲区大小，将外存上的文件分成若干长度为$\ell$的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件为归并段或顺串;②对这些归并段进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。</p>
<p>例如，一个含有2000个记录的文件，每个磁盘块可容纳125个记录，首先通过8次内部排序得到8个初始归并段R1~R8，每个段都含250个记录。然后对该文件做如图8.7所示的两两归并，直至得到一个有序文件。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702163859.png"></p>
<p>把内存工作区等分为3个缓冲区，如图8.6所示，其中的两个为输入缓冲区，一个为输出缓冲区。首先，从两个输入归并段R1和R2中分别读入一个块，放在输入缓冲区1和输入缓冲区2中。然后，在内存中进行2路归并，归并后的对象顺序存放在输出缓冲区中。若输出缓冲区中对象存满，则将其顺序写到输出归并段(R1’)中，再清空输出缓冲区，继续存放归并后的对象。若某个输入缓冲区中的对象取空，则从对应的输入归并段中再读取下一块，继续参加归并。如此继续，直到两个输入归并段中的对象全部读入内存并都归并完成为止。当R1和R2归并完后，再归并R3和R4、R5和R6、最后归并R7和R8，这是一趟归并。再把上趟的结果R1’和R2’、R3’和R4’两两归并，这又是一趟归并。最后把R1”和R2”两个归并段归并，结果得到最终的有序文件，一共进行了3趟归并。</p>
<p>在外部排序中实现两两归并时，由于不可能将两个有序段及归并结果段同时存放在内存中，因此需要不停地将数据读出、写入磁盘，而这会耗费大量的时间。一般情况下:</p>
<blockquote>
<p>外部排序的总时间=内部排序所需的时间＋外存信息读写的时间＋内部归并所需的时间</p>
</blockquote>
<p>显然，外存信息读写的时间远大于内部排序和内部归并的时间，因此应着力减少I/O次数。由于外存信息的读/写是以“磁盘块”为单位的，可知每一趟归并需进行16次“读”和16次“写”,3趟归并加上内部排序时所需进行的读/写，使得总共需进行32x3＋32=128次读写。</p>
<blockquote>
<p>$\color{red}{\text{Q}}$:为什么是16次读，16次写？<br>$\color{red}{\text{A}}$:2000/125=16</p>
</blockquote>
<p>若改用4路归并排序，则只需⒉趟归并，外部排序时的总读/写次数便减至32×2 + 32 = 96。因此，增大归并路数，可减少归并趟数，进而减少总的磁盘IO次数，如图8.8所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702164017.png"></p>
<p>一般地，对r个初始归并段，做k路平衡归并，归并树可用严格k叉树（即只有度为k与度为0的结点的k叉树）来表示。第一趟可将r个初始归并段归并为$\lceil r/k \rceil$个归并段，以后每趟归并将m个归并段归并成$\lceil m/k \rceil$ 个归并段，直至最后形成一个大的归并段为止。树的高度=$\lceil log_kr \rceil$= 归并趟数$S$。可见，只要增大归并路数$k$，或减少初始归并段个数$r$，都能减少归并趟数$S$，进而减少读写磁盘的次数，达到提高外部排序速度的目的。</p>
<h4 id="多路平衡归并与败者树"><a href="#多路平衡归并与败者树" class="headerlink" title="多路平衡归并与败者树"></a>多路平衡归并与败者树</h4><p>上节讨论过，增加归并路数k能减少归并趟数S，进而减少I/O次数。然而，增加归并路数k时，内部归并的时间将增加。做内部归并时，在k个元素中选择关键字最小的记录需要比较k-1次。每趟归并n个元素需要做(n-1)(k-1)次比较，S趟归并总共需要的比较次数为</p>
<p>S(n- 1)(k- 1)=$\lceil log_k r \rceil$ (n - 1)(k - 1)=$\lceil log_k r \rceil$ (n - 1)(k - 1)/$\lceil log_2k \rceil$</p>
<p>式中，$(k-1)/log_2k$随k增长而增长，因此内部归并时间亦随k的增长而增长。这将抵消由于增大k而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并排序算法。</p>
<p>为了使内部归并不受$k$的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，可视为一棵完全二叉树。$k$个叶结点分别存放$k$个归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。</p>
<!-- 如图8.9(a)所示，b3与b4比较，b4是败者，将段号4写入父结点ls[4]。b1与b2比较，b2是败者，将段号2写入ls[3]。b3与b4的胜者b3与b0比较，b0是败者，将段号0写入 ls[2]。最后两个胜者b3与b1比较，b1是败者，将段号1写入ls[1]。而将胜者b3的段号3写入ls[0]。此时，根结点 ls[O]所指的段的关键字最小。b3中的6输出后，将下一关键字填入 b3，继续比较。·因为k路归并的败者树深度为l logzk]，因此k个记录中选择最小关键字，最多需要[ logzk l次比较。所以总的比较次数为
S(n - 1)「 log,k=「 logxrT(n- 1)l logzkT-(n- 1)[ logzrl
可见，使用败者树后，内部归并的比较次数与k无关了。因此，只要内存空间允许，增大归并路数k将有效地减少归并树的高度，从而减少IO次数，提高外部排序的速度。 -->

<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702164635.png"></p>
<blockquote>
<p>S趟归并总共需要的比较次数怎么来的<br>外部归并的时候每一次要从内存中选出最小的值，最原始的算法就是遍历内存中的所有值</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dfuw13072/article/details/102440971">构建败者树的参考文献</a></p>
<details><summary>构建败者树的过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210803212113.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210803212113.png';" /></details>

<h4 id="置换-选择排序-生成初始归并段）"><a href="#置换-选择排序-生成初始归并段）" class="headerlink" title="置换-选择排序(生成初始归并段）"></a>置换-选择排序(生成初始归并段）</h4><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702164623.png"></p>
<h4 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h4><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210702164605.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/index/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/index/">1</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/index/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/30/">30</a><a class="extend next" rel="next" href="/index/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">292</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
