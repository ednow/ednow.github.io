<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ednow">
<meta property="og:url" content="http://ednow.github.io/index/page/5/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ednow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ednow.github.io/index/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch20-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch20-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch20-面向服务的架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:58:29" itemprop="dateCreated datePublished" datetime="2021-07-19T12:58:29+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-20 17:14:19" itemprop="dateModified" datetime="2021-10-20T17:14:19+08:00">2021-10-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h2><p>Massimo Pezzini，Gartner Group说过，“当有一天，所有的应用都写成Web服务，集成也许可以变得更容易”</p>
<p>服务是一个由服务提供者提供的，用于满足使用者请求的业务单元。服务的提供者和使用者都是软件代理为了各自的利益而产生的角色。</p>
<p>在SOA中，服务的概念有了延伸，泛指系统对外提供的功能集。例如，在一个大型企业内部，可能存在进销存、人事档案和财务等多个系统，在实施SOA后，每个系统用于提供相应的服务，财务系统作为资金运作的重要环节，也向整个企业信息化系统提供财务处理的服务，那么财务系统的开放接口可以看成是一个服务。</p>
<h3 id="SOA的相关概念"><a href="#SOA的相关概念" class="headerlink" title="SOA的相关概念"></a>SOA的相关概念</h3><h4 id="SOA的定义"><a href="#SOA的定义" class="headerlink" title="SOA的定义"></a>SOA的定义</h4><p>面向服务的体系结构（Service-Oriented Architecture，SOA），从应用和原理的角度看，目前有两种业界公认的标准定义。</p>
<p>从应用的角度定义，可以认为SOA是一种应用框架，它着眼于日常的业务应用，并将它们划分为单独的业务功能和流程，即所谓的服务。SOA使用户可以构建、部署和整合这些服务，且无需依赖应用程序及其运行平台，从而提高业务流程的灵活性。这种业务灵活性可使企业加快发展速度，降低总体拥有成本，改善对及时、准确信息的访问。SOA有助于实现更多的资产重用、更轻松的管理和更快的开发与部署。</p>
<p>从软件的基本原理定义，可以认为SOA是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以一种统一和通用的方式进行交互。</p>
<p>作为软件架构师，后一种从软件原理方面的定义，对日常工作更具指导性。</p>
<h4 id="业务流程与BPEL"><a href="#业务流程与BPEL" class="headerlink" title="业务流程与BPEL"></a>业务流程与BPEL</h4><p>业务流程是指为了实现某种业务目的行为所进行的流程或一系列动作。在计算机领域，业务流程代表的是某一个问题在计算机系统内部得到解决的全部流程。</p>
<p>由于业务流程来源于现实世界，传统上是通过复杂的语言进行描述。在计算机业务系统建模中，需要用到一种特定的、简洁的语言来专门描述计算机系统的业务流程，这便促使了BPEL的诞生。</p>
<p>BPEL（Business Process Execution Language For Web Services）翻译成中文的意思是面向Web服务的业务流程执行语言，也有的文献简写成BPEL4WS，它是一种使用Web服务定义和执行业务流程的语言。使用BPEL，用户可以通过组合、编排和协调Web服务自上而下地实现面向服务的体系结构。 $\color{red}{\text{BPEL}}$ 提供了一种相对简单易懂的方法， $\color{green}{\text{可将多个Web服务组合到一个新的复合服务}}$ （称作业务流程）中。</p>
<p>BPEL目前用于整合现有的Web Services，将现有的Web Services按照要求的业务流程整理成为一个新的Web Services，在这个基础上，形成一个从外界看来和单个Service一样的Service。</p>
<h3 id="SOA的发展历史"><a href="#SOA的发展历史" class="headerlink" title="SOA的发展历史"></a>SOA的发展历史</h3><h4 id="SOA的发展历史-1"><a href="#SOA的发展历史-1" class="headerlink" title="SOA的发展历史"></a>SOA的发展历史</h4><p>SOA的概念最初由Gartner公司提出，由于当时的技术水平和市场环境尚不具备真正实施SOA的条件，因此当时SOA并未引起人们的广泛关注，SOA在当时沉寂了一段时间。伴随着因特网的浪潮，越来越多的企业将业务转移到因特网领域，带动了电子商务的蓬勃发展。为了能够将公司的业务打包成独立的、具有很强伸缩性的基于因特网的服务，人们提出了Web服务的概念，这可以说是SOA的起源。</p>
<p>Web服务开始流行以后，因特网迅速出现了大量的基于不同平台和语言开发的Web服务组件。为了能够有效地对这些为数众多的组件进行管理，人们迫切需要找到一种新的面向服务的分布式Web计算架构，该架构要能够使这些由不同组织开发的Web服务相互学习和交互，保障安全以及兼顾复用性和可管理性。由此，人们重新找回面向服务的架构，并赋予其时代的特征。需求推动技术进步，正是这种强烈的市场需求，使得SOA再次成为人们关注的焦点。回顾SOA发展历程，我们把其大致分为了三个阶段，下面将分别介绍每个阶段的重要标准和规范。</p>
<p>SOA的发展最初始于国外，其经历了如下三个阶段。</p>
<h5 id="萌芽阶段"><a href="#萌芽阶段" class="headerlink" title="萌芽阶段"></a>萌芽阶段</h5><p>这一阶段以XML技术为标志，时间大致从20世纪90年代末到21世纪初。虽然这段时期很少提到SOA，但XML的出现无疑为SOA的兴起奠定了稳固的基石。</p>
<p>XML系W3C所创建，源自流行的标准通用标记语言（Standard Generalised Markup Language，SGML），它在20世纪60年代后期就已存在。这种广泛使用的元语言，允许组织定义文档的元数据，实现企业内部和企业之间的电子数据交换。由于SGML比较复杂，实施成本很高，因此很长时间里只用于大公司之间，限制了它的推广和普及。</p>
<p>通过XML，开发人员摆脱了HTML语言的限制，可以将任何文档转换成XML格式，然后跨越因特网协议传输。借助XML转换语言（eXtensible Stylesheet Language Transformation，XSLT），接受方可以很容易地解析和抽取XML的数据。这使得企业既能够将数据以一种统一的格式描述和交换，同时又不必负担SGML那样高的成本。事实上，XML实施成本几乎和HTML一样。</p>
<p>XML是SOA的基石。XML规定了服务之间以及服务内部数据交换的格式和结构。XSD Schemas保障了消息数据的完整性和有效性，而XSLT使得不同的数据表达能通过Schema映射而互相通信。</p>
<h5 id="标准化阶段"><a href="#标准化阶段" class="headerlink" title="标准化阶段"></a>标准化阶段</h5><p>2000年以后，人们普遍认识到基于公共——专有因特网之上的电子商务具有极大的发展潜力，因此需要创建一套全新的基于因特网的开放通信框架，以满足企业对电子商务中各分立系统之间通信的要求。于是，人们提出了Web服务的概念，希望通过将企业对外服务封装为基于统一标准的Web服务，实现异构系统之间的简单交互。这一时期，出现了三个著名的Web服务标准和规范：简单对象访问协议（Simple Object Access Protocal，SOAP）、Web服务描述语言（Web Services Description Language，WSDL）及通用服务发现和集成协议（Universal Discovery Description and Integration，UDDI）。</p>
<p>这三个标准可谓Web服务三剑客，极大地推动了Web服务的普及和发展。短短几年之间，因特网上出现了大量的Web服务，越来越多的网站和公司将其对外服务或业务接口封装成Web服务，有力地推动了电子商务和因特网的发展。Web服务也是因特网Web 2.0时代的一项重要特征。</p>
<h5 id="成熟应用阶段"><a href="#成熟应用阶段" class="headerlink" title="成熟应用阶段"></a>成熟应用阶段</h5><p>从2005年开始，SOA推广和普及工作开始加速。不仅专家学者，几乎所有关心软件行业发展的人士都开始把目光投向SOA。一时间，SOA频频出现在各种技术媒体、新产品发布会和技术交流会上。</p>
<p>各大厂商也逐渐放弃成见，通过建立厂商间的协作组织共同努力制定中立的SOA标准。这一努力最重要的成果体现在三个重量级规范上：SCA/SDO/WS-Policy。SCA和SDO构成了SOA编程模型的基础，而WS-Policy建立了SOA组件之间安全交互的规范。这三个规范的发布，标志着SOA进入了实施阶段。</p>
<p>从整体架构角度看，人们已经把关注点从简单的Web服务拓展到面向服务体系架构的各个方面，包括安全、业务流程和事务处理等。</p>
<h4 id="国内SOA的发展现状与国外对比"><a href="#国内SOA的发展现状与国外对比" class="headerlink" title="国内SOA的发展现状与国外对比"></a>国内SOA的发展现状与国外对比</h4><p>在SOA概念深入普及的同时，国内也兴起了对SOA的研究和初步实践。2007年，IDC发布了《SOA中国路线图》。有观点认为，这是“国际研究机构首次基于中国IT背景，针对中国企业实施SOA路线所做的特定解读”，这也是目前关于SOA这一新兴技术在中国实施的第一份比较权威的报告。</p>
<p>报告中，重点指出了中国和美国在SOA领域的差距。</p>
<p>在美国，过去的半个多世纪，美国从主机时代、PC时代，到了现在的网络时代，积累了大量的应用系统。美国实现SOA架构的关键任务是：对已有系统中的功能进行提取和包装，形成标准的“服务”。</p>
<p>在中国，过去近30年的IT建设多为生产型系统，服务型系统普遍未开始建设，大量“服务”需要全新构造才是中国SOA的主要任务。</p>
<p>这份报告的可取之处如下。</p>
<p>（1）指出了中美IT系统所面临的根本性问题不同。现阶段，国内主要是以“构建支撑某一业务的应用系统”为主，其中伴随着一部分企业内部应用系统之间的整合。如果用前面的“三个阶段”来做以下匹配，可能更多还处于第一阶段，即使第二阶段的应用也处于起步状态。</p>
<p>（2）为国内大型集团化企业指明了如何解决系统集成和系统构建的融合性问题，基于SOA方式下的解决方案。</p>
<p>关于国内实施SOA的现状，报告用表20-1进行了阐述。</p>
<details><summary>表20-1　国内商用领域和政府领域的SOA应用</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170115.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170115.png';" /></details>

<h3 id="SOA的参考架构"><a href="#SOA的参考架构" class="headerlink" title="SOA的参考架构"></a>SOA的参考架构</h3><p>IBM的Websphere业务集成参考架构（如图20-1所示，以下称参考架构）是典型的以服务为中心的企业集成架构，接下来的讨论都将以此参考架构为背景进行。</p>
<p>以服务为中心的企业集成采用“关注点分离（Separation of Concern）”的方法规划企业集成中的各种架构元素，同时从服务视角规划每种架构元素提供的服务，以及服务如何被组合在一起完成某种类型的集成。这里架构元素提供的服务既包括狭义的服务（WSDL描述），也包括广义的服务（某种能力）。从服务为中心的视角来看，企业集成的架构按图20-1所示的方式划分为6大类。</p>
<p>（1）业务逻辑服务（Business Logic Service）：包括用于实现业务逻辑的服务和执行业务逻辑的能力，其中包括业务应用服务（Business Application Service）、业务伙伴服务（Partner Service）以及应用和信息资产（Application and Information asset）。</p>
<details><summary>图20-1　IBM WebSphere业务集成参考架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170138.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170138.png';" /></details>


<p>2）控制服务（Control Service）：包括实现人（people）、流程（process）和信息（infor-mation）集成的服务，以及执行这些集成逻辑的能力。</p>
<p>（3）连接服务（Connectivity Service）：通过提供企业服务总线提供分布在各种架构元素中服务间的连接性。</p>
<p>（4）业务创新和优化服务（Business Innovation and Optimization Service）：用于监控业务系统运行时服务的业务性能，并通过及时了解到的业务性能和变化，采取措施适应变化的市场。</p>
<p>（5）开发服务（Development Service）：贯彻整个软件开发生命周期的开发平台，从需求分析，到建模、设计、开发、测试和维护等全面的工具支持。</p>
<p>（6）IT服务管理（IT Service Management）：支持业务系统运行的各种基础设施管理能力或服务，如安全服务、目录服务、系统管理和资源虚拟化。</p>
<h4 id="连接服务——企业服务总线"><a href="#连接服务——企业服务总线" class="headerlink" title="连接服务——企业服务总线"></a>连接服务——企业服务总线</h4><p>企业服务总线（Enterprise Service Bus，ESB）是过去消息中间件的发展，采用了“总线”这样一种模式来管理和简化应用之间的集成拓扑结构，以广为接受的开放标准为基础来支持应用之间在消息、事件和服务的级别上动态地互联互通。</p>
<p>ESB的基本特征和能力包括：描述服务的元数据和服务注册管理；在服务请求者和提供者之间传递数据，以及对这些数据进行转换的能力，并支持由实践中总结出来的一些模式如同步模式、异步模式等；发现、路由、匹配和选择的能力，以支持服务之间的动态交互，解耦服务请求者和服务提供者。高级一些的能力，包括对安全的支持、服务质量保证、可管理性和负载平衡等。</p>
<p>ESB所提供的基于标准的连接服务，将应用中实现的功能或者数据资源转化为服务请求者能以标准的方式来访问的服务；当请求者来请求一个服务时，ESB中这种中介转化过程可能简单到什么也没有，也可能需要很复杂的中介服务支持，包括动态地查找、选择一个服务，消息的传递、路由和转换、协议的转换。这种中介过程，是ESB借助于服务注册管理以及问题域相关的知识（如业务方面的一些规则等）自动进行的，不需要服务请求者和提供者介入，从而实现了解耦服务请求者和提供者的技术基础，使得服务请求者不需要关心服务提供者的位置和具体实现技术，双方在保持接口不变的情况下，各自可以独立地演变。</p>
<p>所以，ESB采用总线结构模式简化了应用之间的集成拓扑，通过源自实践的模式，提供了基于标准的通用连接服务，使得服务请求者和服务提供者之间可以以松散耦合、动态的方式交互，从而在不同层次上使得SOI解决方案是一个松散耦合、灵活的架构。</p>
<p>一个典型的企业服务总线如图20-2所示。需要注意的是，ESB是一种架构模式，不能简单地等同于特定的技术或者产品，但实现ESB确实需要各种产品在运行时和工具方面的支持。IBM有很好的产品支持，运行时支持包括WebSphere ESB和WebSphere Message Broker；而工具方面IBM则有WebSphere Integration Developer，支持用户以图形界面的方式来完成相关的开发任务，如发布服务，使用各种模式、转换消息和定义路由等。</p>
<details><summary>图20-2　一个典型的企业服务总线</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170228.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170228.png';" /></details>

<h4 id="业务逻辑服务"><a href="#业务逻辑服务" class="headerlink" title="业务逻辑服务"></a>业务逻辑服务</h4><p>1）整合已有应用——应用和信息访问服务</p>
<p>已有应用和信息是实现业务逻辑和业务数据的重要资产。通过集成已有的应用和信息将可以在已有企业系统上实现更多增值服务，所以集成已有应用和信息是企业集成中重要的一环。</p>
<p>以服务为中心的企业集成通过应用和信息访问服务（Application and Information Access Service）来实现对已有应用和信息的集成。它通过各种适配器技术将已有系统中的业务逻辑和业务数据包装成企业服务总线支持的协议和数据格式。通过企业服务总线，这些被包装起来的业务逻辑和数据就可以方便地参与上层的业务流程，从而已有应用系统的能力可以得以继续发挥。这里的已有应用包括遗留应用、预包装的应用和各种企业数据存储。在参考架构中，主要有两类访问服务。</p>
<p>（1）可接入服务（On-Ramp Service）：通过各种消息通信模式（单向、请求/应答和轮询）将业务逻辑和业务数据包装成企业服务总线可以访问的功能。</p>
<p>（2）事件发现服务（Event Detect Service）：提供事件通知服务将已有应用和数据中的变化通过事件框架发布到企业服务总线上。</p>
<p>2）整合新开发的应用——业务应用服务</p>
<p>同已有应用和数据类似，新开发的应用也作为重要的业务逻辑成为企业集成的目标。以服务为中心的企业集成通过业务应用服务（Business Application Service）实现新应用集成。一方面，业务应用服务帮助程序员开发可重用、可维护和灵活的业务逻辑组件；另一方面，它也提供运行时的集成对业务逻辑组件的自治管理。在参考架构中，有三类业务应用服务。</p>
<p>（1）组件服务（Component Service）：为可重用的组件提供应用的运行时容器管理服务，如对象持久化、组件安全管理和事务管理等。</p>
<p>（2）核心服务（Core Service）：提供运行时的服务，包括内存管理、对象实例化和对象池、性能管理和负载均衡、可用性管理等。</p>
<p>（3）接口服务（Interface Service）：提供和其他企业系统集成的接口，如其他企业应用，数据库、消息系统和管理框架。</p>
<p>3）整合客户和业务伙伴（B2C/B2B ）——伙伴服务</p>
<p>以服务为中心的企业集成通过伙伴服务提供与企业外部的B2B的集成能力。因为业务伙伴系统的异构性，伙伴服务需要支持多种传输协议和数据格式。在参考架构中，提供如下服务。</p>
<p>（1）社区服务（Community Service）：用于管理和企业贸易的业务伙伴，支持以交易中心（Trade Hub）为主的集中式管理和以伙伴为中心的自我管理。</p>
<p>（2）文档服务（Document Service）：用于支持和业务伙伴交换的文档格式，以及交互的流程和状态管理，支持主流的RosettaNet、EDI和AS1/AS2等。</p>
<p>（3）协议服务（Protocol Service）：为文档的交互提供传输层的支持，包括认证和路由等。</p>
<h4 id="控制服务"><a href="#控制服务" class="headerlink" title="控制服务"></a>控制服务</h4><p>1）数据整合——信息服务</p>
<p>企业数据的分布性和异构性是应用系统方便访问企业数据和在企业数据之上提供增值服务的主要障碍。数据集成和聚合技术在这种背景下诞生，用于提供对分布式数据和异构数据的透明访问。</p>
<p>以服务为中心的企业集成通过信息服务提供集成数据的能力，目前主要包括如下集中信息服务。</p>
<p>（1）联邦服务（Federation Service）：提供将各种类型的数据聚合的能力，它既支持关系型数据，也支持像XML数据、文本数据和内容数据等非关系型数据。同时，所有的数据仍然按照自己本身的方式管理。</p>
<p>（2）复制服务（Replication Service）：提供远程数据的本地访问能力，它通过自动的实时复制和数据转换，在本地维护一个数据源的副本。本地数据和数据源在技术实现上可以是独立的。</p>
<p>（3）转换服务（Transformation Service）：用于数据源格式到目标格式的转换，可以是批量的或者是基于记录的。</p>
<p>（4）搜索服务（Search Service）：提供对企业数据的查询和检索服务，既支持数据库等结构化数据，也支持像PDF等非结构化数据。</p>
<p>2）流程整合——流程服务</p>
<p>企业部门内部的IT系统通过将业务活动自动化来提高业务活动的效率。但是这些部门的业务活动并不是独立的，而是和其他部门的活动彼此关联的。毋庸置疑，将彼此关联的业务活动组成自动化流程可以进一步提高业务活动的效率。业务流程集成正是在这一背景下诞生的。</p>
<p>以服务为中心的企业集成通过流程服务来完成业务流程集成。在业务流程集成中，粒度的业务逻辑被组合成业务流程，流程服务提供自动执行这些业务流程的能力。在参考架构中，流程服务包括如下内容。</p>
<p>（1）编排服务（Choreography Service）：通过预定义的流程逻辑控制流程中业务活动的执行，并帮助业务流程从错误中恢复。</p>
<p>（2）事务服务（Transaction Service）：用于保证流程执行中的事务特性（ACID）。对于短流程，通常采用传统的两阶段提交技术；对于长流程，一般采用补偿的方法。</p>
<p>（3）人工服务（Staff Service）：用于将人工的活动集成到流程中。一方面，它通过关联的交互服务使得人工可以参与到流程执行中；另一方面，它需要管理由于人工参与带来的管理任务，如任务分派，授权和监管等。</p>
<p>3）用户访问整合——交互服务</p>
<p>将适当的信息、在适当的时间、传递给适当的人一直是信息技术追求的目标。用户访问集成是实现这一目标的重要一环，它负责将信息系统中的信息传递给客户，不管它在哪里，以什么样的设备接入。</p>
<p>以服务为中心的企业集成，通过交互服务来实现用户访问集成。参考架构中的交互服务包括如下类型。</p>
<p>（1）交付服务（Delivery Service）：提供运行时的交互框架，它通过各种技术支持同样的交互逻辑可以在多种方式（图形界面、语音和普及计算消息）和设备（桌面、PDA和无线终端等）上运行，例如通过页面聚合和标签翻译使得同一个Portlet可以在桌面浏览器和PDA浏览器上展现。</p>
<p>（2）体验服务（Experience Service）：通过用户为中心的服务增强用户体验，其中的技术包括个性化、协作和单点登录等。</p>
<p>（3）资源服务（Resource Service）：提供运行时交互组件的管理，如安全配置、界面皮肤等。</p>
<h4 id="开发支持"><a href="#开发支持" class="headerlink" title="开发支持"></a>开发支持</h4><p>企业集成涉及面很广，不仅需要开发新的应用并使其成为可以被用于企业集成的功能组件，而且需要将被包装的已有的应用和数据用于集成；不仅有企业内部的集成，而且需要和企业外部的系统集成；不仅有交互集成和数据集成，还有功能和应用集成。考虑到这其中的每部分在技术上都会涉及到各种平台和中间件，企业集成的技术复杂性是普通应用开发不可比拟的。这种技术复杂性需要更强有力的开发工具支持。企业集成的开发工具需要有标准的工具框架，这些工具能够以即插即用方式支持来自多家厂商的开发工具。同时，企业集成的开发工具需要支持整个软件开发周期，以提高开发过程中各种角色的生产力。</p>
<p>在以服务为中心的企业集成中，除了需要支持整个软件开发周期和标准的工具框架以外，开发服务需要提供和服务开发相关的技术。</p>
<p>（1）用于支持以服务为中心的企业集成方法学和建模，如SODA和IBM的SOMA（Service Oriented Modeling and Architecture）。</p>
<p>（2）用于服务为中心的编程模型，如WSDL、BPEL4WS、SCA和SDO等。</p>
<p>开发环境和工具中为不同开发者的角色提供的功能被称为开发服务。根据开发过程中开发者角色和职责的不同，有如下4类服务。</p>
<p>（1）建模服务（Model Service）：用于构建可视化的业务流程模型。</p>
<p>（2）设计服务（Design Service）：根据业务模型，进一步分解为服务组件，设计服务用于设计和开发这些服务组件。</p>
<p>（3）实现服务（Implementation Service）：用于将设计和开发的服务组件部署到生产环境中。</p>
<p>（4）测试服务（Test Service）：支持服务组件的单元测试和系统的集成测试。</p>
<h4 id="业务创新和优化"><a href="#业务创新和优化" class="headerlink" title="业务创新和优化"></a>业务创新和优化</h4><p>一方面，以服务为中心的企业集成通过各种集成提高信息流转速度，从而提高生产效率。另一方面，以服务为中心的企业集成也为业务创新和优化提供了支持平台——业务创新和优化服务。</p>
<p>业务创新和优化服务以业务性能管理（Business Process Management，BPM）技术为核心提供业务事件发布、收集和关键业务指标监控能力。具体而言，业务创新和优化服务由以下服务组成。</p>
<p>（1）公共事件框架服务（Common Event Infrastructure Service）：通过一个公共事件框架提供IT和业务事件的激发、存储和分类等。</p>
<p>（2）采集服务（Collection Service）：通过基于策略的过滤和相关性分析检测感兴趣的服务。</p>
<p>（3）监控服务（Monitoring Service）：通过事件与监控上下文间的映射，计算和管理业务流程的关键性能指标（Key Performance Indicators，KPI）。</p>
<p>业务创新和优化服务与开发服务是紧密相联的。在建模阶段被确定的业务流程的关键性能指标，被转为特别的事件标志构建到业务流程中，建模过程中的业务流程也被转换为用于监控服务的监控上下文。在业务流程执行过程中，这些事件标志激发的事件被公共事件框架服务截获，经过采集服务的过滤被传递给监控服务用于计算关键性能指标。关键性能指标作为重要的数据被用于重构或优化业务流程，这种迭代的方法使得业务流程处于不断的优化中。</p>
<h4 id="管理支持"><a href="#管理支持" class="headerlink" title="管理支持"></a>管理支持</h4><p>为业务流程和服务提供安全、高效和健康的运行环境，也是以服务为中心的企业集成重要的部分，它由IT服务管理来完成。IT服务管理包括如下两部分。</p>
<p>（1）安全和目录服务（Security and Directory Service）：企业范围的用户、认证和授权管理，如单点登录（SSO）。</p>
<p>（2）系统管理和虚拟化服务（System Management and Virtualization Service）：用于管理服务器、存储、网络和其他IT资源。</p>
<p>IT服务管理中相当一部分服务是面向软硬件管理的；而另外一部分服务，特别是安全和目录服务，以及操作系统和中间件管理，会通过企业服务总线和其他服务集成在一起，用于实现业务流程和服务的非功能性需求，如性能、可用性和安全性等。</p>
<h3 id="SOA主要技术和标准"><a href="#SOA主要技术和标准" class="headerlink" title="SOA主要技术和标准"></a>SOA主要技术和标准</h3><p>Web服务作为实现SOA中服务的最主要手段。首先来了解跟Web Service相关的标准，它们大多以WS-作为名字的前缀，所以统称WS-*。Web服务最基本的协议包括UDDI、WSDL和SOAP，通过它们，可以提供直接而又简单的Web Service支持，如图20-3所示。</p>
<details><summary>图20-3　基本Web服务协议</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170421.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170421.png';" /></details>

<h4 id="UDDI协议"><a href="#UDDI协议" class="headerlink" title="　UDDI协议"></a>　UDDI协议</h4><p>UDDI（统一描述、发现和集成协议）计划是一个广泛的、开放的行业计划，它使得商业实体能够彼此发现；定义它们怎样在Internet上互相作用，并在一个全球的注册体系架构中共享信息。UDDI是这样一种基础的系统构筑模块，它使商业实体能够快速、方便地使用它们自身的企业应用软件来发现合适的商业对等实体，并与其实施电子化的商业贸易。</p>
<p>UDDI同时也是Web服务集成的一个体系框架，包含了服务描述与发现的标准规范。UDDI规范利用了W3C和Internet工程任务组织的很多标准作为其实现基础，如XML、HTTP和DNS等协议。另外，在跨平台的设计特性中，UDDI主要采用了已经被提议给W3C的SOAP（Simple Object Access Protocol，简单对象访问协议）规范的早期版本。</p>
<h4 id="WSDL规范"><a href="#WSDL规范" class="headerlink" title="WSDL规范"></a>WSDL规范</h4><p>WSDL（Web Services Description Language，Web服务描述语言），是一个用来描述Web服务和说明如何与Web服务通信的XML语言。它是Web服务的接口定义语言，由Ariba、Intel、IBM和MS等共同提出，通过WSDL，可描述Web服务的三个基本属性。</p>
<p>（1）服务做些什么——服务所提供的操作（方法）。</p>
<p>（2）如何访问服务——和服务交互的数据格式以及必要协议。</p>
<p>（3）服务位于何处——协议相关的地址，如URL。</p>
<p>WSDL文档以端口集合的形式来描述Web服务，WSDL服务描述包含对一组操作和消息的一个抽象定义，绑定到这些操作和消息的一个具体协议，和这个绑定的一个网络端点规范。WSDL文档被分为两种类型：服务接口（service interface）和服务实现（service implementations）。文档基本结构框架如图20-4所示。</p>
<details><summary>图20-4　文档基本结构框架</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170506.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170506.png';" /></details>

<p>服务接口文档中主要元素的作用分别如下。</p>
<p>●　types：定义了Web服务使用的所有数据类型集合，可被元素的各消息部件所引用。它使用某种类型系统（一般使用XML Schema中的类型系统）。</p>
<p>●　message：通信消息数据结构的抽象类型化定义。使用Types所定义的类型来定义整个消息的数据结构。</p>
<p>●　operation：对服务中所支持操作的抽象描述。一般单个operation描述了一个访问入口的请求/响应消息对。</p>
<p>●　portType：对于某个访问入口点类型所支持操作的抽象集合。这些操作可以由一个或多个服务访问点来支持。</p>
<p>●　binding：包含了如何将抽象接口的元素（portType）转变为具体表示的细节，具体表示也就是指特定的数据格式和协议的结合；特定端口类型的具体协议和数据格式规范的绑定。</p>
<p>●　port：定义为协议/数据格式绑定与具体Web访问地址组合的单个服务访问点。</p>
<p>●　service：这是一个粗糙命名的元素，代表端口的集合；相关服务访问点的集合。</p>
<h4 id="SOAP协议"><a href="#SOAP协议" class="headerlink" title="SOAP协议"></a>SOAP协议</h4><p>SOAP是在分散或分布式的环境中交换信息的简单的协议，是一个基于XML的协议。它包括4个部分：SOAP封装（Envelop），定义了一个描述消息中的内容是什么，是谁发送的，谁应当接收并处理它以及如何处理它们的框架；SOAP编码规则（Encoding Rules），用于表示应用程序需要使用的数据类型的实例；SOAP RPC表示（RPC Representation），表示远程过程调用和应答的协定；SOAP绑定（Binding），使用底层协议交换信息。</p>
<p>虽然这4个部分都作为SOAP的一部分，作为一个整体定义的，但它们在功能上是相交的、彼此独立的。特别地，信封和编码规则是被定义在不同的XML命名空间（Namespace）中，这样使得定义更加简单。</p>
<p>SOAP的两个主要设计目标是简单性和可扩展性，这就意味着有一些传统消息系统或分布式对象系统中的某些性质将不是SOAP规范的一部分。例如，分布式垃圾收集（Distributed Garbage Collection）、成批传送消息（Boxcarring or atching of messages）、对象引用（Objects-by-reference which requires distributed garbage collection）和对象激活（Activation which requires objects-by-reference）等。</p>
<p>但是，基本协议无法保证企业计算需要的安全性和可靠性，所以需要增加这方面的协议，例如WS-Security、WS-Reliability和WS-ReliableMessaging；对于复杂的业务场景，我们需要WS-BPEL和WS-CDL这样的语言来将多个服务编排成为业务流程；管理服务的协议如WS-Manageability、WSDM等。跟Web服务相关的标准，还在快速发展当中。目前在SOA产品和实践中，除了基本协议外，比较重要的还包括BPEL、WS-Security、WS-Policy和SCA/SDO。</p>
<h3 id="SOA的特性"><a href="#SOA的特性" class="headerlink" title="SOA的特性"></a>SOA的特性</h3><h4 id="文档标准化"><a href="#文档标准化" class="headerlink" title="文档标准化"></a>文档标准化</h4><p>SOA服务具有平台独立的自我描述XML文档。Web服务描述语言是用于描述服务的标准语言。</p>
<h4 id="通信协议标准"><a href="#通信协议标准" class="headerlink" title="通信协议标准"></a>通信协议标准</h4><p>SOA服务用消息进行通信，该消息通常使用XML Schema来定义（也叫做XSD，XML Schema Definition）。消费者和提供者、或消费者和服务之间的通信多见于不知道提供者的环境中。服务间的通信也可以看作企业内部处理的关键商业文档。</p>
<h4 id="应用程序统一登记与集成"><a href="#应用程序统一登记与集成" class="headerlink" title="应用程序统一登记与集成"></a>应用程序统一登记与集成</h4><p>在一个企业内部，SOA服务通过一个扮演目录列表（Directory Listing）角色的登记处（Registry）来进行维护。应用程序在登记处（Registry）寻找并调用某项服务。统一描述、定义和集成是服务登记的标准。</p>
<h4 id="服务品质"><a href="#服务品质" class="headerlink" title="服务品质"></a>服务品质</h4><p>每项SOA服务都有一个与之相关的服务品质（Quality of Service，QoS）。QoS的一些关键元素有安全需求（例如认证和授权）、可靠通信（译注：可靠消息是指确保消息“仅且仅仅”发送一次，从而过滤重复信息）以及谁能调用服务的策略。</p>
<p>在企业中，关键任务系统（Mission-critical System，译注：关键任务系统是指如果一个系统的可靠性对于一个组织是至关重要的，那么该系统就是该企业的关键任务系统。例如，电话系统对于一个电话促销企业来说就是关键任务系统，而文字处理系统就不那么关键了。）用来解决高级需求，例如安全性、可靠性和事务。当一个企业开始采用服务架构作为工具来进行开发和部署应用的时候，基本的Web服务规范，像WSDL、SOAP以及UDDI就不能满足这些高级需求。正如前面所提到的，这些需求也称作服务品质。与QoS相关的众多规范已经由一些标准化组织（Standards Bodies）提出，像W3C和OASIS（the Organization for the Advancement of Structured Information Standards）。下面的部分将会讨论一些QoS服务和相关标准。</p>
<h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><p>在典型的SOA环境中，服务消费者和服务提供者之间会有几种不同的文档在进行交换。具有诸如“仅且仅仅传送一次（Once-and-only-once Delivery）”、“最多传送一次（At-most-once Delivery）”、“重复消息过滤（Duplicate Message Elimination）”和“保证消息传送（Guaranteed Message Delivery）”等特性消息的发送和确认，在关键任务系统（Mission-critical Systems）中变得十分重要。WS-Reliability和WS-ReliableMessaging是两个用来解决此类问题的标准。这些标准现在都由OASIS负责。</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>Web服务安全规范用来保证消息的安全性。该规范主要包括认证交换、消息完整性和消息保密。该规范吸引人的地方在于它借助现有的安全标准，例如，SAML（as Security Assertion Markup Language）实现Web服务消息的安全。OASIS正致力于Web服务安全规范的制定。</p>
<h5 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h5><p>服务提供者有时候会要求服务消费者与某种策略通信。例如，服务提供商可能会要求消费者提供Kerberos安全标示才能取得某项服务。这些要求被定义为策略断言（Policy Assertions），一项策略可能会包含多个断言。WS-Policy用来标准化服务消费者和服务提供者之间的策略通信。</p>
<h5 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h5><p>在SOA中，进程是使用一组离散的服务创建的。BPEL4WS或者WSBPEL（Web Service Business Process Execution Language）是用来控制这些服务的语言。当企业着手于服务架构时，服务可以用来整合数据仓库（silos of data），应用程序，以及组件。整合应用意味着像异步通信，并行处理，数据转换，以及校正等进程请求必须被标准化。</p>
<h5 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h5><p>随着企业服务的增长，所使用的服务和业务进程的数量也随之增加，一个用来让系统管理员管理所有，运行在多种环境下的服务的管理系统就显得尤为重要。WSDM（Web Services for Distributed Management）的制定，使任何根据WSDM实现的服务都可以由一个WSDM适应（WSDM-compliant）的管理方案来管理。</p>
<p>其他的QoS特性，例如合作方之间的沟通和通信，多个服务之间的事务处理，都在WS-Coordination和WS-Transaction标准中描述，这些都是OASIS的工作。</p>
<h3 id="SOA的作用"><a href="#SOA的作用" class="headerlink" title="SOA的作用"></a>SOA的作用</h3><p>在一个企业内部，可能存在不同的应用系统，而这些应用系统由于开发的时间不同，采用的开发工具不同，一个业务请求很难有效地调用所有的应用系统。用简单的语言来表述，这些已有应用系统是孤立的，也就是我们常说的“信息孤岛”。</p>
<p>不同种类的操作系统，应用软件，系统软件和应用基础结构（Application Infrastructure）相互交织，这是“信息孤岛”的表现症状。一些现存的应用程序被用来处理当前的业务流程（Business Processes），因此从头建立一个新的基础环境是不可能的。企业应该能对业务的变化做出快速的反应，利用对现有的应用程序和应用基础结构的投资来解决新的业务需求，为客户、商业伙伴以及供应商提供新的互动渠道，并呈现一个可以支持有机业务（Organic Business）的构架。SOA凭借其松耦合的特性，使得企业可以按照模块化的方式来添加新服务或更新现有服务，以解决新的业务需要，提供选择从而可以通过不同的渠道提供服务，并可以把企业现有的或已有的应用作为服务，从而保护了现有的IT基础建设投资。</p>
<p>在SOA得以普及之前，解决企业内部信息系统“信息孤岛”的问题通常是采用EAI（企业应用整合）的方式。为了保证所有的应用能够互通互用，每一个应用都需要一个EAI Server来对应。打个简单的比方，EAI Server就好像一个“翻译”一样，让每两个应用之间可以对话，可以互相调用。但是，这样会带来EAI Server呈几何倍数的增长，当一个企业只有两个应用的时候需要一个“翻译”，当企业有三个应用需要互通的时候需要三个“翻译”，当有四个应用的时候就需要六个“翻译”，五个应用互通就需要十个“翻译”……这显然不是解决“信息孤岛”的妥善办法。</p>
<p>SOA对于实现企业资源共享，打破“信息孤岛”的步骤如下。</p>
<p>（1）把应用和资源转换成服务。</p>
<p>（2）把这些服务变成标准的服务，形成资源的共享。</p>
<p>从这个意义上讲，SOA不仅仅是一个技术，而是一个软件架构。企业的决策者只需要根据企业的策略来制定流程，把应用作为服务“拿来就用”，而无需考虑底层的集成。这样就可以实现IT和企业业务之间同步。</p>
<p>一个服装零售组织拥有500家国际连锁店，它们常常需要更改设计来赶上时尚的潮流。这可能意味着不仅需要更改样式和颜色，甚至还可能需要更换布料、制造商和可交付的产品。如果零售商和制造商之间的系统不兼容，那么从一个供应商到另一个供应商的更换可能就是一个非常复杂的软件流程。通过利用WSDL接口在操作方面的灵活性，每个公司都可以将它们的现有系统保持现状，而仅仅匹配WSDL接口并制订新的服务级协定，这样就不必完全重构它们的软件系统了。这是业务的水平改变，也就是说，它们改变的是合作伙伴，而所有的业务操作基本上都保持不变。这里，业务接口可以作少许改变。而内部操作却不需要改变。之所以这样做，仅仅是为了能够与外部合作伙伴一起工作。</p>
<h3 id="SOA设计原则"><a href="#SOA设计原则" class="headerlink" title="SOA设计原则"></a>SOA设计原则</h3><p>SOA架构中，继承了来自对象和组件设计的各种原则，如封装、自我包含等。那些保证服务的灵活性、松散耦合和重用能力的设计原则，对SOA架构来说同样是非常重要的。</p>
<p>结构上，服务总线是SOA的架构模式之一。</p>
<p>关于服务，一些常见和讨论的设计原则如下。</p>
<p>（1）无状态。以避免服务请求者依赖于服务提供者的状态。</p>
<p>（2）单一实例。避免功能冗余。</p>
<p>（3）明确定义的接口。服务的接口由WSDL定义，用于指明服务的公共接口与其内部专用实现之间的界线。WS-Policy用于描述服务规约，XML模式（Schema）用于定义所交换的消息格式（即服务的公共数据）。使用者依赖服务规约调用服务，所以服务定义必须长时间稳定，一旦公布，不能随意更改；服务的定义应尽可能明确，减少使用者的不适当使用；不要让使用者看到服务内部的私有数据。</p>
<p>（4）自包含和模块化。服务封装了那些在业务上稳定、重复出现的活动和组件，实现服务的功能实体是完全独立自主的，独立进行部署、版本控制、自我管理和恢复。</p>
<p>（5）粗粒度。服务数量不应该太大，依靠消息交互而不是远程过程调用（RPC），通常消息量比较大，但是服务之间的交互频度较低。</p>
<p>（6）服务之间的松耦合性。服务使用者看到的是服务的接口，其位置、实现技术和当前状态等对使用者是不可见的，服务私有数据对服务使用者是不可见的。</p>
<p>（7）重用能力。服务应该是可以重用的。</p>
<p>（8）互操作性、兼容和策略声明。为了确保服务规约的全面和明确，策略成为一个越来越重要的方面。这可以是技术相关的内容，例如一个服务对安全性方面的要求；也可以是跟业务有关的语义方面的内容，例如需要满足的费用或者服务级别方面的要求，这些策略对于服务在交互时是非常重要的。WS-Policy用于定义可配置的互操作语义，来描述特定服务的期望、控制其行为。在设计时，应该利用策略声明确保服务期望和语义兼容性方面的完整和明确。</p>
<h3 id="SOA的设计模式"><a href="#SOA的设计模式" class="headerlink" title="SOA的设计模式"></a>SOA的设计模式</h3><h4 id="服务注册表模式"><a href="#服务注册表模式" class="headerlink" title="服务注册表模式"></a>服务注册表模式</h4><p>服务注册表（Service Registry）主要在SOA设计时段使用，虽然它们常常也具有运行时段的功能。注册表支持驱动SOA治理的服务合同、策略和元数据的开发、发布和管理。因此，它们提供一个主控制点，或者称为策略执行点（Policy Enforcement Point，PEP）。在这个点上，服务可以在SOA中注册和被发现。</p>
<p>注册表可以包括有关服务和相关软件组件的配置、遵从性和约束配置文件。任何帮助注册、发现和检索服务合同、元数据和策略的信息库、数据库、目录或其他节点都可以被认为是一个注册表。</p>
<p>主要的服务注册厂商分为两个阵营。一个阵营是提供服务、策略和元数据注册表及信息库的纯SOA厂商，其中包括Flashline、Infravio、LogicLibrary、SOA Software和Systinet（Mercury Interactive下属分公司）；另一个阵营是SOA平台厂商，这些厂商将注册表作为集成产品套件的一个组件，他们的集成产品套件常常包括应用服务器、门户、数据库管理系统、BI工具、集成中间件和其他功能组件。提供注册表的SOA平台厂商包括BEA、IBM、Microsoft、Novell、Oracle、SAP、Sun和WebMethods。UDDI（通用描述、发现与集成）标准定义了SOA的一种主要注册环境，尽管这绝非唯一的环境。</p>
<p>大多数纯SOA厂商和SOA平台厂商还提供SOA开发、集成和管理工具。没有自已注册表的SOA厂商，常常通过UDDI v3和其他开放标准与一个或多个第三方注册表产品进行集成。大多数商用服务注册产品支持下面的SOA治理功能。</p>
<p>（1）服务注册：应用开发者，也叫服务提供者，向注册表公布他们的功能。他们公布服务合同，包括服务身份、位置、方法、绑定、配置、方案和策略等描述性属性。实现SOA治理最有效的方法之一，是限制哪类新服务可以向主注册表发布、由谁发布以及谁批准和根据什么条件批准。此外，许多注册表包含开发向注册表发布服务可能需要的说明性服务模板。</p>
<p>（2）服务位置：也就是服务应用开发者，帮助他们查询注册服务，寻找符合自身要求的服务。注册表让服务的消费者检索服务合同。对谁可以访问注册表，以及什么服务属性通过注册表暴露的控制，是另一些有效的SOA治理手段，注册表产品一般都支持此类功能。</p>
<p>（3）服务绑定：服务的消费者利用检索到的服务合同来开发代码，开发的代码将与注册的服务绑定、调用注册的服务以及与它们实现互动。开发者常常利用集成的开发环境自动将新开发的服务与不同的新协议、方案和程序间通信所需的其他接口绑在一起。工具驱动对服务绑定的控制，有效地管理服务在ESB上的互动。</p>
<p>设计时段，SOA治理中新出现的最佳实践之一是注册表中的配置文件（Profile）管理。配置文件用于说明服务目前的生命周期阶段和该阶段的相关策略。Fiorano公司的CTO Atul Saini是这样描述服务配置是如何在开发时段发挥作用的：“有人可能想在某台使用某个输入参数集合的机器上运行一项服务。机器名和参数成为与服务连接在一起的开发配置文件的一部分，一旦服务被开发，它可以被升级到质量保证阶段，运行在使用不同参数的不同机器上。第二台机器/参数集合构成一个新配置文件。这样，可以为某个服务创建多个配置文件，只需在任意时间将不同的配置文件与服务建立联系，这个服务就可以在其生命周期中的不同阶段之间移动。”</p>
<p>配置文件管理常常假设开发部门拥有一个将服务升级到下一阶段的结构化流程。一些SOA开发工具包含嵌入式工作流环境，帮助企业满足这方面的设计时段治理需要。LogicLibrary公司CTO、合作创始人Brent Carlson说：“公司的Logidex工具帮助开发部门将检查点、角色和多步骤工作流配置到SOA开发流程之中。”</p>
<p>他说：“您可以自动执行将服务提升到下一阶段所涉及的审查和验证，如果发现定义不一致，在服务向注册表发布之前，可将它退回开发者加以改正。”</p>
<h4 id="企业服务总线模式"><a href="#企业服务总线模式" class="headerlink" title="企业服务总线模式"></a>企业服务总线模式</h4><p>在企业基于SOA实施EAI、B2B和BMP的过程中，如果采用点对点的集成方式存在着复杂度高，可管理性差，复用度差和系统脆弱等问题。企业服务总线（Enterprise Service Bus，ESB）技术在这种背景下产生，其思想是提供一种标准的软件底层架构，各种程序组件能够以服务单元的方式“插入”到该平台上运行，并且组件之间能够以标准的消息通信方式来进行交互。它的定义通常如下：企业服务总线是由中间件技术实现的支持面向服务架构的基础软件平合，支持异构环境中的服务以基于消息和事件驱动模式的交互，并且具有适当的服务质量和可管理性。</p>
<p>如图20-5所示，ESB本质上是以中间件形式支持服务单元之间进行交互的软件平台。各种程序组件以标准的方式连接在该“总线”上，并且组件之间能够以格式统一的消息通信的方式来进行交互。一个典型的在ESB环境中组件之间的交互过程是：首先由服务请求者触发一次交互过程，产生一个服务请求消息，并将该消息按照ESB的要求标准化，然后标准化的消息被发送给服务总线。ESB根据请求消息中的服务名或者接口名进行目的组件查找，将消息转发至目的组件，并最终将处理结果逆向返回给服务请求者。这种交互过程不再是点对点的直接交互模式，而是由事件驱动的消息交互模式。通过这种方式，ESB最大限度上解耦了组件之间的依赖关系，降低了软件系统互连的复杂性。连接在总线上的组件无需了解其他组件和应用系统的位置及交互协议，只需要向服务总线发出请求，消息即可获得所需服务。服务总线事实上实现了组件和应用系统的位置透明和协议透明。技术人员可以通过开发符合ESB标准的组件（适配器）将外部应用连接至服务总线，实现与其他系统的互操作。同时，ESB以中间件的方式，提供服务容错、负载均衡、QoS保障和可管理功能。</p>
<details><summary>图20-5　ESB示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170839.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170839.png';" /></details>


<p>（1）提供位置透明性的 $\color{green}{\text{消息路由}}$ 和 $\color{green}{\text{寻址服务}}$ 。</p>
<p>（2）提供服务 $\color{green}{\text{注册}}$ 和 $\color{green}{\text{命名}}$ 的管理功能。</p>
<p>（3）支持多种消息传递 $\color{green}{\text{范型}}$ （如请求/响应、发布/订阅等）。</p>
<p>（4）支持多种可以广泛使用的 $\color{green}{\text{传输协议}}$ 。</p>
<p>（5）支持多种数据格式及其 $\color{green}{\text{相互转换}}$ 。</p>
<p>（6）提供 $\color{green}{\text{日志}}$ 和 $\color{green}{\text{监控}}$ 功能。</p>
<p>由于采用了基于标准的互连技术，ESB使得企业内部以及外部系统之间可以很容易地进行异步或同步交互。它采用的面向服务的架构为系统提供了易扩展性和灵活性，在提高集成应用的开发效率的同时降低了成本。ESB技术克服了传统应用集成技术的缺陷，能够对各种技术和应用系统提供支持，具有很强的灵活性和可扩展性，可以说是目前理想的EAI、B2B应用系统集成支撑平台。</p>
<p>ESB本身为EAI提供了良好的支持平台，但是，作为最终的企业用户需要的则是包含业务集成软件基础平台、各种预制服务组件、集成应用开发、部署、管理和监控工具为一体的EAI环境。因此，作为软件厂商只是以ESB中间件作为基础软件平台，为用户提供整套立体的完善的企业应用软件集成平台。</p>
<p>案例研究</p>
<p>协同企业服务总线SynchroESB就是基于SOA体系结构，以ESB为底层架构，包含丰富的预制程序组件，集中式管理工具和可视化应用程序开发界面的服务整合软件平台。该产品在国家高新技术产业化计划的支持下，由西安协同时光软件公司和西北工业大学计算机学院联合研究开发的。系统结构如图20-6所示，系统分为4个层次设计。</p>
<details><summary>图20-6　SynchroESB层次结构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170856.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170856.png';" /></details>


<p>服务总线层为整个EAI应用环境提供底层支持。ESB层之上的数据转换与适配器层为各种EAI应用提供接入功能，它要解决的是应用集成服务器与被集成系统之间的连接和数据接口的问题。其上是流程整合层，它将不同的应用系统连接在一起，进行协同工作，并提供业务流程管理的相关功能，包括流程设计、监控和规划，实现业务流程的管理。最上端的用户交互层，则是为用户在界面上提供一个统一的信息服务功能入口，通过将内部和外部各种相对分散独立的信息组成一个统一的整体。</p>
<p>SynchroESB支持企业构建可管理的、可扩展的和经济实用的EAI解决方案。它提供简单经济可扩展的方法和工具，以组件化的方式灵活构建业务流程。应用独创的“粗颗粒”组件编程模型技术构建可重用的组件库，使得诸如构建、原型化、生产和管理分布式复杂应用的活动，变得和今天我们习惯使用的电子表格操作一样简单。SynchroESB支持企业以基于标准的、面向服务架构的方式将应用系统和流程跨越企业进行集成。通过分布式架构和集中式管理，SynchroESB解决了集中式的集成方式中存在的问题，它使企业能够利用企业内任何地方的现有业务系统来快速组建一个有效的解决方案。SynchroESB采用事件驱动架构使得企业能够更快地响应业务的变化。</p>
<h3 id="构建SOA架构时应该注意的问题"><a href="#构建SOA架构时应该注意的问题" class="headerlink" title="构建SOA架构时应该注意的问题"></a>构建SOA架构时应该注意的问题</h3><h4 id="原有系统架构中的集成需求"><a href="#原有系统架构中的集成需求" class="headerlink" title="原有系统架构中的集成需求"></a>原有系统架构中的集成需求</h4><p>当架构师基于SOA来构建一个企业级的系统架构时，一定要注意对原有系统架构中的集成需求进行细致的分析和整理。我们都知道，面向服务的体系结构是当前及未来应用程序系统开发的重点。面向服务的体系结构本质上来说是一种具有特殊性质的体系结构，它由具有互操作性和位置透明的组件集成构建并互连而成。基于SOA的企业系统架构通常都是在现有系统架构投资的基础上发展起来的，我们并不需要彻底重新开发全部的子系统，SOA可以通过利用当前系统已有的资源（开发人员、软件语言、硬件平台、数据库和应用程序）来重复利用系统中现有的系统和资源。SOA是一种可适应的、灵活的体系结构类型，基于SOA构建的系统架构可以在系统的开发和维护中缩短产品上市时间，因而可以降低企业系统开发的成本和风险。因此，当SOA架构师遇到一个十分复杂的企业系统时，首先考虑的应该是如何重用已有的投资而不是替换遗留系统，因为如果考虑到有限的预算，整体系统替换的成本是十分高昂的。</p>
<p>当SOA架构师分析原有系统中的集成需求时，不应该只限定为基于组件构建的已有应用程序的集成，真正的集成比这要宽泛得多。在分析和评估一个已有系统体系结构的集成需求时，必须考虑一些更加具体的集成的类型，这主要包括以下几个方面：应用程序集成的需求，终端用户界面集成的需求，流程集成的需求以及已有系统信息集成的需求。当SOA架构师分析和评估现有系统中所有可能的集成需求时，可以发现实际上所有集成方式在任何种类的企业中都有一定程度的体现。针对不同的企业类型，这些集成方式可能是简化的，或者没有明确地进行定义的。因而，SOA架构师在着手设计新的体系结构框架时，必须要全面地考虑所有可能的集成需求。例如，在一些类型的企业系统环境中可能只有很少的数据源类型，因此，系统中对消息集成的需求就可能会很简单。但在一些特定的系统中，例如航运系统中的EDI（Electronic Data Interchange，电子数据交换）系统，会有大量的电子数据交换处理的需求，因此也就会存在很多不同的数据源类型，在这种情况下整个系统对于消息数据的集成需求就会比较复杂。因此，如果SOA架构师希望所构建的系统架构能够随着企业的成长和变化成功地继续得以保持，则整个系统构架中的集成功能就应该由服务提供，而不是由特定的应用程序来完成。</p>
<h4 id="服务粒度的控制以及无状态服务的设计"><a href="#服务粒度的控制以及无状态服务的设计" class="headerlink" title="服务粒度的控制以及无状态服务的设计"></a>服务粒度的控制以及无状态服务的设计</h4><p>当SOA架构师构建一个企业级的SOA系统架构时，关于系统中最重要的元素，也就是SOA系统中服务的构建有两点需要特别注意的地方：首先是对于服务粒度的控制，另外就是对于无状态服务的设计。</p>
<h5 id="服务粒度的控制"><a href="#服务粒度的控制" class="headerlink" title="服务粒度的控制"></a>服务粒度的控制</h5><p>SOA系统中服务粒度的控制是一项十分重要的设计任务。通常来说，对于将暴露在整个系统外部的服务推荐使用粗粒度的接口，而相对较细粒度的服务接口通常用于企业系统架构的内部。从技术上讲，粗粒度的服务接口可能是一个特定服务的完整执行，而细粒度的服务接口可能是实现这个粗粒度服务接口的具体的内部操作。举个例子来说，对于一个基于SOA架构的网上商店来说，粗粒度的服务可能就是暴露给外部用户使用的提交购买表单的操作，而系统内部细粒度的服务可能就是实现这个提交购买表单服务的一系列的内部服务，如创建购买记录、设置客户地址和更新数据库等一系列的操作。虽然细粒度的接口能为服务请求者提供更加细化和更多的灵活性，但同时也意味着引入较难控制的交互模式易变性，也就是说服务的交互模式可能随着不同的服务请求者而不同。如果我们暴露这些易于变化的服务接口给系统的外部用户，就可能造成外部服务请求者难于支持不断变化的服务提供者所暴露的细粒度服务接口；而粗粒度服务接口保证了服务请求者将以一致的方式使用系统中所暴露出的服务。虽然面向服务的体系结构并不强制要求一定要使用粗粒度的服务接口，但是建议使用它们作为外部集成的接口。通常架构设计师可以使用BPEL来创建由细粒度操作组成的业务流程的粗粒度的服务接口。</p>
<h5 id="无状态服务的设计"><a href="#无状态服务的设计" class="headerlink" title="无状态服务的设计"></a>无状态服务的设计</h5><p>SOA系统架构中的具体服务应该都是独立的、自包含的请求，在实现这些服务的时候不需要前一个请求的状态，也就是说服务不应该依赖于其他服务的上下文和状态，即SOA架构中的服务应该是无状态的服务。当某一个服务需要依赖时，最好把它定义成具体的业务流程（BPEL）。</p>
<p>在服务的具体实现机制上，可以通过使用EJB组件来实现粗粒度的服务。我们通常会利用无状态的Session Bean来实现具体的服务，如果基于Web Service技术，就可以将无状态的Session Bean暴露为外部用户可以调用到的Web服务，也就是把传统的Session Facade模型转化为EJB的Web服务端点。这样，就可以向Web服务客户提供粗粒度的服务。</p>
<p>如果要在J2EE的环境下（基于WebSphere）构建Web服务，Web服务客户可以通过两种方式访问J2EE应用程序。客户可以访问用JAX-RPC API创建的Web服务（使用Servlet来实现）；Web服务客户也可以通过EJB的服务端点接口访问无状态的Session Bean，但Web服务客户不能访问其他类型的企业Bean，如有状态的Session Bean、实体Bean和消息驱动Bean。后一种选择（公开无状态EJB组件作为Web服务）有很多优势，基于已有的EJB组件，可以利用现有的业务逻辑和流程。在许多企业中，现有的业务逻辑可能已经使用EJB组件编写，通过Web服务公开它可能是实现从外界访问这些服务的最佳选择。EJB端点是一种很好的选择，因为它使业务逻辑和端点位于同一层上。另外，EJB容器会自动提供对并发的支持，作为无状态Session Bean实现的EJB服务端点不必担心多线程访问，因为EJB容器必须串行化对无状态会话Bean任何特定实例的请求。由于EJB容器都会提供对于Security和Transaction的支持，因此Bean的开发人员可以不需要编写安全代码以及事务处理代码。性能问题对于Web服务来说一直都是一个问题，由于几乎所有EJB容器都提供了对无状态会话Bean群集的支持以及对无状态Session Bean池与资源管理的支持，因此当负载增加时，可以向群集中增加机器。Web服务请求可以定向到这些不同的服务器，同时由于无状态Session Bean池改进了资源利用和内存管理，使Web服务能够有效地响应多个客户请求。由此可以看到，通过把Web服务模型化为EJB端点，可以使服务具有更强的可伸缩性，并增强了系统整体的可靠性。</p>
<h3 id="SOA实施的过程"><a href="#SOA实施的过程" class="headerlink" title="SOA实施的过程"></a>SOA实施的过程</h3><h4 id="选择SOA解决方案"><a href="#选择SOA解决方案" class="headerlink" title="选择SOA解决方案"></a>选择SOA解决方案</h4><p>在实施SOA之前，选择最佳的解决方案，是保证SOA实施成功的前提条件。总体来说，必须从以下三个方面进行选择。</p>
<h5 id="尽量选择能进行全局规划的方案"><a href="#尽量选择能进行全局规划的方案" class="headerlink" title="尽量选择能进行全局规划的方案"></a>尽量选择能进行全局规划的方案</h5><p>SOA的实施，有很大的技术因素在其中，作为用户来讲，既需要选择适当的工具，还需要有专业的技术人才。</p>
<p>作为用户，实施SOA，首先要对自己的系统做全面的评估，要了解自己已有的系统能用多少，有多少需要改造，还需要上哪些新的系统，自己将来的系统该如何满足自己的需求，自己可能为这个新的系统投入的资本大概有多少等。总之，要有整体的规划，这也是实施SOA最为基础的一步。其次，要选择适合的工具和技术。上什么系统，建什么平台，先改造哪个系统，需要一步一步来，而在这个过程中，所选择的产品也必然有所不同，一定要做到心中有数。最后，就是开发的过程了，开发对于大多数的用户来说，也是一个边学习、边实践的过程。</p>
<h5 id="选择时充分考虑企业自身的需求"><a href="#选择时充分考虑企业自身的需求" class="headerlink" title="选择时充分考虑企业自身的需求"></a>选择时充分考虑企业自身的需求</h5><p>评估SOA项目的方式与评估传统软件项目有所不同，SOA在企业范围内通过各种渠道表现自己的优势。SOA通过共享服务来优化业务流程，使全面创新成为可能，其“价值机会”远远超过了传统的软件项目。要建立强大的业务实例，通过SOA实现业务创新是一个重要的分水岭。必须认识到，用于构建SOA项目的前期投资将产生巨大效益，这些好处会随着时间的推移越来越明显地表现出来。</p>
<p>SOA具体实施的进度和资金投入一方面取决于企业对IT应用的沉淀，另一方面取决于实行SOA的目标层次。</p>
<h5 id="从平台、实施等技术方面进行考察"><a href="#从平台、实施等技术方面进行考察" class="headerlink" title="从平台、实施等技术方面进行考察"></a>从平台、实施等技术方面进行考察</h5><p>用户在选择SOA产品和技术时，应该从平台的选择、实施方法与途径、供应商的选择三个方面进行考量。在选择软件平台时，用户首先要考虑的是平台的开放性和对标准的支持。在实施方法与途径方面，以往的成功经验总结有6个方面：业务战略和流程、基础架构、构建模块、项目和应用、成本和效益以及规划和管理。在实施SOA时，CIO应该综合考虑这6方面的因素。SOA的实施涉及到整个企业的IT系统以及业务流程的调整和改变，离不开相应的咨询和专业服务。因此，在选择供应商时，首先要看它的产品是否符合企业的实际需求、是否已经有很多成功的应用案例、现有客户对它的评价如何；其次，还要仔细考察供应商的专业服务能力，是否能够帮助用户分析企业IT现状，提出建设性的意见。</p>
<h4 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h4><h5 id="建立服务模型"><a href="#建立服务模型" class="headerlink" title="建立服务模型"></a>建立服务模型</h5><p>1） 自顶向下分解法</p>
<p>自上而下的领域分解方式从业务着手进行分析，选择端到端的业务流程进行逐层分解至业务活动，并对其间涉及的业务活动和业务对象进行变化分析。</p>
<p>业务组件模型是业务领域分解的输入之一。业务组件模型是一种业务咨询和转型的工具，它根据业务职责、职责间的关系等因素，将业务细分为业务领域、业务执行层次和业务组件。由于企业内部和外部环境的不同，每个业务组件在成本、投资和竞争力等方面不尽相同。因此，每个业务组件在企业发展的过程中战略职责和演化的路径也是不同的。由于角度的不同，就形成了所谓的业务组件的“热点视图”。对于面向服务的分析和设计，业务组件模型提供了进行服务划分的依据，而且这种划分的方法可以平滑地从业务视图细化到服务视图。</p>
<p>端到端的业务流程是业务领域分解的另一个输入。将业务流程分解成子流程或者业务活动，逐级进行，直到每个业务活动都是具备业务含义的最小单元。流程分解得到的业务活动树上的每一个节点，都是服务的候选者，构成了服务候选者组合。业务领域分解可以帮助发现主要的服务候选者，加上自下而上和中间对齐方式发现的新服务候选者，最终会构成一个服务候选者列表。在SOA的方法中，服务是业务组件间的契约，因此将服务候选者划分到业务组件，是服务分析中不可或缺的一步。服务候选者列表经过业务组件的划分，会最终形成层次化的服务目录。</p>
<p>变化分析的目的是将业务领域中易变的部分和稳定的部分区分开来，通过将易变的业务逻辑及相关的业务规则剥离出来，保证未来的变化不会破坏现有设计，从而提升架构应对变化的能力。变化分析可能会从未来需求的分析中发现一些新的服务候选者，这些服务候选者需要加入到服务候选者目录中。</p>
<p>2）业务目标分析法</p>
<p>通过关键性能指标分析来验证已有服务候选者以及发现遗漏的服务候选者，这也可以叫做“目标服务建模（Goal Service Modeling）”。它的思想是这样的：从企业的业务目标出发，目标分解为子目标，子目标再分派给相关的服务来实现，这样就形成了一棵“目标服务树”，处于叶子节点上的每个服务都能回溯到具体的业务目标。第一步的工作必须基于之前对企业关键性能指标的分析之上。</p>
<p>3）自底向上分析法</p>
<p>自下而上方式的目的是利用已有资产来实现服务，已有资产包括已有系统、套装或定制应用、行业规范或业务模型等。这也可以叫做“遗留资产分析”，它的主要思想是：通过建立已有系统所具有的功能模块目录列表，可以方便地发现那些在不同的系统中被重复实现的功能模块以及可以复用的功能模块，从而将这些模块包装成服务发布出来。遗留资产分析的来源一般是原有系统的分析和设计文档，遗留系统分析的结果是可以重用的服务列表。</p>
<p>通过对已有资产的业务功能、技术平台、架构及实现方式的分析，除了能够验证服务候选者或者发现新的服务候选者，还能够通过分析已有系统、套装或定制应用的技术局限性，尽早验证服务实现决策的可行性，为服务实现决策提供重要的依据。</p>
<h5 id="建立业务流程"><a href="#建立业务流程" class="headerlink" title="建立业务流程"></a>建立业务流程</h5><p>1）建立业务对象</p>
<p>业务对象（Business Object，BO）是对数据进行检索和处理的组件，是简单的真实世界的软件抽象。业务对象通常位于中间层或者业务逻辑层。</p>
<p>业务对象可以在一个应用中自动地加入一个特定的功能来获得增值效应，使知识重用变为可能。例如，如果要开发一个包含多货币处理的应用，可以选择使用一个已经开发完成的，包含所有多货币处理功能的业务对象来开始你的开发，使开发工作极大地减少。</p>
<p>业务对象的分类如下。</p>
<p>（1）实体业务对象。表达了一个人、地点、事物或者概念。根据业务中的名词从业务域中提取，如客户、订单和物品。</p>
<p>（2）过程业务对象。表达应用程序中业务处理过程或者工作流程任务，通常依赖于实体业务对象，是业务的动词。</p>
<p>（3）事件业务对象。表达应用程序中由于系统的一些操作造成或产生的一些事件。</p>
<p>通过对业务对象的抽象，你的架构系统将体现更高的架构体系高度。</p>
<p>2）建立服务接口</p>
<p>在实现SOA解决方案的上下文中，服务接口的结构非常重要。设计糟糕的服务接口可能会极大地导致使用此接口的很多服务使用者应用程序的开发过程变得非常复杂。从业务角度而言，设计糟糕的服务接口可能使得业务流程的开发和优化变得复杂；相反，设计良好的服务接口可以加速开发计划的执行，并对业务级别的灵活性起到促进作用。</p>
<p>服务接口通常应该包含多个操作，定义为单个服务接口一部分的操作应该从语义上相关，仅包含单个操作或少量操作的大部分服务都表明服务粒度不恰当；反过来，采用很少的服务（或者单个服务）来包含大量操作也同样表明服务粒度不恰当。</p>
<p>服务之间的交换可以为有状态、也可以为无状态。当服务提供者保留关于在之前的操作调用期间服务使用者和服务提供者之间交换的数据信息时，服务之间进行的是有状态（或对话型）交换。例如，服务接口可以定义为setCustomerNumber()和getCustomerInfo()的操作。在有状态交换中，服务请求者将首先调用setCustomerNumber()操作，并同时传入客户编号；服务提供者在内存中保留客户编号；接下来，服务请求者调用getCustomerInfo()操作，服务提供者将随后返回与之前调用中设置的客户编号对应的客户信息响应。</p>
<p>在构建SOA的过程中，将无状态接口视为最好的选择。无状态接口可以方便地供很多服务使用者应用程序重用，可以采用最适合每个应用程序的方式管理状态。传入操作的请求消息应该包含完成该操作所必要的所有信息，而不受到调用其他接口操作的顺序的影响。</p>
<p>3）建立业务流程</p>
<p>流程是指定的活动顺序，包含明确确定的用于提供业务值的输入和输出。例如，技术文档搜索流程从Web页面提取客户的搜索请求，并生成可选的文档列表。</p>
<p>对流程进行建模应当确保捕获的相关信息的一致性及完整性，以便业务分析员及开发人员能够理解模型所捕获的业务需求。在建模过程中，除了正常操作以外，标准流程的其他操作和异常必须获取，具有不同领域兴趣的专职人员和专家可以构建适合于大范围业务对象的流程模型。例如，分析员需要对流程有高度的见解以做出战略性决策，并进行诸如仿真之类的流程分析；开发人员将流程模型作为输入来实现解决方案。</p>
<p>分析员基于从业务需求所有者中所收集的需求构建业务流程（Business Process，BP）模型。通过使用适当的工具（例如PowerPoint、spreadsheets、IBM Rational Requisite Pro或者其他任意工具组合，并且在适当的时候可能是流程建模工具本身）来收集这些需求，分析员将这些需求及对现有流程的分析作为构建模型的输入条件，现有的流程模型用于对其进行分析或者通过修改现有的模型来创建新的流程模型，而不用从头重新创建。</p>
<p>通过将BP分成子流程开始建模过程。随后是对感兴趣的各子流程进行分析以确定组件、服务、输入输出数据、策略及测量。通过使用WebSphere Business Integration Modeler软件工具（Business Integration Modeler）将这些元素编码到BP模型中。</p>
<p>使用一种名为流程元素的建模构件来定义BP段，将其设计为可复用。流程元素是一种定义流程段的构件资产，在BP模型中，这种流程段被设计为可复用的构件来管理。它们将已建立的一系列任务、决策、对数据对象的引用、策略、角色及测试合并起来，例如，登录流程元素包含一系列活动，登录证书数据以及完成用户登录过程的登录规则。</p>
<p>这些流程元素表示可接受的操作行为，类似的需求也可复用它们。例如，作为子流程模型可检验并为购物篮中的商品定价。</p>
<p>BP分析员与BP所有者及领域专家协作来获取所需的全部信息以构建BP模型。例如，分析员使用适当的工具收集角色、任务、序列信息、资源、数据、叙述和需求等，并将它们作为构建BP模型的输入内容。通过在Business Integration Modeler中创建流程模型，业务分析员所获取的信息可以轻易地导出给工作流开发人员，使他们在Application Developer工具中使用这些信息。</p>
<p>为流程建模的任务包括定义业务流程的细节，并为所有数据、资源及流程中所使用的其他元素建模。业务流程包含一些流程步骤，它们通过控制流相连接，这些控制流将活动与决策点相连。决策点遵循业务规则（转换条件），使用这些业务规则来确定流程应当依照什么路线进行。建模包括将BP分解成子流程并将所需的流程元素添加到模型中；分析员可以将现有的模型构件（例如，服务或流程元素）用于促进并加速模型的构建。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch19-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch19-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch19-嵌入式系统设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:58:13" itemprop="dateCreated datePublished" datetime="2021-07-19T12:58:13+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 16:54:08" itemprop="dateModified" datetime="2021-09-04T16:54:08+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="嵌入式系统设计"><a href="#嵌入式系统设计" class="headerlink" title="嵌入式系统设计"></a>嵌入式系统设计</h2><p>嵌入式软件是与硬件最为相关的软件系统。随着嵌入式设备的增长，嵌入式软件复杂度也不断增加。本章介绍了嵌入式系统的特点及针对嵌入式系统的软件设计。</p>
<h3 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h3><h4 id="嵌入式系统概念"><a href="#嵌入式系统概念" class="headerlink" title="嵌入式系统概念"></a>嵌入式系统概念</h4><h5 id="嵌入式系统的基本概念"><a href="#嵌入式系统的基本概念" class="headerlink" title="嵌入式系统的基本概念"></a>嵌入式系统的基本概念</h5><p>嵌入式系统是一种以应用为中心，以计算机技术为基础，可以适应不同应用对功能、可靠性、成本、体积和功耗等方面的要求，集可配置可裁减的软、硬件于一体的专用计算机系统。主要由嵌入式硬件平台、相关支撑硬件、嵌入式操作系统、支撑软件以及应用软件组成。</p>
<p>嵌入式系统具有以下特点。</p>
<p>（1）系统专用性强。</p>
<p>（2）系统实时性强。</p>
<p>（3）软、硬件依赖性强。</p>
<p>（4）处理器专用。</p>
<p>（5）多种技术紧密结合。</p>
<p>（6）系统透明性。</p>
<p>（7）系统资源受限。</p>
<h5 id="嵌入式系统的实时概念"><a href="#嵌入式系统的实时概念" class="headerlink" title="嵌入式系统的实时概念"></a>嵌入式系统的实时概念</h5><p>兼有实时系统的特性和嵌入式系统特性的系统称为实时嵌入式系统。它们之间的关系如图19-1所示。</p>
<details><summary>图19-1　实时嵌入式系统</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163613.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163613.png';" /></details>

<h5 id="嵌入式系统的分类"><a href="#嵌入式系统的分类" class="headerlink" title="嵌入式系统的分类"></a>嵌入式系统的分类</h5><p>按照嵌入方式、嵌入程度、实时性和系统的复杂程度4种准则可以对现有的嵌入式系统进行如下分类。</p>
<p>根据嵌入方式分类：整机式嵌入、部件式嵌入和芯片式嵌入。</p>
<p>根据嵌入程度分类：深度嵌入、中度嵌入和浅度嵌入。</p>
<p>根据实时性分类：实时嵌入式系统和非实时嵌入式系统。</p>
<p>根据系统的复杂程度分类：单微处理器嵌入式系统、组件式嵌入式系统和分布式嵌入式系统。</p>
<h5 id="嵌入式系统的应用领域"><a href="#嵌入式系统的应用领域" class="headerlink" title="嵌入式系统的应用领域"></a>嵌入式系统的应用领域</h5><p>嵌入式系统和嵌入式软件的主要应用领域如下。</p>
<p>（1）工业控制领域。</p>
<p>（2）家电领域。</p>
<p>（3）商业和金融领域。</p>
<p>（4）交通运输领域。</p>
<p>（5）通信领域。</p>
<p>（6）建筑领域。</p>
<p>（7）环境监测领域。</p>
<p>（8）医疗卫生领域。</p>
<h4 id="嵌入式系统的基本架构"><a href="#嵌入式系统的基本架构" class="headerlink" title="嵌入式系统的基本架构"></a>嵌入式系统的基本架构</h4><h5 id="嵌入式系统-1"><a href="#嵌入式系统-1" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h5><p>嵌入式系统一般由软件和硬件两个部分组成，其中嵌入式处理器、存储器和外部设备等（如图19-2所示）构成整个系统的硬件基础。嵌入式系统的软件部分可以分为多个层次（如图19-3所示），其中系统软件和支撑软件是基础，应用软件则是最能体现整个嵌入式系统的特点和功能的部分。</p>
<details><summary>图19-2　典型嵌入式系统硬件架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163725.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163725.png';" /></details>

<h5 id="硬件平台的系统架构"><a href="#硬件平台的系统架构" class="headerlink" title="硬件平台的系统架构"></a>硬件平台的系统架构</h5><p>微处理器是整个嵌入式系统的核心，负责控制系统的执行。根据目前的使用情况，嵌入式处理器可以分为如下几类。</p>
<p>（1）嵌入式微处理器。</p>
<p>（2）嵌入式微控制器。</p>
<p>（3）嵌入式数字信号处理器。</p>
<p>（4）嵌入式片上系统。</p>
<h5 id="嵌入式系统的软件架构"><a href="#嵌入式系统的软件架构" class="headerlink" title="嵌入式系统的软件架构"></a>嵌入式系统的软件架构</h5><p>一个完整的嵌入式软件体系如图19-3所示。这个体系自底向上由以下部分组成：设备驱动管理层、嵌入式操作系统、支撑软件和应用软件。</p>
<details><summary>图19-3　一种基于Linux的嵌入式软件架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163809.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163809.png';" /></details>

<p>例如，在Linux核心操作系统的架构中，文件系统、网络支持等部分都以模块化的方式与核心协调工作。整个Linux核心的源代码树可以通过工程手段根据需要进行剪裁，从中剔除掉不必要的设备驱动程序、文件系统、语言和显示等的支持，从而在保证核心具备必须功能的前提下达到精简核心尺寸的目的。</p>
<p>存储方案支持固化Flash、CF卡、DOC/DOM/DOF以及各种低噪音的嵌入式硬盘。在实际的开发过程中，存储方案的选择与具体的应用模式相结合，根据不同的应用模式来采用相应的存储方案。实际上，存储方案的选择就是在嵌入式Linux系统的可靠性、尺寸、功能、成本之间寻求最佳的平衡点。</p>
<p>因此，嵌入式软件需要通过裁减与组合，以适应各种应用场合和成本需要。嵌入式软件架构需要很好的可配置性和扩展性。</p>
<h4 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h4><h5 id="嵌入式操作系统的概念与特点"><a href="#嵌入式操作系统的概念与特点" class="headerlink" title="嵌入式操作系统的概念与特点"></a>嵌入式操作系统的概念与特点</h5><p>嵌入式操作系统是指运行在嵌入式计算机系统上支持嵌入式应用程序的操作系统，是用于控制和管理嵌入式系统中的硬件和软件资源、提供系统服务的软件集合。嵌入式操作系统是嵌入式软件的一个重要组成部分。</p>
<p>与通用操作系统相比，嵌入式操作系统主要有以下特点。</p>
<p>（1）微型化。</p>
<p>（2）代码质量高。</p>
<p>（3）专业化。</p>
<p>（4）实时性强。</p>
<p>（5）可裁减、可配置。</p>
<h5 id="嵌入式操作系统的分类"><a href="#嵌入式操作系统的分类" class="headerlink" title="嵌入式操作系统的分类"></a>嵌入式操作系统的分类</h5><p>从嵌入式操作系统的获得形式上，可以分为商业型和非商业型两类。</p>
<p>根据嵌入式操作系统的实时性，可以分为实时嵌入式操作系统和非实时嵌入式操作系统两类。</p>
<h5 id="嵌入式操作系统的一般结构"><a href="#嵌入式操作系统的一般结构" class="headerlink" title="嵌入式操作系统的一般结构"></a>嵌入式操作系统的一般结构</h5><p>嵌入式操作系统的一般结构如图19-4所示。嵌入式操作系统主要由应用程序接口、设备驱动和操作系统内核等几部分组成。</p>
<details><summary>图19-4　嵌入式操作系统的一般结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163855.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163855.png';" /></details>

<p>嵌入式操作系统是一个按时序方式调度执行、管理系统资源并为应用代码提供服务的基础软件。每个嵌入式操作系统都有一个内核。另一方面，嵌入式操作系统也可以是各种模块的有机组合，包括内核、文件系统、网络协议栈和其他部件。但是，如图19-5所示，大多数内核都包含以下三个公共部件：调度器、内核对象和内核服务。</p>
<details><summary>图19-5　嵌入式操作系统的内核部件</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163914.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163914.png';" /></details>

<h5 id="嵌入式操作系统的多任务调度"><a href="#嵌入式操作系统的多任务调度" class="headerlink" title="嵌入式操作系统的多任务调度"></a>嵌入式操作系统的多任务调度</h5><p>1）基本概念</p>
<p>（1）任务。</p>
<p>（2）任务对象。</p>
<p>（3）多任务。</p>
<p>（4）调度器。</p>
<p>（5）可调度实体。</p>
<p>（6）上下文切换。</p>
<p>（7）可重入性。</p>
<p>（8）分发器。</p>
<p>（9）调度算法。</p>
<p>（10）优先级。</p>
<p>目前，大多数内核支持两种普遍的调度算法，即基于优先级的抢占调度（Preemptive Priority-Based Scheduling）和时间轮转调度算法（Round-Robin Scheduling）。</p>
<p>2）调度算法</p>
<p>（1）任务优先级分配方法。</p>
<p>一般地，可以采用单调执行速率调度法RMS（Rate Monotonic Scheduling）来给任务分配优先级，执行最频繁的任务优先级最高。</p>
<p>（2）时间轮转调度。</p>
<p>基于优先级抢占式扩充时间轮转调度，对于优先级相同的任务使用时间片获得相等的CPU执行时间。内核在满足以下条件时，把CPU控制权转交给下一个就绪态的任务。</p>
<p>（3）任务操作。</p>
<p>内核提供任务管理服务，也提供一个允许开发者操作任务的系统调用。典型的任务操作有任务创建和删除、任务调度控制、任务信息获取。</p>
<h5 id="嵌入式操作系统的内核对象"><a href="#嵌入式操作系统的内核对象" class="headerlink" title="嵌入式操作系统的内核对象"></a>嵌入式操作系统的内核对象</h5><p>实时嵌入式操作系统的用户可以使用内核对象来解决系统设计中的问题，如并发、同步与互斥、数据通信等。内核对象包括信号量、消息队列、管道、事件与信号等。</p>
<h5 id="实时嵌入式操作系统的内核服务"><a href="#实时嵌入式操作系统的内核服务" class="headerlink" title="实时嵌入式操作系统的内核服务"></a>实时嵌入式操作系统的内核服务</h5><p>实时嵌入式操作系统的内核服务有异常和中断、计时器、I/O管理。</p>
<h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><p>不论嵌入式系统的类型如何，对内存系统的普遍要求是最高的内存利用率、最小的管理负载和确定的分配时间。管理内容如下。</p>
<p>（1）嵌入式系统中固定尺寸内存池的内存管理。</p>
<p>（2）阻塞与非阻塞的内存函数。</p>
<p>（3）硬件内存管理单元。</p>
<p>（4）同步与通信。</p>
<h4 id="典型嵌入式操作系统"><a href="#典型嵌入式操作系统" class="headerlink" title="典型嵌入式操作系统"></a>典型嵌入式操作系统</h4><p>嵌入式操作系统分为从不同的通用操作系统发展来的通用嵌入式操作系统，如WinCE、Linux等，大多数是特定领域专用操作系统，如表19-1所示。</p>
<details><summary>表19-1　主要嵌入式操作系统</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164038.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164038.png';" /></details>

<details><summary>表19-1　主要嵌入式操作系统-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164053.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164053.png';" /></details>

<p>以VxWrorks为例，VxWrorks是一个运行在目标机上的高性能、可裁减的嵌入式实时操作系统。VxWrorks是专门为实时嵌入式系统设计开发的操作系统内核，为程序员提供了高效的实时多任务调度、中断管理、实时的系统资源以及实时的任务间通信。VxWrorks在各种CPU平台上提供了统一的编程接口和一致的运行特性，尽可能地屏蔽了不同CPU之间的底层差异。</p>
<p>VxWrorks以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空和航天等高精尖技术及实时性要求极高的领域中，如卫星通信、军事演习、弹道制导和飞机导航等。</p>
<p>VxWrorks操作系统的基本构成部件主要有以下5个部分：板级支持包BSP（Board Support Package）、微内核Wind、网络系统、文件系统和I/O系统。</p>
<p>VxWorks系统具有高性能的微内核设计、可裁剪的运行软件、综合的网络工具、兼容POSIX 1003.1b标准、平台的选择、方便地移植到用户硬件上及操作系统选件等特色。</p>
<h4 id="嵌入式数据库管理"><a href="#嵌入式数据库管理" class="headerlink" title="嵌入式数据库管理"></a>嵌入式数据库管理</h4><h5 id="嵌入式数据库管理系统概述"><a href="#嵌入式数据库管理系统概述" class="headerlink" title="嵌入式数据库管理系统概述"></a>嵌入式数据库管理系统概述</h5><p>通常，嵌入式数据库管理系统就是在嵌入式设备上使用的数据库管理系统。由于用到嵌入式数据库管理系统的系统大多数都是移动信息设备，所以，嵌入式数据库也称为移动数据库或嵌入式移动数据库。其作用主要是解决移动计算环境下数据的管理问题，移动数据库是移动计算环境中的分布式数据库。</p>
<h5 id="嵌入式数据库管理系统使用环境的特点"><a href="#嵌入式数据库管理系统使用环境的特点" class="headerlink" title="嵌入式数据库管理系统使用环境的特点"></a>嵌入式数据库管理系统使用环境的特点</h5><p>嵌入式数据库系统是一个包含嵌入式数据库管理系统在内的跨越移动通信设备、工作站或台式机以及数据服务器的综合系统。其使用环境的特点可以简单地归纳如下。</p>
<p>（1）设备随时移动性。</p>
<p>（2）网络频繁断接。</p>
<p>（3）网络条件多样化。</p>
<p>（4）通信能力不对称。</p>
<h5 id="嵌入式数据库管理系统组成与关键技术"><a href="#嵌入式数据库管理系统组成与关键技术" class="headerlink" title="嵌入式数据库管理系统组成与关键技术"></a>嵌入式数据库管理系统组成与关键技术</h5><p>1）嵌入式数据库管理系统组成</p>
<p>一个完整的嵌入式数据库管理系统包括主数据库管理系统、同步服务器、嵌入式数据库管理系统和连接网络等几个子系统，如图19-6所示。</p>
<details><summary>图19-6　嵌入式数据库系统组成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164159.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164159.png';" /></details>

<p>2）嵌入式移动数据库在应用中的关键</p>
<p>嵌入式移动数据库在实际应用中必须解决好数据的一致性（复制性）、高效的事务处理和数据的安全性等问题。</p>
<p>3）移动数据库管理系统的特性</p>
<p>由于嵌入式移动数据库管理系统在移动计算的环境下应用在嵌入式操作系统之中，是一种动态分布式数据库管理系统，其特点和功能如下。</p>
<p>（1）微核结构。</p>
<p>（2）对标准SQL的支持。</p>
<p>（3）事务管理功能。</p>
<p>（4）完善的数据同步机制。</p>
<p>（5）支持多种连接协议。</p>
<p>（6）完备的嵌入式数据库管理功能。</p>
<p>（7）支持多种嵌入式操作系统。</p>
<p>还应考虑的因素有对断接操作的支持、对跨区长事务的支持、对位置相关查询的支持、对查询优化的特殊考虑以及对提高有限资源的利用率和对系统效率的考虑等。</p>
<h5 id="嵌入式移动数据库管理系统的应用"><a href="#嵌入式移动数据库管理系统的应用" class="headerlink" title="嵌入式移动数据库管理系统的应用"></a>嵌入式移动数据库管理系统的应用</h5><p>嵌入式数据库管理系统主要用于以移动信息设备为终端、并需要定期汇总的金融、零售、医疗、公安、保险、工业制造、仓储以及电信等多个行业和领域。</p>
<h5 id="嵌入式数据库管理系统案例"><a href="#嵌入式数据库管理系统案例" class="headerlink" title="嵌入式数据库管理系统案例"></a>嵌入式数据库管理系统案例</h5><p>SQL Anywhere Studio是Sybase公司开发的一个嵌入式数据库系统，主要用于笔记本式计算机、手持设备和智能电器等领域。</p>
<p>Adaptive Server Anywhere嵌入式数据库管理系统具有支持多种操作系统、支持Java、支持Internet、支持多种应用程序接口、易于管理及系统规模配置灵活等主要特性。</p>
<h4 id="嵌入式网络及其他"><a href="#嵌入式网络及其他" class="headerlink" title="嵌入式网络及其他"></a>嵌入式网络及其他</h4><p>嵌入式网络是用于连接各种嵌入式系统，使之可以互相传递信息、共享资源的网络系统。嵌入式系统在不同的场合采用不同的连接技术，如在家庭居室采用家庭信息网，在工业自动化领域采用现场总线，在移动信息设备等嵌入式系统则采用移动通信网。此外，还有一些专用连接技术用于连接嵌入式系统。</p>
<h5 id="现场总线网"><a href="#现场总线网" class="headerlink" title="现场总线网"></a>现场总线网</h5><p>现场总线（Field Bus）是将数字传感器、变换机、工业仪表及控制执行机构等现场设备与工业过程控制单元、现场操作站等相互连接而成的网络。它具有全数字化、分散、双向传输和多分支的特点，是工业控制网络向现场级发展的产物。</p>
<p>嵌入式现场控制系统将专用微处理器置入传统的测量控制仪表，使其具备数字计算和数字通信能力。</p>
<p>现场总线主要有总线型与星型两种拓扑结构。现场总线控制系统通常由以下部分组成：现场总线仪表、控制器、现场总线线路、监控、组态计算机，并通过现场总线网卡、通信协议软件连接到网上。</p>
<p>现场总线控制系统的优点如下。</p>
<p>（1）全数字化。</p>
<p>（2）全分布。</p>
<p>（3）双向传输。</p>
<p>（4）自诊断。</p>
<p>（5）节省布线及控制室空间。</p>
<p>（6）多功能。</p>
<p>（7）开放性。</p>
<p>（8）互操作性。</p>
<p>（9）智能化与自治性。</p>
<p>具有代表性的实例有德国BOSCH公司的CAN（Control Area Network），Echelon公司的LONGWORKS。</p>
<h5 id="家庭信息网"><a href="#家庭信息网" class="headerlink" title="家庭信息网"></a>家庭信息网</h5><p>家庭信息网是把家庭范围内的个人计算机，家用电器，水、电、气仪表，照明设备和网络设备及安全设备等连接在一起的局域网。其主要功能是集中控制上述设备并将其接入Internet，以共享网络资源和服务。</p>
<p>家庭信息网需要解决的两个基本问题如下。</p>
<p>（1）如何将家用电器，水、电、气仪表，照明设备等互相连接起来。</p>
<p>（2）如何实现这些连在一起的设备之间的互操作。</p>
<p>家庭信息网的拓扑结构有总线型和星型等。</p>
<p>目前，家庭信息网的传输技术有两类：一类是有线连接技术，包括以太网、电话线、电力线、IEEE1394以及USB等。另一类是无线连接技术，包括蓝牙（BlueTooth）、红外线（InfraRed）、无线USB以及802.11x等相关无线标准。</p>
<h5 id="无线数据通信网"><a href="#无线数据通信网" class="headerlink" title="无线数据通信网"></a>无线数据通信网</h5><p>无线数据通信网是一种通过无线电波传送数据的网络系统。通过无线数据通信网，智能手机、PDA及笔记本式计算机可以互相传递数据信息，并接入因特网。</p>
<p>无线数据通信网分为短程无线网和无线因特网。短程无线网主要包括802.11、蓝牙、IrDA及HomeRF等。无线因特网或移动因特网主要采用两种无线连接技术：一种是移动无线接入技术，如GSM（Global System for Mobile）、GPRS（General Packet Radio Service）和CDPD（Cellular Digital Packet Data）等。另一种是固定无线接入技术，包括微波、扩频通信、卫星及无线光传输等。</p>
<p>无线局域网（Wireless LocalArea Network，WLAN）是计算机网络与无线通信技术相结合的产物。无线局域网的传输媒体是红外线（IR）或者无线电波（RF），目前无线电波的使用更广泛一些。</p>
<p>目前常见的无线网络标准以IEEE802.11x系列为主。</p>
<h5 id="嵌入式因特网"><a href="#嵌入式因特网" class="headerlink" title="嵌入式因特网"></a>嵌入式因特网</h5><p>随着Internet和嵌入式技术的飞速发展，越来越多的信息电器都要求与Internet连接，来共享Internet所提供的方便、快捷、无处不在的信息资源和服务，即嵌入式Internet技术。嵌入式Internet技术在智能交通、家政系统、家庭自动化、工业自动化、POS及电子商务等领域具有广阔的应用前景。</p>
<p>嵌入式因特网有直接接入因特网和通过网关接入因特网两种接入方法。</p>
<h5 id="嵌入式系统的其他支撑软件"><a href="#嵌入式系统的其他支撑软件" class="headerlink" title="嵌入式系统的其他支撑软件"></a>嵌入式系统的其他支撑软件</h5><p>嵌入式系统的支撑软件通常包括窗口系统、网络系统、数据库管理系统及Java虚拟机等几个部分。</p>
<h5 id="嵌入式窗口系统"><a href="#嵌入式窗口系统" class="headerlink" title="嵌入式窗口系统"></a>嵌入式窗口系统</h5><p>嵌入式窗口系统是用于控制嵌入式系统中的位映像显示设备与输入设备的软件系统，管理屏幕、窗口、字体、光标、图形图像以及输入设备等资源。</p>
<p>图形用户界面系统是指计算机系统以图形方式向用户提供的人机交互的操作环境，如图19-7所示。</p>
<h5 id="嵌入式窗口系统实例分析"><a href="#嵌入式窗口系统实例分析" class="headerlink" title="嵌入式窗口系统实例分析"></a>嵌入式窗口系统实例分析</h5><p>嵌入式系统往往是一种定制的设备，它们对图形用户界面的需求也各不相同，因此很多嵌入式系统需要自己特定的嵌入式图形用户界面。常用的嵌入式图形用户界面有MiniGUI、Microwindows、OpenGUI和Qt/Embedded。</p>
<h5 id="嵌入式系统的Java虚拟机"><a href="#嵌入式系统的Java虚拟机" class="headerlink" title="嵌入式系统的Java虚拟机"></a>嵌入式系统的Java虚拟机</h5><p>Java最初是由Sun公司开发的编程语言，可以在网络环境下为不同类型的计算机和操作系统开发软件。目前，在智能手机、机顶盒等嵌入式系统中得到了广泛的应用。</p>
<p>运行J2ME（Java 2 Platform Micro-Edition）微型版的嵌入式设备主要有两大类：受限连接设备（Connected Limited Device）和连接设备（Connected Device）。如图19-8所示，J2ME的结构分为4个层次：框架、配置、Java虚拟机及嵌入式操作系统，J2ME的核心是Java虚拟机。</p>
<details><summary>图19-7　图形用户界面系统的层次模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164511.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164511.png';" /></details>

<details><summary>图19-8　J2ME的层次结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164521.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164521.png';" /></details>


<p>KVM（K Virtual Machine）和CVM（C Virtual Machine）都是JVM的子集，均可被看做是一种Java虚拟机，它们是J2SE JVM的压缩版。框架、配置、虚拟机与嵌入式操作系统之间的关系如图19-9所示。</p>
<details><summary>图19-9　框架、配置、虚拟机与嵌入式操作系统之间的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164714.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164714.png';" /></details>

<p>目前，在J2ME中，主要有MIDP、Personal、PDA、Foundation和RMI等框架。</p>
<p>移动信息设备框架（Mobile Information Device Profile，MIDP）是一个Java API集合，它处理诸如用户界面、持久存储和联网等问题。</p>
<h3 id="嵌入式系统的设计"><a href="#嵌入式系统的设计" class="headerlink" title="嵌入式系统的设计"></a>嵌入式系统的设计</h3><h4 id="嵌入式系统分析与设计"><a href="#嵌入式系统分析与设计" class="headerlink" title="嵌入式系统分析与设计"></a>嵌入式系统分析与设计</h4><h5 id="嵌入式系统设计的核心技术"><a href="#嵌入式系统设计的核心技术" class="headerlink" title="嵌入式系统设计的核心技术"></a>嵌入式系统设计的核心技术</h5><p>嵌入式系统的核心技术有三种：处理器技术、IC技术和设计/验证技术。</p>
<p>1）处理器技术</p>
<p>处理器技术与实现系统功能的计算引擎结构有关，不可编程的数字系统也可以视为处理器，这些处理器的差别在于其面向特定功能的专用化程度，导致其设计指标与其他处理器不同。</p>
<p>（1）通用处理器。</p>
<p>这类处理器可用于不同类型的应用，一个重要的特征就是存储程序，由于设计者不知道处理器将会运行何种运算，所以无法用数字电路建立程序。另一个特征就是通用的数据路径，为了处理各类不同的计算，数据路径是通用的，其数据路径一般有大量的寄存器以及一个或多个通用的算术逻辑单元。设计者只需要对处理器的存储器编程来执行所需的功能，即设计相关的软件。</p>
<p>在嵌入式系统中使用通用处理器具有设计指标上的一些优势：上市时间快和成本较低；设计者只需编写程序，而不需要做任何数字电路设计；灵活性高，功能的改变通过修改程序进行。与自行设计处理器相比，小批量时单位成本较低。</p>
<p>当然，这种方式也有一些设计指标上的缺陷，数量大时的单位成本相对较高。因为数量大时，自行设计的成本分摊下来，可降低单位成本。同时，对于某些应用，性能可能很差。由于包含了非必要的处理器硬件，系统的体积和功耗可能变大。</p>
<p>（2）单用途处理器。</p>
<p>单用途处理器是设计用于执行特定程序的数字电路，也指协处理器、加速器和外设等。如JPEG编码解码器执行单一程序，压缩或解压视频信息。嵌入式系统设计者可通过设计特定的数字电路来建立单用途的处理器，也可以采用预先设计好的商品化的单用途处理器。</p>
<p>在嵌入式系统中使用单用途处理器，在指标上有一些优缺点。这些优缺点与通用处理器基本相反，性能可能更好，体积与功率可能较小，数量大时的单位成本可能较低，而设计时间与NRE成本可能较高，灵活性较差，数量小时的单位成本较高，对某些应用性能不如通用处理器。</p>
<p>（3）专用处理器。</p>
<p>专用指令集处理器（ASIP）是一个可编程处理器，针对某一特定类型的应用进行最优化。这类特定应用具有相同的特征，如嵌入式控制、数字信号处理等。在嵌入式系统中使用ASIP，可以在保证良好的性能、功率和大小的情况下，提供更大的灵活性，但这类处理器仍需要昂贵的NRE成本建立处理器本身和编译器。单片机和数字信号处理器是两类应用广泛的ASIP，数字信号处理器是一种针对数字信号进行常见运算的微处理器，而单片机是一种针对嵌入式控制应用进行最佳化的微处理器。通常控制应用中的常见外设，如串行通信外设、定时器、计数器、脉宽调制器及数/模转换器等都集成到了微处理器芯片上，从而使得产品的体积更小、成本更低。</p>
<p>2）IC技术</p>
<p>（1）全定制/VLSI。</p>
<p>在全定制IC技术中，需要根据特定的嵌入式系统的数字实现来优化各层设计人员从晶体管的版图尺寸、位置、连线开始设计，以达到芯片面积利用率高、速度快、功耗低的最优化性能。利用掩膜在制造厂生产实际芯片，全定制的IC设计也常称为大规模集成电路设计（VLSI），具有很高的成本，很长的制造时间，适用于大量或对性能要求严格的应用。</p>
<p>（2）半定制ASIC。</p>
<p>半定制ASIC是一种约束型设计方法，包括门阵列设计法和标准单元设计法。它是在芯片上制作一些具有通用性的单元元件和元件组的半成品硬件，设计者仅需要考虑电路的逻辑功能和各功能模块之间的合理连接即可。这种设计方法灵活方便、性价比高，缩短了设计周期，提高了成品率。</p>
<p>（3）可编程ASIC。</p>
<p>可编程器件中所有各层都已经存在，设计完成后，在实验室里即可烧制出设计的芯片，不需要IC厂家参与，开发周期显著缩短。可编程ASIC具有较低的成本，单位成本较高，功耗较大，速度较慢。</p>
<p>3）设计/验证技术</p>
<p>嵌入式系统的设计技术主要包括硬件设计技术和软件设计技术两大类。其中，硬件设计领域的技术主要包括芯片级设计技术和电路板级设计技术两个方面。</p>
<p>芯片级设计技术的核心是编译/综合、库/IP、测试/验证。编译/综合技术使设计者用抽象的方式描述所需的功能，并自动分析和插入实现细节。库/IP技术将预先设计好的低抽象级实现用于高级。测试/验证技术确保每级功能正确，减少各级之间反复设计的成本。</p>
<p>软件设计技术的核心是软件语言。软件语言经历了从低级语言（机器语言、汇编语言）到高级语言（如结构化设计语言、面向对象设计语言）的发展历程，推动其发展的是汇编技术、分析技术、编译/解释技术等诸多相关技术。</p>
<p>早期，随着通用处理器概念的逐渐形成，软件技术迅速发展，软件的复杂度也开始增加，软件设计和硬件设计的技术和领域完全分开。设计技术和工具在这两个领域同步得到发展，也使得行为描述可以在越来越抽象的级别上进行，以适应设计复杂度不断增长的需要。采用UML等建模，进行分析与设计已成为统一共识。</p>
<h5 id="系统的设计流程"><a href="#系统的设计流程" class="headerlink" title="系统的设计流程"></a>系统的设计流程</h5><p>嵌入式系统软件的开发过程可以分为项目计划、可行性分析、需求分析、概要设计、详细设计、程序建立、下载、调试、固化、测试及运行等几个阶段，这些阶段的次序和关系如图19-10所示。</p>
<details><summary>图19-10　嵌入式软件开发的一般过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164859.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164859.png';" /></details>

<p>（1）评估用户的需求采用计算机的必要性。从经济效益和社会效益这两个侧面来考虑。</p>
<p>（2）用户需求调查与分析，并提炼出规格说明。</p>
<p>（3）选择处理器。在用户需求调查清楚的基础上，再仔细进行分析。理解满足用户需求所需什么样的速度、什么样的精度、什么样规模的嵌入式系统可以实现用户的需求。在此基础上，首先确定作为系统的核心部件的处理器。选择合适的处理器对实现用户需求、提高系统性能、降低系统成本以及缩短开发周期都是十分重要的。选择处理器可从字长、速度、中断能力、环境的适应能力、硬件和软件的支持能力、开发和调试手段几个方面来考虑。</p>
<p>（4）制订系统方案。在系统的核心部件处理器确定后，便可以根据需求来制订系统的总体方案。这包括硬件系统方案和软件系统方案两个方面，并对总体方案进行评审。</p>
<p>（5）软、硬件分别设计。</p>
<p>（6）实验室联调。</p>
<p>（7）现场调试和试运行。</p>
<p>（8）鉴定或验收。</p>
<p>1）需求分析阶段</p>
<p>当确定要为用户设计开发嵌入式计算机系统后，接下来重要的一步就是对用户的需求进行认真仔细的调查和分析。这一步极为重要，因为此后系统设计的所有工作都是以用户的需求为依据的。用户的需求没有做好，则设计一定是失败的；用户没有要求的功能在设计中做了，有可能是锦上添花，也可能是画蛇添足。因此，最重要的在于满足用户的需求。</p>
<p>用户的需求调查一定要仔细进行，全面详细地了解要求，仔细地倾听用户的解释，经分析以文字的形式写出来并形成文档。而且使设计者的理解与用户的解释完全一致，不能存在二义性。</p>
<p>在需求调查时，除了仔细了解用户的需求外，还要对用户使用嵌入式系统的环境进行调查。这些内容也许用户没有意识到它们的重要性，但系统设计者必须予以高度重视。</p>
<p>一般都将形成文档的用户需求报告作为系统开发研制合同的附件，因为它既是开发的依据，又可在出现争议时备查。</p>
<p>2）规格说明</p>
<p>对用户需求进行提炼便可得到系统的规格说明。规格说明里包含了进行系统体系结构设计所需要的足够信息。将客户的描述转化为系统设计者的描述的结构化方法就是从客户的需求中获取一组一致性的需求，然后从中整理出正式的规格说明。</p>
<p>规格说明起到客户和生产者之间合同的作用，所以规格说明必须小心编写，以便精确地反映客户的需求并且作为设计时必须明确遵循的要求。</p>
<p>规格说明还应该足够明晰，以便别人可以验证它是否符合系统需求并且是否能完全满足客户的期望，它亦不能有歧义。</p>
<p>3）设计阶段</p>
<p>稍具规模的嵌入式系统设计过程都是系统工程，需多个技术人员齐心协力共同以最快的速度加以实现。单靠一个人，即使有能力解决所有问题，但一个系统设计做出来可能就需好多年。当几年后系统完成时也就成为落后和无用的东西了，因为这个领域的技术发展非常快。</p>
<p>在硬件好分割的地方将硬件分割成若干模块。在软件好分割的地方、界面比较简单的地方将软件分割成若干模块，然后将硬件模块和软件模块分别交给不同的技术人员同时进行设计。</p>
<p>在设计过程中，规定设计进度，限定时间将各自的模块设计并调试出来。在此过程中，对出现的问题要进行协调。若有方案上的变更，要以文字的形式通知设计人员。各设计人员在设计和调试自己的模块过程中要做必要的记录。</p>
<p>4）系统集成与测试阶段</p>
<p>当软、硬件各模块都设计调试完成后，便可在实验室进行联调。</p>
<p>将硬件模块逐块加到硬件系统上，逐块模板进行调试。直到所有硬件模块都调试出来，证明它们可以正常工作。</p>
<p>同时，对各自设计的软件模块逐块进行连接并调试，证明软件系统可以工作。</p>
<p>将软、硬件结合在一起，对整个系统进行调试，并在实验室里进行模拟试运行。在实验室模拟试运行中，如果需要，可在实验室里产生模拟信号。例如，称重传感提供0～20mV的称重信号，也许实验室里没有称重传感器，但实验室里一定可以产生0～20mV的信号代替传感器的输出。同样，实验室里可能没有需要0～5mV的执行机构，但用万用表便可测量出系统硬件是否能够输出执行机构所需要的0～5mV的信号。</p>
<p>经过不断的模拟试运行，仔细观察并分析出现的现象和状态。判断系统工作是否正常，决不要放过任何的异常，对出现的问题随时加以解决。</p>
<p>由于用户需求的复杂性、多样性，使得系统的硬件和软件变得复杂得多。因此，在实验室里进行模拟试运行时，一定要想办法使用户程序的每一条路径都能走到，即测试用户程序的各种可能。同时，要使系统连续运行较长的时间，以便发现可能隐藏的软、硬件故障。</p>
<p>5）现场调试和试运行</p>
<p>在实验室模拟试运行确认系统工作是正确的情况下，便可将系统运往用户现场，在现场进行安装和调试。这时，系统所连接的专用外设都是系统真正要使用的，在调试时也应逐个进行外设的连接，逐个进行调试。</p>
<p>在调试通过后，即可使系统开始试运行。在试运行的过程中，一定要密切注视系统运行的状态，不要放过任何的异常情况；对系统运行的状态和数据进行详细记录；如果出现问题，应立即予以解决；要使系统无故障地、正常运行半年或更长的时间。</p>
<p>如果可能，最好多做几套样机，并将它们安装在不同的用户现场上，进行半年或更长时间的试运行，以便确定系统的工作性能。</p>
<h4 id="嵌入式软件设计模型"><a href="#嵌入式软件设计模型" class="headerlink" title="嵌入式软件设计模型"></a>嵌入式软件设计模型</h4><h5 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h5><p>有限状态机（FSM）是一种描述系统状态及其状态转换的节点网，包括节点和边，节点表示状态，边表示状态之间的转换关系。边上面标注事件，表示状态转换对该事件敏感。在一个典型的有限状态机中，系统总是处于单个状态，事件通信可以是广播、同步和非阻塞方式。图19-11显示了一个有限状态机的示例。</p>
<details><summary>图19-11　有限状态机示例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904165025.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904165025.png';" /></details>


<p>有限状态机适合于对控制领域的系统建模。但是，由于缺乏并发和层次化支持，创建系统的规模受限，无法对并发系统建模，这是由于有限状态机总是假设系统处于单个状态而造成的。</p>
<p>状态机被描述为：输入事件的集合；输出事件的集合；状态集合；把状态和输入事件映射到输出事件的集合；把状态和输入事件映射到状态的集合；对初始状态的描述；有限状态机是有限状态的机器。有限状态机可被用作提出和解决问题的开发工具，也可被用作为以后开发者描述解决方案的正式工具。有很多种显示状态机的方法，从简单的表格到图形示例。所谓状态机模型，是一个描述状态变迁的方法，它总是将一种状态向另一种状态的变迁视为由输入消息激励所产生的结果。这样，每当消息促使事务需要做出某种操作时，有限状态机的当前状态也随之改变，这种改变是根据预先制定好的规则来实现的。</p>
<p>状态机模型具有如下特点。</p>
<p>（1）输出由当前的输入和当前的状态决定。这是状态机模型和组合模型之间的最大区别。</p>
<p>（2）当前的状态由过去的输入决定。很显然，一个对象之所以拥有当前状态，是因为它在此前经历过初始化并响应过若干次外界的操作请求（即接受了外界的输入）。</p>
<p>（3）当前的状态是上一步输出的反映。被测对象处于当前状态的直接原因是对象对上一次的输入做了有效的回应，即产生了上一步的输出。</p>
<p>（4）输出受输入顺序的影响。因为对状态机模型而言，当前状态加上当前输入才可以得到预期的输出。如果把当前输入放在上一步输入之前，那时状态机既然不是处于当前状态之下，就无法得到预期的输出了。</p>
<h5 id="数据流模型"><a href="#数据流模型" class="headerlink" title="数据流模型"></a>数据流模型</h5><p>数据流图允许系统作为操作网进行建模，特别适合于对实现进行分区的系统模型。这些模型的长度能够描述系统控制和数据域，这使得它们能够适合于对异构系统的建模。</p>
<p>数据流模型主要包括布尔数据流、层次化的流图和Petri网。</p>
<p>1）布尔数据流</p>
<p>布尔数据流克服了同步数据流模型中数据依赖操作的缺陷，引入了开关结点，能够根据输入值选择输出，支持对复杂算法的建模和实现。图19-12显示了一个布尔数据流模型。</p>
<details><summary>图19-12　布尔数据流模型示例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904165159.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904165159.png';" /></details>

<p>2）层次化的流图</p>
<p>层次化的流图包括节点和边，节点表示操作，边表示依赖。操作可以是条件、计算、等待和循环操作。条件操作支持在图模型中使用数据依赖。通信可以是阻塞式（Wait）和非阻塞式（Receive）。层次化的流图用于在系统中执行分区、调度和综合。</p>
<p>3）Petri网</p>
<p>Petri网是一种流程建模机制，其基本形式是由Petri提出的，所以命名为Petri网。目前，Petri网得到了广泛应用，特别是在离散事件仿真、实时调度、工业控制和工作流等方面。基本Petri网通常包括库所（Places）、操作（Transitions）和有向边（弧）。库所上的数据称为令牌（Tokens）。输入库所上的令牌可以触发迁移，消耗输入库所上的令牌，并为输出库所生成令牌。图19-13显示了一个Petri网的示例。</p>
<details><summary>图19-13　Petri网示例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904165240.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904165240.png';" /></details>

<h5 id="并发进程模型"><a href="#并发进程模型" class="headerlink" title="并发进程模型"></a>并发进程模型</h5><p>并发进程模型包括CSP与CCS等。</p>
<p>1）CSP模型</p>
<p>CSP（Communicating Sequential Processes）通信顺序进程是C. A. R. Hoare于1978年提出的一种并发、分布式程序设计语言模型。CSP一经出现就被广泛地应用于计算机科学的诸多领域，如网络通信协议的形式化描述等。</p>
<p>CSP将输入、输出操作列为程序语言的基本要素，而将实现顺序进程间通信的并行组合作为基本的程序控制结构。用这种语言设计的一个程序，就是一组进程，它们通过一个通信网络彼此通信。</p>
<p>CSP模型的目的是描述一种在计算机应用的广泛领域中适用的最简单的数学理论，其主要贡献是把计算机所涉及的各种计算形式及其性质建立在一套严密的形式系统上。其新版本TCSP在并发和通信方法及语义的研究方面与Milner的CCS很类似，对“失效语义”给出了精确的数学描述，使CSP理论更加可靠完善。</p>
<p>2）CCS模型</p>
<p>CCS（Calculus of Communicating System）通信演算系统是R. Milner于1980年发表的一个建立于极小原语集上的函数式程序设计语言模型，为通信的、非确定的并发系统提供了一个通用数学模型。</p>
<p>CCS模型是在一种较弱条件下建立起来的并发进程模型，企图俘获并发性及通信的一般数学性质。其主要贡献是关于并发系统构成的等价性研究，其中有代表性的是建立在双模拟基础上的等价概念。</p>
<p>CCS从简单的事实出发，以严谨、优美的数学形式，建立了并发系统行为的形式理论。</p>
<h5 id="面向对象模型"><a href="#面向对象模型" class="headerlink" title="面向对象模型"></a>面向对象模型</h5><p>面向对象模型的出发点，就是要把现实世界中物与物的关系怎样不变地用程序表示出来，并把现实世界的组织结构在计算机上再现。这种结构直观、易懂。现实世界中的万物都有自己的功能和任务，自己能干的事情自己完成，自己不能干的事情托他人代办，只要取得结果就可以了。因此，就要注意现实世界中各事物——即对象之间的联系，为每个对象分配任务，对象之间也相互传递任务，进行工作。这就是面向对象的方法。</p>
<p>面向对象的基本结构可用6个术语来描述，即对象、类、属性、消息、操作和关系。系统的结构中心是对象，每个对象中有属性和操作，属性和操作封装在一个盒子里。对象之间通过传送消息来协调工作。每个对象又进一步抽象为类，类是对象实体的模板。对象之间的相互地位用关系表示。关系大致分为三大类，即关联关系、Part-Of关系和Is-a关系。关联关系表示对象之间对等访问或利用关系。对象之间存在关联，表示相连的对象之间可以传递消息。Part-Of关系表示一方是他方对象的一部分的包含关系，是对象间的集约关系。Is-a关系则是类间的包含关系。在Is-a关系中，子类既继承父类的性质，又有自己独有的性质。这里的性质是指属性、操作和关系。</p>
<p>面向对象的模型特征可以从以下几个方面体现。</p>
<p>1）抽象化</p>
<p>通过对象来抽象现实世界有两点好处：首先是能自然地表示现实世界，通过对现实世界的模仿，就可以类推出需要的功能和操作；其次，是很容易明确分析焦点，只要把现实世界的一个重要侧面模型化，在以后的分析中必须注重的焦点就自然明确了。抽象化除把现实世界的事物抽象为对象外，还把性质相同的对象群进一步抽象为类。通过这种层次式的抽象，便可构造事物的体系，很自然地把握现实世界。</p>
<p>2）封装化</p>
<p>封装化可以把对象内部的数据和操作过程隐藏起来，可以控制模块间信息公开和隐藏的范围。对外，只让看到过程的规格说明，使得对象的规格说明和实现相分离。封装化的最大效果是把对象的提供者和对象的使用者分开，对象的使用者只知道在对象中定义的操作的规格说明，对象内部的数据结构和操作过程是不知道的。有些过程群是为了访问特定的数据结构而设置的，可以集中放在类中，也不会影响到对象使用者的信息，为需求的变更带来方便，同时还可以拒绝非法使用者的访问，达到保密的目的。</p>
<p>3）继承化</p>
<p>面向对象模型中，父类的概念可继承到子类，且子类还可以有自己的新性质，这就叫继承性。继承性可有效地重用资源、提高生产效率，具体体现在两点上：一是可以把类作为体系化的手段，即多个子类的共同性质抽象为一个父类。由此，父类容易明白子类之间性质的不同及分类观点，也便于子类追加自己的性质。二是可利用继承性来定义新类，只要定义出与现有类的不同点就可以了，有利于产品重用和更改管理。</p>
<p>4）状态</p>
<p>对象中所定义的过程能否使用，实际上是通过内部的属性值来决定的。根据属性值，可以把对象分成多个不同的状态。每种状态下，都标识出此刻可使用的过程。把状态的概念放入对象规格说明中，使得对象的提供者能把正确接收消息的过程作为状态转移图，提供给使用者。</p>
<p>由面向对象模型的分析可看出，面向对象方法论的特征是能在早期获取模型结构和现实世界结构的对应关系，所有的软件都可以看成是现实世界的模拟。</p>
<p>类—责任—协作者（Class-Responsibility-Collaborator，CRC）模型是面向对象建模的对象描述工具，用于标识类、指明类的责任（属性和操作）以及类之间的协作（多个类协同完成某些操作）。面向对象模型还包括对象信息、行为模型等，它们从不同侧面（静态、动态）描述系统。</p>
<h4 id="嵌入式系统软件开发环境"><a href="#嵌入式系统软件开发环境" class="headerlink" title="嵌入式系统软件开发环境"></a>嵌入式系统软件开发环境</h4><h5 id="嵌入式系统开发概述"><a href="#嵌入式系统开发概述" class="headerlink" title="嵌入式系统开发概述"></a>嵌入式系统开发概述</h5><p>嵌入式系统的软件开发采用交叉平台开发方法（Cross Platform Development），即软件在一个通用的平台上开发，而在另一个嵌入式目标平台上运行。这个用于开发嵌入式软件的通用平台通常叫做宿主机系统，被开发的嵌入式系统称为目标机系统。而当软件执行环境和开发环境一致时的开发过程则称为本地开发（Native Development）。</p>
<h5 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h5><p>在嵌入式系统的实际开发实践中，经常采用的调试方法有直接测试法、调试监控法、在线仿真法、片上调试法及模拟器法等。</p>
<h5 id="开发环境分类"><a href="#开发环境分类" class="headerlink" title="开发环境分类"></a>开发环境分类</h5><p>嵌入式系统的开发环境可以分为如下几类。</p>
<p>（1）与嵌入式操作系统配套的开发环境。</p>
<p>（2）与处理器芯片配套的开发环境。</p>
<p>（3）与具体应用平台配套的开发环境。</p>
<p>（4）其他类。</p>
<h5 id="开发环境举例"><a href="#开发环境举例" class="headerlink" title="开发环境举例"></a>开发环境举例</h5><p>目前业界应用最广泛的集成开发环境为Tornadoll，美国WindRiver公司的VxWorks操作系统是Tornadoll嵌入式开发环境的关键组成部分。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch18-%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch18-%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch18-面向方面的编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:57:48" itemprop="dateCreated datePublished" datetime="2021-07-19T12:57:48+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 16:34:09" itemprop="dateModified" datetime="2021-09-04T16:34:09+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="面向方面的编程"><a href="#面向方面的编程" class="headerlink" title="面向方面的编程"></a>面向方面的编程</h2><p>随着计算机越来越广泛地应用于社会各个行业，应用软件的规模不断扩大，复杂度不断提高。传统的软件开发方法，如过程化程序设计、面向对象程序设计等已渐渐不能适应这种变化。近年来，一种新的程序开发方法——AOP（Aspect Oriented Programming，面向方面编程）引起了国内外的广泛关注，并被《MIT技术评论》杂志评为21世纪10种对经济和人类生活工作方式最具影响力的技术之一。</p>
<ul>
<li>切面相当于装饰器</li>
</ul>
<h3 id="方面编程的概念"><a href="#方面编程的概念" class="headerlink" title="方面编程的概念"></a>方面编程的概念</h3><h4 id="AOP产生的背景"><a href="#AOP产生的背景" class="headerlink" title="AOP产生的背景"></a>AOP产生的背景</h4><h5 id="面向过程编程面临的问题"><a href="#面向过程编程面临的问题" class="headerlink" title="面向过程编程面临的问题"></a>面向过程编程面临的问题</h5><p>面向过程编程是一种自顶向下的编程方法，其实质是对软件进行功能性分解。它适用于小型软件系统，例如某一算法的实现。在大型应用系统中，自顶向下逐步求精的方法无论在系统体系结构的确立，系统的进化和维护，以及软件重用性方面都存在其不足之处。</p>
<h5 id="传统面向对象编程面临的问题"><a href="#传统面向对象编程面临的问题" class="headerlink" title="传统面向对象编程面临的问题"></a>传统面向对象编程面临的问题</h5><p>传统的面向对象语言由于其良好的封装性、层次化性以及继承性等特性而取得了很大的成功，并且对象模型可以很好地映射到实际领域。但是，在软件的生命周期中，它存在以下不足之处。</p>
<p>（1）设计阶段，由于以类为单位组织建模，因此它不能全面地反映软件系统的需求。</p>
<p>（2）编码阶段，将数据和方法封装到类中的思想增强了数据的安全性和软件的模块化，但是有一些数据和方法是特定于应用的，因此这种编码阶段的封装减少了代码重用的可能性。</p>
<p>（3）维护阶段，由于类中夹杂了各种特定于应用的代码，使得维护人员难以理解代码。此外，完成某个特定需求的代码分散在各个类中，当这些代码需要改变时，很难把它们全部找到，这就给程序的健壮性带来了隐患。</p>
<p>由于上述这些问题的产生，需要一种新的程序设计方法从更高的层次上对软件系统进行抽象，将传统的按功能或按对象划分程序模块的方法转化为按系统特征划分程序模块，这就是AOP的基本思想。</p>
<h5 id="AOP的产生"><a href="#AOP的产生" class="headerlink" title="AOP的产生"></a>AOP的产生</h5><p>在1997年的欧洲面向对象编程大会（ECOOP97）上，施乐公司Palo Alto研究中心首席科学家、大不列颠哥伦比亚大学教授Gregor Kiczales等人首次提出了AOP的概念，此后每年的ECOOP上都有AOP相关的专题研讨会，各大公司、大学、研究机构纷纷投入人员进行研究。2001年3月15日，Palo Alto研究中心发布了首种支持AOP的语言AspectJ。</p>
<h4 id="面向方面的原因"><a href="#面向方面的原因" class="headerlink" title="面向方面的原因"></a>面向方面的原因</h4><p>为了理解和完成一个复杂的程序，通常要把程序划分为若干较小的子程序。理想的划分准则已成为众多研究的题目——这些研究的目标对开发人员在程序的设计、发展、维护和更新方面有所帮助。</p>
<p>当一个程序按实现过程编写时，应用程序依照实现的行为和步骤模块化。当使用面向对象的方法时，程序的模块化组则基于类中封装的数据。两种情况下，某些操作较难实现模块化。我们称涉及到这些操作的代码是分散的。</p>
<h5 id="代码分散现象"><a href="#代码分散现象" class="headerlink" title="代码分散现象"></a>代码分散现象</h5><p>无论是使用面向对象程序设计还是其他方法，代码分散的问题与特定的程序设计语言没有关系，且其影响已经在大量的应用程序中表现出来。事实上，代码分散可能出现在任何编程环境——从J2SE或J2EE下的Java，到.NET下的C#，到其他语言。但对此现象最广泛的研究是用Java实现的。</p>
<p>例如，AspectJ小组分析了Tomcat服务器的容器。他们认识到，如果像URL模式匹配和XML分析这些操作在一个或两个类中完全模块化，其他操作会高度分散在引用程序中，例如日志功能和对使用者通信的管理。</p>
<h5 id="关于代码分散的分析"><a href="#关于代码分散的分析" class="headerlink" title="关于代码分散的分析"></a>关于代码分散的分析</h5><p>知道了代码分散的出现，那么是否可以不同地组织类的结构或用其他方法设计程序来消除这个问题呢？</p>
<p>代码分散现象发生的主要原因与服务的可用方式和其使用方式的不同有关。一个类通过它的方法提供一个或多个服务。在同一个类中，聚集可用的服务是相对容易的。然而，一旦这些服务被若干个类所使用，将对这些方法的调用聚集在一起并重新构建这个应用程序会变得困难。因此，一个基本的服务在应用程序中到处被调用就没有什么奇怪的了。</p>
<p>代码分散现象在所有复杂程序中都会表现出来。然而，它的出现实际上依赖于一个具体的问题，代码分散问题很难去除。</p>
<p>应用程序中的代码分散减慢了程序的发展、维护和更新的速度。当若干个操作被分散，情况就会变得更复杂，因为代码包含了许多对多种关系的调用，这些关系逻辑上联系松散但需要结合在一起。</p>
<h5 id="一个模块化的新因素"><a href="#一个模块化的新因素" class="headerlink" title="一个模块化的新因素"></a>一个模块化的新因素</h5><p>AOP主要的贡献在于在某一方面提供了一种融合代码的方式——否则这些代码会分散在整个应用程序中。</p>
<p>方面的定义：一个设计来用于捕捉应用程序横切面功能的程序单位。</p>
<p>一个方面通常描述为一个横切程序的结构。实际上，方面这个概念的发明者Gregor Kiczales提到，“AOP是用来捕捉一个横切的结构。”</p>
<p>方面的定义几乎和类一样普通。当对一个问题建模时，人们用类来表示对象（顾客、命令和供应者等）的种类，且每个对象包含适当的数据（属性）和过程（操作）。同样地，方面用于实现一个应用程序中的功能性（安全性、持续性、日志记录等等），而这些功能性要求同样的数据和处理。使用AOP时，一个应用程序包含各个类和方面。方面与类的不同在于它实现了横切程序的功能。在面向过程和面向对象的案例中，横切的功能就是那些遍及应用程序的代码。程序中包括类和方面意味着模块性可以在两个因素上实现：类实现基本的功能性（这个因素叫做结构性），方面实现横切的功能性（这个因素叫做可操作性）。</p>
<p>图18-1说明了方面在应用程序的代码优化上的作用。图18-1（a）表现了一个含有三个类的程序。水平线表示代码行相应的横切的功能性，如日志功能。这种功能横切整个应用程序，因其可影响所有类。图18-1（b）显示使用了方面处理日志功能的同样的程序（带阴影的矩形）。实现这个功能的代码已完全被这个方面所包含，而类则与这些代码分离了。用这种方法设计的程序比没用使用方面的程序容易编写、维护和改编。</p>
<details><summary>图18-1　横切功能中方面的影响</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904155143.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904155143.png';" /></details>


<h5 id="横切功能的综合"><a href="#横切功能的综合" class="headerlink" title="横切功能的综合"></a>横切功能的综合</h5><p>方面由两个部分组成：切入点和通知代码。</p>
<p>通知代码包括要执行的代码，切入点定义了程序中要执行的代码处的点。</p>
<p>显然，方面所包含的代码（或更准确地说，通知代码）依赖于你所要执行的操作。例如，若你想保证数据的持久性，需要在数据库编写保存数据的代码。虽然可以根据基本原理编写这些代码，但你极少会这样做。通常认为的良好的习惯做法是使用一个专门的API，例如Hibernate，通过这种类型的框架，这个方面的代码只是调用了API。这种工作方式意味着方面并不需要知道服务是怎样执行的，因而方面就与一个特定的执行独立了。</p>
<p>根据这种最优方法，一个方面只允许你整合一个贯穿程序的功能到程序中，这个功能利用一个专门的API执行。在图18-2中，方面PersistenceAspect使用Hibernate整合维持数据持续性的功能到类1和类3中。</p>
<details><summary>图18-2　使用方面实现横切的数据持续性功能的综合</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904155215.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904155215.png';" /></details>

<p>严格地说，一个方面并不直接执行一个横切程序的功能，而是使用了一个专门的API去实现。但为了使这方面的知识容易理解，仍可以说一个方面执行了一个横切程序的功能。</p>
<h5 id="非功能的服务和方面"><a href="#非功能的服务和方面" class="headerlink" title="非功能的服务和方面"></a>非功能的服务和方面</h5><p>大多数应用程序有两种考虑：商业的和非功能的。商业的考虑，也叫做功能上的需求，符合真实世界需要建模的行为。非功能的考虑，或非功能的需求，是附加的服务，这些服务是应用程序必须执行的——事实上，这是出于技术上的或系统级上的考虑。例如，在一个管理人力资源的应用程序中，添加和删除雇员的功能是出于商业上的考虑，而程序安全性和权限的问题是非功能的。</p>
<p>无论如何，在利用这种差别的时候要仔细，因为一个服务可以在一个程序中是非功能性的，但在另一个程序中却是功能性的。很多情况下，非功能性的服务会被遍及各处的商业层面上的代码调用。因此，非功能性的服务在AOP中会像方面一样实现，而商业的考虑则会向类一样实现。然而某些情况下，商业的考虑也可能横切程序——使其适合像方面一样实现。</p>
<h5 id="依赖性的颠倒"><a href="#依赖性的颠倒" class="headerlink" title="依赖性的颠倒"></a>依赖性的颠倒</h5><p>在面向对象或程序化编程中，一旦程序从API使用一个技术服务，设备与服务之间的一种依赖性就建立了，每个程序对API外在的调用会发生一种联系。当API改变了或它的语义发展了，整个程序中对它服务的调用就必须作出改变。这种修改有可能是非常昂贵的——尤其是当API被用在程序中众多不同的地方时。</p>
<p>另外，要使用API还需要理解它的主要原理。要知道应调用什么方法，应按什么顺序调用，应传递哪些参数等。非功能的服务要被包含进每个开发它的新程序中。所以，即使API只开发一次，它可能要包含进许多不同的应用程序中。</p>
<p>通过使用AOP，程序的开发者并不需要担心非功能的服务。方面开发者除了编写提供服务的代码外，还要管理程序中服务的融合。方面开发者的优势在于，专门的方面开发者比一般的程序开发者对服务有着更好的了解，而一般的程序开发者只是API的使用者。特别地，方面开发者能确定通过实现服务使用方式的某些约束，使服务的融合是合适的。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ivan820819/article/details/79744797">浅谈IOC—说清楚IOC是什么</a></li>
</ul>
<h4 id="AOP技术"><a href="#AOP技术" class="headerlink" title="AOP技术"></a>AOP技术</h4><p>AOP可以说是OOP（Object-Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当需要为分散的对象引入公共行为时，OOP则显得无能为力。也就是说，OOP允许定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能，日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为Aspect，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却被业务模块所共同调用的逻辑或责任封装起来，以减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为，那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天工的妙手将这些剖开的切面复原，不留痕迹。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似，例如权限认证、日志、事务处理。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>
<p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。然而殊途同归，实现AOP的技术特性却是相同的。</p>
<p>（1）join point（连接点）：是程序执行中的一个精确执行点，例如类中的一个方法。它是一个抽象的概念，在实现AOP时，并不需要去定义一个join point。</p>
<p>（2）point cut（切入点）：本质上是一个捕获连接点的结构。在AOP中，可以定义一个point cut，来捕获相关方法的调用。</p>
<p>（3）advice（通知）：是point cut的执行代码，是执行“方面”的具体逻辑。</p>
<p>（4）aspect（方面）：point cut和advice结合起来就是aspect，它类似于OOP中定义的一个类，但它代表的更多的是对象间横向的关系。</p>
<p>（5）introduce（引入）：为对象引入附加的方法或属性，从而达到修改对象结构的目的。有的AOP工具又将其称为mixing。</p>
<p>上述的技术特性组成了基本的AOP技术，大多数AOP工具均实现了这些技术。它们也可以是研究AOP技术的基本术语。</p>
<h4 id="AOP特性"><a href="#AOP特性" class="headerlink" title="AOP特性"></a>AOP特性</h4><p>衡量软件质量高低的要素主要包括可靠性、可扩展性、可重用性、兼容性以及易用性、易维护性等。AOP作为一种程序设计方法学，关注于提高软件的抽象程度和模块性，从而在很大程度上改善了软件的可扩展性、重用性、易理解性和易维护性，并由此提高影响软件质量的其他因素。下面通过对OOP和AOP在提高软件可扩展性、可重用性和易理解性、易维护性等方面的能力比较来阐述AOP特性。</p>
<p>（1）可扩展性：指软件系统在需求更改时程序的易更改能力。OOP主要通过提供继承和重载机制来提高软件的可扩展性，因此它的扩展性体现在类一级。AOP提供系统的扩展机制，通过扩展Aspect（AspectJ支持Aspect的继承机制）或增加Aspect，系统相关的各个部分都随之产生变化。由此带来的另一好处是在软件测试中，通过屏蔽某些Aspect，可以大大简化软件的测试复杂度，提高测试精度。</p>
<p>（2）可重用性：是指某个应用系统中的元素被应用到其他系统的能力。OOP的类机制作为一种抽象数据类型，提供了比过程化更好的重用性。泛化机制也使可重用性得到很大提高。OOP所提供的重用性对非特定于系统的功能模块有很好的支持，如对于堆栈的操作或窗口机制的实现等。但在特定于系统的功能模块中，一个类通常包含很多应用系统相关的数据及对其的操作，此时类的重用性变得十分困难。此外，OOP的重用性也限于类一级，对于不能封装成类的元素，如异常处理等，很难实现有效的重用。AOP中的系统模块包括系统组件和影响这些组件的特性，通过将实现基本功能的组件和特定于应用的系统特性分离，使得组件（包括类或者函数）的重用性得到提高，并使不能封装为类或函数的系统元素（Aspect）的重用成为可能。</p>
<p>（3）易理解性和易维护性：是影响软件质量的内在因素，它对软件开发人员和维护人员产生影响。在OOP中，类机制的引入使其具有比过程化编程更好的模块性，因此也更易于被程序员理解和维护。但是如上所述的代码缠结问题的存在，使OOP技术在易理解性和易维护性方面都难有更大的提高。Kiczales经过统计发现：“如果一个他人写的程序有37处需要改动，对于一个最优秀的软件开发人员，也大概只能找到35个”。而对于AOP，对一个aspect的修改可以通过联结器影响到系统相关的各个部分，从而大大提高了系统的易维护性。另外，对系统特征的模块化封装无疑也能提高程序的易理解性。</p>
<h4 id="AOP程序设计"><a href="#AOP程序设计" class="headerlink" title="AOP程序设计"></a>AOP程序设计</h4><h5 id="AOP程序结构"><a href="#AOP程序结构" class="headerlink" title="AOP程序结构"></a>AOP程序结构</h5><p>基于AOP的应用程序结构与传统高级语言的应用程序结构基本类似。传统的高级语言系统实现由以下三部分组成。</p>
<p>（1）一种编程语言。</p>
<p>（2）特定于这种语言的编译器。</p>
<p>（3）利用这种语言编写的应用程序。</p>
<p>基于AOP的系统实现也有以上三个主要部分，但由于AOP中有了动态aspect的概念，因此可进一步细化为如下部分。</p>
<p>（1）一种组件语言，一种或多种aspect语言。</p>
<p>（2）一个用来合并两者的aspect编织器（weaver）。</p>
<p>（3）利用组件语言实现的系统组件，利用aspect实现的aspect组件。</p>
<h5 id="AOP的程序设计步骤"><a href="#AOP的程序设计步骤" class="headerlink" title="AOP的程序设计步骤"></a>AOP的程序设计步骤</h5><p>AOP应用程序包括以下三个主要的开发步骤。</p>
<p>（1）将系统需求进行功能性分解，区分出普通关注点以及横切关注点，确定哪些功能是组件语言必须实现的，哪些功能可以以aspect的形式动态加入到系统组件中。</p>
<p>（2）单独完成每一个关注点的编码和实现，构造系统组件和系统aspect。这里的系统组件，是实现该系统的基本模块，对OOP语言，这些组件可以是类；对于过程化程序设计语言，这些组件可以是各种函数和API。系统aspect是指用AOP语言实现的将横切关注点封装成的独立的模块单元。</p>
<p>（3）用联结器指定的重组规则，将组件代码和aspect代码进行组合，形成最终系统。为达到此目的，应用程序需要利用或创造一种专门指定规则的语言，用它来组合不同应用程序片断。这种用来指定联结规则的语言可以是一种已有编程语言的扩展，也可以是一种完全不同的全新语言。将以上过程用图18-3的形式来表示，该图中将系统需求看作一束光线，需求光束通过可标识关注点的棱镜将每个关注点区分开，形成单独关注点的实现，最后通过另一个Weaver棱镜将这些关注点整合，形成最终的应用程序。</p>
<details><summary>图18-3　AOP系统开发过程示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904155824.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904155824.png';" /></details>

<h4 id="AOP的优势"><a href="#AOP的优势" class="headerlink" title="AOP的优势"></a>AOP的优势</h4><p>面向方面的技术具有很多潜在的优势，它为在系统中详细指定并封装横切点提供了方法。随着它们的发展，允许我们更好地进行系统维护。AOP还将使我们对现存系统以一种有组织的方式增加新的特点。表达及结构方面的提高允许我们保持系统运行更长的时间，并且不会带来完全改写的开销就可以增量地对其维护。</p>
<p>AOP还是质量专业人员工具箱的利器。使用AOP语言，可以自动测试应用程序代码而不会对代码带来干扰。这将消除可能的代码错误。</p>
<p>在理解AOSD（方面面向软件设计）全部潜能中我们还处于一个初始阶段。显然，这项技术为保证未来的探索与实验提供了足够多的优点。距离每日使用AOP语言进行应用程序开发还有多远？这取决于我们向谁询问这个问题。</p>
<p>现在已经看到了一些优点，下面来看一些关于AOSD的风险，以及将其引入软件开发主流所需要的东西。</p>
<h5 id="质量及风险"><a href="#质量及风险" class="headerlink" title="质量及风险"></a>质量及风险</h5><p>基于从质量的角度所做出的考察以及所完成的对AspectJ的探索，我已经看到了伴随着优点所带来的潜在风险。下面将讨论三个问题，以说明随着AOSD越来越普遍所带来的我们需要面对的关于质量的问题。</p>
<p>（1）如何修正我们的过程来适合AOP。最有效的探测软件缺陷的技术之一是通过代码检查及复审。在复审中，一组程序员评论代码，以决定其是否满足了需求。在面向对象程序设计中，可以对类或一组相关类进行复审，并进行推论。可以查看代码并确定其是否正确处理了意料之外的事件，是否具有逻辑上的缺陷等。在OO系统中，每个类完全封装了特定概念的数据以及行为。</p>
<p>但是，在AOP中，仅仅通过代码查看，我们不再能够进行推论。我们并不知道代码是否被来自某些方面的通知所增长，或是完全被这种通知所取代。为了能够对应用程序代码做推断，我们必须能够查看来自每个类的代码，以及能够影响这个类行为的任何一个方面的代码。但是，也许这些方面还没有被编写出来。如果这样，那么当我们孤立地考虑它的时候，我们实际上能够对这个应用程序类的代码行为理解多少呢？</p>
<p>实际上，考虑AOP代码正确性的方法与我们考虑面向对象的程序设计代码是相反。在OOP中，我们自内向外：我们考虑一个类，对它的上下文环境做假设，然后通过孤立的以及按照它如何与其他类交互的两种方式推断它的正确性。在AOP中，需要从外向内来看，并确定在可能的连接点上每个方面的效果。确定如何才能正确推断AOP，以及开发适宜的技术和工具来帮助我们是一个值得研究的领域。</p>
<p>（2）测试工具以及技术的开发，特别是单元测试。由于代码可以被某一个方面所改变，当一个可以完美运行的单元测试的类被集成入一个AOP系统中时，可能会出现完全不同的运行状况。下面的例子说明了这一点。</p>
<p>例如，堆栈是一种数据结构，被用来以后进先出的模式增加或移除条目。如果向堆栈压入数据2、4、6，然后弹出栈两次，将按照顺序得到6与4。可以很直观地写出对堆栈类的单元测试，并能够很好地保证实现是正确的。但当用AspectJ实现了一个简单的改变——对每个条目做增一操作时，向栈上压入2、4、6，然后从栈顶弹出两个元素。单元测试的代码并没有改变，但是行为改变了。不再是6和4，而是变成了7和5。</p>
<p>这是一个很小的例子，在真实环境中不太可能发生，但是它显示了一个恶意的程序员可以很容易地导致许多损害。即使我们忽略这种恶意的程序员，由于我们所做出的改变存在着许多副作用，许多错误仍然可能发生。要保证一个为非常有效推断所实现的方面不会对现存程序功能带来多余的效果是非常困难的。</p>
<p>（3）测试过程本身。一旦我们有了一组工具及技术，如何修改我们的测试过程以有效地使用它们并且能够支持我们整体的开发目标？虽然这个问题也许并不是一个主要的问题，我仍然相信在我们可以真正地对采用方面所构件的软件进行很好的测试以前需要解决它。</p>
<p>对AOSD采用的其他障碍</p>
<p>质量问题也许是对AOSD方法采用的最大阻碍，但是它们并不是唯一的。AOSD是一种新的范例。正如其他范例一样，当它们刚刚出现时（例如面向对象的软件开发），由于所包含的学习曲线，需要经历一段时间才能被广泛采用。首先，我们需要学习基本技术以及结构，然后是高级技术，再然后是如何更好地应用技术以及什么时候它们才是最适合的。</p>
<p>工具在AOP中具有很重要的地位。除了编译器以及编辑器之外，我们需要能够帮助我们推断系统，确定潜在横切关注点，以及能够帮助我们对所存在的方面进行测试的工具。例如在UML中描述方面，我们的工具必须发展以支持这些方法。</p>
<p>此外，其他类似于AOP的范例也正在出现中。例如，关注点范例的多维分离，已在IBM研究院处于发展中（<a target="_blank" rel="noopener" href="http://www.alphaworks.ibm.com/tech/hyperj）。任何对新范例的使用都是有风险的，直至对你所使用语言的标准实现被建立起来。例如，AspectJ是一个仍然发展的AOP实现。风险是，也许你开发了合并入横切点的软件，你的实现方案或者将不再被支持，或者要做很大的改动。">http://www.alphaworks.ibm.com/tech/hyperj）。任何对新范例的使用都是有风险的，直至对你所使用语言的标准实现被建立起来。例如，AspectJ是一个仍然发展的AOP实现。风险是，也许你开发了合并入横切点的软件，你的实现方案或者将不再被支持，或者要做很大的改动。</a></p>
<h5 id="向构建软件的更好方法前进"><a href="#向构建软件的更好方法前进" class="headerlink" title="向构建软件的更好方法前进"></a>向构建软件的更好方法前进</h5><p>很显然，我们具有一种能够为使AOP对日常应用可行化而开发工具与过程的方法。但是，这里讨论的任何问题不代表不可克服的困难。当为AOP开发出经得起考验的一组工具与流程时，可以找到比今天所做的更好的构建软件的方法。</p>
<p>正如Barry M. Boehm所述的关于敏捷流程，我们必须小心的采用AOP。无论是作为早期应用者或是等待这种技术成为主流，都需要确保软件投资者在今天或是未来能够提供可接受的回报，这是非常好的商业判断力。</p>
<h4 id="当前的AOP技术"><a href="#当前的AOP技术" class="headerlink" title="当前的AOP技术"></a>当前的AOP技术</h4><p>当前，各种AOP技术层出不穷，其中相当成熟完善适用于商业开发的AOP技术主要包括AspectJ、AspectWerkz、JBoss AOP和Spring AOP，这些皆适合用于商业开发中的开源项目。AOP是一种概念，不同的技术可以有不同的实现。</p>
<p>在语法方面，AspectWerkz、JBoss AOP和Spring AOP都在没有改变Java语言语法的情况下加入了方面语义，而AspectJ则对Java语言进行了扩展。</p>
<p>在声明方式方面，AspectJ在代码中对方面进行声明。AspectWerkz和JBossAOP支持用元数据对Java代码进行注释，或者在独立的XML文件中对方面进行声明。在SpringAOP中，则完全用XML对方面进行声明，比起JBossAOP和AspectWerkz，SpringAOP提供了更加精细的配置。</p>
<p>在性能方面，AspectJ通过编译时对目标二进制类的增强获得面向方面能力，所以在编译时会带来开销，运行时可获得更快的速度。JBossAOP和SpringAOP基于拦截技术则在运行时有更多的工作要做，对比之下，AspectJ的构建时开销最多，AspectWerkz次之，JBossAOP再次，SpringAOP没有构建时开销。</p>
<p>下面将重点介绍AspectJ和SpringAOP的概念构造与实践。</p>
<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><h4 id="AspectJ概述"><a href="#AspectJ概述" class="headerlink" title="AspectJ概述"></a>AspectJ概述</h4><p>AspectJ既是一个语言规范，又是一个AOP语言实现。语言规范部分定义了多种语言构造以及它们支持面向方面范型的方式；语言实现部分则提供了编译、调试及从代码生成文档的工具。</p>
<p>AspectJ的语言构造是从Java语言中扩展而来的，因此所有合法的Java程序也都是合法的AspectJ程序。AspectJ编译器生成的是符合Java字节码规范的．class文件，这使得所有符合规范的Java虚拟机都可以解释、执行其所生成的代码。通过选择Java为基础语言，AspectJ继承了Java的所有优点并使Java程序员能够比较容易地上手。</p>
<p>AspectJ还提供了许多有用的工具。它有一个方面编织器（以编译器的方式）、一个调试器、文档生成工具以及一个独立的可用来以可视化的方式观察通知是如何切入系统各部分的方面浏览器。另外，AspectJ还提供了与流行IDE的集成，如Sun公司的Forte、Borland公司的JBuilder以及Emacs等，这使得AspectJ成为一个很有用的AOP实现，特别是对Java开发者而言。</p>
<h4 id="AspectJ语言概念和构造"><a href="#AspectJ语言概念和构造" class="headerlink" title="AspectJ语言概念和构造"></a>AspectJ语言概念和构造</h4><h5 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h5><p>连接点是AspectJ中的一个重要概念，它是程序执行过程中明确定义的点。连接点可能定义在方法调用、条件检测、循环的开始或是赋值动作处。连接点有一个与之相关联的上下文。例如，一个方法调用连接点的上下文可能会包含一个目标对象及调用参数等。</p>
<p>虽然程序执行过程中所有可以确认的点都可以是连接点，但并不是每个点都是有用的。在AspectJ中，有下列可用的连接点。</p>
<p>（1）方法的调用（call）和执行（execution）。</p>
<p>（2）构造器（constructor）的调用和执行。</p>
<p>（3）对属性（field）的读/写访问。</p>
<p>（4）异常处理的执行。</p>
<p>（5）对象和类的初始化执行。</p>
<p>AspectJ中没有提供在像if条件检查或for循环这样细粒度语言构造上的连接点。</p>
<h5 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h5><p>切入点是用来指明所需连接点的程序构造，可以用它来指明一系列的连接点。同时，它还可以为在连接点上执行的通知提供上下文信息。例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160125.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160125.png';" /></details>


<p>其中，pointcut关键字表明其后是一个命名的切入点的声明。接着，callSayMessagc()是切入点的名字，这与方法声明类似。其后的空括号表明此切入点不需要上下文信息。</p>
<p>再往后，call (public static void HelloWorld.say<em>(…)) 捕获所需的连接点。call表明此切入点捕获对指定方法的调用，而不是方法的执行或是别的什么。public static void HelloWorld.say</em>(…) 是将会产生影响的方法的签名。void是说所捕获的方法必须要有一个void返回类型。HelloWorld.say<em>指明将要捕获的方法的类和名字。这里，我们指定HelloWorld类；say</em>使用通配符，来说明要捕获的方法应以say开始。最后，（…）指明了将要捕获的方法的参数列表。这里使用了“…”，表示任何形式的参数列表都在考虑范围之内。</p>
<p>现在，你已经知道了如何指定切入点来捕获连接点，下面再来看一下其他的切入点类型。</p>
<p>1）方法调用和构造器调用切入点</p>
<p>方法调用和构造器切入点捕获执行中准备好了方法参数后而尚未执行方法本身时的那个点。它们的形式是call（方法或是构造器的签名）。</p>
<p>2）方法执行和构造器执行切入点</p>
<p>方法执行和构造器执行切入点捕获方法的执行，与调用切入点相比，执行切入点体现在方法和构造器本身。其形式为execution（方法或是构造器的签名）。</p>
<p>3）属性访问切入点</p>
<p>属性访问切入点捕获对一个类中属性的读写访问。可以捕获所有对System类中的out属性的访问，如System.out；也可以仅捕获读访问或写访问。举个例子来说，可以捕获对MyClass的属性x的写访问，其形式为MyClass.x=5。读访问切入点的形式为get（FieldSignature）；写访问切入点的形式则为set（FieldSignature）。其中FieldSignature可以用与调用或执行切入点里的McthodOrConstructor同样的方式使用通配符。</p>
<p>4）异常处理切入点</p>
<p>异常处理切入点捕获特定类型异常处理的执行，其形式为handler（ExceptionTypePattern）。</p>
<p>5）类初始化切入点</p>
<p>类初始化切入点捕获类初始化部分中静态部分的执行，这里静态部分是指类定义中Static代码块中指定的代码。其形式为staticinitialization（TypePattarn）。</p>
<p>6）基于语法结构的切入点</p>
<p>基于语法结构的切入点捕获一个类或方法中所有语法结构里的连接点。捕获类（包括内部类）中的语法结构连接点的切入点形式为within（TypePattern），捕获类方法或类构造器中的语法结构连接点的切入点形式为withincode（Method-OrConstructor-Signature）。</p>
<p>7）基于控制流的切入点</p>
<p>基于控制流的切入点捕获所有指定范围的控制流（程序的指令流）内的连接点。例如，在某个执行过程里，方法a调用方法b，方法b就在方法a的控制流里。通过使用基于控制流的切入点，可以捕获由于一个方法调用而引发的所有方法调用、属性访问及异常处理等。这种类型的切入点可捕获在其控制流内的其他切入点，如果包括其自身，形式为cflow（pointcut）；如果不包括其自身，则形式为cflowbelow（Pointcut）。</p>
<p>8）基于当前对象、目标对象及参数类型的切入点</p>
<p>此类切入点可捕获定义在对象自身、目标对象或参数上的连接点。它是唯一可以在连接点上取得上下文的语言构造，捕获基于当前对象的连接点的切入点形式为this（TypePattern或Objecctldentifier），捕获某个目标对象的连接点的切入点形式为target（TypePattern or ObjectIdentifier），基于参数的切入点形式为args （TypePattern orObjectIdentifier，…）。</p>
<p>9）条件测试切入点</p>
<p>这种切入点基于某种条件测试捕获连接点，其形式为if（BooleanExpression）。</p>
<h5 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h5><p>通知指定当到达特定切入点处应执行的代码。AspectJ提供了三种把通知关联到连接点的方式：before、after及around。before通知在连接点的前面运行；after通知在连接点的后面运行。对于after通知而言，还可以指定是在正常返回后运行还是在抛出异常后运行，或者也可以是两种情况下都运行。around通知包在连接点的外面，并有权决定是否运行此连接点，还可以在此处修改连接点上下文环境。</p>
<h5 id="方面"><a href="#方面" class="headerlink" title="方面"></a>方面</h5><p>方面是AspectJ的模块单元，其地位就像是Java里的类。它把切入点和通知包在一起。和类相似，方面也可以包含方法和属性、从其他类或方面扩展以及实现接口等。与类不同的是，不能用new来建立一个方面实例。</p>
<p>AspectJ允许在类中声明切入点，但在类中只能声明static的切入点。而且AspectJ不允许类里包含通知，只有方面可以包含通知。</p>
<p>方面可以标记其自身和任何切入点为抽象的（abstract）。抽象的切入点，其概念与抽象类相似，允许把细节实现推迟到派生方面里。一个具体的方面可以从抽象的方面扩展而来，它要提供抽象方面里切入点的具体定义。</p>
<h4 id="AspectJ实践"><a href="#AspectJ实践" class="headerlink" title="AspectJ实践"></a>AspectJ实践</h4><p>AspectJ也许是已知最好的，并且应用最广泛的AOP实现。</p>
<p>图18-4描述了一种可以进行系统修正的方法。金融系统具有一个接口以及数个方法以更新雇员金融数据。方法名均以单词update开头（例如，updateFederalTaxlnfo），并且每个金融更新均以雇员对象做实参。雇员个人信息也通过雇员对象，使用图10-5所示的方法做更新。</p>
<p>我们的任务是，每一次当调用任何更新函数，或是更新成功完成后，写入一个日志消息。为了简单起见，我们说我们向标准输出打印了一个日志消息。在实际系统中，我们将写入一个日志文件。下面将通过三个步骤采用AspectJ实现我们的解决方案。</p>
<p>确定在代码中需要插入日志代码的位置。这被称作在AspectJ中定义连接点，编写日志代码，编译新代码并将其编织入系统中。下面详细描述每一个步骤。</p>
<h5 id="定义连接点"><a href="#定义连接点" class="headerlink" title="定义连接点"></a>定义连接点</h5><p>一个连接点是在代码中被良好定义的，我们所关注的应用程序横切的点。典型的，对每一个关注点存在着许多连接点。如果仅有一两个，通过很少的努力，就可以手工改写代码。</p>
<details><summary>图18-4　与更新雇员信息相关的类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160255.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160255.png';" /></details>

<p>在AspectJ中，通过将连接点分组为切点对其进行定义（AspectJ的语法十分丰富，我们将试图在此对其进行完整的描述）。初始，定义两个切点，分别将雇员类及IEmployeeFinance组件中的连接点分组。下列代码定义了这两个切点。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160314.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160314.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160321.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160321.png';" /></details>

<p>第一个切点称作employeeUpdates，描述了我们调用雇员对象中以字符串update开头，以字符串Info结尾，且无实参的方法的连接点位置，它还通过target指示器明确指定了在雇员类中定义的方法。第二个切点employeeFinanceUpdates，描述了所有以update开头，以Info结尾的，具有一个Employee类型实参的方法的调用点。合起来，这两个切点定义了所有我们关注的连接点。如果要为雇员类或IEmployeeFinance组件增加更多的更新方法，只要保持同样的命名规则，对它们的调用会自动被包含于切点中。这意味着当每次增加更新方法时，不需要特意地去包含日志代码。</p>
<h5 id="编写日志代码"><a href="#编写日志代码" class="headerlink" title="编写日志代码"></a>编写日志代码</h5><p>实现日志的代码与Java中其他任何方法都很相似，但是被置于一个称作方面的新风格中。方面是用来对与某一特定关注相关联的代码进行封装的一种机制。对雇主数据变更日志的方面实现如下所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160353.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160353.png';" /></details>

<p>首先，注意到方面的结构与Java中的类结构很相似。典型地，方面被置于它独有的文件中，正如Java的类一样。虽然通常的方法是在方面代码中包含以往定义的切点，但是也可以将它们更紧密地包括在含有切点的代码中。</p>
<p>在切点之后，有一段与常规Java代码中方法相似的代码，这被称作AspectJ中的通知。存在着三种不同类型的通知：before、after和around。它们分别在连接点之前、之后，或是取代连接点而执行。还存在着许多可以使用的变种以定制你自己的通知。在我们的例子中，选择连接点返回中的更新方法之后立即运行日志。还要注意到，我们通过在冒号之后的通知头中立即分别对它们命名，以及通过逻辑“或”的方式组合两个切点。因为每个切点都有一个雇员参数，因此可以很容易地完成这项工作。</p>
<p>随着雇员名字，通知中的两条语句打印出了雇员信息被改变的事实。既然受到影响的雇员对象作为实参被传递给通知，那么这很容易安排。第二条语句指明了通知被执行的确切连接点，并且应用了AspectJ的JoinPoint类。只要通知执行，仅存在一个被thisJoinPoint引用的关联连接点。</p>
<h5 id="编译及测试"><a href="#编译及测试" class="headerlink" title="编译及测试"></a>编译及测试</h5><p>现在，已经编写了日志代码，接下来需要编译并将其集成入现存的系统。为了方便起见，已经实现了两个类：Employee和EmployeeFinance。我们还拥有一个具有主函数的简单测试类，如下所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160416.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160416.png';" /></details>

<p>这个代码不需要任何AOP实现就可以很好地运行。为了我们的例子，所有更新方法的函数体仅包含一个打印语句。当运行这个例子时，得到如下输出：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160434.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160434.png';" /></details>

<p>为了将我们的方面合并入系统，我们向项目中增加了方面的源代码，并且采用AspectJ编译器，ajc进行编译。编译器接受每一个方面，并建立包含通知代码的类文件。然后，在这些类文件中对适当方法的调用被编织入原始应用程序代码。在当前AspectJ的发行版中，这种编织在Java字节码级别发生，因此不存在可以进行查阅以对最终代码进行审查的中间源文件。但是，如果你很好奇，可以对Java字节码进行反编译。</p>
<p>在开发中，我使用Eclipse，而AspectJ插件保证采用正确的实参调用编译器。一旦利用AspectJ编译器对项目进行了编译，得到如下输出：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904162920.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904162920.png';" /></details>

<p>现在，我们知道哪个雇员信息被改变，以及改变是在哪里发生的。当然，日志可以更精细，但是基本的方法没有变化。</p>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="Spring-AOP概述"><a href="#Spring-AOP概述" class="headerlink" title="Spring AOP概述"></a>Spring AOP概述</h4><p>在有很多的开放源代码和专有的J2EE Framework时，Spring Framework能够脱颖而出，并且一枝独秀，我们应该相信Spring是独特的。Spring定位的领域是许多其他流行的Framework不具有的，Spring是全面的和模块化的，引入了方面（Aspect）提供一种新的方法来管理你的业务对象。Spring有分层的体系结构，这意味着你能选择使用它的任何部分，它的架构仍然是内在稳定的。</p>
<p>Spring的架构性，能有效地组织你的中间层对象，无论你是否选择使用了EJB。如果你仅仅使用了Struts或其他的包含了J2EE特有APIs的framework，你会发现Spring关注了遗留下来的问题，Spring能消除在许多工程上对Singleton的过多使用。Spring能够消除各类属性文件的定制，在Spring应用中大多数业务对象没有依赖于Spring，创建的应用程序更易于单元测试。</p>
<p>Spring为已建立的企业级应用提供了一个轻量级的解决方案，这个方案包括声明式事务管理，通过RMI或webservices远程访问业务逻辑，mail支持工具以及数据库持久化的多种选择。Spring还提供了一个MVC应用框架、可以透明地把AOP集成到你的软件中的途径和一个优秀的异常处理体系，包括自动从Spring特有的异常体系中映射。</p>
<p>Spring是潜在的一站式解决方案，定位于与典型应用相关的大部分基础结构。同时，Spring也是组件化的，允许使用它的部分组件而不需牵涉其他部分。可以使用Bean容器，在前台展现层使用Struts；还可以只使用Hibernate集成部分或是JDBC抽象层。Spring是无侵入性的，意味着根据实际使用的范围，应用对框架的依赖几乎没有或是绝对最小化的。</p>
<p>Spring包含许多功能和特性，并被很好地组织在图18-5所示的7个模块中。</p>
<details><summary>图18-5　Spring框架图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163021.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163021.png';" /></details>

<p>Core包是框架的基础部分，并提供依赖注入特性来管理Bean容器功能。这里的基础概念是BeanFactory，它提供Factory模式来消除对程序性单例的需要，并允许从程序逻辑中分离出依赖关系的配置和描述。</p>
<p>构建于Beans包上的Context包，提供了一种框架式的Bean访问方式，有些像JNDI注册。Context包的特性得自Beans包，并添加了文本消息的发送，通过资源串、事件传播、资源装载的方式和Context的透明创建，如通过Servlet容器。</p>
<p>DAO包提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。该包也提供了一种方法实现编程性和声明性事务管理，不仅仅是针对实现特定接口的类，而且对所有的POJO。</p>
<p>ORM包为流行的关系——对象映射APIs提供了集成层，包括JDO、Hibernate和iBatis。通过ORM包，可与所有Spring提供的其他特性相结合来使用这些对象/关系映射，如前边提到的简单声明性事务管理。</p>
<p>Spring的AOP包提供与AOP联盟兼容的面向方面编程实现，允许定义，如方法拦截器和切点，来干净地给从逻辑上说应该被分离的功能实现代码解析。使用源码级的元数据功能，可将各种行为信息合并到你的代码中。</p>
<p>Spring的Web包提供了基本的面向Web的综合特性，如Multipart功能，使用Servlet监听器的Context的初始化和面向Web的application Context。当与WebWork或Struts一起使用Spring时，这个包使Spring可与其他框架结合。</p>
<p>Spring的Web MVC包提供了面向Web应用的Model-View-Controller实现。Spring的MVC实现不仅仅是一种实现，它提供了一种domain model代码和web form的清晰分离，这使用户可使用Spring框架的所有其他特性，如校验。</p>
<h4 id="Spring语言概念和构造"><a href="#Spring语言概念和构造" class="headerlink" title="Spring语言概念和构造"></a>Spring语言概念和构造</h4><p>前面提到，AOP提供从另一个角度来考虑程序结构以完善面向对象编程。面向对象将应用程序分解成各个层次的对象，而AOP将程序分解成各个方面或者说关注点。这使得可以模块化诸如事务管理等这些横切多个对象的关注点，称作横切关注点。</p>
<p>Spring的一个关键组件就是AOP框架。Spring IoC容器（BeanFactory和Application-Context）并不依赖于AOP，这意味着如果不需要，可以不使用AOP。AOP完善了Spring IoC，使之成为一个有效的中间件解决方案。</p>
<h5 id="AOP在Spring中的使用"><a href="#AOP在Spring中的使用" class="headerlink" title="AOP在Spring中的使用"></a>AOP在Spring中的使用</h5><p>（1）提供声明式企业服务，特别是作为EJB声明式服务的替代品。这些服务中最重要的是声明式事务管理，这个服务建立在Spring的事务管理抽象之上。</p>
<p>（2）允许用户实现自定义的方面，用AOP完善他们的OOP的使用。这样，可以把Spring AOP看作是对Spring的补充，它使得Spring不需要EJB就能提供声明式事务管理；或者使用Spring AOP框架的全部功能来实现自定义的方面。</p>
<h5 id="Spring-AOP的功能"><a href="#Spring-AOP的功能" class="headerlink" title="Spring AOP的功能"></a>Spring AOP的功能</h5><p>Spring AOP用纯Java实现，不需要特别的编译过程，区别于AspectJ的实现。Spring AOP不需要控制类装载器，因此适用于J2EE Web容器或应用服务器。</p>
<p>Spring目前支持拦截方法调用。成员变量拦截器没有实现，虽然加入成员变量拦截器支持并不破坏Spring AOP核心API。Spring提供代表切入点或各种通知类型的类。Spring使用术语advisor来表示代表方面的对象，它包含一个通知和一个指定特定连接点的切入点。各种通知类型有MethodInterceptor，来自AOP联盟的拦截器APD和定义在org.springframework.aop包中的通知接口。所有通知必须实现org.aopalliance.aop.Advice标签接口。取出就可使用的通知有MethodInterceptor、ThrowsAdvice、BeforeAdvice和AfterReturningAdvice。</p>
<p>Spring实现AOP的途径不同于其他大部分AOP框架，它的目标不是提供及其完善的AOP实现（虽然Spring AOP非常强大）；而是提供一个和Spring IoC紧密整合的AOP实现，帮助解决企业应用中的常见问题。因此，例如Spring AOP的功能通常是和Spring IoC容器联合使用的。AOP通知是用普通的bean定义语法来定义的（虽然可以使用autoproxying功能）。通知和切入点本身由Spring IoC管理，这是一个重要的其他AOP实现的区别。有些是使用Spring AOP无法容易或高效地实现，例如通知非常细粒度的对象。这种情况AspectJ可能是最合适的选择。但是，我们的经验是Spring针对J2EE应用中大部分能用AOP解决的问题提供了一个优秀的解决方案。</p>
<h5 id="Spring-AOP的重要概念"><a href="#Spring-AOP的重要概念" class="headerlink" title="Spring AOP的重要概念"></a>Spring AOP的重要概念</h5><p>前面已经提到了AOP的重要概念，下面介绍在Spring中的定义和实现。</p>
<p>（1）方面：一个关注点的模块化，这个关注点的实现可能横切另外多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的Advisor或拦截器实现。</p>
<p>（2）连接点：程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</p>
<p>（3）通知：在特定的连接点，AOP框架执行的动作。各种类型的通知包括around、before和throws通知。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。</p>
<p>（4）切入点：指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点。例如，使用正则表达式。</p>
<p>（5）引入：添加方法或字段到被通知的类。Spring允许引入新的接口到任何被通知的对象。例如，可以使用一个引入使任何对象实现IsModified接口，来简化缓存。</p>
<p>（6）目标对象：包含连接点的对象。也被称作被通知或被代理对象。</p>
<p>（7）AOP代理：AOP框架创建的对象，包含通知。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
<p>（8）织入：组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<p>特别指出，Spring默认使用JDK动态代理实现AOP代理。这使得任何接口或接口的集合能够被代理。Spring也可以是CGLIB代理。这可以代理类，而不是接口。如果业务对象没有实现一个接口，CGLIB被默认使用。但是，作为一针对接口编程而不是类编程的良好实践，业务对象通常实现一个或多个业务接口。</p>
<p>前面提到横切关注点是AOP中的重要因素，使之独立于OO的层次选定目标，横切点到系统的切入点理所当然是构成系统的结构要素。下面看看Spring是如何处理切入点这个重要因素的。</p>
<p>Spring的切入点模型能够使切入点独立于通知类型被重用，同样的切入点有可能接受不同的通知。org.springframework.aop.Pointcut接口是重要的接口，用来指定通知到特定的类和方法目标。完整的接口定义如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163154.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163154.png';" /></details>

<p>将Pointcut接口分成两个部分有利于重用类和方法的匹配部分，并且组合细粒度的操作（如和另一个方法匹配器执行一个“并”的操作）。ClassFilter接口被用来将切入点限制到一个给定的目标类的集合。如果matches永远返回true，所有的目标类都将被匹配。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163209.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163209.png';" /></details>

<p>MethodMatcher接口通常更加重要。完整的接口如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163221.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163221.png';" /></details>

<p>matches（Method，Class）方法被用来测试这个切入点是否匹配目标类的给定方法。这个测试可以在AOP代理创建的时候执行，避免在所有方法调用时都需要进行测试。如果两个参数的匹配方法对某个方法返回true，并且MethodMatcher的isRuntime()也返回true，那么三个参数的匹配方法将在每次方法调用时被调用。这使得切入点能够在目标通知被执行之前立即查看传递给方法调用的参数。</p>
<p>大部分MethodMatcher都是静态的，意味着isRuntime()方法返回false。这种情况下，三个参数的匹配方法永远不会被调用。如果可能，尽量使切入点是静态的，使当AOP代理被创建时，AOP框架能够缓存切入点的测试结果。当然，目前的技术只实现了方面静态织入，无法动态地在运行状态下组合方面。</p>
<h4 id="Spring-AOP应用"><a href="#Spring-AOP应用" class="headerlink" title="Spring AOP应用"></a>Spring AOP应用</h4><p>Spring AOP是Spring框架的重要组成部分，它实现了AOP联盟约定的接口。Spring AOP是由纯Java开发完成的，它实现了方法级别的连接点，而在J2EE应用中，AOP拦截到方法级的操作已经足够了。由于OOP倡导的是基于setter/getter的方法访问，而非直接访问域，所以Spring仅仅提供方法级的连接点。为了使控制反转（IoC）很方便地使用健壮、灵活的企业服务，需要Spring AOP来实现，因为它在运行时才创建Advice对象。下面讨论使用Spring AOP松散耦合的几种方式。</p>
<h5 id="创建通知"><a href="#创建通知" class="headerlink" title="创建通知"></a>创建通知</h5><p>为实现AOP，开发者需要开发AOP通知（Advice）。AOP通知包含了方面（Aspect）的业务逻辑。当创建一个Advice对象时，就编写了实现横切（cross-cutting）功能的代码。Spring的连接点是用方法拦截器实现的，这就意味着编写的Spring AOP通知将在方法调用的不同点织入程序中。由于在调用一个方法时有几个不同的时间点，Spring可以在不同的时间点织入程序。</p>
<p>Spring AOP中，提供了如下4种通知的接口。</p>
<p>（1）MethodBeforeAdvice：用于在目标方法调用前触发。</p>
<p>（2）AfterReturningAdvice：用于在目标方法调用后触发。</p>
<p>（3）ThrowsAdvice：用于在目标方法抛出异常时触发。</p>
<p>（4）MethodInterceptor：用于实现Around通知（Advice），在目标方法执行的前后触发。</p>
<p>如果要实现相应的功能，则需要实现上述接口。例如，实现Before通知（Advice）需要实现方法void before（Method method，Object[] args，Object target）；实现After通知（Advice）需要实现方法void afterReturning（Method method，Object[] args，Object target）。</p>
<h5 id="在Spring中定义切入点"><a href="#在Spring中定义切入点" class="headerlink" title="在Spring中定义切入点"></a>在Spring中定义切入点</h5><p>在不能明确调用方法时，通知就很不实用。切入点则可以决定特定的类、特定的方法是否匹配特定的标准。如果匹配，则通知将应用到此方法上。Spring切入点允许用很灵活的方式将通知组织进我们的类中。Spring中的切入点框架的核心是Pointcut接口，此接口允许定义织入通知中的类和方法。许多方面就是通过一系列的通知和切入点组合来定义的。</p>
<p>在Spring中，一个advisor就是一个方面的完整的模块化表示。Spring提供了PointcutAdvisor接口把通知和切入点组合成一个对象。Spring中很多内建的切入点都有对应的PointcutAdvisor，因此可以很方便地在一个地方管理切入点和通知。Spring中的切入点分为两类：静态和动态。因为静态切入点的性能要优于动态切入点，所以优先考虑使用静态切入点。Spring为我们提供创建静态切入点很实用的类StaticMethodMatherPointcut，在这个类中，只需要关心setMappedName和setMappedNams方法，可以使用具体的类名，也可以使用通配符。例如，设置mappedName属性为set*，则匹配所有的set方法。Spring还提供了通过正则表达式来创建静态切入点的实用类RegexpMethodPointcut。通过使用Perl样式的正则表达式来定义感兴趣的方法。当切入点需要用运行时参数值来执行通知时，则使用动态切入点。Spring提供了一个内建的动态切入点ControlFlowPointcut，此切入点匹配基于当前线程的调用堆栈。只有在当前线程运行时找到特定的类和特定的方法才返回true，使用动态切入点有很大的性能损耗。大多数的切入点可以静态确定，我们很少有机会创建动态切入点。为了增加切入点的可重用性，Spring提供了切入点上的集合操作——交集和并集。</p>
<h5 id="用ProxyFactoryBean创建AOP代理"><a href="#用ProxyFactoryBean创建AOP代理" class="headerlink" title="用ProxyFactoryBean创建AOP代理"></a>用ProxyFactoryBean创建AOP代理</h5><p>ProxyFactoryBean和其他Spring的FactoryBean实现一样，引入一个间接的层次。如果定义一个名字为myfactory的ProxyFactoryBean，引用myfactory的对象所看到的不是ProxyFactoryBean实例本身，而是由实现ProxyFactoryBean的类的getObject()方法所创建的对象。这个方法将创建一个包装了目标对象的AOP代理。使用ProxyFactoryBean或者其他IoC可知的类来创建AOP代理最重要的一个优点是IoC可以管理通知和切入点。这是一个非常强大的功能，能够实现其他AOP框架很难实现的特定的方法。例如，一个通知本身可以引用应用对象（除了目标对象，它在任何AOP框架中都可以引用应用对象），这完全得益于依赖注入所提供的可插入性。通常，不需要ProxyFactoryBean的全部功能，因为我们常常只对一个方面感兴趣。例如，事务管理。当我们仅仅对一个特定的方面感兴趣时，可以使用许多便利的工厂来创建AOP代理，如TransactionProxyFactoryBean。</p>
<h5 id="自动代理"><a href="#自动代理" class="headerlink" title="自动代理"></a>自动代理</h5><p>在应用规模比较小，只有很少类需要被通知时，ProxyFactoryBean可以很好地工作。当有许多类需要被通知时，创建每个代理就显得很烦琐。幸运的是，Spring提供了使用自动通过容器来创建代理的功能。这时，只需要配置一个Bean来做烦琐的工作。Spring提供了两个类实现自动代理：BeanNameAutoProxyCreator和DefaultAdvisorAutoProxyCreator。BeanNameAutoProxyCreator为匹配名字的Bean产生代理，它可将一个或者多个方面应用在命名相似的Bean中。自动代理框架将自动产生代理要暴露出的接口。如果目标Bean没有实现任何接口，就会动态产生一个子类。而更强大的自动代理是DefaultAdvisorAutoProxyCreator，只需要在BeanFactory中包含它的配置就可完成代理。这个类的奇妙之处在于它实现了BeanPostProcessor接口。当Bean定义被加载到Spring容器中后，DefaultAdvisorAutoProxyCreator将搜索上下文中的Advisor，最后它将Advisor应用到匹配Advisor切入点的Bean中。这个代理只对Advisor起作用，它需要通过Advisor来得到需要通知的Bean。元数据自动代理（MetaDataAutoProxy）配置依赖于源代码属性而不是外部XML配置文件。这可以非常方便地将源代码和AOP元数据组织在同一个地方。元数据自动代理最常用的地方是用来声明事务，Spring提供了很强的AOP框架来声明事务。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch17-%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch17-%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch17-企业集成架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:57:20" itemprop="dateCreated datePublished" datetime="2021-07-19T12:57:20+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 16:31:26" itemprop="dateModified" datetime="2021-09-26T16:31:26+08:00">2021-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="企业集成架构设计"><a href="#企业集成架构设计" class="headerlink" title="企业集成架构设计"></a>企业集成架构设计</h2><p>企业信息集成是解决“孤岛”问题的需要，技术发展的同时也推动了集成架构等相关的研究。企业集成平台的核心是企业集成架构，包括信息、过程、应用集成的架构。本章从集成平台概念出发，探讨相关的标准、规范、技术及设计模型，包括面向企业整体集成模型和作用。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42801723/article/details/105395540">信息化孤岛问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21516296">OA系统和EIP系统的区别？</a></li>
</ul>
<h3 id="企业集成平台"><a href="#企业集成平台" class="headerlink" title="企业集成平台"></a>企业集成平台</h3><p>信息时代的企业集成需要在一个开放的计算机支撑环境下实现。企业集成平台（Enterprise Integration Platform, EIP）技术是近年来用于企业信息系统集成的一种先进的计算机软件技术，其目的是能够根据业务模型的变化快速地进行信息系统的配置和调整，保证不同系统、应用、服务或操作人员之间顺畅地互操作，进而提高企业适应市场变化的能力，使企业能够在复杂多变的市场环境中生存。</p>
<p>企业集成的水平在很大程度上取决于企业内部各种系统、应用或服务的集成化运行水平，良好的软件支持工具可以帮助企业加快实现企业系统集成。作为支持企业集成化运行的工具，企业集成平台的主要功能是为企业中各种数据、系统和过程等多种对象的协同运行提供各种公共服务及运行时的支撑环境，从而降低实现企业内部的信息孤岛集成的复杂度，提高应用间集成的有效性，将信息系统实施规划中确定的企业中各种应用系统、服务、人员、信息资源及数字化设备的协同关系物化到集成化运行的可执行系统中去。</p>
<h4 id="企业集成平台的概念"><a href="#企业集成平台的概念" class="headerlink" title="企业集成平台的概念"></a>企业集成平台的概念</h4><p>企业集成平台概念的提出和发展来自于企业应用需求和计算机技术发展两方面的驱动。一方面，企业中各种业务信息系统（包含各种遗留信息系统）数量的增加为企业集成平台产生了需求拉动的作用；另一方面，计算机及软件技术的发展是产生企业集成平台的技术推动力。</p>
<p>实现企业集成的技术和手段多种多样，早期比较简单的集成方式是通过在不同的应用之间开发一对一的专用接口来实现应用之间的数据集成，即采用点到点的集成方式。这种点到点的集成方式的优点是比较直观，在企业应用数量少时易实现。但这种方式也存在比较多的问题：工作量大；集成系统的维护费用高，系统升级和扩展困难；不易于标准化，由于接口数量多，给系统管理造成比较大的困难；一般仅能够解决应用系统之间的数据集成问题，难以用来支持过程集成和应用之间的协调。</p>
<p>为了克服点到点集成方式给企业应用系统集成和维护管理带来的困难，人们提出了采用集成平台的方式来实现企业集成。企业集成平台是一个支持复杂信息环境下信息系统开发、集成和协同运行的软件支撑环境。它基于各种企业经营业务的信息特征，在异构分布环境（操作系统、网络、数据库）下为应用提供一致的信息访问和交互手段，对其上运行的应用进行管理，为应用提供服务，并支持企业信息环境下各特定领域的应用系统的集成。</p>
<p>经过多年的发展，集成平台已经成为支持企业集成的先进和有效的方法。基于集成平台，可以使分散的信息系统通过一个单一的接口，以可管理、可重复的方式实现单点集成，使企业内的所有应用都可以通过集成平台进行通信和数据交换，实现广义范围内和深层次上的企业资源共享和集成。图17-1给出了企业集成平台的示意图。</p>
<details><summary>图17-1　企业集成平台的应用架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151753.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151753.png';" /></details>

<p>企业集成平台的产生和发展，使得企业应用软件的开发方式较传统方式发生了很大变化，也使得应用系统维护和扩展的难度及费用大为减少。应用集成平台提供的应用软件集成机制和接口可以实现应用间的透明信息交换，使得在异构分布环境下的应用软件通过该接口集成到平台上，共享平台所拥有的资源。采用集成平台可以大大降低集成的复杂度，提高集成的有效性。</p>
<p>由于其诸多的优点，从20世纪80年代中期以后，集成平台的概念和产品在全世界范围内得到了广泛的推广应用，出现了狭义的集成平台和广义的集成平台两种概念。狭义的集成平台是指一个软件平台，它为企业内多个应用软件系统或组件间的信息共享与互操作提供所需的通用服务，达到降低企业内（间）多个应用软件系统或系统之间的集成复杂性的目的。广义的集成平台则是指由支撑软件系统（狭义集成平台）同其他完成不同业务的逻辑功能的各应用系统一起组成数字化企业的协同运行环境。但无论是广义的集成平台，还是狭义的集成平台，其核心的内容都是为企业提供集成所需要的服务，并对集成系统进行管理。</p>
<p>集成平台是支持企业集成的支撑环境，包括硬件、软件、软件工具和系统，通过集成各种企业应用软件形成企业集成系统。由于硬件环境和应用软件的多样性，企业信息系统的功能和环境都非常复杂，因此，为了能够较好地满足企业的应用需求，作为企业集成系统支持环境的集成平台，其基本功能主要如下。</p>
<p>1） $\color{green}{\text{通信服务}}$ </p>
<p>提供分布环境下透明的同步/异步通信服务功能，使用户和应用程序无需关心具体的操作系统和应用程序所处的网络物理位置，而以透明的函数调用或对象服务方式完成它们所需的通信服务要求。</p>
<p>2） $\color{green}{\text{信息集成服务}}$ </p>
<p>为应用提供透明的信息访问服务，通过实现异种 $\color{green}{\text{数据库系统}}$ 之间数据的交换、互操作、分布数据管理和共享信息模型定义（或共享信息数据库的建立），使集成平台上运行的应用、服务或用户端能够以一致的语义和接口实现对数据（数据库、数据文件、应用交互信息）的访问与控制。</p>
<p>3） $\color{green}{\text{应用集成服务}}$ </p>
<p>通过高层应用编程接口来实现对相应应用程序的访问，这些高层应用编程接口包含在不同的适配器或代理中，被用来连接不同的应用程序。这些接口以函数或对象服务的方式向平台的组件模型提供信息，使用户在无需对原有系统进行修改（不会影响原有系统的功能）的情况下，只要在原有系统的基础上加上相应的访问接口就可以将现有的、用不同的技术实现的系统互联起来，通过为应用提供数据交换和访问操作，使各种不同的系统能够相互协作。</p>
<p>4） $\color{green}{\text{二次开发工具}}$ </p>
<p>是集成平台提供的一组帮助用户开发特定应用程序（如实现数据转换的适配器或应用封装服务等）的支持工具，其目的是简化用户在企业集成平台实施过程中（特定应用程序接口）的开发工作。</p>
<p>5） $\color{green}{\text{平台运行管理工具}}$ </p>
<p>是企业集成平台的运行管理和控制模块，负责企业集成平台系统的静态和动态配置、集成平台应用运行管理和维护、事件管理和出错管理等。通过命名服务、目录服务、平台的动态静态配置，以及其中的关键数据的定期备份等功能来维护整个服务平台的系统配置及稳定运行。</p>
<h4 id="集成平台的标准化"><a href="#集成平台的标准化" class="headerlink" title="集成平台的标准化"></a>集成平台的标准化</h4><p>集成平台上集成的应用软件系统通常都是由不同的软件厂家提供的产品，具有很强的异构性，所以在集成平台中需要广泛采用新的开放性标准。研究和发展系统集成的相关标准，不断地使平台的接口和服务标准化，可以显著提高集成平台系统的适应性和可扩展性，减少异构性给集成带来的障碍。采用标准化的技术也是提高集成平台系统开放性和软件模块可重用性的重要方法。</p>
<p>集成平台的标准化内容涉及通信协议、中间件、企业建模、工作流管理系统、Internet环境下的数据交换、产品数据标准和应用系统集成的标准等。Goldstone技术公司在国际标准化组织定义的开放系统互联（ISO/OSI）的7层网络应用模型的基础上，给出了图17-2所示的集成平台的12层OSI模型。</p>
<details><summary>图17-2　企业集成平台的12层OSI模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151834.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151834.png';" /></details>

<p>在这个12层OSI模型中，下面的7层依然是采用ISO关于网络应用7个层次的定义。第8层为支持应用集成的中间件层，它为集成平台提供商实施企业系统集成提供了可扩展集成的架构。第9层为应用开发商定义的应用间方法（服务）调用、接收/发送消息格式的接口语法层。第10层为应用提供商和集成平台提供商共同提供的用来描述应用软件系统结构和内涵的应用语义层。第11层作为业务语义描述层，供业务操作人员和信息管理人员用来定义基于模型操作的业务对象的数据结构及其语义。第12层为业务过程层，用来为业务操作人员定义企业关键业务流程及流程之间的交互关系。</p>
<h4 id="实现技术的发展趋势"><a href="#实现技术的发展趋势" class="headerlink" title="实现技术的发展趋势"></a>实现技术的发展趋势</h4><p>通过分析国内外集成平台的应用及发展情况，结合企业集成系统对集成平台实施提出的要求和计算机软件技术的发展趋势，企业集成技术有如下的发展趋势。</p>
<h5 id="集成的技术实现从2层到n层过渡"><a href="#集成的技术实现从2层到n层过渡" class="headerlink" title="集成的技术实现从2层到n层过渡"></a>集成的技术实现从2层到n层过渡</h5><p>传统的集成实现一般采用图17-3所示的两层C/S或B/S结构，这样的系统将业务逻辑和应用表示逻辑封装在一起。这个封装在一起的逻辑模块可以安装在客户端应用上，也可以安装在服务器上，但是无论是在服务器端，还是在客户端， 由于业务逻辑和应用表示逻辑的紧密捆绑，对系统的升级和扩展都带来了比较大的困难。</p>
<details><summary>图17-3　集成技术的两层实现</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151917.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151917.png';" /></details>

<p>未来的集成平台将采用图17-4所示的n层系统集成方式，将业务过程逻辑、业务表示逻辑等进行分离，将每层的功能集中在一个特定的角色上，这样可以得到一个非常便于进行系统功能扩展、逻辑修改的应用集成框架，进而提高集成平台和集成系统的柔性。</p>
<details><summary>图17-4　集成技术的n层实现</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151937.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151937.png';" /></details>

<h5 id="集成支持的方式从面向信息集成扩充到面向过程集成、服务集成"><a href="#集成支持的方式从面向信息集成扩充到面向过程集成、服务集成" class="headerlink" title="集成支持的方式从面向信息集成扩充到面向过程集成、服务集成"></a>集成支持的方式从面向信息集成扩充到面向过程集成、服务集成</h5><p>面向信息的集成主要是针对设计、制造和管理部门中大量存在的自动化孤岛和信息孤岛而提出来的，其目的是为了解决企业内不同应用和系统间的数据共享和集成。这些应用系统分布在网络环境下的异构计算机系统中，它们所管理和操作的数据格式和存储方式各异，实现信息集成就是要实现数据的转换（不同数据格式和存储方式之间的转换）、数据源的统一（同一个数据仅有一个数据入口）、数据一致性的维护、异构环境下不同的应用系统之间的数据传送。面向信息的集成主要应用于企业内的数据库和数据源上，其具体的实现方法主要有数据复制、数据捆绑和基于接口的信息集成三种方式。</p>
<p>（1）面向过程的集成（这里主要是指技术层面的过程集成）：通过工作流引擎对企业内业务流程模型的执行来实现业务应用数据或信息在不同应用、子过程或执行任务的人员之间流动（如图17-5所示）。采用工作流管理方式可以对业务过程逻辑和应用逻辑进行分离，实现过程建模和数据、功能的分离，从而可以在保持具体功能单元不变的情况下，通过修改过程模型来改变系统功能，进而提高系统的柔性。面向过程集成需要在信息集成的基础上进行，或者说面向过程集成可能会对信息集成提出新的要求，因为在执行过程模型时，过程模型中包含的各种活动之间（特别是自动应用之间）同样需要信息共享与集成。过程集成更重要的是一种策略行为，它还具有过程逻辑可视化、业务执行过程自动化、业务过程执行状态和性能的实时监控等功能。</p>
<details><summary>图17-5　面向过程集成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152003.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152003.png';" /></details>

<p>（2）面向服务的集成（如图17-6所示）：主要是为支持大范围内的公共业务过程集成而提出的一种动态集成方式（如供应链企业群体内），可以较好地实现（企业间）具有松散耦合关系的不同应用间的互操作。在这种集成方式中，服务提供者（平台、企业）将应用作为服务部署在Web上，通过使用Web服务描述语言来描述Web服务提供的功能，并通过统一的服务发布与发现协议（Universal Description, Discovery and Integration, UDDI）将其注册到UDDI中心。服务请求者使用UDDI协议定义的API向UDDI中心提出服务请求，UDDI为其寻求到它所需要的服务，并由UDDI中心返回服务请求，同时与特定服务进行绑定，在此基础上，服务请求者继而通过SOAP协议完成应用服务的调用。基于服务的集成方式对于集成企业原有的系统同样十分方便，在不需要对原有系统进行修改的情况下，只要在原有系统的基础上增加一个对它们进行访问的SOAP接口，就可以完成原有系统到集成平台的集成。面向服务的集成将以前主要在企业内部网络基础上实施的集成扩展到了面向开放网络环境下的集成，从而大大扩展了集成的范围。基于服务的集成方式具有最好的柔性和开放性，然而，这种松散的动态集成方式牺牲了性能和网络流量。</p>
<details><summary>图17-6　面向服务集成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152029.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152029.png';" /></details>

<h5 id="集成规范的标准化程度不断提高"><a href="#集成规范的标准化程度不断提高" class="headerlink" title="集成规范的标准化程度不断提高"></a>集成规范的标准化程度不断提高</h5><p>开放性和标准化在集成的实现技术中的重要性已经得到广泛的认同。从数据描述的角度来看，数据结构的定义已经由原来的各个应用专有数据类型、行业内的标准数据表达（如STEP、EDI等），逐渐过渡到具有自描述功能的基于XML语言的数据表达与存储。从应用间集成接口的实现与接口表现形式来看，已经从最初的自定义应用编程接口、基于IDL接口定义（如CORBA或COM的接口描述语言），发展到更通用的基于XML语言的Web服务接口定义语言（WSDL）的集成接口描述。从业务过程定义方面来看，则由不同产品给出的自定义业务过程描述方式，工作流联盟为实现不同工作流产品间互操作而提出的工作流过程定义语言（WPDL），到近来出现的关于如何利用Web服务集成架构实现过程集成的基于XML语言的商业流程模型描述语言（如WSFL、BPEL等）。标准化技术的采用增强了集成平台的开放性和通用性，从而为企业集成提供了更强有力的技术支持。</p>
<h5 id="所支持的集成耦合度及集成的粒度的变化"><a href="#所支持的集成耦合度及集成的粒度的变化" class="headerlink" title="所支持的集成耦合度及集成的粒度的变化"></a>所支持的集成耦合度及集成的粒度的变化</h5><p>随着编程技术的发展，集成平台所采用的集成实现形式也在不断发展，应用集成的耦合度（松散集成、紧密集成）不断降低，集成范围不断扩大，而集成粒度（对象、组件、服务）也在不断缩小，图17-7给出了集成的范围和集成耦合度的对应关系。</p>
<p>随着集成范围的不断扩大，集成的耦合度不断降低。集成耦合度最高的对象间集成方式比较适合于功能单元之间的集成，集成耦合度最低的服务集成方式则能够比较好地实现企业间的集成，集成耦合度中等的组件集成方式可以较好地完成企业内的集成。对象间集成主要通过程序代码级对象之间的调用来实现。组件之间的集成方式则主要通过构建企业内分布式计算环境、采用远程过程调用来实现跨语言、进程和计算机间的基于组件的集成。基于服务的集成方式包括基于消息中间件服务和基于Web服务两种。基于消息中间件的服务集成通过消息中间件（如MSMQ）来实现应用或系统之间的互操作，基于Web服务的集成通过SOAP消息交换协议（防火墙透明的）来实现Internet环境下的分布式计算。由于Web服务的方式具有良好的松散耦合集成结构，因此它更适合于用来支持企业间应用的集成。</p>
<details><summary>图17-7　集成尺度与范围、耦合度的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152106.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152106.png';" /></details>


<h4 id="集成平台的发展趋势"><a href="#集成平台的发展趋势" class="headerlink" title="集成平台的发展趋势"></a>集成平台的发展趋势</h4><p>企业集成平台技术已经逐步成熟，国外已经出现了许多商用产品。从功能上可以将其划分为企业应用集成和业务到业务的集成（B2B）两种。其中，EAI主要侧重于企业内部的纵向集成，B2B侧重于支持企业间业务往来的横向集成。目前在市场上的产品主要有Active Enterprise 3.0（Tibco公司）、Mercator（Mercator公司）、MQ Series Integrator（IBM公司）、WebMethods Enterprise（WebMethods公司）和Business Ware。</p>
<h5 id="Active-Enterprise-3-0（Tibco公司）"><a href="#Active-Enterprise-3-0（Tibco公司）" class="headerlink" title="Active Enterprise 3.0（Tibco公司）"></a>Active Enterprise 3.0（Tibco公司）</h5><p>Tibco公司主要为具有基本信息技术应用知识的企业用户提供端到端的异构信息系统集成方案。其产品Active Enterprise 3.0采用了模块化的结构，它的每一个组件（如数据仓库、集成服务器、消息代理以及监控工具等）都可以在不同机器上独立运行，组件间的通信通过一个连接所有组件的信息总线实现。信息总线采用其独有的串行UDP技术实现，能够保证在发生系统级事件（包括通信错误）时及时向相关组件发送通知。考虑到在企业有大量的系统需要集成的情况下，对于整个集成系统的管理和监控将会很复杂，Tibco采用一个轻型代理实现对整个平台所有层次上的系统和过程进行全面的监控。轻型代理采用广播的形式向信息总线上的所有组件发送必要的监控和管理消息，采用这种方式可以将监控系统对平台系统性能造成的影响降到最低。通过轻型代理和信息总线的协同作用，可以使Active Enterprise对新接入的应用或服务具有动态发现能力。另外，Active Enterprise利用工作流技术为用户提供了强大的业务过程管理能力，用户可以在简单、直观的过程建模工具的支持下，建立相应的业务过程模型，并通过其工作流引擎同时支持自动化过程和人工型工作流的执行。</p>
<h5 id="Mercator（Mercator公司）"><a href="#Mercator（Mercator公司）" class="headerlink" title="Mercator（Mercator公司）"></a>Mercator（Mercator公司）</h5><p>Mercator由Enterprise Broker、Web Broker和Commerce Broker三个独立的产品构成。其中Enterprise Broker用于企业内应用的集成。Web Broker是B2以外，配合以上产品提供了企业间的流程设计的GUI工具Integration Flow Designer。目前，全世界已经有5000套Mercator投入运行，Mercator在集成SAP R/3用户方面具有很强的优势。</p>
<h5 id="MQ-Series-Integrator（IBM公司）"><a href="#MQ-Series-Integrator（IBM公司）" class="headerlink" title="MQ Series Integrator（IBM公司）"></a>MQ Series Integrator（IBM公司）</h5><p>MQ Series Integrator由消息中间件MQSeries、消息代理Integrator以及实现业务流程自动化的MQSeries Workflow构成。MQSeries是IBM开发和销售的消息中间件产品，是消息中间件事实上的标准，它支持35种以上的协议，可以用统一的API进行异构机种间的连接，主要是进行异步消息处理，但也可以实现实时消息的连接。MQSeries符合JMS标准，可以很容易地与WebLogic和WebSphere等应用服务器实现连接。MQSeries Workflow可以采用图形的方式方便地定义跨不同企业系统间的业务流程，也可以对工作流的实例状态进行控制和调整。特别是MQSeries Workflow可以将规则嵌入到流程节点中来，这点得到了用户广泛的好评。目前IBM已将WebSphere B2B Integrator加到这些产品中，以提供包含企业内和企业间集成的综合解决方案。</p>
<h5 id="WebMethods-Enterprise（WebMethods公司）"><a href="#WebMethods-Enterprise（WebMethods公司）" class="headerlink" title="WebMethods Enterprise（WebMethods公司）"></a>WebMethods Enterprise（WebMethods公司）</h5><p>该产品是WebMethods公司面向技术型用户提供的B2B解决方案，其核心部件是Active Works。Active Works提供了通信协议转换、队列管理和队列分配、60多种适配器、业务流程的控制，XML变换和Web应用接口等EAI的基本功能。需要指出的是，WebMethods Enterprise实现了EAI功能的一体化，即各种EAI功能可以在一个界面上统一进行设计和操作，所以容易进行应用系统开发和实施。特别地，每一次定义的业务流程都可以以模板的方式进行保存。WebMethods Enterprise采用总线型体系结构，利用Java框架来实现客户适配器的开发，因此具有良好的可扩展性和可用性，特别适用于大型企业的系统集成。WebMethods Enterprise消息交换的可靠性也较高，它包含一个异步事务协调引擎，并带有一个可用于MQSeries的适配器。监控代理、适配器及其各自的流程能够在死机的情况下自动恢复，也可以进行事件的自动重送。在对可靠性有更高要求的应用情况下，还可以在系统的外部配置作业控制器的相关服务模块。在收购了Active（EAI）和IntelliFrame（工作流管理系统）后，WebMethods公司具有为企业提供全面的端到端的集成方案的能力，它为许多主流的ERP、CRM、基于消息的中间件系统提供了广泛可用的内置适配器。一旦在技术上实现与这些并购产品的全面集成，WebMethods的领先地位将从目前的B2B领域扩展到EAI领域。</p>
<h5 id="BusinessWare（Vitria-Technology公司）"><a href="#BusinessWare（Vitria-Technology公司）" class="headerlink" title="BusinessWare（Vitria Technology公司）"></a>BusinessWare（Vitria Technology公司）</h5><p>Business Ware产品主要面向技术型用户，它采用以过程为核心的方式实现系统集成。BusinessWare产品具体由业务流程管理工具、可作为系统连接的EAI平台、实时监视工作流状态的实时分析工具、在应用层担当B2B集成的功能模块4个部分构成。它的业务流程管理工具具有友好的用户界面，用户可以在不需要事先编程和配置连接器的条件下，进行业务过程的可视化设计。Business Ware以CORBA技术为核心，采用通道/Hub（集线器）式的系统体系结构，与各系统连接的连接器控制各通道的输入输出，使用连接器开发工具包来支持客户化适配器的开发。BusinessWare中可以用多个类来定义发布/订阅通道的消息，通道采用与域名服务运行方式类似的联邦式分散结构，以实现对不同企业间集成化业务运作提供高性能和高可靠性的服务。在实时分析工具的界面上可以监视所设计流程的运行状态和性能。BusinessWare可以为那些希望自己进行业务过程建模的企业用户提供标准化的集成服务。</p>
<p>集成平台产品的发展具有以下的主要趋势。</p>
<p>（1）与商用工作流产品的融合发展。</p>
<p>集成平台产品通过与商用工作流产品的融合，一方面将基于工作流的业务流程分析、优化及过程管理功能引入到平台中来，并增强支持业务过程的自动执行能力及平台的可实施性；另一方面，利用商用工作流系统与用户的友好交互能力将人的因素集成到自动执行的企业业务操作过程中来，从而提高系统的柔性与可用性。</p>
<p>（2）与底层集成服务器产品的融合发展。</p>
<p>集成平台产品通过与底层集成服务器产品的融合，一方面可以增加集成平台产品内部各组件模块的无缝集成性，进而提高集成到平台上各应用系统间的互操作能力；另一方面，利用商用构件对企业用户提供从底层服务支撑技术到上层应用、过程集成的一体化支持，以保证集成平台的成功实施。</p>
<p>（3）兼容点到点（Point-to-Point）集成和端到端（End-to-End）集成。</p>
<p>集成平台厂商通过将其传统产品支持的点到点集成（主要指同步集成）方式扩展到端到端集成（侧重于异步集成）方式，以分别适用于企业内部集成所需要的大流量数据交换模式和企业间协同所需要的灵活的小流量数据交换模式。</p>
<p>（4）基于模型的集成与协调。</p>
<p>通过采用统一定义和表示的模型（在一些协议或规则的辅助下实现模型的构造和控制）实现不同应用系统之间的协同工作（应用软件通过模型操作接口实现对模型中定义的产品、过程、资源数据的访问，从而实现不同应用软件之间的无缝集成），这样就可以通过模型在整个生命周期的不断演化来实现企业集成信息系统的演化。</p>
<h3 id="企业集成平台的实现"><a href="#企业集成平台的实现" class="headerlink" title="企业集成平台的实现"></a>企业集成平台的实现</h3><h4 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h4><p>构建企业集成平台的首要目的是实现数据集成，即为平台上运行的各种应用、系统或服务，提供具有完整性、一致性和安全性的数据访问、信息查询及决策支持服务。数据集成主要为了解决不同应用和系统间的数据共享和交换需求，具体包括共享信息管理、共享模型管理和数据操作管理三个部分。其中，共享信息管理通过定义统一的集成服务模型和共享信息访问机制，完成对集成平台运行过程中产生数据信息的共享、分发和存储管理；共享模型管理则提供数据资源配置管理、集成资源关系管理、资源运行生命周期管理及相应的业务数据协同监控管理等功能；数据操作管理则为集成平台用户提供数据操作服务，包括多通道的异构模型之间的数据转换、数据映射、数据传递和数据操作等功能服务。</p>
<p>企业运行的业务应用系统采用的体系结构与其实现技术的标准化（规范化）程度，对数据集成的水平有非常大的影响。企业现有各种应用系统的规范化程度不高是影响企业数据集成水平的主要问题，因此，采用先进的软件体系结构和规范化的实现技术是实现良好的数据集成的基础。</p>
<p>企业集成技术架构层次如图17-8所示。</p>
<details><summary>图17-8　企业集成技术架构层次图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152345.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152345.png';" /></details>

<p>数据集成主要有以下三种模式：数据联邦、数据复制和基于接口的数据集成。如图17-9所示，它们分别描述了对多个异构数据源透明、一致访问的三种实现方法。</p>
<details><summary>图17-9　三种典型的数据集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152404.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152404.png';" /></details>


<h5 id="数据联邦"><a href="#数据联邦" class="headerlink" title="数据联邦"></a>数据联邦</h5><p>数据联邦是指不同的应用共同访问一个全局虚拟数据库，通过全局虚拟数据库管理系统为不同的应用提供全局信息服务，实现不同的应用和数据源之间的信息共享和数据交换，其具体实现由客户端应用、全局信息服务和若干个局部数据源三部分组成。</p>
<h5 id="数据复制模式"><a href="#数据复制模式" class="headerlink" title="数据复制模式"></a>数据复制模式</h5><p>在数据复制模式中，通过底层应用数据源之间的一致性复制来实现（访问不同数据库的）不同应用之间的信息共享和互操作，其实现的关键是必须能够提供在两个或多个数据库系统之间实现数据转换和传输的基础结构（以屏蔽不同数据库间数据模型的差异）。</p>
<h5 id="基于接口的数据集成模式"><a href="#基于接口的数据集成模式" class="headerlink" title="基于接口的数据集成模式"></a>基于接口的数据集成模式</h5><p>在基于接口的数据集成模式中，不同的应用系统之间利用适配器（或接口代理）提供的应用编程接口来实现相互调用。应用适配器或接口代理通过其开放或私有接口将业务信息从其所封装的具体应用系统中提取出来，进而实现不同的应用系统之间业务数据的共享与互交换。接口调用的方式可以采用同步调用方法，也可以采用基于消息中间件的异步方法来实现。</p>
<h4 id="应用集成"><a href="#应用集成" class="headerlink" title="应用集成"></a>应用集成</h4><p>应用集成是指两个或多个应用系统根据业务逻辑的需要而进行的功能之间的相互调用和互操作。应用集成需要在数据集成的基础上完成。应用集成在底层的网络集成和数据集成的基础上实现异构应用系统之间语用层次上的互操作。它们共同构成了实现企业集成化运行最顶层会聚集成所需要的，技术层次上的基础支持。</p>
<p>应用集成最初主要采用点对点的紧耦合方式。这种集成方式虽然不需要对应用系统做较大的改动，但用这种方式集成的系统缺乏必要的柔性，不能适应业务系统快速重构的需求。随着应用软件系统设计和实现过程中标准化程度的不断提高，系统的开放性（可配置性、可扩展性）越来越好，组件化的系统实现及松散耦合（它是实现系统柔性的基础）的应用集成方式逐渐成为构建企业业务处理系统的主流。</p>
<p>应用集成模式包括集成适配器、集成信使、集成面板和集成代理4种，每种应用集成模式都是对具有业务功能依赖关系的多个应用之间互操作实现方法的总结。在具体应用中，集成模式可能以某种变形（这是一种扩展集成模式的主要方式）的形式出现，这些变形可能不仅仅只是一种模式的实例化，也可能是一种具有广泛适用性的集成方式。</p>
<h5 id="适配器集成模式"><a href="#适配器集成模式" class="headerlink" title="适配器集成模式"></a>适配器集成模式</h5><p>在EAI技术发展的初期，广泛采用在需要交互的系统之间加入适配器（Adapter）的解决方案来实现企业原有应用系统与新实施系统之间的互操作。在应用系统提供的API的基础上（在应用系统没有提供API的情况下，可以在其数据库表结构已知的条件下直接完成对其数据库的写入与读出），通过适配器完成不同的系统间数据格式及访问方式的转换与映射，进而实现不同的系统之间业务功能及业务数据的集成，如图17-10所示。</p>
<details><summary>图17-10　适配器集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152517.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152517.png';" /></details>

<h5 id="信使集成模式"><a href="#信使集成模式" class="headerlink" title="信使集成模式"></a>信使集成模式</h5><p>随着企业中业务应用系统个数的增多，应用系统间的接口问题变得越来越复杂。为了更灵活地实现应用系统间点对点的集成问题，提出了图17-11所示的基于信使的集成结构。在这种集成结构中，系统之间的通信和数据交换通过信使（消息代理）来实现，每个应用只需要建立与集成信使之间的接口连接，就可实现与所有通过集成信使相联的应用系统间的交互。这种结构大大减少了接口连接数量，同时由于采用了信使（消息代理）作为信息交流的中介，可以将应用之间的交互对通信服务能力的依赖程度降到最低。另外，当某一系统发生改变时、只需要改变信使中相应的部分，从而降低系统维护工作量和系统升级的难度。</p>
<details><summary>图17-11　信使集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152546.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152546.png';" /></details>

<h5 id="面板集成模式"><a href="#面板集成模式" class="headerlink" title="面板集成模式"></a>面板集成模式</h5><p>面板集成模式和面向对象的软件设计方法中的面板模式很相似，它是从应用交互实现的层面来描述客户端应用和服务器端应用集成的一种方法。图17-12给出了面板集成模式框架图。集成面板可以为一对多、多对一、多对多等多种应用提供集成接口，在这种模式中包含有一个或多个客户端应用、一个集成面板、一个或多个服务器端应用。集成面板通过对服务器端应用功能的抽象和简化，为客户端应用访问与调用服务器端应用提供了一种简化的公共接口。集成面板在得到客户端应用服务请求后，将客户端的服务请求转换成服务器端应用能理解的形式，并将该请求提交给服务器端应用。</p>
<details><summary>图17-12　面板集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152613.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152613.png';" /></details>

<h5 id="代理集成模式"><a href="#代理集成模式" class="headerlink" title="代理集成模式"></a>代理集成模式</h5><p>面板集成模式实现了服务器端应用交互逻辑的分离。在代理集成模式中，由于不存在很明显的客户端应用和服务器端应用的划分，它仅需要将待集成的应用间的交互逻辑从应用中分离出来，并对应用间的交互逻辑进行封装，进而由集成代理来引导多个应用之间的交互，如图17-13所示。</p>
<details><summary>图17-13　代理集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152642.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152642.png';" /></details>

<h4 id="企业集成"><a href="#企业集成" class="headerlink" title="企业集成"></a>企业集成</h4><p>企业应用软件系统从功能逻辑上可以分为表示、业务逻辑和数据三个层次，其中表示层负责完成系统与用户交互的接口（界面）定义，业务逻辑层主要根据具体业务规则完成相应业务数据的处理，数据层负责存储由业务逻辑层处理或产生的业务数据，它是系统中相对稳定的部分。按照这些逻辑功能层次间是否分离和分离的程度，在软件系统具体实现上可以大致分为如下4类。</p>
<p>（1）单层结构系统。</p>
<p>很多企业遗留应用系统属于这一类，这种应用一般是采用传统的编程方法得到的一个紧密结构应用，三个层次之间没有进行分离，因此某个层次的变化通常需要重新设计与开发其他两个层次的内容。</p>
<p>（2）两层结构系统。</p>
<p>通常是将表示层与业务逻辑层（胖客户）紧密地耦合在一起，或者是将业务逻辑和数据库层紧密地耦合在一起（只将表示层分离出来为瘦客户）。这种结构实现了三个层次间部分的分离，这样在应用的某个部分发生变化时仅需要修改与其紧密耦合的部分，而无需重新开发所有的代码。如将表示层分离出来，可以使同样的业务功能采用不同的图形化用户接口及显示器屏幕模式，改变客户端接口（如增加Web界面）并不需要修改业务的逻辑功能来实现。</p>
<p>（3）三层结构系统。</p>
<p>这是当前比较流行的系统实现方式。它将业务应用系统的表示、业务逻辑和数据三个层次分成独立的模块实现。这样，应用系统的各层可以并行开发，各层也可以选择各自最适合的开发环境和编程语言。这种系统结构不但提高了系统的可维护性，也有利于系统的安全管理。</p>
<p>（4）n层结构系统。</p>
<p>将三层系统结构进一步细化（主要是将业务逻辑及数据库层分成更多、粒度更小的分布式业务对象来分别实现），其目的是提高系统不同业务功能模块的独立性。在提高了系统的可配置能力的同时，可以使系统具有最好的柔性及可扩展能力。</p>
<p>支持企业间应用集成和交互的集成平台在系统结构上通常都采用多层的结构，其目的是在最大程度上提高系统的柔性。在集成平台的具体设计开发中，还需要按照功能的通用性程度（通用功能、面向特定领域的功能、专业化功能）对系统实现模块进行分层（分成不同的中间件）。</p>
<p>根据企业集成平台功能的支持范围，可以将其划分为侧重于支持企业内部集成化运行的EAI和侧重于支持企业间业务集成的B2B。一般来说，EAI是B2B的基础，下面主要讨论EA1的实现模式。</p>
<p>从企业集成运行的实现策略上看，EAI主要有如下三种实现模式。</p>
<p>（1）前端集成模式。</p>
<p>所谓前端集成模式，是指EAI侧重于业务应用系统表示层的集成，它主要通过单一的用户入口实现跨多个应用事务的运作。这种方式适合于用户启动的业务过程会产生多个跨应用的事务，而且这些事务都需要实时响应的情况（主要指B2C的环境）。另外，采用前端集成模式还可以实现对已经运行的核心业务应用系统增加功能或特征的目的。</p>
<p>（2）后端集成模式。</p>
<p>后端集成模式主要侧重于应用系统数据层面的集成。它通过专门的数据维护及转换工具实现不同应用或数据源之间的信息交换，维护企业整体业务数据的完整性和一致性。</p>
<p>后端集成模式就像一个方便多个应用系统之间数据自动交互的数据管道，后端集成模式的实施同样需要得到数据集成及应用集成的支持。后端集成模式实现起来相对比较简单，因为EAI服务器不需要跨应用的事务维护，而只需要维护一些相对简单的业务规则。基于EAI服务器提供的存储——转发机制可以方便地实现对合作伙伴企业之间大量业务数据交换（主要指B2B集成）的支持。</p>
<p>（3）混合集成模式。</p>
<p>混合集成模式是前端集成模式和后端集成模式的组合。客户通过基于Web浏览器的客户端（瘦客户）实现对业务应用或EAI服务器的访问，服务请求可以由前端应用系统执行，也可以通过EAI服务器将服务请求路由到后端，由后端的业务应用来执行。这种模式几乎具有前端集成模式和后端集成模式的所有特征，主要应用于既需要响应大量服务请求、又需要维护多个数据源的完整性和一致性的情况。</p>
<h3 id="企业集成的关键应用技术"><a href="#企业集成的关键应用技术" class="headerlink" title="企业集成的关键应用技术"></a>企业集成的关键应用技术</h3><h4 id="数据交换格式"><a href="#数据交换格式" class="headerlink" title="数据交换格式"></a>数据交换格式</h4><p>企业业务数据可以分为结构化数据（表单）和非结构化数据（文档），它们一般存储在不同的数据库或文档管理系统中。不同的应用系统、数据库所处理的文档和数据格式有很大差别，建立各个应用都可以识别和访问的通用数据模型及表示规范，是实现不同的应用系统之间交互和互操作的最基本方法。企业数据集成中常用的几种数据交换格式如下。</p>
<h5 id="EDI"><a href="#EDI" class="headerlink" title="EDI"></a>EDI</h5><p>EDI（Electronic Data Interchange，电子数据交换）是一种利用计算机进行商务处理的方法，它将贸易、运输、保险、银行和海关等行业的信息，用一种国际公认的标准格式，通过计算机通信网络，供有关部门、公司与企业之间进行数据交换与处理，并完成以贸易为中心的全部业务过程。</p>
<p>EDI格式处理的目的是将在功效上与纸介质文件等同的电子表单用统一的（或标准的）格式进行表示，以保证各个独立开发的计算机应用间能够实现表单数据共享与集成。用于描述电子表单格式的标准称为EDI格式标准或EDI标准，目前广泛使用的EDI格式标准主要有UN/EDIFACT和ANSIX12，分别由联合国欧洲经济委员会（The United Nations Economic Commission for Europe, UN/ECE）和美国国家标准化协会（American National Standard Institute, ANSI）制定。</p>
<p>国际标准化组织采用UN/EDIFACT作为国际标准（IS09735）。按照UN/EDIFACT标准，贸易伙伴之间一次交换的内容称为一个交换，交换由交换头/尾、功能组头/尾、报文头/尾、数据段（或段组）和数据元（简单数据元和复合数据元）等组成。为简化起见，数据段（或段组）、数据元等在本文中都被称为报文项。图17-14给出了EDIFACT报文的数据结构。</p>
<details><summary>图17-14　EDIFACT报文的数据结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152807.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152807.png';" /></details>


<h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>XML是国际组织W3C制定的一个面向各类信息的数据存储工具和可配置载体的开放式标准。提出XML的目的是为了更好地适应Web应用的需求，解决HTML在表达能力、可扩展性和交互性等方面的缺陷。XML是通过对SGML标准进行简化而形成的元标记语言，具有语法清晰简单和结构无歧义等优点。它利用一套定义标记的规则将文件的内容和外观进行分离，实现了XML文档的可延伸性及自我描述特性，从而使各种业务信息可以在全球信息网或企业间的应用系统中传递、处理及储存。这里需要指出的是，虽然XML称为可扩展标记语言，但它本身并不是一种标记语言，而是一种创建、设计和使用标记语言的根规则集，是一种创建标记语言（如HTML）的元语言。图17-15给出了XML相关标准的层次图。</p>
<h5 id="STEP"><a href="#STEP" class="headerlink" title="STEP"></a>STEP</h5><p>STEP标准（Standard for the Exchange of Product Model Data）是一个描述如何表达和交换数字化产品信息的ISO标准（ISO10303），其目的是提供一种不依赖于具体系统的中性模型和机制，并将其用来描述整个生命周期内的产品数据。</p>
<p>图17-16给出了STEP标准的结构，其核心由描述产品数据的形式化语言规范（描述方法）、STEP实现方法、集成资源和一致性测试标准4部分组成，而围绕该核心定义的各种应用协议及抽象测试套件构成了对STEP的外层支持。描述方法用于集成资源的定义，由集成资源模型产生应用协议，应用协议和实现方法相结合产生一种STEP实现，一致性测试则用于测试STEP实现是否与STEP标准相一致。</p>
<details><summary>图17-15　XML标准体系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152849.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152849.png';" /></details>

<details><summary>图17-16　SETP标准的结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152903.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152903.png';" /></details>

<h5 id="PDML"><a href="#PDML" class="headerlink" title="PDML"></a>PDML</h5><p>PDML的技术目标是提供一种灵活的方法，使得不同应用软件系统中的产品数据能够进行交换。它是在STEP和XML基础上实现不同系统间产品数据交换和集成的一种新模式。</p>
<p>PDML中主要应用了STEP的集成资源和EXPRESS数据规范语言两个部分。在PDML中，与特定领域词汇表（或数据字典）相应的组件被称为应用事务集（Application Service Set，ATS），与跨多个应用领域的通用词汇表相应的组件被称为集成方案，集成方案的设计基于STEP的集成资源。</p>
<p>PDML使用XML来描述所有业务应用软件系统中的产品数据，并通过提供一系列的标准DTD来进行产品数据的导入和导出。由于EXPRESS在（产品相关的）语义和约束的表达能力方面要比XML的DTD优越很多，因此EXPRESS被选择作为定义PDML模式的规范。为了充分利用EXPRESS语言在数据建模和XML语言在数据交换方面的优点，PDML定义了一个从EXPRESS模式到XMLDTD的转换机制。</p>
<p>PDML不是单一的产品数据规范，而是一个用来发布和使用集成产品数据的相关标准和工具的集合。PDML由7个应用事务集、一个集成大纲、应用事务集和集成大纲间的映射规范、PDML工具集4部分组成。图17-17给出了应用事务集、集成大纲和映射规范之间的关系。</p>
<details><summary>图17-17　PDML各组成部分之间的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152930.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152930.png';" /></details>

<h4 id="分布式应用集成基础框架"><a href="#分布式应用集成基础框架" class="headerlink" title="分布式应用集成基础框架"></a>分布式应用集成基础框架</h4><p>随着计算机网络应用的不断深入和普及，大规模的计算机网络将不断增加，在这种计算机网络中，不仅硬件设备型号、种类、规模相异，而且操作系统平台、程序设计环境及应用也各不相同，这就是大规模计算机网络的重要特征——异构性。人们迫切希望通过在这种计算机网络上建立一套体系结构和一组规范来保证分布式系统的互操作性、可迁移性和可重用性，进而实现分布式环境下的信息共享与应用集成。因此，在面向对象技术和分布式计算基础上产生的分布式对象计算（Distributed Object Computing，DOC），成为20世纪90年代计算机技术发展的一个热点。而在当今众多的分布式对象技术中，比较有影响的分布式软件对象（组件）标准有下面三种。</p>
<h5 id="CORBA"><a href="#CORBA" class="headerlink" title="CORBA"></a>CORBA</h5><p>CORBA（Common Object Request Broker Architecture，公共对象请求代理体系结构）是对象管理组织（OMG）为解决分布式处理环境中硬件和软件系统的互连而提出的一种标准的面向对象应用程序体系规范。</p>
<p>OMG组织给出了分布计算的参考模型，称为对象管理参考模型（Object Management Architecture，OMA）。OMA模型中把软件作为对象，并通过对象请求代理与其他对象进行通信。其体系结构如图17-18所示。</p>
<details><summary>图17-18　对象管理参考模型的体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153004.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153004.png';" /></details>

<p>OMA体系结构的核心是对象请求代理（Object Request Broker，ORB），CORBA规范对ORB的组成和功能进行了定义，它支持对象服务、通用设施、领域接口和应用接口之间的交互和通信。</p>
<p>ORB是CORBA的对象互操作中介，作为应用对象间服务请求响应的中间代理，接收对象请求并把请求转给相应的对象，服务完成后又把执行结果或异常情况返回给请求者。ORB可以使对象以语言、位置和平台独立的方式发出请求和提供服务，相互协同工作，从而建立真正的分布处理，是实现分布对象互操作的核心。COBAR ORB的组成结构如图17-19所示。</p>
<details><summary>图17-19　CORBAORB结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153020.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153020.png';" /></details>

<h5 id="COM＋"><a href="#COM＋" class="headerlink" title="COM＋"></a>COM＋</h5><p>COM+是Microsoft公司基于Windows平台的一个分布式企业应用模型，它与Windows操作系统紧密结合，是沿着DDE-OLE-OLE2-COM-DOOM-COM+的路线发展而来。目前，COM、DCOM和COM+应用比较广泛。</p>
<p>COM是一个开放的组件标准，有很强的扩充和扩展能力。COM组件标准的基础是COM核心，它规定了组件对象与客户通过二进制接口标准进行交互的原则。COM主要由COM接口、COM对象、COM服务器、类工厂和类型库等组成。其中，COM接口是和COM对象之间互相调用相关的一组语义规范，每个接口有一个唯一标识（UUID）；COM对象则为一个或多个COM接口提供具体的服务（功能实现），对COM对象的调用是通过一个指向其接口的指针实现的；COM服务器提供COM运行的环境，完成COM对象的管理，并向COM客户提供服务；类工厂则是用于创建、注册COM对象的特殊对象，它为COM对象的实例化提供一种标准机制；类型库是一个二进制资源文件，包含COM服务器中对象与接口的类型信息。在COM系统中，客户对组件对象功能的调用接口一般采用COM IDL来描述。COM定义了两类服务器，即进程内服务器和进程外服务器。进程内服务器即本地机上的DLL，进程外服务器分为两类：一是本地机上的EXE可执行程序，二是远程机上的DLL或EXE程序。服务器内部包括组件接口的实现和类工厂，类工厂生产组件对象，将对象的接口指针返回给客户。组件服务器的定位由COM库完成并返回对象指针。COM对象位置的透明性处理由COM的服务控制机制保证。进程外的对象必须先调用服务控制机制提供的代理，代理生成服务对象的远程过程调用（Remote Process Call，RPC）。基于COM的系统调用原理如图17-20所示。</p>
<p>另外，COM组件标准还包括结构化存储、统一数据传输和智能命名等。其中结构化存储定义了复合文档的存储格式以及创建文档的接口，统一数据传输约定了组件之间数据交换的标准接口，智能命名则给予对象一个系统可识别的唯一标识。COM组件标准为COM对象之间的相互操作奠定了基础。</p>
<details><summary>图17-20　COM调用原理</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153058.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153058.png';" /></details>

<h5 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h5><p>J2EE（Java 2 Platform Enterprise Edition，Java 2平台企业版）是由Sun公司制定的基于Java技术的分布式组件计算平台规范。</p>
<p>Sun设计J2EE的初衷是为了解决两层模式的弊端，即系统难于升级或改进、可扩展性差，而且经常基于某种专有的协议。它使得重用业务逻辑和界面逻辑非常困难。J2EE将两层化系统模型中的不同层面切分成许多层，从而形成了一个多层的端到端的分布式应用系统架构。在图17-21给出的基于J2EE标准的典型运行结构中，主要包含客户层、Web层、业务逻辑层和数据层（包含遗留系统）4个层次。</p>
<details><summary>图17-21　J2EE运行结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153127.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153127.png';" /></details>

<p>J2EE很好地融合了Internet技术，有利于企业建立基于Web、具有n层结构的分布式应用，同时它也为应用系统集成提供了良好的解决办法。J2EE的应用集成架构如图17-22所示。J2EE的基础是核心Java平台或Java2平台的标准版，J2EE将J2SE集成到自己的体系结构中，不仅巩固了标准版中的许多优点，同时也使J2EE供应商能够独立于操作系统与硬件平台来实现应用程序产品。各种组件可以通过J2EE配置工具将其部署到相应的J2EE容器中，客户端对各种组件的访问及各种组件之间的调用都通过容器及服务器来完成。</p>
<details><summary>图17-22　基于J2EE的应用集成架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153143.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153143.png';" /></details>

<h5 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h5><p>Web Service（Web服务）是指服务提供者将应用作为服务部署在Web上，通过使用Web服务描述语言来描述特定Web服务提供的功能。服务请求者在需要一种Web服务时，可以通过Internet，在Web服务的注册机构中查找分布在Web站点上的Web服务，并自动实现与服务的绑定，完成数据交换，在这个过程中无须人工干预。Web服务的工作原理如图17-23所示。由于Web服务的系统架构和实现技术基本上基于已有的技术，因此，Web服务可以看成是现有应用面向Internet的一个延伸。</p>
<p>实现Web服务需要相关技术标准的支持，目前支持Web服务的技术标准主要有：用于进行数据交换和表达的元语言标准XML，XML用来在Web服务中表示服务请求和应答的内容； $\color{red}{\text{UDDI}}$ （Universal Description，Discovery &amp; Integration），UDDI用于Web $\color{green}{\text{服务注册和服务查找}}$ ；WSDL， $\color{red}{\text{WSDL}}$ 用于 $\color{green}{\text{描述Web服务的接口和操作功能}}$ ； $\color{red}{\text{SOAP}}$ （Simple Object Access Protocol），SOAP为 $\color{green}{\text{建立Web服务和服务请求之间的通信提供支持}}$ 。图17-24给出了支持Web服务实现的体系结构。</p>
<details><summary>图17-23　Web服务的发布、请求和绑定过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153210.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153210.png';" /></details>

<details><summary>图17-24　Web服务的体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153221.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153221.png';" /></details>

<h3 id="面向整体解决方案的企业模型"><a href="#面向整体解决方案的企业模型" class="headerlink" title="面向整体解决方案的企业模型"></a>面向整体解决方案的企业模型</h3><h4 id="企业模型在整体解决方案中的作用"><a href="#企业模型在整体解决方案中的作用" class="headerlink" title="企业模型在整体解决方案中的作用"></a>企业模型在整体解决方案中的作用</h4><p>企业模型是人们了解企业并经过抽象得到的对于企业某个或者某些方面的描述，它是实施企业信息化工程与实现企业集成的基础。企业建模在企业信息化整体解决方案中发挥的作用主要表现在以下几个方面。</p>
<p>（1）企业模型可以为信息化整体解决方案提供对企业公共一致的、规范的表达和描述。</p>
<p>模型为信息化工作中的所有人员提供一个公共的企业表达，所有的规划和决策人员可以站在同一个理解层面上讨论信息化的开展和实施，同时也为信息系统或部件的设计提供一个公共的模型规范，避免在每个信息系统设计时都直接去抽取需要的数据，减少由于这种工作方式带来的不同信息系统反映的企业数据的不一致问题。</p>
<p>（2）建模和基于模型的分析是企业信息化工作的入手点和建立有效的实施途径的基础。</p>
<p>实施企业信息化，首先必须要明确信息化的目的和范围。信息化应该从企业中最迫切需要改革、最影响和制约企业业务目标实现的环节开始，因此企业信息化实施的第一步应该是企业诊断。企业建模是有效并准确地进行企业诊断和分析的必要基础，通过模型来总结概括企业的现状，使信息化工作建立在一个具体、准确的需求的基础上。通过建模过程以及基于模型的诊断来辅助发现企业生产经营中需要解决的企业瓶颈问题和实现企业战略目标的业务需求，指明信息化需要解决的企业实际问题，为企业决策提供科学的支持。</p>
<p>（3）建模可以对信息系统规划方案进行预评价。</p>
<p>信息化工程是一项风险工程，会牵涉到企业的过程、组织、人员和资源等方面。在企业诊断之后，要进行企业信息化规划，对信息系统方案进行选择和论证。企业建模可以用于建立企业的改进模型，并基于对改进模型的分析来评价改进的效果以及对整个企业的影响。信息化过程也是企业的一种改进过程，企业建模可以描述按照某种规划方案布置了信息系统后的企业业务运行模型（模拟企业未来业务运作的模型），通过对该模型的仿真分析，并与企业现状模型进行比较，评价这个信息系统规划方案的效果以及需要付出的代价。通过对多种不同方案的比较分析，可以选择一种相对优异的信息系统规划方案。</p>
<p>（4）基于模型的工作流执行可以导航和监控各信息系统之间及信息系统与外界的交互。</p>
<p>面向工作流执行的企业模型可以准确地描述贯穿企业所有信息系统的业务过程，以及过程执行中传递的信息，并且可以定义信息系统交互过程中出现的异常情况的处理过程。在信息化工程进入实施阶段后，企业模型可以对集成的信息系统运行的导航和监控起到一定的支持作用。</p>
<p>由以上各方面看出，可以把整体解决方案的求解问题转化为更加具体的，基于企业模型的整体解决方案的求解。这样，在企业信息化整体解决方案的每个部分中都会包含企业模型、企业建模、模型管理、模型操作、模型标准、模型评价、模型转换和参考模型等相应的内容及工具。</p>
<h4 id="整体解决方案中的企业模型重"><a href="#整体解决方案中的企业模型重" class="headerlink" title="整体解决方案中的企业模型重"></a>整体解决方案中的企业模型重</h4><p>通过企业模型重用可以提高企业建模的效率与效果，进而更好地支持企业信息化整体解决方案的实施。不同的企业虽然在生产经营诸多方面都有其特殊性，但是它们都是企业系统的实例，都具有企业最本质的行为和特征，如为了完成企业的目标，都要进行一系列活动（或过程）。可以将构成企业的所有要素（无论是物质实体还是抽象过程）分成三类：一类是最通用的，适用于任何企业；第二类是在一定范围内通用，例如在一个行业内；第三类是某个企业专有的。对应这种分类，集成化企业建模体系框架中定义了三个实现企业模型重用的通用性层次：通用层、部分通用层和专用层。</p>
<p>（1）通用层：提供了整个集成化企业建模体系结构的基本构成成分，既包括不同的建模阶段、不同的建模视图的基本模型构件，也包括与建模活动相关的约束、规则、术语、服务和协议等。该层次的内容具有最强的通用性，能够广泛地适用于各类企业。</p>
<p>（2）部分通用层：在通用模型层的基础上，以生产经营方式类似的企业为背景，通过对它们典型业务流程和企业行为特征的分析和提炼，形成一组适合于某一行业的部分通用模型（模板），即行业参考模型。每种行业的部分通用模型拥有该行业中大部分企业共有的典型结构参考模型，它可以适用于这一个行业的所有或大部分企业。</p>
<p>（3）专用层：根据企业实际情况和需求，选择一定的参考模型并进行适当改动，形成适合于一个特定企业的专有模型，该模型仅能够用于所描述的企业。</p>
<p>通用性层次的划分使企业建模活动能够从简单到复杂、从抽象到具体、从一般到特殊逐步进行，形成一个层次化过程。利用模型构件可以组成参考模型，参考模型又可以派生出具体的专用模型，对专用模型再进行抽象后又可以形成新的参考模型。</p>
<p>企业通用模型构件及参考模型是在大量工程应用案例的基础上，对诸多企业的共同特征进行抽取而得到的。模型构件及参考模型库的建立和维护可以为企业信息化工程不同阶段的工作提供有实际应用价值的模型框架基础，并有助于进行企业诊断和模型优化，为提高企业建模质量、缩短企业建模周期、减少企业建模成本提供直接的支持。</p>
<p>企业模型可以采用从零开始的方法来建立，但是这种方法存在建模周期长和建模质量低等问题。因此，基于参考模型建立企业具体的专用模型是较好的方法。其实现过程包括两个阶段：参考模型的选择和参考模型的实例化。其中参考模型的选择具体包括以下几个步骤。</p>
<p>（1）确定企业建模的目标和基本需求。</p>
<p>（2）划定企业建模的范围。企业建模可以覆盖整个企业，也可以覆盖企业的某一部分。</p>
<p>（3）提出候选参考模型。参考模型的选择要依据企业规模相关性、行业相关性、产品相关性、生产经营模式相关性和领域相关性等准则。</p>
<p>（4）确定最终使用的参考模型。在候选参考模型中，经过进一步的分析和评价，最终确定一个或一组参考模型。</p>
<p>参考模型的实例化是在参考模型的基础上完成的，实例化过程在具体操作中可以采用的方法如下。</p>
<p>（1）继承：将参考模型中的模型构件或组件直接继承为企业应用模型的一部分。</p>
<p>（2）剪裁：对选取的参考模型，根据企业建模的目的和范围，进行适当的剪裁，作为企业应用模型的一部分。</p>
<p>（3）细化：在参考模型的基础上，根据企业建模的目的和需求，对模型中的某些部分作进一步的分解、细化和完善。</p>
<p>（4）扩充：按照参考模型的结构，对参考模型没有覆盖的企业建模范围加以扩充，形成企业应用模型。</p>
<p>（5）修改：对参考模型中的某些部分按照企业的实际需要进行修改，或者对参考模型中某些组件进行重组。</p>
<p>在具体的建模过程中，通用层、部分通用层和专用层三个层次又具有相互迭代的关系。当为某个行业里多个具体企业建立起企业模型后，通过抽取模型中共有的行业特性，可以总结出一个适合于这个行业的参考模型。当行业参考模型的内容非常丰富时，可以从中抽取出一些通用的建模构件。反过来，当拥有了足够多且好用的建模构件后，可以通过这些建模构件来搭建新的参考模型。当拥有了足够完善的参考模型后，可以通过实例化参考模型来快速建立起一个具体的企业模型。图17-25给出了这一迭代过程的图示化表示。</p>
<details><summary>图17-25　企业模型中的三个层次间的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153315.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153315.png';" /></details>

<h4 id="整体解决方案中企业模型演化"><a href="#整体解决方案中企业模型演化" class="headerlink" title="整体解决方案中企业模型演化"></a>整体解决方案中企业模型演化</h4><p>企业信息化整体解决方案实施的不同阶段在一定程度上也反映了企业模型及建模过程的阶段性，在不同的阶段，对模型的广度、深度和粒度要求都是不同的，各阶段需要采用哪些视图、各视图采用什么样的描述方法也都会有所不同。所以，在企业信息化整体解决方案的实施中，企业模型处于不断演化的状态之中。信息系统实施的生命周期可以分成需求分析阶段、系统设计阶段、系统实施阶段和运行维护阶段。下面分别介绍这4个阶段对企业模型的要求和在建模过程中需要完成的工作。</p>
<h5 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h5><p>需求分析阶段主要完成企业业务策略、信息技术/系统策略的确定与分析，并在完成业务调查及建立企业现状模型的基础上，结合用户需求，发现企业现有的优缺点，并针对缺点和瓶颈提出优化需求以及优化目标。在这一阶段通过对用户需求的抽象形成需求分析模型，以作为下一个阶段的输入。所建立的需求分析模型应该包含有较高层次上的企业业务流程、资源分配、组织结构和产品结构等信息。最后还需要确定系统的总体目标和评价标准。</p>
<h5 id="系统设计阶段"><a href="#系统设计阶段" class="headerlink" title="系统设计阶段"></a>系统设计阶段</h5><p>在确定了信息系统的需求之后，系统设计阶段则主要完成企业目标模型的确定和信息系统集成框架的求解，从未来的信息系统相关的业务模型中抽取出功能模型和信息模型，用它们来设计和构造信息系统。功能模型描述系统功能的划分和逐级分解，每一个功能单元对应信息系统的一个功能模块，功能模型是对业务过程模型中过程和活动所实现功能的归纳。信息模型描述信息系统需要使用到的数据结构和数据之间的关系，为建立信息系统数据库进行概念建模和物理建模。信息模型中的内容也来源于需求分析阶段建立的业务核心模型。</p>
<h5 id="系统实施阶段"><a href="#系统实施阶段" class="headerlink" title="系统实施阶段"></a>系统实施阶段</h5><p>系统实施阶段主要完成整体解决方案指导下的信息系统构建，将企业集成框架物化为实现企业集成化运作的协同信息系统。这一阶段实现了企业模型从设计模型向可执行模型的转化。在设计模型的基础上，通过定义具体的操作者、执行器、资源实体、组织单元和应用软件等，形成系统的实施模型。在给定的软硬件和网络环境下，将所得到的实施模型按照系统规划的实施步骤逐步投入运行。具体的工作包括将经过优化后得到的过程模型进行实例化，为业务流程中需要使用的人员、资源和产品指派实际的对象，建立企业信息的物理数据库供实际业务系统使用。</p>
<h5 id="运行维护阶段"><a href="#运行维护阶段" class="headerlink" title="运行维护阶段"></a>运行维护阶段</h5><p>运行维护阶段则主要完成对投入运行的企业集成化系统的运行维护，通过文档管理、版本控制等方法实现对运行系统的有效管理和监控，并通过集成需求管理软件工具来对运行过程中企业不断提出的新的需求进行记录和管理，所积累的需求和文档是下一个生命周期的输入。</p>
<p>企业的优化是一个持续的过程，一个系统实施后在运行维护阶段搜集的问题和需求又会启动一个新的生命周期。所以整个企业模型演化构成一个闭环，每个阶段的结果（输出）是下一个阶段的输入，上一个生命周期的运行维护阶段得到的结果（输出）是下一个生命周期需求分析阶段的输入。这个不断循环的生命周期以螺旋式上升的形式实现企业相关状态及行为的改进与扩展。企业模型演化的生命周期如图17-26所示。</p>
<details><summary>图17-26　企业模型演化的生命周期</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153422.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153422.png';" /></details>

<h4 id="模型驱动的企业集成系统演化"><a href="#模型驱动的企业集成系统演化" class="headerlink" title="模型驱动的企业集成系统演化"></a>模型驱动的企业集成系统演化</h4><p>采用企业信息化整体解决方案的目标是通过系统化的理论与方法来指导企业信息系统的规划与实施，构建一个既能够满足当前企业需求、又具有可持续发展能力的集成化业务计算环境。企业可持续发展必然要求支持企业各种资源（包括数据、应用、业务流程、服务及人员等）协同运作的企业集成系统具有可逐步发展和演化的特性。</p>
<details><summary>图17-27　基于模型的企业集成系统演化模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153447.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153447.png';" /></details>

<p>图17-27给出了基于模型的企业集成系统演化模式。首先，经过集成平台实施形成了（根据企业业务模型确定的）企业信息系统集成框架，以及在集成平台支持下的满足企业当前需求的协同信息系统（可能只实现了集成框架下的部分功能）。由于这种实施是根据企业当前的市场策略、业务过程规划和当前的信息技术现状进行的，它只能够在当前的企业和市场状态下，通过信息技术支持企业实现其竞争优势。在这样的集成平台支持下的业务运作，是和企业的业务逻辑（反映市场环境）与业务功能实现技术（反映技术现状）密切相关的。随着市场的变化、技术的进步，企业的核心能力及竞争策略可能要做相应的调整，而这种根据市场、技术的变化调整业务流程或资源配置结构的需求必然要在（在各种信息系统支持下的）业务协同运作过程中得以体现。随着这种需求的不断增加，企业的管理层需要对企业竞争战略或业务流程作必要的调整或改进，从而将这种调整业务模型的需求反馈到（转变为）描述企业业务特征的企业集成化模型中，进而驱动了企业目标模型的演化，企业目标模型的演化又推动了基于模型的企业集成框架和支持业务协同运作的企业集成平台的演化（业务逻辑模型修改或升级信息系统），这个不断循环的过程导致企业信息化工程以螺旋的方式不断上升。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch16-%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch16-%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch16-层次式架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:57:09" itemprop="dateCreated datePublished" datetime="2021-07-19T12:57:09+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 18:56:43" itemprop="dateModified" datetime="2021-09-04T18:56:43+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="层次式架构设计"><a href="#层次式架构设计" class="headerlink" title="层次式架构设计"></a>层次式架构设计</h2><h3 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h3><p>1968年，在Garmish召开的国际软件工程会议上，人们迫切地感到了软件危机给计算机软件产业的发展带来的巨大阻力。软件危机的两个比较大的问题是：软件的规模越来越大，软件复杂度越来越高。伴随着这两个问题的日益突出，整个软件系统结构的设计与规格说明便显得比算法选择和计算问题的数据结构更为重要。因此，代码级别的软件复用已经远远不能满足大型软件开发的需求，由此便引入了“软件体系结构”这一概念。</p>
<p>软件体系结构可定义为：软件体系结构为软件系统提供了结构、行为和属性的高级抽象，由构成系统的元素描述、这些元素的相互作用、指导元素集成的模式以及这些模式的约束组成。软件体系结构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些设计决策的基本原理，是构建于软件系统之上的系统级复用。</p>
<p>软件体系结构贯穿于软件研发的整个生命周期内，具有重要的影响。这主要从以下三个方面来进行考察。</p>
<p>（1）利益相关人员之间的交流。软件体系结构是一种常见的系统抽象，代码级别的系统抽象仅仅可以成为程序员的交流工具，而包括程序员在内的绝大多数系统的利益相关人员都借助软件体系结构来作为相互沟通的基础。</p>
<p>（2）系统设计的前期决策。软件体系结构是我们所开发的软件系统最早期设计决策的体现，而这些早期决策对软件系统的后续开发、部署和维护具有相当重要的影响。这也是能够对系统进行分析的最早时间点。</p>
<p>（3）可传递的系统级抽象。软件体系结构是关于系统构造以及系统各个元素工作机制的相对较小、却又能够突出反映问题的模型。由于软件系统具有的一些共通特性，这种模型可以在多个系统之间传递，特别是可以应用到具有相似质量属性和功能需求的系统中，并能够促进大规模软件的系统级复用。</p>
<p>分层设计是一种最常见的架构设计方法，能有效地使设计简化，使设计的系统机构清晰，便于提高复用能力和产品维护能力。</p>
<h3 id="表现层框架设计"><a href="#表现层框架设计" class="headerlink" title="表现层框架设计"></a>表现层框架设计</h3><h4 id="使用MVC模式设计表现层"><a href="#使用MVC模式设计表现层" class="headerlink" title="使用MVC模式设计表现层"></a>使用MVC模式设计表现层</h4><p>MVC是一种目前广泛流行的软件设计模式。近年来，随着J2EE（Java 2Enterprise Edition）的成熟，MVC成为了J2EE平台上推荐的一种设计模式。MVC强制性地把一个应用的输入、处理、输出流程按照视图、控制、模型的方式进行分离，形成了控制器、模型、视图三个核心模块。</p>
<p>（1）控制器（Controller）：接受用户的输入并调用模型和视图去完成用户的需求。该部分是用户界面与Model的接口。一方面它解释来自于视图的输入，将其解释成为系统能够理解的对象，同时它也识别用户动作，并将其解释为对模型特定方法的调用；另一方面，它处理来自于模型的事件和模型逻辑执行的结果，调用适当的视图为用户提供反馈。</p>
<p>（2）模型（Model）：应用程序的主体部分。模型表示业务数据和业务逻辑。一个模型能为多个视图提供数据。由于同一个模型可以被多个视图重用，所以提高了应用的可重用性。</p>
<p>（3）视图（View）：用户看到并与之交互的界面。视图向用户显示相关的数据，并能接收用户输入的数据，但是它并不进行任何实际的业务处理。视图可以向模型查询业务状态，但不能改变模型。视图还能接受模型发出的数据更新事件，从而对用户界面进行同步更新。</p>
<p>三者的协作关系如图16-1所示。</p>
<details><summary>图16-1　MVC设计模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142745.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142745.png';" /></details>


<p>从图16-1中可以看到，首先，控制器接收用户的请求，并决定应该调用哪个模型来处理；然后，模型根据用户请求进行相应的业务逻辑处理，并返回数据；最后，控制器调用相应的视图来格式化模型返回的数据，并通过视图呈现给用户。</p>
<p>使用MVC模式来设计表现层，可以有以下的优点。</p>
<p>1）允许多种用户界面的扩展。在MVC模式中，视图与模型没有必然的联系，都是通过控制器发生关系，这样如果要增加新类型的用户界面，只需要改动相应的视图和控制器即可，而模型则无需发生改动。</p>
<p>（2）易于维护。控制器和视图可以随着模型的扩展而进行相应的扩展，只要保持一种公共的接口，控制器和视图的旧版本也可以继续使用。</p>
<p>（3）功能强大的用户界面。用户界面与模型方法调用组合起来，使程序的使用更清晰，可将友好的界面发布给用户。</p>
<p>MVC是构建应用框架的一个较好的设计模式，可以将业务处理与显示分离，将应用分为控制器、模型和视图，增加了应用的可拓展性、强壮性及灵活性。基于MVC的优点，目前比较先进的Web应用框架都是基于MVC设计模式的。</p>
<h4 id="使用XML设计表现层，统一Web-Form与Windows-Form的外观"><a href="#使用XML设计表现层，统一Web-Form与Windows-Form的外观" class="headerlink" title="使用XML设计表现层，统一Web Form与Windows Form的外观"></a>使用XML设计表现层，统一Web Form与Windows Form的外观</h4><p>XML（可扩展标记语言）与HTML类似，是一种标记语言。与主要用于控制数据的显示和外观的HTML标记不同，XML标记用于定义数据本身的结构和数据类型。XML已被公认为是优秀的数据描述语言，并且成为了业内广泛采用的数据描述标准。</p>
<p>由于XML的设计目标是描述数据并集中于数据的内容，所以虽然XML和HTML类似，但是业内很少采用XML作为表现层技术，表现层技术仍然是HTML唱主角。但是，由于Web应用程序对特定浏览器的局限以及性能问题，基于窗体表现形式的胖客户端应用程序又开始有了卷土重来的趋势。这两种应用程序各有优势，在未来很长一段时间这两种技术架构都会并存。因此，许多开发厂商在开发新产品时提出了既要支持胖客户端的表现形式，又要支持Web的表现形式。于是，有人提出将GUI用一个标准的形式描述，对于不同的表现形式，提供特定形式的转换器，根据GUI的描述转换成相应的表现形式。这就要求描述语言有非常好的通用性和扩展性，XML恰恰是这种描述语言理想的载体。</p>
<p>对于大多数应用系统，GUI主要是由GUI控件组成。控件可以看成是一个数据对象，其包含位置信息、类型和绑定的事件等。这些信息在XML中都可以作为数据结点保存下来，每一个控件都可以被描述成一个XML结点，而控件的那些相关属性都可以描述成这个XML结点的Attribute。由于XML本身就是一种树型结构描述语言，所以可以很好地支持控件之间的层次结构。同时，XML标记由架构或文档的作者定义，并且是无限制的，所以架构开发人员可以随意约定控件的属性，例如可以约定type=”button”是一个按钮，type=”panel”是一个控件容器，type=”Constraint”是位置等。这样，整个GUI就可以完整而且简单地通过XML来描述。例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142823.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142823.png';" /></details>

<p>这么一段XML很清晰地表示一个控件容器位置是（16,22,78,200），包含了一个不可视按钮。用上述的XML形式将GUI按照数据描述的形式保存下来代替原先特有的表现形式所需要的GUI描述载体。然后，对于特定的表现技术，实现不同的解析器解析XML配置文件。根据XML中的标签，按照特有的表现技术实例化的GUI控件实例对象。例如，解析器遇到button，JFC解析器会给予JLabel对象，XSLT解析器会给予<code>&lt;button id=… &gt;</code>这样一个HTML字符串，再调用特定表现技术的API将实例化出来的组件对象添加到GUI上显示。</p>
<p>从设计模式的角度来说，整个XML表现层解析的机制是一种策略模式。在调用显示GUI时，不是直接的调用特定的表现技术的API，而是装载GUI对应的XML配置文件，然后根据特定的表现技术的解析器解析XML，得到GUI视图实例对象。这样，对于GUI开发人员来说，GUI视图只需要维护一套XML文件即可。</p>
<h4 id="表现层中UIP设计思想"><a href="#表现层中UIP设计思想" class="headerlink" title="表现层中UIP设计思想"></a>表现层中UIP设计思想</h4><p>应用程序通常要用代码来管理用户界面，例如一个窗体可以决定下一个要呈现给用户的窗体。开发人员可以把这些代码写在UI代码中间，但是会使得代码复杂，不易复用、维护和扩展。另一方面，应用程序要运行在其他的平台也变得相当困难，因为它进行控制的逻辑和状态都不能被复用。</p>
<p>在大多数情况下，应用程序需要维护一个状态，如状态存储在窗体中，代码需要访问这个窗体以重新恢复状态。这样做会比较困难并且代码也会变得不雅，同时也会对用户接口的重用性和可扩展性产生影响。</p>
<p>用户应用系统的时候，他可能会先启动一个任务，离开一段时间后再回来继续。如果在中间用户关闭了应用程序，它将失去当前的状态，要想继续任务的话必须一切从头开始。因此设计程序的时候，必须分开来考虑工作流、导航、与商业服务的交互等各个组成部分，以获取数据并呈现给用户。</p>
<p>UIP (User Interface Process Application Block) 是微软社区开发的众多Application Block中的其中之一，它是开源的。UIP提供了一个扩展的框架，用于简化用户界面与商业逻辑代码的分离的方法，可以用它来写复杂的用户界面导航和工作流处理，并且它能够复用在不同的场景、并可以随着应用的增加而进行扩展。</p>
<p>使用UIP框架的应用程序把表现层分为了以下几层。</p>
<p>●　User Interface Components：这个组件就是原来的表现层，用户看到的和进行交互都是这个组件，它负责获取用户的数据并且返回结果。</p>
<p>●　User Interface Process Components：这个组件用于协调用户界面的各部分，使其配合后台的活动，例如导航和工作流控制，以及状态和视图的管理。用户看不到这一组件，但是这些组件为User Interface Components提供了重要的支持功能。</p>
<p>图16-2展示了这两层在基于.Net的分布式应用程序中的位置。</p>
<details><summary>图16-2　UI Components和UIP Components</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143122.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143122.png';" /></details>

<p>UIP的组件主要负责的功能是：管理经过User Interface Components的信息流；管理UIP中各个事件之间的事务；修改用户过程的流程以响应异常；将概念上的用户交互流程从实现或者涉及的设备上分离出来；保持内部的事务关联状态，通常是持有一个或者多个的与用户交互的事务实体。因此，这些组件也能进行从UI组件收集数据以执行服务器的成组的升级或是跟踪UIP中的任务过程的管理。</p>
<h4 id="表现层动态生成设计思想"><a href="#表现层动态生成设计思想" class="headerlink" title="表现层动态生成设计思想"></a>表现层动态生成设计思想</h4><p>基于XML的界面管理技术可实现灵活的界面配置、界面动态生成和界面定制。其思路是用XML生成配置文件及界面所需的元数据，按不同需求生成界面元素及软件界面。</p>
<p>基于XML界面管理技术，包括界面配置、界面动态生成和界面定制三部分，如图16-3所示。</p>
<details><summary>图16-3　基于XML的界面管理技术框图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143152.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143152.png';" /></details>

<p>界面配置是对用户界面的静态定义，通过读取配置文件的初始值对界面配置。由界面配置对软件功能进行裁剪、重组和扩充，以实现特殊需求。</p>
<p>界面定制是对用户界面的动态修改过程，在软件运行过程中，用户可按需求和使用习惯，对界面元素（如菜单、工具栏、键盘命令）的属性（如文字、图标、大小和位置等）进行修改。软件运行结束，界面定制的结果被保存。</p>
<p>系统通过DOM API读取XML配置文件的表示层信息（初始界面大小、位置等），通过数据存取类读取数据库中的数据层信息，运行时由界面元素动态生成界面。界面配置和定制模块在软件运行前后修改配置文件、更改界面内容。</p>
<p>基于XML的界面管理技术实现的管理信息系统实现了用户界面描述信息与功能实现代码的分离，可针对不同用户需求进行界面配置和定制，能适应一定程度内的数据库结构改动。只需对XML文件稍加修改，即可实现系统的移植。</p>
<h3 id="中间层架构设计"><a href="#中间层架构设计" class="headerlink" title="中间层架构设计"></a>中间层架构设计</h3><h4 id="业务逻辑层组件设计"><a href="#业务逻辑层组件设计" class="headerlink" title="业务逻辑层组件设计"></a>业务逻辑层组件设计</h4><p>业务逻辑组件分为接口和实现类两个部分。</p>
<p>接口用于定义业务逻辑组件，定义业务逻辑组件必须实现的方法是整个系统运行的核心。通常按模块来设计业务逻辑组件，每个模块设计一个业务逻辑组件，并且每个业务逻辑组件以多个DAO组件作为基础，从而实现对外提供系统的业务逻辑服务。增加业务逻辑组件的接口，是为了提供更好的解耦，控制器无须与具体的业务逻辑组件耦合，而是面向接口编程。</p>
<h5 id="业务逻辑组件的实现类"><a href="#业务逻辑组件的实现类" class="headerlink" title="业务逻辑组件的实现类"></a>业务逻辑组件的实现类</h5><p>业务逻辑组件以DAO组件为基础，必须接收Spring容器注入的DAO组件，因此必须为业务逻辑组件的实现类提供对应的setter方法。业务逻辑组件的实现类将DAO组件接口实例作为属性（面向接口编程），而对于复杂的业务逻辑，可能需要访问多个对象的数据，那么只需在这个方法里调用多个DAO接口，将具体实现委派给DAO完成。</p>
<h5 id="业务逻辑组件的配置"><a href="#业务逻辑组件的配置" class="headerlink" title="业务逻辑组件的配置"></a>业务逻辑组件的配置</h5><p>由于业务逻辑组件的DAO组件从未被初始化过，那么业务方法如何完成？DAO组件初始化是由Spring的反向控制（Inverse of Control, IoC）或者称为依赖注入（Dependency Injection, DI）机制完成的。为此，还需要在applicationContext.xml里面配置FacadeManager组件。</p>
<p>定义FacadeManager组件时必须为其配置所需要的DAO组件，配置信息表示BaseManager继承刚才配置的事务代理模板。并且由容器给BaseManager注入dao的组件，即BaseDAOHibernate。而target则是TransactionProxy FactoryBean需要指定的属性，TransactionProxyFactoryBean负责为某个bean实例生成代理，代理必须有个目标，target属性则用于指定目标。</p>
<p>当然，也可以不使用事务代理模板及嵌套bean，而是为组件指定单独的事务代理属性，让事务代理的目标引用容器中已经存在的bean。</p>
<p>applicationContext.xml文件的源代码配置了应用的数据源和SessionFactory等bean，而业务逻辑组件也被部署在该文件中。</p>
<p>在配置文件中，采用继承业务逻辑组件的事务代理，将原有的业务逻辑组件作为嵌套bean配置，避免了直接调用没有事务特性的业务逻辑组件。</p>
<p>系统实现了所有的后台业务逻辑，并且向外提供了统一的Facade接口，前台Web层仅仅依赖这个Facade接口。这样，Web层与后台业务层的耦合已经非常松散，系统可以在不同的Web框架中方便切换，即使将整个Web层替换掉也非常容易。</p>
<h4 id="业务逻辑层工作流设计"><a href="#业务逻辑层工作流设计" class="headerlink" title="业务逻辑层工作流设计"></a>业务逻辑层工作流设计</h4><p>工作流管理联盟（Workflow Management Coalition）将工作流定义为：业务流程的全部或部分自动化，在此过程中，文档、信息或任务按照一定的过程规则流转，实现组织成员间的协调工作以达到业务的整体目标。</p>
<p>工作流管理一直是企业界和学术界关注的热点领域。1993年，国际上专门成立了工作流管理联盟（Workflow Management Coalition, WFMC），以便对工作流实现标准化管理。它是一种反映业务流程的计算机化的模型，是为了在先进计算机环境支持下实现经营过程集成与经营过程自动化而建立的可由工作流管理系统执行的业务模型。它解决的主要问题是：使在多个参与者之间按照某种预定义的规则传递文档、信息或任务的过程自动进行，从而实现某个预期的业务目标，或者是促使此目标的实现。</p>
<details><summary>图16-4　工作流参考模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143343.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143343.png';" /></details>

<p>（1）interface 1：过程定义导入/导出接口。这个接口的特点是：转换格式和API调用，从而支持过程定义信息间的互相转换。这个接口也支持已完成的过程定义或过程定义的一部分之间的互相转换。早期标准是WPDL，后来发展为XPDL。</p>
<p>（2）interface 2：客户端应用程序接口。通过这个接口工作流机可以与任务表处理器交互，代表用户资源来组织任务。然后由任务表处理器负责，从任务表中选择、推进任务项。由任务表处理器或者终端用户来控制应用工具的活动。</p>
<p>（3）interface 3：应用程序调用接口。允许工作流机直接激活一个应用工具，来执行一个活动。典型的是调用以后台服务为主的应用程序，没有用户接口。当执行活动要用到的工具，需要与终端用户交互，通常是使用客户端应用程序接口来调用那个工具，这样可以为用户安排任务时间表提供更多的灵活性。</p>
<p>（4）interface 4：工作流机协作接口。其目标是定义相关标准，以使不同开发商的工作流系统产品相互间能够进行无缝的任务项传递。WFMC定义了4个协同工作模型，包含多种协同工作能力级别。</p>
<p>（5）interface 5：管理和监视接口。提供的功能包括用户管理、角色管理、审查管理、资源控制、过程管理和过程状态处理器等。</p>
<p>用工作流的思想组织业务逻辑，优点是：将应用逻辑与过程逻辑分离，在不修改具体功能的情况下，通过修改过程模型改变系统功能，完成对生产经营部分过程或全过程的集成管理，可有效地把人、信息和应用工具合理地组织在一起，发挥系统的最大效能。</p>
<h4 id="业务逻辑层实体设计"><a href="#业务逻辑层实体设计" class="headerlink" title="业务逻辑层实体设计"></a>业务逻辑层实体设计</h4><p>业务逻辑层实体具有以下特点：业务逻辑层实体提供对业务数据及相关功能（在某些设计中）的状态编程访问。业务逻辑层实体可以使用具有复杂架构的数据来构建，这种数据通常来自数据库中的多个相关表。业务逻辑层实体数据可以作为业务过程的部分I/O参数传递。业务逻辑层实体可以是可序列化的，以保持它们的当前状态。例如，应用程序可能需要在本地磁盘、桌面数据库（如果应用程序脱机工作）或消息队列消息中存储实体数据。业务逻辑层实体不直接访问数据库，全部数据库访问都是由相关联的数据访问逻辑组件提供的。业务逻辑层实体不启动任何类型的事务处理，事务处理由使用业务逻辑层实体的应用程序或业务过程来启动。</p>
<p>在应用程序中表示业务逻辑层实体的方法有很多（从以数据为中心的模型到更加面向对象的表示法），如XML、通用DataSet、有类型的DataSet等。</p>
<p>以下示例显示了如何将一个简单的业务逻辑层实体表示为XML。该业务逻辑层实体包含一个产品。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143420.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143420.png';" /></details>

<p>将业务逻辑层实体表示为XML的优点如下。</p>
<p>（1）标准支持。XML是World Wide Web Consortium (W3C)的标准数据表示格式。</p>
<p>（2）灵活性。XML能够表示信息的层次结构和集合。</p>
<p>（3）互操作性。在所有平台上，XML都是与外部各方及贸易伙伴交换信息的理想选择。</p>
<p>如果XML数据将由ASP.NET应用程序或Windows窗体应用程序使用，则还可以把这些XML数据装载到一个DataSet中，以利用DataSet提供的数据绑定支持。</p>
<p>将业务逻辑层实体表示为通用DataSet。通用DataSet是DataSet类的实例，它是在ADO.NET的System.Data命名空间中定义的。DataSet对象包含一个或多个DataTable对象，用于表示数据访问逻辑组件从数据库检索到的信息。</p>
<p>图16-5所示为用于Product业务逻辑层实体的通用DataSet对象。该DataSet对象具有一个DataTable，用于保存产品信息。该DataTable具有一个UniqueConstraint对象，用于将ProductID列标记为主键。DataTable和UniqueConstraint对象是在数据访问逻辑组件中创建该DataSet时创建的。</p>
<details><summary>图16-5　用于Product业务逻辑层实体的通用DataSet</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143433.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143433.png';" /></details>

<p>图16-6所示为用于Order业务逻辑层实体的通用DataSet对象。此DataSet对象具有两个DataTable对象，分别保存订单信息和订单详细信息。每个DataTable具有一个对应的UniqueConstraint对象，用于标识表中的主键。此外，该DataSet还有一个Relation对象，用于将订单详细信息与订单相关联。</p>
<details><summary>图16-6　用于Order业务逻辑层实体的通用DataSet</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143453.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143453.png';" /></details>

<p>将业务逻辑层实体表示为通用DataSet的优点如下。</p>
<p>（1）灵活性。DataSet可以包含数据的集合，能够表示复杂的数据关系。</p>
<p>（2）序列化。在层间传递时，DataSet本身支持序列化。</p>
<p>（3）数据绑定。可以把DataSet绑定到ASP.NET应用程序和Windows窗体应用程序的任意用户界面控件。</p>
<p>（4）排序与过滤。可以使用DataView对象排序和过滤DataSet。应用程序可以为同一个DataSet创建多个DataView对象，以便用不同方式查看数据。</p>
<p>（5）与XML的互换性。可以用XML格式读写DataSet。</p>
<p>（6）开放式并发。在更新数据时，可以配合使用数据适配器与DataSet方便地执行开放式并发检查。</p>
<p>（7）可扩展性。如果修改了数据库架构，则适当情况下数据访问逻辑组件中的方法可以创建包含修改后的DataTable和DataRelation对象的DataSet。</p>
<p>将业务逻辑层实体表示为有类型的DataSet。有类型的DataSet是包含具有严格类型的方法、属性和类型定义以公开DataSet中的数据和元数据的类。</p>
<p>将业务逻辑层实体表示为有类型的DataSet的优点如下。</p>
<p>（1）代码易读。要访问有类型的DataSet中的表和列，可以使用有类型的方法和属性。</p>
<p>（2）有类型的方法和属性的提供使得使用有类型的DataSet比使用通用DataSet更方便。使用有类型的DataSet时，IntelliSense将可用。</p>
<p>（3）编译时类型检查，无效的表名称和列名称将在编译时而不是在运行时检测。</p>
<h4 id="业务逻辑层框架"><a href="#业务逻辑层框架" class="headerlink" title="业务逻辑层框架"></a>业务逻辑层框架</h4><p>业务框架位于系统架构的中间层，是实现系统功能的核心组件。采用容器的形式，便于系统功能的开发、代码重用和管理。图16-7便是在吸收了SOA思想之后的一个三层体系结构的简图。</p>
<details><summary>图16-7　业务框架在整个系统架构中的位置</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143533.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143533.png';" /></details>

<p>从图16-7中可以看到，业务层采用业务容器（Business Container）的方式存在于整个系统当中，采用此方式可以大大降低业务层和相邻各层的耦合，表示层代码只需要将业务参数传递给业务容器，便不需要业务层多余的干预。如此一来，可以有效地防止业务层代码渗透到表示层。</p>
<p>在业务容器中，业务逻辑是按照Domain Model—Service—Control思想来实现的。</p>
<p>（1）Domain Model是领域层业务对象，它仅仅包含业务相关的属性。</p>
<p>（2）Service是业务过程实现的组成部分，是应用程序的不同功能单元，通过在这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。这种具有中立的接口定义（没有强制绑定到特定的实现上）的特征称为服务之间的松耦合。松耦合系统的好处有两点，一是它的灵活性，二是当组成整个应用程序的每个服务的内部结构和实现逐渐地发生改变时，它能够继续存在。</p>
<p>（3）Control服务控制器，是服务之间的纽带，不同服务之间的切换就是通过它来实现的。通过服务控制器控制服务切换可以将服务的实现和服务的转向控制分离，提高了服务实现的灵活性和重用性。</p>
<p>以下是Domain Model-Service-Control三者的互动关系。</p>
<p>（1）Service的运行会依赖于Domain Model的状态，反之，Service也会根据业务规则改变Domain Model的状态。</p>
<p>（2）Control作为服务控制器，根据Domain Model的状态和相关参数决定Service之间的执行顺序及相互关系。</p>
<p>Domain Model—Service—Control的互动关系，是吸取了Model—View—Control的优点，在“控制和显示的分离”的基础之上演变而来的，通过将服务和服务控制隔离，使程序具备高度的可重用性和灵活性。</p>
<h3 id="数据访问层设计（持久层架构设计）"><a href="#数据访问层设计（持久层架构设计）" class="headerlink" title="数据访问层设计（持久层架构设计）"></a>数据访问层设计（持久层架构设计）</h3><h4 id="5种数据访问模式"><a href="#5种数据访问模式" class="headerlink" title="5种数据访问模式"></a>5种数据访问模式</h4><h5 id="在线访问"><a href="#在线访问" class="headerlink" title="在线访问"></a>在线访问</h5><p>在线访问是最基本的数据访问模式，也是在实际开发过程中最常采用的。</p>
<p>如图16-8所示，这种数据访问模式会占用一个数据库连接，读取数据，每个数据库操作都会通过这个连接不断地与后台的数据源进行交互。</p>
<details><summary>图16-8　在线访问模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143641.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143641.png';" /></details>


<h5 id="Data-Access-Object"><a href="#Data-Access-Object" class="headerlink" title="Data Access Object"></a>Data Access Object</h5><p>如图16-9所示，DAO模式是标准J2EE设计模式之一，开发人员常常用这种模式将底层数据访问操作与高层业务逻辑分离开。</p>
<details><summary>图16-9　DAO模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143708.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143708.png';" /></details>

<p>一个典型的DAO实现通常有以下组件。</p>
<p>（1）一个DAO工厂类。</p>
<p>（2）一个DAO接口。</p>
<p>（3）一个实现了DAO接口的具体类。</p>
<p>（4）数据传输对象。</p>
<p>这当中具体的DAO类包含访问特定数据源的数据的逻辑。</p>
<h5 id="Data-Transfer-Object"><a href="#Data-Transfer-Object" class="headerlink" title="Data Transfer Object"></a>Data Transfer Object</h5><p>如图16-10所示，Data Transfer Object是经典EJB设计模式之一。DTO本身是这样一组对象或是数据的容器，它需要跨不同的进程或是网络的边界来传输数据。这类对象本身应该不包含具体的业务逻辑，并且通常这些对象内部只能进行一些诸如内部一致性检查和基本验证之类的方法，而且这些方法最好不要再调用其他的对象行为。</p>
<details><summary>图16-10　DTO模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143734.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143734.png';" /></details>

<p>在具体设计这类对象（DTO）时，通常可以有如下两种选择。</p>
<p>（1）使用编程语言内置的集合对象，它通常只需要一个类，就可以在整个应用程序中满足任何数据传输目的；而且几乎所有的编程语言都内置了集合类型，不需要再另外编写实现代码。同时，使用内置的集合对象来实现DTO对象的时候，客户端必须按位置序号（在简单数组的情况下）或元素名称（在键控集合的情况下）访问集合内的字段。不过，集合存储的是同一类型（通常是最基本的Object类型）的对象，这有时会导致在编译时碰到一些无法检测到的编码错误。</p>
<p>（2）通过创建自定义类来实现DTO对象，通过定义显示的get或是set方法来访问数据。这种方式能够提供与任何其他对象完全一样的、客户端应用程序可访问的强类型对象。这种对象可以提供编译时的类型检查，但是增加了编码的工作量，若应用程序发出许多远程调用的话，需要编写大量的调用代码。</p>
<p>具体实现中有许多方法试图将上述这两种方法的优点结合在一起。第一种方法是代码生成技术，该技术可以生成脱离现有元数据（如可扩展标记语言XML架构）的自定义DTO类的源代码；第二种方法是提供更强大的集合，尽管它也是平台内置的一般的集合，但它将关系和数据类型信息与原始数据存储在一起，例如IBM提出的SDO技术或是微软ADO.NET中的DataSet就支持这类方法。</p>
<h5 id="离线数据模式"><a href="#离线数据模式" class="headerlink" title="离线数据模式"></a>离线数据模式</h5><p>离线数据模式是以数据为中心，数据从数据源获取之后，将按照某种预定义的结构（这种结构可以是SDO中的Data图表结构，也同样可以是ADO.NET中的关系结构）存放在系统中，成为应用的中心。离线，对数据的各种操作独立于各种与后台数据源之间的连接或是事务；与XML集成，数据可以方便地与XML格式的文档之间互相转换；独立于数据源，离线数据模式的不同实现定义了数据的各异的存放结构和规则，这些都是独立于具体的某种数据源的。</p>
<h5 id="对象-关系映射（Object-Relation-Mapping-O-R-Mapping）"><a href="#对象-关系映射（Object-Relation-Mapping-O-R-Mapping）" class="headerlink" title="对象/关系映射（Object/Relation Mapping, O/R Mapping）"></a>对象/关系映射（Object/Relation Mapping, O/R Mapping）</h5><p>在最近几年，采用OR映射的指导思想来进行数据持久层的设计似乎已经成了一种潮流。对象/关系映射的基本思想来源于这样一种现实：大多数应用中的数据都是依据关系模型存储在关系型数据库中；而很多应用程序中的数据在开发或是运行时则是以对象的形式组织起来的。那么，对象/关系映射就提供了这样一种工具或是平台，能够帮助将应用程序中的数据转换成关系型数据库中的记录；或是将关系数据库中的记录转换成应用程序中代码便于操作的对象。</p>
<h4 id="工厂模式在数据访问层应用"><a href="#工厂模式在数据访问层应用" class="headerlink" title="工厂模式在数据访问层应用"></a>工厂模式在数据访问层应用</h4><p>在应用程序的设计中，数据库的访问是非常重要的，数据库的访问需要良好的封装性和可维护性。在.Net中，数据库的访问，对于微软自家的SqlServer和其他数据库（支持OleDb），采用不同的访问方法，这些类分别分布于System.Data.SqlClient和System.Data.OleDb名称空间中。微软后来又推出了专门用于访问Oracle数据库的类库。我们希望在编写应用系统的时候，不因这么多类的不同而受到影响，尽量做到数据库无关。</p>
<p>这就需要在实际开发过程中将这些数据库访问类再作一次封装。经过这样的封装，不仅可以达到上述的目标，还可以减少操作数据库的步骤，减少代码编写量。工厂设计模式是使用的主要方法。</p>
<p>工厂模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。这里可能会处理对多种数据库的操作，因此，需要首先定义一个操纵数据库的接口，然后根据数据库的不同，由类工厂决定实例化哪个类。</p>
<p>下面首先来定义这个访问接口。为了方便说明问题，在这里只列出了比较少的方法，其他的方法是很容易参照添加的。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143944.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143944.png';" /></details>

<p>因为DataAccess的具体实现类有一些共同的方法，所以先从DataAccess实现一个抽象的AbstractDataAccess类，包含一些公用方法。然后，分别为Sql Server、Oracle和OleDb数据库编写三个数据访问的具体实现类。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144006.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144006.png';" /></details>

<p>现在已经完成了所要的功能，下面需要创建一个Factory类，来实现自动数据库切换的管理。这个类很简单，主要的功能就是根据数据库类型，返回适当的数据库操纵类。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144029.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144029.png';" /></details>

<p>现在一切都完成了，客户端在代码调用的时候，可能就是采用如下形式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144047.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144047.png';" /></details>

<p>或者，如果事先设定了DataAccessFactory的DefaultPersistenceProperty属性，可以直接使用DataAccess db= DataAccessFactory.CreateDataAccess()方法创建DataAccess实例。</p>
<p>当数据库发生变化时，只需要修改PersistenceProperty的值，客户端不会感觉到变化，也不用去关心。这样，实现了良好的封装性。当然，前提是你在编写程序时，没有用到特定数据库的特性，例如，Sql Server的专用函数。</p>
<h4 id="ORM、Hibernate与CMP2-0设计思想"><a href="#ORM、Hibernate与CMP2-0设计思想" class="headerlink" title="ORM、Hibernate与CMP2.0设计思想"></a>ORM、Hibernate与CMP2.0设计思想</h4><p>ORM（Object-Relation Mapping）在关系型数据库和对象之间作一个映射，这样，在具体操作数据库时，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作即可。</p>
<p>当你开发一个应用程序的时候（不使用OR Mapping），可能会涉及许多数据访问层的代码，用来从数据库保存、删除和读取对象信息等，然而这些代码写起来总是重复的。</p>
<p>一个更好的办法就是引入OR Mapping。实质上，一个OR Mapping会为你生成DAL。与其自己写DAL代码，不如用OR Mapping，你只需要关心对象就好。</p>
<p>使用ORM可以大大降低学习和开发成本。而在实际的开发中，真正对客户有价值的是其独特的业务功能，而不应该把大量时间花费在编写数据访问、CRUD方法、后期的Bug查找和维护上。在使用ORM之后，ORM框架已经把数据库转变成了我们熟悉的对象，我们只需要了解面向对象开发就可以实现数据库应用程序的开发，不需要浪费时间在SQL上。同时也可减少代码量，减少数据层出错机会。</p>
<p>通过Cache的实现，能够对性能进行调优，实现了ORM区隔了实际数据存储和业务层之间的关系，能够对每一层进行单独跟踪，增加了性能优化的可能。</p>
<p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了轻量级的对象封装，使Java程序员可以随心所欲地使用对象编程思维来操纵数据库。它不仅提供了从Java类到数据表之间的映射，还提供了数据查询和恢复机制。相对于使用JDBC和SQL来手工操作数据库，Hibernate可以大大减少操作数据库的工作量。另外，Hibernate可以利用代理模式来简化载入类的过程，这将大大减少利用Hibernate QL从数据库提取数据的代码的编写量。Hibernate可以和多种Web服务器或者应用服务器良好集成，如今已经支持几乎所有流行的数据库服务器。</p>
<p>Hibernate技术本质上是一个提供数据库服务的中间件，它的架构如图16-11所示。</p>
<details><summary>图16-11　Hibernate架构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144125.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144125.png';" /></details>

<p>图16-11显示了Hibernate件（如hibernate.properties）的工作原理，它是利用数据库以及其他一些配置XML Mapping等来为应用程序提供数据持久化服务的。</p>
<p>Hibernate具有很大的灵活性，但同时它的体系结构比较复杂，提供了好几种不同的运行方式。在轻型体系中，应用程序提供JDBC连接，并且自行管理事务，这种方式使用了Hibernate的一个最小子集。在全面解决体系中，对于应用程序来说，所有底层的JDBC/JTA API都被抽象了，Hibernate会替你照管所有的细节。</p>
<p>Hibernate是一个功能强大，可以有效地进行数据库数据到业务对象的0/R映射方案。Hibernate推动了基于普通Java对象模型，用于映射底层数据结构的持久对象的开发。通过将持久层的生成自动扩展到一个更大的范围，Hibernate使开发人员专心实现业务逻辑而不用分心于繁琐的数据库方面的逻辑，同时提供了更加合理的模块划分的方法。</p>
<h4 id="灵活运用Xml-Schema"><a href="#灵活运用Xml-Schema" class="headerlink" title="灵活运用Xml Schema"></a>灵活运用Xml Schema</h4><p>XML Schema用来描述XML文档合法结构、内容和限制。XML Schema由XML 1.0自描述，并且使用了命名空间，有丰富的内嵌数据类型及其强大的数据结构定义功能，充分地改造了并且极大地扩展了DTDs（传统描述XML文档结构和内容限制的机制）的能力，将逐步替代DTDs，成为XML体系中正式的类型语言，同XML规范、Namespace规范一起成为XML体系的坚实基础。</p>
<p>XML Schema由诸如类型定义和元素声明的组件组成，可以用来评估一个格式良好元素和属性信息的有效性。XML Schema是Schema组件的集合，这些组件分为三组：基本组件、组件和帮助组件。其中基本组件包括简单类型定义、复杂类型定义、属性声明和元素声明；组件包括属性组、完整性约束定义、模型组和符号声明；帮助组件包括注释、模型组、小品词、通配符和属性使用。Schema组件详细说明了抽象数据模型的每个组件的严格语义，每个组件在XML中的表示，一个XML Schema文档类型的DTD和XML Schema引用。</p>
<p>XML Schema提供了创建XML文档必要的框架，详细说明了一个XML文档的不同元素和属性的有效结构、限制和数据类型。XML Schema规范由如下三部分组成。</p>
<p>（1）XML Schema PartO: Primer。一个非标准化的文档，提供了XML Schema的一个简单可读的描述，目的是快速地理解如何利用XML Schema语言创建一个Schema（框架）。</p>
<p>（2）XML Schema Part1: Structures。这一部分详细说明了XML Schema定义语言，这个语言为描述XML 1.0文档的结构和内容限制提供了便利，包括开发了XMLNamespace（命名空间）的使用。</p>
<p>（3）XML Schema Part2: Datatypes。这一部分定义了可用于XML Schema和其他XML规范中的定义数据类型的方法。这个数据类型语言，本身由XML 1.0自描述，提供了说明元素和属性数据类型的XML 1.0文档类型定义（DTDs）的一个超集。这部分提出了标准的数据类型内容集合，其中讲述了目的、需求、范围和术语。XML Schema与DTD相比，有其独特的特点，提供了丰富的数据类型，实现了继承和复用，与命名空间紧密联系，易于使用。</p>
<p>与DTD不同，XML Schema规范提供了丰富的数据类型。其中不仅包括一些内嵌的数据类型，如string、integer、Boolean、time和date等，还提供了定义新类型的能力，如complexType和simpleType。开发者可以利用内嵌的数据类型和用户定义的数据类型，有效地定义和限制XML文档的属性和元素值。</p>
<p>XML Schema支持继承是它的另一特点。可以利用从已经存在的schema中获得某些类型而构造新的schema，也可以在不需要时使获得的类型无效。同时，XML Schema能将一个schema分成单独的组件，这样，在写Schema时，就可以正确地引用已经定义的组件。继承性使得软件复用更加有效，帮助开发者避免了每一次创建都要从零开始，极大地提高了软件开发和维护的效率。</p>
<p>XML Schema与XML Namespace紧密联系，使得在一个命名空间中创建元素和属性非常容易。这种联系简化了使用多个命名空间定义多个schema的XML文档的创建和验证文档有效性。</p>
<h4 id="事务处理设计"><a href="#事务处理设计" class="headerlink" title="事务处理设计"></a>事务处理设计</h4><p>事务是现代数据库理论中的核心概念之一。如果一组处理步骤或者全部发生或者一步也不执行，我们称该组处理步骤为一个事务。当所有的步骤像一个操作一样被完整地执行，我们称该事务被提交。由于其中的一部分或多步执行失败，导致没有步骤被提交，则事务必须回滚（回到最初的系统状态）。事务必须服从ISO/IEC所制定的ACID原则。ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）的缩写。事务的原子性表示事务执行过程中的任何失败都将导致事务所做的任何修改失效。一致性表示当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态。隔离性表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见。持久性表示已提交的数据在事务执行失败时，数据的状态都应该正确。</p>
<p>一般情况下，J2EE应用服务器支持JDBC事务、JTA （Java Transaction API）事务和容器管理事务。一般情况下，最好不要在程序中同时使用上述三种事务类型，例如在JTA事务中嵌套JDBC事务。另外，事务要在尽可能短的时间内完成，不要在不同方法中实现事务的使用。下面举列说明两种事务处理方式。</p>
<h5 id="JavaBean中使用JDBC方式进行事务处理"><a href="#JavaBean中使用JDBC方式进行事务处理" class="headerlink" title="JavaBean中使用JDBC方式进行事务处理"></a>JavaBean中使用JDBC方式进行事务处理</h5><p>在JDBC中怎样将多个SQL语句组合成一个事务呢？在JDBC中，打开一个连接对象Connection时，默认是auto-commit模式，每个SQL语句都被当作一个事务，即每次执行一个语句，都会自动地得到事务确认。为了能将多个SQL语句组合成一个事务，要将auto-commit模式屏蔽掉。在auto-commit模式屏蔽掉之后，如果不调用commit()方法，SQL语句不会得到事务确认。在最近一次commit()方法调用之后的所有SQL会在方法commit()调用时得到确认。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144235.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144235.png';" /></details>

<h5 id="SessionBean中的JTA事务"><a href="#SessionBean中的JTA事务" class="headerlink" title="SessionBean中的JTA事务"></a>SessionBean中的JTA事务</h5><p>JTA是事务服务的J2EE解决方案。本质上，它是描述事务接口（例如UserTransaction接口，开发人员直接使用该接口或者通过J2EE容器使用该接口来确保业务逻辑能够可靠地运行）的J2EE模型的一部分。JTA具有的三个主要的接口，分别是UserTransaction接口、TransactionManager接口和Transaction接口。这些接口共享公共的事务操作，例如commit()和rollback()；但是也包含特殊的事务操作，例如suspend()、resume()和enlist()，它们只出现在特定的接口上，以便在实现中允许一定程度的访问控制。例如，UserTransaction能够执行事务划分和基本的事务操作，而TransactionManager能够执行上下文管理。</p>
<p>应用程序可以调用UserTransaction.begin()方法开始一个事务，该事务与应用程序正在其中运行的当前线程相关联。底层的事务管理器实际处理线程与事务之间的关联。UserTransaction.commit()方法终止与当前线程关联的事务。UserTransaction.rollback()方法将放弃与当前线程关联的当前事务。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144309.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144309.png';" /></details>

<h4 id="连接对象管理设计"><a href="#连接对象管理设计" class="headerlink" title="连接对象管理设计"></a>连接对象管理设计</h4><p>在基于JDBC的数据库应用开发中，数据库连接的管理是一个难点，因为它是决定该应用性能的一个重要因素。</p>
<p>对于共享资源，有一个很著名的设计模式——资源池。该模式正是为了解决资源频繁分配、释放所造成的问题。把该模式应用到数据库连接管理领域，就是建立一个数据库连接池，提供一套高效的连接分配、使用策略。</p>
<p>建立连接池的第一步，就是要建立一个静态的连接池。所谓静态，是指池中的连接是在系统初始化时就分配好的，并且不能够随意关闭。Java中给我们提供了很多容器类，可以方便地用来构建连接池，如Vector、Stack等。在系统初始化时，根据配置创建连接并放置在连接池中，以后所使用的连接都是从该连接池中获取的，这样就可以避免连接随意建立、关闭造成的开销（当然，我们没有办法避免Java的Garbage Collection带来的开销）。</p>
<p>有了这个连接池，下面就可以提供一套自定义的分配、释放策略。当客户请求数据库连接时，首先看连接池中是否有未分配出去的连接。如果存在空闲连接则把连接分配给客户，并作相应处理。具体处理策略，在关键议题中会详述，主要的处理策略就是标记该连接为已分配。若连接池中没有空闲连接，就在已经分配出去的连接中，寻找一个合适的连接给客户，此时该连接在多个客户间复用。</p>
<p>当客户释放数据库连接时，可以根据该连接是否被复用，进行不同的处理。如果连接没有使用者，就放入到连接池中，而不是被关闭。可以看出，正是这套策略保证了数据库连接的有效复用。</p>
<h3 id="数据架构规划与设计"><a href="#数据架构规划与设计" class="headerlink" title="数据架构规划与设计"></a>数据架构规划与设计</h3><h4 id="数据库设计与类的设计融合"><a href="#数据库设计与类的设计融合" class="headerlink" title="数据库设计与类的设计融合"></a>数据库设计与类的设计融合</h4><p>对类和类之间关系的正确识别是数据模型的关键所在。本节将讨论如何发现、识别以及描述类。要想将建模过程缩减为一个简单的、逐步进行的过程是不太可能的。从本质上讲，建模是一项艺术。对一个给定的复杂情况而言，不存在唯一正确的数据模型，然而却存在好的数据模型。一个企业或机构的某个数据模型可能会优于另一个数据模型，但就如何为一个特定的系统建立数据模型，却没有唯一的解决方案。</p>
<p>好模型的目标是将工程项目整个生存期内的花费减至最小，同时也会考虑到随时间的推移系统将可能发生的变化，因而设计时也要很容易地能适应这些变化。因此，将目光集中在最大限度地降低开发费用上是一个错误。</p>
<h4 id="数据库设计与XML设计融合"><a href="#数据库设计与XML设计融合" class="headerlink" title="数据库设计与XML设计融合"></a>数据库设计与XML设计融合</h4><p>WWW的迅速发展，使其成为全球信息传递和共享日益重要和最具潜力的资源，电子商务、电子图书和远程教育等全新领域的需求和发展，使Web数据变得更加复杂和多样化，利用传统数据库技术很难存储和管理所有不同的Web数据。</p>
<p>目前，XML正在成为Internet上数据描述和交换的标准，并且将来会代替HTML而成为Web上保存数据的主要格式。</p>
<p>XML文档分为两类：一类是以数据为中心的文档，这种文档在结构上是规则的，在内容上是同构的，具有较少的混合内容和嵌套层次，人们只关心文档中的数据而并不关心数据元素的存放顺序，这种文档简称为数据文档，它常用来存储和传输Web数据。另一类是以文档为中心的文档，这种文档的结构不规则，内容比较零散，具有较多的混合内容，并且元素之间的顺序是有关的，这种文档常用来在网页上发布描述性信息、产品性能介绍和E-mail信息等。</p>
<p>Web上存有大量的XML文档，并需要持久保存，这一需求引发了人们对XML文档的存储技术研究。已经提出的XML文档的存储方式有两种：基于文件的存储方式和数据库存储方式。</p>
<p>（1）基于文件的存储方式。基于文件的存储方式是指将XML文档按其原始文本形式存储，主要存储技术包括操作系统文件库、通用文档管理系统和传统数据库的列（作为二进制大对象BLOB或字符大对象CLOB）。这种存储方式需维护某种类型的附加索引，以建立文件之间的层次结构。基于文件的存储方式的特点：无法获取XML文档中的结构化数据；通过附加索引可以定位具有某些关键字的XML文档，一旦关键字不确定，将很难定位；查询时，只能以原始文档的形式返回，即不能获取文档内部信息；文件管理存在容量大、管理难的缺点。</p>
<p>（2）数据库存储方式。数据库在数据管理方面具有管理方便、存储占用空间小、检索速度快、修改效率高和安全性好等优点。一种比较自然的想法是采用数据库对XML文档进行存取和操作，这样可以利用相对成熟的数据库技术处理XML文档内部的数据。数据库存储方式的特点：能够管理结构化和半结构化数据；具有管理和控制整个文档集合本身的能力；可以对文档内部的数据进行操作；具有数据库技术的特性，如多用户、并发控制和一致性约束等；管理方便，易于操作。</p>
<p>在某种程度上，XML及其一系列相关技术就是一个数据库系统。它提供了传统数据库所具有的特点，如存储（以XML文档形式）、数据库的模式（DTD或XMLSchema）、查询语言（XQuery、XPath、XQL和XML-QL等）和编程接口（如SAX、DOM）等。但与传统数据库相比，它在存储、索引、安全、多用户访问和事务管理等方面还存在不足之处。在一定的环境下，例如当数据量和操作用户较少并且性能要求不高的情况下，XML文档能够作为数据库在应用程序中使用。如果应用程序有许多操作用户，并且要求严格的数据完整性和性能要求，则不宜采用XML文档。</p>
<p>XML数据库是一组XML文档的集合，并且是持久的和可操作的；有专门的DBMS管理（不是XML文件系统）；文档都是有效的（即符合某一模式）；文档的集合可能基于多个模式文件（即文件扩展名为.xsd），多个模式文件之间可能有语法和语义上的相互联系。</p>
<h3 id="实战案例——电子商务网站（网上商店PetShop）"><a href="#实战案例——电子商务网站（网上商店PetShop）" class="headerlink" title="实战案例——电子商务网站（网上商店PetShop）"></a>实战案例——电子商务网站（网上商店PetShop）</h3><p>PetShop是一个范例，微软用它来展示.Net企业系统开发的能力。PetShop随着版本的不断更新，至现在基于.Net 2.0的PetShop4.0为止，整个设计逐渐变得成熟而优雅，有很多可以借鉴之处。PetShop是一个小型的项目，系统架构与代码都比较简单，却也凸现了许多颇有价值的设计与开发理念。</p>
<h4 id="PetShop的系统架构设计"><a href="#PetShop的系统架构设计" class="headerlink" title="PetShop的系统架构设计"></a>PetShop的系统架构设计</h4><p>PetShop的表示层是用ASP.Net设计的，也就是说，它应是一个BS系统。在.Net中，标准的BS分层式结构如图16-12所示。</p>
<details><summary>图16-12　Net中标准的BS分层式结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144722.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144722.png';" /></details>

<p>随着PetShop版本的更新，其分层式结构也在不断的完善，例如PetShop 2.0，就没有采用标准的三层式结构，如图16-13所示。</p>
<details><summary>图16-13　PetShop 2.0的体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144739.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144739.png';" /></details>

<p>从图16-13中可以看到，并没有明显的数据访问层设计。这样的设计虽然提高了数据访问的性能，但也同时导致了业务逻辑层与数据访问的职责混乱。一旦要求支持的数据库发生变化，或者需要修改数据访问的逻辑，由于没有清晰的分层，会导致项目做大的修改。而随着硬件系统性能的提高，以及充分利用缓存、异步处理等机制，分层式结构所带来的性能影响几乎可以忽略不计。</p>
<p>PetShop 3.0纠正了此前层次不明的问题，将数据访问逻辑作为单独的一层独立出来。PetShop 3.0的体系架构如图16-14所示。</p>
<details><summary>图16-14　PetShop 3.0的体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144756.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144756.png';" /></details>

<p>PetShop 4.0基本上延续了3.0的结构，但在性能上作了一定的改进，引入了缓存和异步处理机制，同时又充分利用了ASP.Net 2.0的新功能MemberShip。因此，PetShop 4.0的系统架构如图16-15所示。</p>
<details><summary>图16-15　PetShop 4.0的体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144820.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144820.png';" /></details>

<p>比较3.0和4.0的系统架构图，其核心的内容并没有发生变化。在数据访问层（DAL）中，仍然采用DAL Interface抽象出数据访问逻辑，并以DAL Factory作为数据访问层对象的工厂模块。对于DAL Interface而言，分别有支持MS-SQL的SQL Server DAL和支持Oracle的Oracle DAL具体实现，而Model模块则包含了数据实体对象，其详细的模块结构如图16-16所示。</p>
<p>可以看到，在数据访问层中，完全采用了“面向接口编程”思想。抽象出来的IDAL模块，脱离了与具体数据库的依赖，从而使得整个数据访问层有利于数据库迁移。DALFactory模块专门管理DAL对象的创建，便于业务逻辑层访问。SQLServerDAL和OracleDAL模块均实现IDAL模块的接口，其中包含的逻辑就是对数据库的Select、Insert、Update和Delete操作。因为数据库类型的不同，对数据库的操作也有所不同，代码也会因此有所区别。</p>
<p>此外，抽象出来的IDAL模块，除了解除了向下的依赖之外，对于其上的业务逻辑层同样仅存在弱依赖关系，如图16-17所示。</p>
<details><summary>图16-17　业务逻辑层的模块结构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144850.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144850.png';" /></details>

<p>图16-17中，BLL是业务逻辑层的核心模块，它包含了整个系统的核心业务。在业务逻辑层中，不能直接访问数据库，而必须通过数据访问层。注意，图16-17中对数据访问业务的调用，是通过接口模块IDAL来完成的。既然与具体的数据访问逻辑无关，则层与层之间的关系就是松散耦合的。如果此时需要修改数据访问层的具体实现，只要不涉及到IDAL的接口定义，那么业务逻辑层就不会受到任何影响。毕竟，具体实现的SQLServerDAL和OracalDAL根本就与业务逻辑层没有半点关系。</p>
<p>因为在PetShop 4.0中引入了异步处理机制，插入订单的策略可以分为同步和异步，两者的插入策略明显不同。但对于调用者而言，插入订单的接口是完全一样的，所以PetShop 4.0中设计了IBLLStrategy模块。虽然在IBLLStrategy模块中，仅仅是简单的IOrderStategy，但同时也给出了一个范例和信息，那就是在业务逻辑的处理中，如果存在业务操作的多样化或者是今后可能的变化，均应利用抽象的原理、或者使用接口、或者使用抽象类，从而脱离对具体业务的依赖。不过在PetShop中，由于业务逻辑相对简单，这种思想体现得不够明显。也正因为此，PetShop将核心的业务逻辑都放到了一个模块BLL中，并没有将具体的实现和抽象严格地按照模块分开。所以表示层和业务逻辑层之间的调用关系，其耦合度相对较高。</p>
<p>图16-18表示层的模块结构图中，各个层次中还引入了辅助的模块，如数据访问层的Messaging模块，是为异步插入订单的功能提供，采用了MSMQ（Microsoft Messaging Queue）技术，而表示层的CacheDependency则提供缓存功能。</p>
<details><summary>图16-18　表示层的模块结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144906.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144906.png';" /></details>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch15-%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E7%AE%A1%E7%90%86%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch15-%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E7%AE%A1%E7%90%86%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch15-架构师的管理实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:56:44" itemprop="dateCreated datePublished" datetime="2021-07-19T12:56:44+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 19:22:39" itemprop="dateModified" datetime="2021-09-26T19:22:39+08:00">2021-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="架构师的管理实践"><a href="#架构师的管理实践" class="headerlink" title="架构师的管理实践"></a>架构师的管理实践</h2><p>在实践过程中，软件架构的主要障碍往往在于组织方面而非技术。创造切实可行的软件架构需要对技术的深入把握、良好的认知能力和沟通技巧以及大量艰苦的工作。技术上出色的架构往往由于没有全面地处理好组织管理因素而失败。架构师利用自己的知识影响团队，常被大家认为是无冕之王，因此架构师需要管理技巧。本章介绍了架构师的VRAPS实践。</p>
<h3 id="VRAPS组织管理原则"><a href="#VRAPS组织管理原则" class="headerlink" title="VRAPS组织管理原则"></a>VRAPS组织管理原则</h3><p>VRAPS是为实践软件架构的组织管理原则提出的，包括构想、节奏、预见、协作和简化5个相关联的原则。每项原则都是实际可操作的，原则的提出都来源于构建软件架构的直接经验，并且都可以用来解释实践。VRAPS模型的焦点在开发和使用软件架构过程的组织管理方面，其应用环境不仅包括建立和部署架构的团队，还包括利用架构开发和利用产品线的团队和使用这些产品的客户。</p>
<p>受益人是指建立并长期保持架构的价值有重要影响的人或组织。受益人一般包括发起人、应用开发人员和应用客户，还可能包括其他重要的参与者，如技术供应方。</p>
<p>（1）构想原则：说明了如何向架构的受益人描述一幅一致的、有约束力和灵活的未来图景。</p>
<p>（2）节奏原则：刻画了一种在整个组织范围内的协调程度，即定期地根据可预测的速度、内容和质量对制品生产进行检查与规划。</p>
<p>（3）预见原则：要在预测未来与检查并适应现状之间做出平衡。</p>
<p>（4）协作原则：解决了如何识别对架构成功关键的团体，以及如何确保这些合作伙伴的有效支持。</p>
<p>（5）简化原则：要求理解组织的结构，了解架构最小的基本特征并最小化架构。</p>
<p>各个原则之间不是相互孤立的，图15-1解释了构想原则如何与其他原则交互。构想原则确立了总体方向，使得节奏原则所要求的协调工作能够进行。而一个好的节奏又可以使组织朝着构想原则制定的目标不断提供递增的进展。构想原则中的假设根据预见原则进行测试和验证。在架构演化中，应注意环境的变化，并把这些变化加入到构想中。构想帮助建立准则，以挑选合作伙伴和理解他人给架构带来的价值。这些合作伙伴的约束是一个好的构想的关键要素。构想对简化原则也起到了作用。预期的价值经过解释被运用到架构的决策中，而反过来又帮助完善构想。</p>
<details><summary>图15-1　构想与其他原则之间的交互关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140553.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140553.png';" /></details>

<p>所有其他的原则也是彼此之间相互影响的。例如，节奏原则中的协调组活动如果没有了协作是不可能完成的。通过在每个开发周期中关注最小的关键需求，节奏原则又帮助了简化原则的进行。</p>
<h3 id="概念框架"><a href="#概念框架" class="headerlink" title="概念框架"></a>概念框架</h3><p>为了更好地使用VRAPS原则，我们用准则、模式和反模式来对各项原则进行补充。准则用于判断每项原则的实施效果如何。模式描述了开发和使用软件架构时可能遇到的常见问题和解决方法，能够帮助组织改进原则。反模式则描述了组织在实践中可能遇到的陷阱。</p>
<h4 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h4><p>为了把原则运用到实践中，需要可操作的实施细节。准则把广泛的原则翻译成是否和如何执行原则的细节。</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>第一项原则都附有一组模式，它描述了开发或者使用软件架构时可能遇到的常见问题的解决方法。模式更注重于解决特定情况下的问题，传达了在给定背景和多方竞争因素下针对常见问题的解决方案。</p>
<h4 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h4><p>反模式描述了组织在实践中可能遇到的陷阱，描述了不该做的事情，或者用在错误背景下的解决方案，可以帮助更深入地理解原则。</p>
<h3 id="形成并统一构想"><a href="#形成并统一构想" class="headerlink" title="形成并统一构想"></a>形成并统一构想</h3><p>构想描述了架构的未来，提供了架构使用的环境和动机。构想是未来价值到架构约束的映射，构想要成功，则必须把它所能提供的价值与客户的约束相对应。构想也必须是明晰的、有约束力的、一致的和灵活的，从而能够被其受益人理解并有效地运用。</p>
<p>例如，在大型组织中，管理层可能把项目架构师与维护产品构想的高级经理分隔开来。这种距离会维持构想一致性，导致架构难以满足维护要求，引发后期运行成本问题。为了应对类似组织结构产生的复杂性，高级经理和架构师之间建立稳固的、积极的关系以及共享统一的构想至关重要。</p>
<p>把价值映射为架构约束，要求开发人员把约束诸如接口、开发语言和模块边界等映射到特定的客户价值上。促使受益人把约束与客户价值捆绑需要高超的技艺，用例建模是把架构的预期使用与能够被满足的切实的用户目标连接起来的一种方法。例如，识别并表达出似乎无关的用例之间的实质性联系是建立构想的一个重要内容。</p>
<h4 id="形成构想"><a href="#形成构想" class="headerlink" title="形成构想"></a>形成构想</h4><p>构想需要维持一致性与协调性。一致性是指受益人的各种期望之间妥协，以及它们与现在和将来的架构之间的需求满足程度。灵活性是指受益人在不破坏架构的情况下，在现有架构之上完成事先没有预料到的需求的容易程度。</p>
<p>一致性并不意味着所有受益人之间拥有一张完全一致的构想视图，而是指各受益人共享的视图根据他们不同的视角保持一致。RUP的“4＋1架构视图”体现了获得这种一致性的方法。RUP通过逻辑视图（Logic View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）和用例视图（Use case View）建立了架构视图。这些架构视图的不同点在于，它们根据不同目的表示系统（例如，用例视图表示了系统的最终用户功能）。</p>
<p>架构师常负有将现实引入业务构想和将构想变成现实的责任。架构师可以推荐技术，包括如何以及何时采用这些技术， 由此来帮助确定业务构想的哪些部分可以在短期内实现，以及各部分实现的次序。</p>
<p>架构师更像管理者而并非实施者，Dean Thompson说：“作为架构师更多地意味着权衡业务、组织运作和使用技术，而不仅仅是技术细节。”例如，架构师应该全面研究整个组织，找出各利益方关注的重点，然后妥善平衡，建立符合主要关注问题的架构描述。</p>
<p>多方整合能促进构想的形成。多方整合是组织各利益方的机制，用于确保获得构想并使其稳定；是指在一个公共的组织层次上对信息、决策和资源进行协调。多方整合能使从事硬件设计的基层经理理解软件设计和开发人员，以及市场营销、客户支持和市场营销的同事的期望，包括增强组织与客户和外部供应者沟通的能力。</p>
<p>Thompson归纳了形成架构构想的三步方法：清楚明确地阐述一条迫切的客户价值；将客户价值映射为少数特定的能解决的问题；将以上问题转译成一组特定的约束条件。</p>
<p>成功的架构师用明确的客户价值映射规划未来，以使用户及它们的客户能将其与约束联系起来。架构师必须格外关注产品开发人员和最终的客户，而且为了成功，还要发动所有其他人做类似的事情。</p>
<h4 id="将构想原则付诸实践"><a href="#将构想原则付诸实践" class="headerlink" title="将构想原则付诸实践"></a>将构想原则付诸实践</h4><p>下面的准则、反模式和模式能帮助建立、形成、维护一个被共享的构想，将构想原则付诸实践。</p>
<p>用于检验构想原则是否起作用的准则如下。</p>
<p>（1）架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>（2）实施人员是否信任并使用架构。</p>
<p>（3）关于架构和构件的潜藏知识对其用户（开发团队）是否是可见的、可获得的。</p>
<p>构想原则中准则到模式、反模式的映射如表15-1所示。</p>
<details><summary>表15-1　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140731.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140731.png';" /></details>

<p>下面详细介绍与各准则相关的反模式和模式。</p>
<p>准则1：架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>为了获得一致、迫切和灵活的架构，需要产品线经理、架构师和实施经理等达成共识。而如果没有阐明用户价值，则会导致构想脱离了重点。</p>
<p>与准则1相关的反模式与模式如下。</p>
<p>1）反模式：风险后置</p>
<p>形容这样统一受益人的构想：用最小的妥协、最大的优化规划出一个构件以满足所有冲突利益的需要。这种统一方法的问题是，设计出来的构件往往在理论上可行，但实际运行中出现风险。</p>
<p>一条新产品线的架构师或经理，需要开发看似很棒但实现有风险的构件。这些要完成构件可能需要打破“物理定律”才能完成，这些风险可能在制品交付的最后才能显现。可是有一批工程师仍然坚持开发这些构件。风险构件被安排到最后完成，以为这样可以有时间消除风险。可是，当计划好的完成日期临近时，依然无法交付。尽管架构在演示的幻灯片上运转良好，实际上却无法正常工作。</p>
<p>面对这种情况，需要分析并阐明风险， 向高级经理提供一个选择，要么承认风险，要么调整任务。</p>
<p>2）模式：前后一致</p>
<p>要求推动架构投资的高级经理积极地维护构想，并防止构想受到短期压力的影响。</p>
<p>一个公共的架构被几个产品共享，它已经变得比预期要复杂得多。而客户们针对每件产品又提出了以前没有预计到的功能特性。如果加入这些功能特性，则不能保证进度，但如果不开发这个特性则可能失去一位重要客户。</p>
<p>这样的情况下，需要评估架构构想的质量和稳定性。只有当两者都正常时，才能采取进一步行动。如果该新特性不属于原来的产品构想支持的代价范围，那就应该放弃开发这个新特性。如果构想不明确，在短期内就交付很可能导致大量缺陷。此时应与客户、架构师和销售、产品、支持人员以及开发经理一起加强产品的构想。如果这个特性确实属于一个稳定的产品构想，那么应该在开发组织内核实这种一致性。</p>
<p>准则2：实施人员信任并使用架构。</p>
<p>只有使用架构，才能从中获得价值。然而，要让开发人员对架构构想充分信任需要做更多的工作，仅仅靠不断兑现承诺是不够的。开发人员需要把他们对构想的了解与他们认为对下一步行动有用的东西联系起来。开发人员在利用架构的过程中，可能会使架构向许多不同的方向发展。一个良好架构应与构想保持一致，同时又能满足用户的需求。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：墙头草</p>
<p>描述了这样一种情况：因为没有良好的构想，导致架构方向在竞争和客户压力的影响下经常改变。这种构想永远不能达到稳定以便有效地被共享。</p>
<p>在开发过程中，经常会出现这样一种情况：来自客户、竞争对手和高级经理的压力使得需要在一次发布的中途加入一些代价高昂的功能，高级经理甚至可能在没有咨询架构师的情况下决定提供这些功能。可是一旦交付了某个激进的功能，组织马上就会陷入对该功能的支持工作中。以后的发布会因需要提供向后兼容而变得更为复杂。</p>
<p>在这种情况下，要做的是理解并阐明构想。方便变更需求是成功构想的一部分，要对其进行规划。高级主管要与架构师一起紧密地工作，理解变更的后果并做出正确的权衡。在建立了构想之后，可以用前后一致模式来评估特定的变更建议。在把功能特性加入到发布之前，要坚持达成一致意见。这需要一种固定的机制，以使达成一致成为正常业务的一部分。如果架构满足了高层的约束条件，那么在细节的实施方面可以允许更多的灵活性。在最极端的情况下，解决墙头草问题可能需要寻找新的、期望更为接近的受益人。</p>
<p>2）模式：三个臭皮匠</p>
<p>三个臭皮匠：反映了这样一种认识，即架构师并非总是架构构想的来源，架构师和客户一起充实、完善构想。</p>
<p>一个共同的架构或平台是产品线战略的关键，架构发起人希望产品团体能开发出“杀手解决方案”，而同时又能避免追随新的标准、潮流带来的困扰。</p>
<p>在这种情况下，需要抵制创建一个无所不能的架构的诱惑，建立一种能让架构师及其用户都能丰富、实现功能特性的构想。高级经理只提供构想、目标和原则，把架构和平台留给架构师，把实现细节留给合适的团队或层次。一个成功的产品线架构必须能为适应市场变化，能适应和采用新技术，能解决在概念阶段还不知道的但变化场景可预见的问题。</p>
<p>这是一项很少有架构师能独立完成的任务，然而，通过高级经理建立正确的顶层业务构想，架构师采取实现构想的正确行动就能取得成功。</p>
<p>准则3：关于架构和构件的潜藏知识对其用户是可见的、可获得的。</p>
<p>1）反模式：一叶障目</p>
<p>一叶障目：发生在这种情况下：开发人员过分专注于应用，以致不知道其他架构解决同类问题的通用的解决方案。</p>
<p>在一个组织中，工程团队正在实践代码所有制模式，工程师们都把精力集中在自己眼前的任务和职责上，没有把自己当作一个共享资源的看护者。陷入本反模式的工程师的视野很窄，面对其他开发同事的请求往往只求解决问题，不愿意多加考虑。这样导致的工作结果可能变得非常复杂、脆弱而且容易出错，这是由一名工程师所无法预见的情况造成的。</p>
<p>要解决上面的问题，需创造一种分享知识的愿望。例如，工程师培训等方式就可以起到一些作用，整个组织的人员启用知识管理平台也能促进产生这种愿望。</p>
<p>2）模式：轮流工作</p>
<p>轮流工作：要求参与架构的工作人员轮流在架构的不同部分上工作。这样能使他们对架构有更多的了解，并有机会发展非正式的人际网络。</p>
<p>当一个产品线的销售增长到一定程度，一个单一的、聚集的团队已无法支撑架构和实现，人员被重新组织到地理上分布不同的团队中。已有的沟通管道与新的形势已经不相适应。</p>
<p>通过帮教制（Apprenticeship）模式阶段性地轮流交换构件的所有权可以解决上面的问题。组织和鼓励构件的前任负责人抽出时间帮助新的负责人，轮转周期应该尽可能地与发布进度保持同步。该方法能使开发人员更容易地发现如何找到有关构件的知识，团队成员掌握某个构件或者在出现问题时知道应该问谁的可能性也大大增加了。因此，意外发生的次数减少了。</p>
<h3 id="节奏：保证节拍、过程和进展"><a href="#节奏：保证节拍、过程和进展" class="headerlink" title="节奏：保证节拍、过程和进展"></a>节奏：保证节拍、过程和进展</h3><p>节奏原则使得软件架构在跨越组织边界的情况下开发和使用成为可能。由于许多参与开发和使用架构的团体是自治性的，不可能自上而下地协调这些团体，节奏原则提供了一个随时间变化的框架，可使团体同步各自的活动与期望。有了节奏，参与者就能知道何时关心和应该关心哪些活动。不仅计划中的活动可以被协调管理，节奏原则也可以协调那些非正式的但很关键的活动，例如团体间的交流，这样参与者就可以知道何时应该或不应该提出对于信息或支持的要求。</p>
<h4 id="节奏定义"><a href="#节奏定义" class="headerlink" title="节奏定义"></a>节奏定义</h4><p>节奏是一个架构团体内部及它与客户和供应者之间反复出现的、可预测的工件交换活动。节奏有三个元素：速度、内容和质量。速度是指一个团体与另一个团体之间同类型交接发生的频率，例如架构团队与产品开发工程师之间。如果交接的时间是可预测的，移交则容易管理。稳定的发布计划是速度的一个例子。内容是指一个团体向另一个团体提供的价值。例如，一个团体开发一种新的或者要修改的特性被另一个团体用于满足某种需要。质量的含义是遵循开发过程确保架构没有缺陷。组织可以通过省略非增值的步骤来加快速度，但是如果重要的流程被截掉了，节奏就会遭到破坏。</p>
<p>节奏在团体和组织之间与内部提供一种协调活动的稳定力量，帮助移交管理。当节奏很强时，受益人能培养很强的预见、实施移交和交接的技能。节奏还能驱动活动完结，拥有良好节奏的组织通过建立有规律的阶段间隙来推动评估、再评估和其他工作的进展。</p>
<h4 id="将节奏原则付诸实践"><a href="#将节奏原则付诸实践" class="headerlink" title="将节奏原则付诸实践"></a>将节奏原则付诸实践</h4><p>没有建立节奏会导致客户不满意、不期望的错误发生和工件无法一起工作。只有当以下准则出现时，才说明节奏原则起了作用。</p>
<p>（1）经理们定期地再评估、同步和调整架构。</p>
<p>（2）架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>（3）通过节奏协调明确的活动。</p>
<p>节奏原则中，准则到模式、反模式的映射如表15-2所示。</p>
<details><summary>表15-2　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904141235.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904141235.png';" /></details>

<p>准则1：经理们定期地再评估、同步和调整架构。</p>
<p>好的节奏需要有规律的节拍。对于架构组织的管理者，这意味着他们必须在稳定的间隙上再评估、同步和调整他们的架构计划。节奏的节拍还能提供一个计划过程的框架。具有良好节奏的一个组织用节拍而不是时间来衡量进度。</p>
<p>相关的反模式和模式如下。</p>
<p>1）反模式：一步成功</p>
<p>一步成功：是指当组织变得过于专注地向市场推出某项功能特性而导致内部节奏遭到破坏时发生的情形。组织被竞争所蒙蔽，全身心地专注于向市场提供该特性，却削减了质量，甚至可能破坏本来的节奏。</p>
<p>相关的解决办法有：把关键的功能特性作为团队节奏的一个组成部分来实现。围绕一个特定的主题来进行一次特定的发布，利用主题帮助抓住市场上的机会。如果关键特性特别复杂，则采用几次迭代来实现。但如果在实现关键特性的时候难以保持节奏，说明该特性的风险和复杂度比预计的要大，需要重新规划。</p>
<p>2）模式：发布委员会</p>
<p>发布委员会：描述了一种协调参与发布新架构的相关各方的方法。该模式向经理们介绍了一种在架构发布的最后阶段再评估、同步和调整架构的方法。</p>
<p>定期举办由组织中每个关键受益人参加的正式会议以引导发布的进程。在会议中，要复审产品功能特性和优先级的变更，从而使产品文档、市场承诺、公共关系、测试和开发保持一致。在适合的地方采用测量指标度量发布的进展，分享责任和依赖，做出如何前进的决定，并记录和传达会议的决定。参加委员会的成员应该保持稳定，会议成员的组成应保持一致，与会人员也应该有足够的决定权。</p>
<p>准则2：架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>如果架构用户不信任架构发布的进度和内容，那么用户就可能不采用新的架构发布，或者可能选择另一个架构。用户对架构发布的进度和内容缺乏信心是一个警告信号，说明没有建立一个良好的节奏。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：超敏捷</p>
<p>超敏捷：发生在组织试图在开发过程中抄近路以维持稳定的发布节拍的时候。该反模式对用户所期望的架构质量和内容进行了妥协。</p>
<p>过程执行的合适方法取决于组织文化。在有些组织中，阶段性的软件审计可以用于保证过程被遵守。然而，在许多组织中，审计并不是一种改变或约束行为的有效方法，高层管理的行动能更直接地改变组织行为。是否已经分配了足够的资源来执行计划中的步骤，经理们是否创建明确的目标来保证对节奏的维持都有非常重要的影响。</p>
<p>2）模式：舍兵保帅</p>
<p>舍兵保帅：探讨了组织如何通过把不太重要的特性移到后面的发布周期以保持一个节拍。通过保持节奏，该模式可以使用户获得对架构发布进度更多的信心。</p>
<p>如果对构件的修订看上去无法及时完成时，而且该修订并不非常重要，应该尽快向受益人说明。在不对延误构件做变更的情况下，继续发布架构。为了避免因用户没有阅读或看见特性变更说明而造成的问题，应该确保从预发布开始就放弃该特性，这样用户就能在α或β测试中体验到变化，而不是在正式的产品发布中。可以在以后的发布中再把该构件的变更加进来。通过上面的方法可以保持发布的速度，使架构发布后的活动计划能按进度进行。该方法还能推动构件负责人按时完成他们的修订工作。因为架构的发布实现了承诺，开发人员增强了信任感，他们对下一次如期发布也有了更多的信心。</p>
<p>准则3：通过节奏协调明确的活动。</p>
<p>软件架构的受益人分布在许多不同的组织中。一个共享的架构节奏能帮助这些自治团体跨越组织边界协同工作，因为它能帮助建立关于关键事件何时发生以及如何发生的共同假定。例如，如果一位产品开发员知道每年有一个架构主发布和若干季节性的维护发布，他就可以根据预期的架构发布安排产品发布时间，更好地利用新的架构特性。</p>
<p>与准则3相关的反模式与模式如下。</p>
<p>1）反模式：销售未检验的产品</p>
<p>销售未检验的产品在此情况下发生：一个组织试图实现定期的建立，但这些建立经常编译失第15章　架构师的管理实践</p>
<p>在实践过程中，软件架构的主要障碍往往在于组织方面而非技术。创造切实可行的软件架构需要对技术的深入把握、良好的认知能力和沟通技巧以及大量艰苦的工作。技术上出色的架构往往由于没有全面地处理好组织管理因素而失败。架构师利用自己的知识影响团队，常被大家认为是无冕之王，因此架构师需要管理技巧。本章介绍了架构师的VRAPS实践。</p>
<p>15.1　VRAPS组织管理原则</p>
<p>VRAPS是为实践软件架构的组织管理原则提出的，包括构想、节奏、预见、协作和简化5个相关联的原则。每项原则都是实际可操作的，原则的提出都来源于构建软件架构的直接经验，并且都可以用来解释实践。VRAPS模型的焦点在开发和使用软件架构过程的组织管理方面，其应用环境不仅包括建立和部署架构的团队，还包括利用架构开发和利用产品线的团队和使用这些产品的客户。</p>
<p>受益人是指建立并长期保持架构的价值有重要影响的人或组织。受益人一般包括发起人、应用开发人员和应用客户，还可能包括其他重要的参与者，如技术供应方。</p>
<p>（1）构想原则：说明了如何向架构的受益人描述一幅一致的、有约束力和灵活的未来图景。</p>
<p>（2）节奏原则：刻画了一种在整个组织范围内的协调程度，即定期地根据可预测的速度、内容和质量对制品生产进行检查与规划。</p>
<p>（3）预见原则：要在预测未来与检查并适应现状之间做出平衡。</p>
<p>（4）协作原则：解决了如何识别对架构成功关键的团体，以及如何确保这些合作伙伴的有效支持。</p>
<p>（5）简化原则：要求理解组织的结构，了解架构最小的基本特征并最小化架构。</p>
<p>各个原则之间不是相互孤立的，图15-1解释了构想原则如何与其他原则交互。构想原则确立了总体方向，使得节奏原则所要求的协调工作能够进行。而一个好的节奏又可以使组织朝着构想原则制定的目标不断提供递增的进展。构想原则中的假设根据预见原则进行测试和验证。在架构演化中，应注意环境的变化，并把这些变化加入到构想中。构想帮助建立准则，以挑选合作伙伴和理解他人给架构带来的价值。这些合作伙伴的约束是一个好的构想的关键要素。构想对简化原则也起到了作用。预期的价值经过解释被运用到架构的决策中，而反过来又帮助完善构想。</p>
<p>alt</p>
<p>图15-1　构想与其他原则之间的交互关系</p>
<p>所有其他的原则也是彼此之间相互影响的。例如，节奏原则中的协调组活动如果没有了协作是不可能完成的。通过在每个开发周期中关注最小的关键需求，节奏原则又帮助了简化原则的进行。</p>
<p>15.2　概念框架</p>
<p>为了更好地使用VRAPS原则，我们用准则、模式和反模式来对各项原则进行补充。准则用于判断每项原则的实施效果如何。模式描述了开发和使用软件架构时可能遇到的常见问题和解决方法，能够帮助组织改进原则。反模式则描述了组织在实践中可能遇到的陷阱。</p>
<p>1．准则</p>
<p>为了把原则运用到实践中，需要可操作的实施细节。准则把广泛的原则翻译成是否和如何执行原则的细节。</p>
<p>2．模式</p>
<p>第一项原则都附有一组模式，它描述了开发或者使用软件架构时可能遇到的常见问题的解决方法。模式更注重于解决特定情况下的问题，传达了在给定背景和多方竞争因素下针对常见问题的解决方案。</p>
<p>3．反模式</p>
<p>反模式描述了组织在实践中可能遇到的陷阱，描述了不该做的事情，或者用在错误背景下的解决方案，可以帮助更深入地理解原则。</p>
<p>15.3　形成并统一构想</p>
<p>构想描述了架构的未来，提供了架构使用的环境和动机。构想是未来价值到架构约束的映射，构想要成功，则必须把它所能提供的价值与客户的约束相对应。构想也必须是明晰的、有约束力的、一致的和灵活的，从而能够被其受益人理解并有效地运用。</p>
<p>例如，在大型组织中，管理层可能把项目架构师与维护产品构想的高级经理分隔开来。这种距离会维持构想一致性，导致架构难以满足维护要求，引发后期运行成本问题。为了应对类似组织结构产生的复杂性，高级经理和架构师之间建立稳固的、积极的关系以及共享统一的构想至关重要。</p>
<p>把价值映射为架构约束，要求开发人员把约束诸如接口、开发语言和模块边界等映射到特定的客户价值上。促使受益人把约束与客户价值捆绑需要高超的技艺，用例建模是把架构的预期使用与能够被满足的切实的用户目标连接起来的一种方法。例如，识别并表达出似乎无关的用例之间的实质性联系是建立构想的一个重要内容。</p>
<p>15.3.1　形成构想</p>
<p>构想需要维持一致性与协调性。一致性是指受益人的各种期望之间妥协，以及它们与现在和将来的架构之间的需求满足程度。灵活性是指受益人在不破坏架构的情况下，在现有架构之上完成事先没有预料到的需求的容易程度。</p>
<p>一致性并不意味着所有受益人之间拥有一张完全一致的构想视图，而是指各受益人共享的视图根据他们不同的视角保持一致。RUP的“4＋1架构视图”体现了获得这种一致性的方法。RUP通过逻辑视图（Logic View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）和用例视图（Use case View）建立了架构视图。这些架构视图的不同点在于，它们根据不同目的表示系统（例如，用例视图表示了系统的最终用户功能）。</p>
<p>架构师常负有将现实引入业务构想和将构想变成现实的责任。架构师可以推荐技术，包括如何以及何时采用这些技术， 由此来帮助确定业务构想的哪些部分可以在短期内实现，以及各部分实现的次序。</p>
<p>架构师更像管理者而并非实施者，Dean Thompson说：“作为架构师更多地意味着权衡业务、组织运作和使用技术，而不仅仅是技术细节。”例如，架构师应该全面研究整个组织，找出各利益方关注的重点，然后妥善平衡，建立符合主要关注问题的架构描述。</p>
<p>多方整合能促进构想的形成。多方整合是组织各利益方的机制，用于确保获得构想并使其稳定；是指在一个公共的组织层次上对信息、决策和资源进行协调。多方整合能使从事硬件设计的基层经理理解软件设计和开发人员，以及市场营销、客户支持和市场营销的同事的期望，包括增强组织与客户和外部供应者沟通的能力。</p>
<p>Thompson归纳了形成架构构想的三步方法：清楚明确地阐述一条迫切的客户价值；将客户价值映射为少数特定的能解决的问题；将以上问题转译成一组特定的约束条件。</p>
<p>成功的架构师用明确的客户价值映射规划未来，以使用户及它们的客户能将其与约束联系起来。架构师必须格外关注产品开发人员和最终的客户，而且为了成功，还要发动所有其他人做类似的事情。</p>
<p>15.3.2　将构想原则付诸实践</p>
<p>下面的准则、反模式和模式能帮助建立、形成、维护一个被共享的构想，将构想原则付诸实践。</p>
<p>用于检验构想原则是否起作用的准则如下。</p>
<p>（1）架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>（2）实施人员是否信任并使用架构。</p>
<p>（3）关于架构和构件的潜藏知识对其用户（开发团队）是否是可见的、可获得的。</p>
<p>构想原则中准则到模式、反模式的映射如表15-1所示。</p>
<p>表15-1　准则到模式、反模式的映射</p>
<p>alt</p>
<p>下面详细介绍与各准则相关的反模式和模式。</p>
<p>准则1：架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>为了获得一致、迫切和灵活的架构，需要产品线经理、架构师和实施经理等达成共识。而如果没有阐明用户价值，则会导致构想脱离了重点。</p>
<p>与准则1相关的反模式与模式如下。</p>
<p>1）反模式：风险后置</p>
<p>形容这样统一受益人的构想：用最小的妥协、最大的优化规划出一个构件以满足所有冲突利益的需要。这种统一方法的问题是，设计出来的构件往往在理论上可行，但实际运行中出现风险。</p>
<p>一条新产品线的架构师或经理，需要开发看似很棒但实现有风险的构件。这些要完成构件可能需要打破“物理定律”才能完成，这些风险可能在制品交付的最后才能显现。可是有一批工程师仍然坚持开发这些构件。风险构件被安排到最后完成，以为这样可以有时间消除风险。可是，当计划好的完成日期临近时，依然无法交付。尽管架构在演示的幻灯片上运转良好，实际上却无法正常工作。</p>
<p>面对这种情况，需要分析并阐明风险， 向高级经理提供一个选择，要么承认风险，要么调整任务。</p>
<p>2）模式：前后一致</p>
<p>要求推动架构投资的高级经理积极地维护构想，并防止构想受到短期压力的影响。</p>
<p>一个公共的架构被几个产品共享，它已经变得比预期要复杂得多。而客户们针对每件产品又提出了以前没有预计到的功能特性。如果加入这些功能特性，则不能保证进度，但如果不开发这个特性则可能失去一位重要客户。</p>
<p>这样的情况下，需要评估架构构想的质量和稳定性。只有当两者都正常时，才能采取进一步行动。如果该新特性不属于原来的产品构想支持的代价范围，那就应该放弃开发这个新特性。如果构想不明确，在短期内就交付很可能导致大量缺陷。此时应与客户、架构师和销售、产品、支持人员以及开发经理一起加强产品的构想。如果这个特性确实属于一个稳定的产品构想，那么应该在开发组织内核实这种一致性。</p>
<p>准则2：实施人员信任并使用架构。</p>
<p>只有使用架构，才能从中获得价值。然而，要让开发人员对架构构想充分信任需要做更多的工作，仅仅靠不断兑现承诺是不够的。开发人员需要把他们对构想的了解与他们认为对下一步行动有用的东西联系起来。开发人员在利用架构的过程中，可能会使架构向许多不同的方向发展。一个良好架构应与构想保持一致，同时又能满足用户的需求。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：墙头草</p>
<p>描述了这样一种情况：因为没有良好的构想，导致架构方向在竞争和客户压力的影响下经常改变。这种构想永远不能达到稳定以便有效地被共享。</p>
<p>在开发过程中，经常会出现这样一种情况：来自客户、竞争对手和高级经理的压力使得需要在一次发布的中途加入一些代价高昂的功能，高级经理甚至可能在没有咨询架构师的情况下决定提供这些功能。可是一旦交付了某个激进的功能，组织马上就会陷入对该功能的支持工作中。以后的发布会因需要提供向后兼容而变得更为复杂。</p>
<p>在这种情况下，要做的是理解并阐明构想。方便变更需求是成功构想的一部分，要对其进行规划。高级主管要与架构师一起紧密地工作，理解变更的后果并做出正确的权衡。在建立了构想之后，可以用前后一致模式来评估特定的变更建议。在把功能特性加入到发布之前，要坚持达成一致意见。这需要一种固定的机制，以使达成一致成为正常业务的一部分。如果架构满足了高层的约束条件，那么在细节的实施方面可以允许更多的灵活性。在最极端的情况下，解决墙头草问题可能需要寻找新的、期望更为接近的受益人。</p>
<p>2）模式：三个臭皮匠</p>
<p>三个臭皮匠：反映了这样一种认识，即架构师并非总是架构构想的来源，架构师和客户一起充实、完善构想。</p>
<p>一个共同的架构或平台是产品线战略的关键，架构发起人希望产品团体能开发出“杀手解决方案”，而同时又能避免追随新的标准、潮流带来的困扰。</p>
<p>在这种情况下，需要抵制创建一个无所不能的架构的诱惑，建立一种能让架构师及其用户都能丰富、实现功能特性的构想。高级经理只提供构想、目标和原则，把架构和平台留给架构师，把实现细节留给合适的团队或层次。一个成功的产品线架构必须能为适应市场变化，能适应和采用新技术，能解决在概念阶段还不知道的但变化场景可预见的问题。</p>
<p>这是一项很少有架构师能独立完成的任务，然而，通过高级经理建立正确的顶层业务构想，架构师采取实现构想的正确行动就能取得成功。</p>
<p>准则3：关于架构和构件的潜藏知识对其用户是可见的、可获得的。</p>
<p>1）反模式：一叶障目</p>
<p>一叶障目：发生在这种情况下：开发人员过分专注于应用，以致不知道其他架构解决同类问题的通用的解决方案。</p>
<p>在一个组织中，工程团队正在实践代码所有制模式，工程师们都把精力集中在自己眼前的任务和职责上，没有把自己当作一个共享资源的看护者。陷入本反模式的工程师的视野很窄，面对其他开发同事的请求往往只求解决问题，不愿意多加考虑。这样导致的工作结果可能变得非常复杂、脆弱而且容易出错，这是由一名工程师所无法预见的情况造成的。</p>
<p>要解决上面的问题，需创造一种分享知识的愿望。例如，工程师培训等方式就可以起到一些作用，整个组织的人员启用知识管理平台也能促进产生这种愿望。</p>
<p>2）模式：轮流工作</p>
<p>轮流工作：要求参与架构的工作人员轮流在架构的不同部分上工作。这样能使他们对架构有更多的了解，并有机会发展非正式的人际网络。</p>
<p>当一个产品线的销售增长到一定程度，一个单一的、聚集的团队已无法支撑架构和实现，人员被重新组织到地理上分布不同的团队中。已有的沟通管道与新的形势已经不相适应。</p>
<p>通过帮教制（Apprenticeship）模式阶段性地轮流交换构件的所有权可以解决上面的问题。组织和鼓励构件的前任负责人抽出时间帮助新的负责人，轮转周期应该尽可能地与发布进度保持同步。该方法能使开发人员更容易地发现如何找到有关构件的知识，团队成员掌握某个构件或者在出现问题时知道应该问谁的可能性也大大增加了。因此，意外发生的次数减少了。</p>
<p>15.4　节奏：保证节拍、过程和进展</p>
<p>节奏原则使得软件架构在跨越组织边界的情况下开发和使用成为可能。由于许多参与开发和使用架构的团体是自治性的，不可能自上而下地协调这些团体，节奏原则提供了一个随时间变化的框架，可使团体同步各自的活动与期望。有了节奏，参与者就能知道何时关心和应该关心哪些活动。不仅计划中的活动可以被协调管理，节奏原则也可以协调那些非正式的但很关键的活动，例如团体间的交流，这样参与者就可以知道何时应该或不应该提出对于信息或支持的要求。</p>
<p>15.4.1　节奏定义</p>
<p>节奏是一个架构团体内部及它与客户和供应者之间反复出现的、可预测的工件交换活动。节奏有三个元素：速度、内容和质量。速度是指一个团体与另一个团体之间同类型交接发生的频率，例如架构团队与产品开发工程师之间。如果交接的时间是可预测的，移交则容易管理。稳定的发布计划是速度的一个例子。内容是指一个团体向另一个团体提供的价值。例如，一个团体开发一种新的或者要修改的特性被另一个团体用于满足某种需要。质量的含义是遵循开发过程确保架构没有缺陷。组织可以通过省略非增值的步骤来加快速度，但是如果重要的流程被截掉了，节奏就会遭到破坏。</p>
<p>节奏在团体和组织之间与内部提供一种协调活动的稳定力量，帮助移交管理。当节奏很强时，受益人能培养很强的预见、实施移交和交接的技能。节奏还能驱动活动完结，拥有良好节奏的组织通过建立有规律的阶段间隙来推动评估、再评估和其他工作的进展。</p>
<p>15.4.2　将节奏原则付诸实践</p>
<p>没有建立节奏会导致客户不满意、不期望的错误发生和工件无法一起工作。只有当以下准则出现时，才说明节奏原则起了作用。</p>
<p>（1）经理们定期地再评估、同步和调整架构。</p>
<p>（2）架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>（3）通过节奏协调明确的活动。</p>
<p>节奏原则中，准则到模式、反模式的映射如表15-2所示。</p>
<p>表15-2　准则到模式、反模式的映射</p>
<p>alt</p>
<p>准则1：经理们定期地再评估、同步和调整架构。</p>
<p>好的节奏需要有规律的节拍。对于架构组织的管理者，这意味着他们必须在稳定的间隙上再评估、同步和调整他们的架构计划。节奏的节拍还能提供一个计划过程的框架。具有良好节奏的一个组织用节拍而不是时间来衡量进度。</p>
<p>相关的反模式和模式如下。</p>
<p>1）反模式：一步成功</p>
<p>一步成功：是指当组织变得过于专注地向市场推出某项功能特性而导致内部节奏遭到破坏时发生的情形。组织被竞争所蒙蔽，全身心地专注于向市场提供该特性，却削减了质量，甚至可能破坏本来的节奏。</p>
<p>相关的解决办法有：把关键的功能特性作为团队节奏的一个组成部分来实现。围绕一个特定的主题来进行一次特定的发布，利用主题帮助抓住市场上的机会。如果关键特性特别复杂，则采用几次迭代来实现。但如果在实现关键特性的时候难以保持节奏，说明该特性的风险和复杂度比预计的要大，需要重新规划。</p>
<p>2）模式：发布委员会</p>
<p>发布委员会：描述了一种协调参与发布新架构的相关各方的方法。该模式向经理们介绍了一种在架构发布的最后阶段再评估、同步和调整架构的方法。</p>
<p>定期举办由组织中每个关键受益人参加的正式会议以引导发布的进程。在会议中，要复审产品功能特性和优先级的变更，从而使产品文档、市场承诺、公共关系、测试和开发保持一致。在适合的地方采用测量指标度量发布的进展，分享责任和依赖，做出如何前进的决定，并记录和传达会议的决定。参加委员会的成员应该保持稳定，会议成员的组成应保持一致，与会人员也应该有足够的决定权。</p>
<p>准则2：架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>如果架构用户不信任架构发布的进度和内容，那么用户就可能不采用新的架构发布，或者可能选择另一个架构。用户对架构发布的进度和内容缺乏信心是一个警告信号，说明没有建立一个良好的节奏。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：超敏捷</p>
<p>超敏捷：发生在组织试图在开发过程中抄近路以维持稳定的发布节拍的时候。该反模式对用户所期望的架构质量和内容进行了妥协。</p>
<p>过程执行的合适方法取决于组织文化。在有些组织中，阶段性的软件审计可以用于保证过程被遵守。然而，在许多组织中，审计并不是一种改变或约束行为的有效方法，高层管理的行动能更直接地改变组织行为。是否已经分配了足够的资源来执行计划中的步骤，经理们是否创建明确的目标来保证对节奏的维持都有非常重要的影响。</p>
<p>2）模式：舍兵保帅</p>
<p>舍兵保帅：探讨了组织如何通过把不太重要的特性移到后面的发布周期以保持一个节拍。通过保持节奏，该模式可以使用户获得对架构发布进度更多的信心。</p>
<p>如果对构件的修订看上去无法及时完成时，而且该修订并不非常重要，应该尽快向受益人说明。在不对延误构件做变更的情况下，继续发布架构。为了避免因用户没有阅读或看见特性变更说明而造成的问题，应该确保从预发布开始就放弃该特性，这样用户就能在α或β测试中体验到变化，而不是在正式的产品发布中。可以在以后的发布中再把该构件的变更加进来。通过上面的方法可以保持发布的速度，使架构发布后的活动计划能按进度进行。该方法还能推动构件负责人按时完成他们的修订工作。因为架构的发布实现了承诺，开发人员增强了信任感，他们对下一次如期发布也有了更多的信心。</p>
<p>准则3：通过节奏协调明确的活动。</p>
<p>软件架构的受益人分布在许多不同的组织中。一个共享的架构节奏能帮助这些自治团体跨越组织边界协同工作，因为它能帮助建立关于关键事件何时发生以及如何发生的共同假定。例如，如果一位产品开发员知道每年有一个架构主发布和若干季节性的维护发布，他就可以根据预期的架构发布安排产品发布时间，更好地利用新的架构特性。</p>
<p>与准则3相关的反模式与模式如下。</p>
<p>1）反模式：销售未检验的产品</p>
<p>销售未检验的产品在此情况下发生：一个组织试图实现定期的建立，但这些建立经常编译失败或无法通过自动测试。这表明协作的失效。</p>
<p>由于团队不把编译和测试用例的失败当回事，认为在以后的开发过程中能消除这些不一致的情况，导致积累下来的问题越来越多，无法按时发布。</p>
<p>在这样的情况下，要确保对定期建立的承诺。管理层必须明确无误地告诉开发人员，定期建立应该成功。软件建立不仅应该包括编译产品，还应该包括某种形式的自动测试。对定期建立的流程进行修改，防止在修正失败的建立之前开展新的工作。同样地，以前曾经通过的失败测试用例应该马上处理。</p>
<p>2）模式：同步发布</p>
<p>同步发布是一种把节奏理念扩展到组织边界以外的技术。该模式提供了一种同步架构团队及其用户的活动的方法。</p>
<p>和你的合作伙伴一起确定交付架构特性的先后顺序，以便他们利用架构开发产品。应尽可能在架构的早期发布中包括这些特性。如果架构中的一些变化需要互补产品做出重大变更，那么应让这些变化出现在最早的预发布中。应该告知合作伙伴何时能够获得哪些特性。作为调整早期发布方式的回报，应与合作伙伴签订协议让他们把包含或需要你的架构的产品迅速推向市场。</p>
<h3 id="预测、验证和调整"><a href="#预测、验证和调整" class="headerlink" title="预测、验证和调整"></a>预测、验证和调整</h3><p>为了使对软件产品线的长期投资能产生回报，组织必须确保架构满足许多应用的需求。组织应能够预见变化并对变化做出反应，包括那些在设计架构时还没想到的需求。架构必须能够适应新的技术、标准、市场和竞争对手。刚开始设计架构时正确的假设几年以后可能就失效了，这就要求组织必须能够对架构进行预测和演化。</p>
<h4 id="预测、验证和调整的定义"><a href="#预测、验证和调整的定义" class="headerlink" title="预测、验证和调整的定义"></a>预测、验证和调整的定义</h4><p>预见是指建立和实现架构的人员根据变化的技术、竞争和客户需求预测、验证和调整架构的程度。</p>
<p>软件架构师不可能总能预测到未来。但是，既然一个成功的架构将被持续使用很长时间，架构师至少要对未来将发生什么做出合理的猜测。架构师必须考虑架构用户可能怎么变化，竞争形势将如何改变，未来的运行环境是怎样的。架构必须能够适应新的组织结构，特别是在一些像银行业这样合并和接管司空见惯的领域中。许多计划建立在对未来的假定上，但是预测意味着这些假定是作为架构描述的一部分而明确表述的。例如，有关的假定可能基于这样一种未来的情况：处理器速度依然遵循摩尔定律，在以后的10年里每18个月翻一番。当然，除非架构师有预知未来的超自然能力，否则这些预测不可能总是正确，所以需要验证。</p>
<p>验证不仅局限于传统软件工程的测试和检查技术，也包括对架构的基础假定的测试。例如，用户真的想要计划好的东西吗？现有的技术能实现用户的需求吗？分析这些假定的重要原因是，架构师及其发起人做出了许多关于架构的艰难决策。在架构成型前要对这些假定进行检查和确认，否则会导致代价高昂的错误。</p>
<p>软件架构的长期成功依赖于对假定的变更和通过预测及验证所获信息的适应程度。调整就是对架构计划及架构本身修正以加入新特性，从而能参与新兴市场的竞争或者在新的环境中生存。因此，调整要求组织具有敏捷性。调整可能不仅包含架构本身，还包括计划，甚至整个架构构想。</p>
<h4 id="将预见原则付诸实践：准则、反模式与模式"><a href="#将预见原则付诸实践：准则、反模式与模式" class="headerlink" title="将预见原则付诸实践：准则、反模式与模式"></a>将预见原则付诸实践：准则、反模式与模式</h4><p>下面的准则、反模式和模式为帮助判定组织在预见验证、调整架构方面提供了指导。当以下情况发生时，说明预见原则发生了作用。</p>
<p>（1）不断增强架构的响应能力：预见到的风险和架构客户及其客户的需求；市场驱动的标准和演变的技术；战略性业务方向的改变。</p>
<p>（2）通过快速复审和开发周期，评估技术和业务上的风险与机会。</p>
<p>（3）当认识到关键的估计或假设有错时，及时调整功能特性、预算。</p>
<details><summary>表15-3　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142106.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142106.png';" /></details>

<details><summary>表15-3　准则到模式、反模式的映射-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142120.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142120.png';" /></details>

<p>准则1：不断增强架构的能力以响应预见到的风险和架构客户及其客户的需求，市场驱动的标准和演变的技术，战略性业务方向的改变。</p>
<p>与此相关的反模式与模式如下。</p>
<p>1）反模式：遗漏细节</p>
<p>遗漏细节：描述了发现一个明显的功能特性被遗漏时的尴尬经历。每个人都关注发布的强大新特性，以致忽视了一些用户必不可少的功能。</p>
<p>对这种情况，需要识别关键用户群，和他们一起找出最重要的需求。这意味着要有一位对这些用户群有着深入了解的专题事务专家的参与。要调查的问题包括“哪些产品会建立在这个架构之上？”，“哪些产品是最重要的？”该方法也可以用来指导架构方向的改变。调研的覆盖面很重要，需要让高级经理了解这一过程以使他们在敦促实现其他高级特性和技术的时候，不会在无意中破坏这些基本特性的交付。</p>
<p>2）模式：示范区</p>
<p>示范区模式应用在如何决定哪个产品应该引入一个新架构的情况下。</p>
<p>挑选一个项目初步实现架构。该项目的客户渴望采用新技术，而且也愿意容忍获得该技术时可能存在的不便。当示范区项目投入使用后，架构师将从实际使用中得到关于架构的有价值反馈。在架构大范围应用之前，缺陷将被发现并解决，这也意味着缺陷的修订受后向兼容问题的约束较小。成功的示范区项目可以在建议其他项目时作为参考。</p>
<p>准则2：通过快速复审和开发周期，评估技术和业务上的风险与机会。</p>
<p>1）反模式：品尝未熟的果实</p>
<p>品尝未熟的果实：说明了当架构师没有考虑其用户的客户，而让其用户支持一种未成熟的技术时发生的情况。</p>
<p>在发起人的要求下，架构师采用了一种新技术来建立下一代架构，团队希望通过它胜过最接近的竞争对手。客户对架构糟糕的性能和各种各样的差错感到很失望，客户并不关心底层技术，他们只需要那些能帮助他们实现目标的东西，一些被以前的换代或升级害苦了的客户则对关于未成熟技术的承诺极度不信任。</p>
<p>在这种情况下，要审慎地选择引入新技术的正确场所。在引入后，要为最初用户提供额外的支持。在选择新架构解决方案时，必须愿意修改技术不完善的部分使其适合一个实际可用的解决方案。不要假定一个未经验证的架构能实现所有的承诺，应该分别在开发人员和产品用户的特定环境下测试你的解决方案。即便如此，还必须向采用新技术的用户提供大量的支持，要谨慎地设定用户正确的期望，留意他们可能遇到问题的迹象。</p>
<p>2）模式： $\color{green}{\text{架构复审}}$ </p>
<p>架构复审模式总结了怎样针对开发中的架构组织执行一次有重点的专家评估，以揭示有重大影响的问题和机遇，例如假设的冲突、可重用的现有方案等。</p>
<p>该模式提出在开发周期的关键时刻成立一个架构复审委员会以检查架构。一旦需求基线初步确定就应该进行首次复审。复审委员会的成员应该包括有经验的架构师、架构小组成员，可能还有客户，人员不要太多，最多七、八个人。在早期复审中，应检测各种假设，看看市场上是否有可购买的解决方案，并进行其他条理性检查。后期的复审应验证假设，确认架构是否满足了需求。注意要让这些复审保持重点。</p>
<p>这种模式可以避免增加成本，因为复审能够在开发过程的早期发现缺陷，这样就可以及时修正。复审能发现可以取代新的开发活动的构件。此外，它还增强了客户对架构提供已承诺能力的信心，从而促进客户使用架构。</p>
<p>准则3：当认识到关键的估计或假设有错时，及时调整功能特性、预算。</p>
<p>1）反模式：创造奇迹</p>
<p>创造奇迹：描绘了当足够的证据显示基础假设和估计已经完全偏离目标时，对架构开发和实现计划不作任何修改将发生的情况。</p>
<p>解决方法分为如下两个部分。</p>
<p>（1）找到架构的基础假设并积极努力测试这些假设。架构复审和示范区模式提供了获取这类信息的手段</p>
<p>（2）一旦发现错误的估计或假设，必须准备好对此采取行动。这可能意味着调整项目进度、功能特性或者启动意外处理计划，此外还包括提醒客户并重新协调进度和发布的内容等。</p>
<p>还应该特别小心那些遏制信息和创意传播、掩盖错误假设的证据的组织文化。无论何种情况，都应该确保把足够的资源编入预算计划，使得当不可避免的意外发生时，有可分配的进度和人员。</p>
<p>2）模式：外包</p>
<p>外包模式展示了怎样适应这种情况，即客户要求的新标准或技术并不属于当前或计划中的核心能力。它提供了指导以说明何时及怎样选择一个已有的第三方构件，或者与供应者合作。</p>
<p>如果存在第三方构件，应考虑采用。如果没有这样的构件，那么组织应该找到合作伙伴来开发和支持该构件。要确定潜在的合作伙伴是否把你需要的构件视为其主营业务的一部分。例如，他们是否能够把它卖给许多其他的客户；评估他们交付和支持该构件所需的特定工作量。把潜在的合作伙伴当作供应商和业务伙伴以评估其能力和信用。基本的规律是，他们必须为你做的专门开发越多，信任程度就要求越高。类似地，信任度越低，你面临的进度和财务风险就越高。如果发现一个非常可靠的潜在供应商，就应该外包构件开发。</p>
<h3 id="协作：建立合作型组织"><a href="#协作：建立合作型组织" class="headerlink" title="协作：建立合作型组织"></a>协作：建立合作型组织</h3><p>协作也是软件架构成功的关键之一，因为不同团体参与者对架构的开发、实现和使用都是很重要的。这些团体跨越了各种各样的组织边界，如团队、地理位置、部门甚至公司。每一个对架构关键的团体必须知道如何使用、努力改进架构从而为自己的利益服务。协作原则解决了如何识别对架构成功起关键作用的团体，以及如何确保这些合作伙伴的支持等问题。</p>
<h4 id="协作定义"><a href="#协作定义" class="headerlink" title="协作定义"></a>协作定义</h4><p>协作是指架构受益人保持明确的、合作的角色并将其所提供和获得的价值最大化的程度。合作是指受益人彼此之间存在一些共享的预期，应该明确表示出达到或未达到预期会有哪些奖励和惩罚。成功协作不仅仅要求架构负责人满足契约条款，合作伙伴还必须采取行动确定和提供预期价值，根据已达成的条款给出特定问题的解决方案。</p>
<h4 id="将协作原则付诸实践：准则、反模式与模式"><a href="#将协作原则付诸实践：准则、反模式与模式" class="headerlink" title="将协作原则付诸实践：准则、反模式与模式"></a>将协作原则付诸实践：准则、反模式与模式</h4><p>协作很容易理解，但将其付诸实践并不简单，当许多团体必须在一个组织内（外）的同一层次上进行合作时尤其如此。正式定义的协作网络与非正式协作网络决定了一个软件架构能否成功。以下准则提供了一种方法用来确定受益人为了使架构与产品服务的价值最大化而进行合作的程度。当出现以下几种情况时，说明协作是有效的。</p>
<p>（1）架构师不断地努力了解谁是最关键的受益人，他们如何贡献价值，以及他们需要什么。</p>
<p>（2）受益人之间达成明确和强制性的契约。</p>
<p>（3）通过社会行为制度和非正式规范强化合作。</p>
<p>表15-4介绍了准则到模式、反模式的映射。</p>
<details><summary>表15-4　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142306.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142306.png';" /></details>

<p>准则1：架构师不断地努力了解谁是最关键的受益人，他们如何贡献价值，以及他们需要什么。</p>
<p>满足受益人的需求说起来很容易，实施起来要困难得多。挑选一批集中的首要客户，找出保证他们参与需要做些什么，然后交付这些内容，这样做可以增大成功的机会。</p>
<p>与准则1相关的反模式和模式如下。</p>
<p>1）反模式：光说不做</p>
<p>光说不做描述了这样一种情况，即架构师知道了用户的需求却遗漏了为了向他们提供有价值的东西所应该做的事情。</p>
<p>架构师忙于其他事务，没有与开发人员进行稳定的交流，各产品团队按照自己的理解开发并升级了产品，放弃了原来同意的清晰的接口。</p>
<p>与许多反模式一样，该反模式中最困难的部分就是，当发生这种情况时如何识别它。当你认为“我们可以以后再补充这些细节”时，应该保证你和你的团队至少理解一些关于开发人员如何从平台获益的明确的例子。模式“了解你的受益人”提供了一种掌握需要哪些措施让受益人参与协作的方法。客户互动模式提供了一些明确、简单和直接的规则与建议，有助于发展有效的协作关系。</p>
<p>2）模式：了解你的受益人</p>
<p>本模式说明了如何利用价值链来识别关键受益人，积极听取他们的意见并获得承诺与支持。</p>
<p>把架构成功的构想与那些最符合合作伙伴能力并积极去做的事情的活动统一起来。阐明设想中架构所能提供的价值，例如架构如何帮助现有产品取得一致的用户界面或者继续保持市场优势，或者是能打开一个针对新产品的全新市场。在初步阐明构想之后，确定潜在的合作伙伴以及他们的能力和利益如何与构想保持一致。</p>
<p>准则2：受益人之间达成明确和强制性的契约。</p>
<p>1）反模式：不记录讨论结果</p>
<p>不记录讨论结果说明了当一个架构团队回避采取必要的行动与其最直接的用户达成明确的契约时会发生什么情况。当用户们失去兴趣时，虽然对话仍在继续，但是讨论已经失去了实质内容，而且通常会浪费所有人的时间。</p>
<p>要确保取得对关键受益人的利益与职责的明确理解。把这些认识记录下来，当互动变得消极或者缺乏建设性时，可以求助于这些文件。这种做法总是很重要，对于那些对别人有强烈影响的参与者而言尤其关键。当状况似乎要失控时，回到当初的约定可以把架构团队从漩涡中解救出来。</p>
<p>2）模式：互惠互利</p>
<p>本模式介绍了一些非常重要的做法，用来建立足够稳固的关系以保障软件架构的共享和成功使用。</p>
<p>互惠互利要求在合作伙伴之间进行公平、主动的价值交换。当共享一个架构的团体之间的关系定义好之后，应该对正式和非正式的契约复审以保证公平的交换。预算中应该包括代码负责人响应其他团体请求所花的时间。要对各个团体支持其他团体的程度进行衡量，而不仅仅评估他们完成自身任务的情况。</p>
<p>准则3：通过社会行为制度和非正式规范强化合作。</p>
<p>协作包括正式和非正式两方面，为了真正巩固协作，需要用社会行为制度和非正式规范来促进合作。</p>
<p>1）反模式：非正式时间做正式工作</p>
<p>非正式时间做正式工作介绍了这样一个情况，即一位工程师申请修改某个构件以便让其他团体使用，却得到一个令人困惑的答复：“你可以做，但是要用你个人的时间。”</p>
<p>让工程师利用业余时间修改，架构师就失去了控制其过程和结果的能力，他可能没有采用组织的文档标准，诸如同级复审等步骤甚至连测试也有可能被删减或完全忽略。如果这种产品加入到其他团队的工件中，这位工程师在需要完成日常任务同时，还接到大量要求提供支持的请求，导致工程师精疲力竭。</p>
<p>对于以上情形，要制定计划奖励工程师花在共享构件上的时间，尽早兑现奖励能减少工作量和大量压力。应仔细考虑如何处理将来这一构件成为多个外部项目的关键的可能性，在权衡利弊时必须根据组织纪律和常理判断，包括企业文化、管理的洞察力、进度压力的程度以及当前状况的细节。很多组织把员工用于开发、维护被团体或项目外部所共享的解决方案的时间编入预算，这样能够预防工程师在利用非正式时间做正式工作开发时对项目的代码偷工减料，并确保你的小组对其他团队或项目的支持能力。</p>
<p>2）模式：杜绝意外</p>
<p>该模式描述了如何在不失去依赖你的构件的其他团体信任的情况下，调整对进度或功能特性的承诺。</p>
<p>要尽早提醒用户注意变更，并及时协商解决方案。在决定变更的内容之前，要确保通知、咨询了构件的用户。让他们了解虽然现在的做法对软件架构能产生直接的影响，但其实它们有着更为广泛的应用。</p>
<p>3）模式：和HR密切合作</p>
<p>和HR密切合作介绍了这样一种做法，即提拔雇员并不仅仅根据个人的技术技能和经验，还要考察其有效地、合乎道德地利用非正式人际网的能力。</p>
<p>软件开发是一种社会活动。可是，很多工程师属于内向型性格，工程师需要与他人交流以获得完成其工作所必需的信息，大部分高级技术岗位要求能迅速获得广泛的潜藏信息。有着广泛非正式人际网的工程师比没有这种网络的工程师能获得质量更好的信息。</p>
<p>在作提拔决定时，要考察一名工程师的非正式人际网的有效性。此时，应找出具体的事例，例如，这位工程师是否通过团队外部的合适人选，获得了曾困扰其同事、阻碍项目进展的问题的答案？如果组织已有晋升的明确标准，那么也可以对此标准做类似的调整。经理们应该避免破坏非正式人际网。</p>
<h3 id="简化：澄清与最小化"><a href="#简化：澄清与最小化" class="headerlink" title="简化：澄清与最小化"></a>简化：澄清与最小化</h3><p>架构师和高级经理必须协力保持架构和组织的平衡。聚焦于客户和业务价值，为架构师提供了方向和指南。确定关键价值是不容易的，尤其是当新客户和新产品的加入使架构偏离原来的方向时，困难会显著增加。构想定义了这种关键价值，而且为实现价值建立了约束。简化则将构想翻译成产品。</p>
<p>简化软件架构的原则概念上看似简单，而实践中它要求对价值非常坚定地专注，以及对架构所生存的组织的理解和支持。架构师必须了解架构最小的基本特征。简化原则还要求通过努力，把这些特征传达给实现架构团队的每一位成员。</p>
<h4 id="简化定义"><a href="#简化定义" class="headerlink" title="简化定义"></a>简化定义</h4><p>简化是指将所作用组织与环境都进行巧妙地理解与最小化，组织形成架构并且思考架构。在决定简化架构时，应当留意组织的结构；否则，你会发现你所做的改变只是暂时的。因此在简化架构之前，必须澄清组织和架构。</p>
<p>澄清组织意味着真实地理解你计划部署架构于其中的组织结构及其影响力（force）。架构对架构团队和客户都必须是清晰的。在简化架构之前，架构师必须精确地知道架构被期望做什么和如何完成这些任务。有时候看似很容易的任务，结果实现起来却很复杂，如果这些复杂性没有被理解清楚，那么建立的架构就可能完全不适合目标任务，而这样的架构会使实现更加复杂。澄清架构就是提供用户所需要的细节。</p>
<p>如果一个组织具备简化、协作和节奏等技能，长期共享架构就能够最小化代码、文档和过程。不必去新发明大量新的代码，却可以开发一种被工程师跨组织共享的公共语言。共享也能促进理解，因为它能最小化用同样术语描述完全不同概念的风险。共享并不能自动产生最小化，在有些不好的组织情况下，共享可能导致架构膨胀。</p>
<h4 id="将简化原则付诸实践：准则、反模式与模式"><a href="#将简化原则付诸实践：准则、反模式与模式" class="headerlink" title="将简化原则付诸实践：准则、反模式与模式"></a>将简化原则付诸实践：准则、反模式与模式</h4><p>当以下准则都满足时，说明简化原则起作用了。</p>
<p>（1）开发人员长期使用架构，减少了总成本和复杂性。</p>
<p>（2）架构小组明确理解关键最小需求，并且将其构造成多应用共享的核心元素。</p>
<p>（3）通过长期的预算和行动确保当相关元素没有被共享、增加了不必要的复杂性时，或者是因为有明确的业务理由时，把相关元素从核心移走。</p>
<p>表15-5介绍了准则到模式、反模式的映射。</p>
<details><summary>表15-5　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142443.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142443.png';" /></details>

<p>准则1：开发人员长期不断地使用架构，减少了总成本和复杂性。</p>
<p>使架构被正确地使用，需要获得并维持经理和实施人员的信任。当存在一个明晰的公共架构构想时，系统可以逐渐变得更加简单。Grady Boody发现，“只有对一个系统的架构有清楚的理解，才能揭示公共的抽象和机制。”利用这种公共性能构造出更简单、更小和更可靠的系统。</p>
<p>与准则1相关的反模式和模式如下。</p>
<p>1）反模式：简单复制并修改</p>
<p>描述了当程序员在学会使用或重视架构之前被强迫迅速完成任务时发生的情况。他们不与构件负责人协商变更就复制并修改架构的部分代码，虽然复制提供了一个快速应付开发新特性的压力的方法，但是它通常会带来深远的后果。例如，如果在原始代码中发现了一个缺陷，组织怎样才能确保修正你和同事复制的所有代码呢？</p>
<p>在一个构件的生命周期中，有几个时机可以避免复制。鼓励工程师在复制构件之前先从构件负责人那里获得变更。可以把避免复制的推测方法加入编程风格指南，以便在代码复制期间识别和去除复制；如果有恰当的理由，这些推测方法可以允许有限的复制。也可以用自动化工具来识别复制代码，特别是在大型遗留系统中。当复制被识别后，可以用一些代码重组技术来去除重复的代码。</p>
<p>2）模式： 由慢而快</p>
<p>描述了当开发人员为了跟上进度而拒绝使用架构结果却更慢时应该怎么做。解决方法是：放宽进度，加强过程。</p>
<p>让开发人员参与架构期望解决的问题的讨论，并通过开发部分解决方案来培训他们，给予过程比进度更高的优先级。指导开发人员逐步采用架构，把以前使用过这种过程有能力修改架构或过程来解决不同问题的专家介绍给开发团队，系统地、认真地遵循验证过程。</p>
<p>准则2：架构小组明确理解关键最小需求，并且将其构造成多应用共享的核心元素。</p>
<p>与准则2相关的反模式与模式如下。</p>
<p>1）反模式：缺乏有效抽象</p>
<p>缺乏有效抽象是直接面对应用编程，虽然开始简洁，但随着应用发展，系统缺乏共享基础。该反模式描述了两种简化的努力走向极端的情况。榕树描述了长期建立单点解决方案的后果。单点解决方案通常是满足一个特定客户需求的最简单方法。根部肥大描述了一个架构或平台小组为平台所支持或可能支持的每个产品开发了专有的特性。</p>
<p>开发小组通过从头开发或者复制一个相关产品，然后根据当前问题进行修改来确保产品尽可能地简单。这样可以很快向客户提供初始产品。然而，这些产品没有共享任何东西。随着每个产品的维护和升级。榕树反模式开始出现，各个产品之间的分离越来越大。由于没有被一个共享平台强力支持，每一个分离产品都要求有自己的支撑结构，很像一棵榕树的分枝被很多枝蔓支撑。</p>
<p>对于这种情况，可以考虑采用类似先复制后合并模式的方法把很多为了适应特定功能特性而被修改的核心架构部分重新并入内核。如果先复制后合并和维护多个产品都不可行，就应考虑通过框架团队来建立一个共享平台。</p>
<p>根部肥大反模式则用枝少干粗的形象描述了这样一种情况，即一个架构或平台小组开发了太多针对单个客户的特性。结果共享了太多的功能，导致平台太大、太慢、推出太迟。根部肥大看起来就像一个倒立的马提尼酒杯，底部很大，杯口太小。</p>
<p>通过其他安排帮助产品小组开发不属于架构的产品特定模块，防止产品专有特性进入平台。把一个最小的共享特性集列入平台计划，并根据优先级以稳定的发布进度交付特性。</p>
<p>2）模式：迁移途径</p>
<p>迁移途径反应了在这样一种情形下的解决方案：架构师打算利用当前架构来支持一个新的有价值的应用领域。但是要在该新应用领域获得成功，需要当前用户所不具备的技能和观念，而拥有这些技能的用户团体却习惯于与当前平台不同的解决问题的方法。</p>
<p>对于这样一种情况，要选择一类最有可能扩大架构价值的采用者，并且努力使架构能被他们很快地理解和采用。考察所有类型的早期采用者，了解他们解决问题的方法和技能。确定哪一种类型最有可能理解或者预见到技术革新的成效，并且严格衡量该类型的用户是否具备解决方案所需的技能和知识。为有目标构想但缺乏重要技能集的专业人员提供迁移途径，提供一个简单的从平台获得基本成果的方法。然后，引导这些用户逐步更具体地使用平台。</p>
<p>准则3：通过长期的预算和行动确保当相关元素没有被共享、增加了不必要的复杂性时，或者是因为有明确的业务理由时，把相关元素从核心移走。</p>
<p>改进一个架构需要时间和经费的稳定投入。稳定性确实很重要，因为当高级经理或主管最不愿意专注于架构时，也是架构最脆弱的时候。他们很容易被诱惑把架构师拉去参加一个紧急的项目以实现一个新特性，而使架构无人照看。</p>
<p>与准则3相关的反模式与模式如下。</p>
<p>1）反模式：编码大于架构</p>
<p>该反模式表明要防止架构师成为实现者。</p>
<p>首席架构师负责调整和维护架构，却被调动了工作要求竭尽全力地实现一个新特性集。这些特性实现了，架构小组却失去了领路人。因为没有时间对架构做出深思熟虑的改变，只好创建了架构的一个特殊版本来解决问题。结果新特性无法适合当前的架构。因为维护一个缺乏概念完整性的产品的工作量太大，结果问题越来越多。</p>
<p>为了防止出现这种情况，应该把首席架构师的时间合理分配给实现新特性和调整架构两个任务，让最能干的工程师来领导实现新特性。在提供时间和资源的同时，允许首席架构师指导实现，以使架构适应新的需求。</p>
<p>2）模式：统计构件变更</p>
<p>统计构件变更是一种通过观察不稳定程度来挑选需要调整的架构构件的方法。</p>
<p>如何才能知道应该重组（Refractor）什么——即从内核去除或简化什么呢？通过长期观测每个构件或子系统的不稳定程度，那些最不稳定的构件就是重组的候选者。因为不稳定表明构件是脆弱和不灵活的，因此应当根本改变该构件。也可以采用其他监控策略，例如监控讨论组以掌握经常被请求的构件。一名经验丰富的实施人员利用该方法可以很快确定哪些构件和子系统是简化的最佳目标，从而节约了时间和精力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch14-%E5%9F%BA%E4%BA%8EODP%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch14-%E5%9F%BA%E4%BA%8EODP%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch14-基于ODP的架构师设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:56:12" itemprop="dateCreated datePublished" datetime="2021-07-19T12:56:12+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 16:57:13" itemprop="dateModified" datetime="2021-09-26T16:57:13+08:00">2021-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="基于ODP的架构师设计"><a href="#基于ODP的架构师设计" class="headerlink" title="基于ODP的架构师设计"></a>基于ODP的架构师设计</h2><p>软件系统架构设计方法是一个实践性大于理论性的工作。从软件有模块概念那天起，就有了总体设计，研究模块、构件与它们之间的关系。架构设计虽然可以归集到几种风格，但面对复杂的应用环境，不同应用领域对架构的理解差异非常大，用事实说话是最基本的研究方法。本章在RM-ODP多视点架构模型上，探讨应用于分布式信息系统的软件架构开发，对软件生命周期其他阶段的影响，特别是架构师在开发过程中的任务与作用。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/caolaosanahnu/article/details/10998099">软件体系架构：RM-ODP参考模型简介</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/seacean2000/article/details/102473736">基于ODP的架构师实践问答</a></li>
<li><a target="_blank" rel="noopener" href="http://www.rm-odp.net/">官网</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ODP/68318?fr=aladdin">Open Distributed Processing</a></li>
</ul>
<h3 id="基于ODP的架构开发过程"><a href="#基于ODP的架构开发过程" class="headerlink" title="基于ODP的架构开发过程"></a>基于ODP的架构开发过程</h3><p>系统架构反映了功能在系统构件中的分布、基础设施相关技术和架构设计模式等，它包含了架构的原则和方法、构件关系与约束，并能支持迭加或增量开发。以软件架构为中心的开发过程是以质量和风险驱动的，最终提供一个稳定、低风险的系统架构，并满足客户的需求（包含潜在需求）。</p>
<p>开放分布进程的参考模型（RM-ODP）是一个ISO标准，它为分布式计算进程提供了一个框架。RM-ODP定义了分布式系统的重要性质：开放性、整体性、灵活性、可塑性、联合性、可操作管理性、优质服务、安全性和透明性，并定义了一组视点。RM-ODP视点定义大体对应于IEEE 1471定义，RM-ODP定义的5个视点如下。</p>
<p>（1）企业视点：在如下因素的环境中分析系统，商业需求和策略、以及系统的范围和目的。RM-ODP处理可能会影响系统中的与企业相关的信息，如组织结构等。</p>
<p>（2）信息视点：指信息的结构，它的变化、流程以及在不同功能间的逻辑划分。</p>
<p>（3）计算视点：重点在于把系统分解为实体和实体间的接口。</p>
<p>（4）工程视点：处理分布式系统对象之间的交互，以及交互是如何得到支持的。</p>
<p>（5）技术视点：定义构成系统的硬件和软件构件。</p>
<p>体系结构视点是把抽象的符号或图表（如UML）运用到具体的体系结构开发任务中。每一个视点有具体的建模目标和系统相关者。例如，环境视图提供了对系统边界及与系统发生交互的外部实体集合的概述。分析视图提供了一个以建模问题而不是答案为中心的实体的抽象集合。</p>
<p>以描述软件设计为目的的视点包括构件、构件交互及构件状态。视图提供了一个对于逻辑运行结构及其功能，以及它们之间通信的映射。子系统接口依赖视图提供了一个子系统依赖关系和接口的图形表示；分层子系统视图提供了一个所有子系统高度抽象的视图；逻辑数据视图提供了构件共有的数据模型描述。</p>
<p>不同视图解决不同方面的问题，这是应对复杂问题的基本研究方法（分治）。采用ODP从5个视点描述信息系统架构，对整个系统开发过程有一定指导意义。除了架构设计阶段，其他阶段对架构师也提出不同的任务与要求。图14-1展示了整个系统及架构开发的10个过程。</p>
<details><summary>图14-1　系统架构开发的10个过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135503.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135503.png';" /></details>

<p>本章按图14-1的次序，探讨架构师的任务与设计工作。</p>
<h3 id="系统构想"><a href="#系统构想" class="headerlink" title="系统构想"></a>系统构想</h3><h4 id="系统构想的定义"><a href="#系统构想的定义" class="headerlink" title="系统构想的定义"></a>系统构想的定义</h4><p>系统构想是指一个系统开发人员与系统用户之间共同的协议。按照该协议，系统开发人员需在特定的时间内完成系统用户的需求。系统构想必须简短而切中要点，给人以清晰的感觉。它不是一成不变的，必须根据系统的不同而不同。</p>
<p>构想描述建立了从需求分析开始的所有项目活动的语境，它高度概括了企业业务架构的核心内容。</p>
<h4 id="架构师的作用"><a href="#架构师的作用" class="headerlink" title="架构师的作用"></a>架构师的作用</h4><p>讨论建模的时候，我们曾提到关键词有目的、关注点、假设和优先级，它们都是系统级的“构想描述（Vision Statement）”的基本元素。如果它们在系统开发过程中改变，项目就有被抛弃的危险。因此，以架构为中心的开发的第一步就是建立一个构想描述，且假定构想描述在系统的各个开发阶段不会改变。所有的改变必须在关键的项目计划中有所反映，特别是在系统架构中。</p>
<p>系统构想包括为客户、为软件系统开发团队等受益人创建的，有助于各方明了系统的目标和范围。对开发者而言，从宏观层面上显示系统架构的需求，为待开发系统提供一个结构清晰的概要，确保系统开发的计划、设计等阶段能依次有序地展开。</p>
<p>系统构想阶段，架构师合理的介入，有以下好处。</p>
<p>（1）有利于使系统架构师本身对系统的看法更加全面、准确。</p>
<p>（2）有利于统一系统开发人员对系统的看法。</p>
<p>（3）有利于正确确定需求的优先次序。</p>
<p>（4）通过系统构想，可以在最大程度上提高客户对设计等过程的参与程度，更好地与客户沟通。</p>
<h4 id="系统构想面临的挑战"><a href="#系统构想面临的挑战" class="headerlink" title="系统构想面临的挑战"></a>系统构想面临的挑战</h4><p>建立和共享架构构想要面临着很多的挑战：架构师对其控制能力之外的因素（例如组织等）通常无能为力；当产品线由一个架构来支撑时，构想就会受更多的因素制约。此外，如果共享的架构构想有问题时，不易马上觉察到。不过，可以通过有效地评估，以及高级经理和架构师之间保持紧密的联系来克服这些困难。</p>
<p>除了以上介绍的挑战外，在系统构想阶段，还必须面对以下几种情况。</p>
<p>（1）很多架构师把架构看成是他们独自的创造，而且只要他们认为合适的就进行修改。</p>
<p>（2）有些人不是拥有产品线构想的高级经理，却总是由这些人来决定雇佣谁来做架构师。由于没有参与架构师的招聘工作，高级经理们将无法评估架构师的能力以及理解并实现其构想。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="架构师的工作"><a href="#架构师的工作" class="headerlink" title="架构师的工作"></a>架构师的工作</h4><p>需求一般定义系统的外部行为和外观及用户信息，而不用设计系统的内部结构。外部行为包括了用来保证外部行为能够完成而所需的内部行为（例如持续性或计算）。外观包括用户界面的布局和导航，用户信息包含用户概念数据结构及关系模型。</p>
<p>架构师对需求分析通常考察以下6个方面的内容。</p>
<p>（1）系统范围对象关系图。主要用于定义系统与系统外部实体间的界限和接口的简单模型，它可以为需求确定一个范围。</p>
<p>（2）用户接口原型。可将其看作为用户操作的一个雏形，通过该接口界面用户能够用一系列的操作完成它想达到的效果。</p>
<p>（3）需求的适用性。即这个需求应该用什么技术解决，它实现后的性能怎么样，是否与其他需求相重合或是矛盾。需求分析应注重需求本身的实用或适用，而不必考虑其实现。</p>
<p>（4）确定需求的优先级。可采用迭代周期来说明何时完成。</p>
<p>（5）为需求建立功能结构模型。可以用UML创建组件图和实体数据对象图，概述系统原型。</p>
<p>（6）使用质量功能分配（Quality Function Deployment, QFD）。根据需求的理解发现隐藏质量需求，建立相关质量场景和易变需求场景，先期预测需求风险。</p>
<p>架构师的一个有效地捕捉行为需求的方法是分析用例（use case）。一个用例包含一个顶层的图和扩展的文字描述。用例符号简单、抽象，非常适合于用来保证在表述顶层需求概念时的简单性和清晰度。</p>
<h4 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h4><h5 id="需求分析的目的"><a href="#需求分析的目的" class="headerlink" title="需求分析的目的"></a>需求分析的目的</h5><p>需求分析的目的是完整、准确地描述用户对系统的需求，跟踪用户需求的变化。将用户的需求准确地反映到系统的架构和设计中，设计和用户的需求保持一致。需求分析具有决策性、方向性和策略性的作用，它在软件开发的过程中具有举足轻重的地位。</p>
<h5 id="需求分析的特点"><a href="#需求分析的特点" class="headerlink" title="需求分析的特点"></a>需求分析的特点</h5><p>一般来说，需求分析特点的共同点都是追求系统需求的完整性、一致性和验证性。</p>
<p>（1）完整性：是准确、全面地描述用户对系统架构的需求。</p>
<p>（2）一致性：是通过分析整理，剔除用户需求矛盾的方面，规范用户需求。</p>
<p>（3）验证性：是需求的一致性表现形式，主要包含以下几个方面的含义。</p>
<p>① 保持和用户要求的同步。</p>
<p>② 保持需求分析各侧面之间的一致。</p>
<p>③ 保持需求和系统设计间的同步。</p>
<p>因此，在对系统架构需求分析之前必须建立需求分析技术层面的基本框架，从技术上保证需求分析的要求，在此基础上进行的架构需求分析才能满足项目对需求分析的要求。</p>
<h4 id="需求文档与架构"><a href="#需求文档与架构" class="headerlink" title="需求文档与架构"></a>需求文档与架构</h4><p>每个用例都有一个相关需求的文字描述。这种方法采用了包含一系列活动的列表形式，用特定领域的平铺直叙的文字来描述。定义用例应该和领域专家一起进行，如果没有领域专家的长期参与，这种活动只能是一种“伪分析”。</p>
<p>用例为定义架构提供了一个系统的领域行为模型。在开发的第7个过程中，用例被特定系统的场景所扩展，最后这些场景会在软件测试中得到运用。</p>
<p>用户界面的外观、功能和导航同用例紧密相联。一个有效定义屏幕的方法叫做低保真度原型（Low-fidelity Prototyping）。在这种方法中，屏幕是用纸和笔先画出来的。同样，最终用户领域专家也始终参与到屏幕定义中去。</p>
<p>有了用例和定义的用户界面以及领域概念模型，我们建立了架构规划的环境。在产生文档之外（包括纸、笔的草图），架构小组得到最终用户领域中需求功能的更深刻理解。需求分析的项目词汇表，也将在架构规划中被扩展。</p>
<h3 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h3><p>系统架构沟通了需求和软件之间巨大的语义上的鸿沟。需求是模糊的、直观的，而软件则具有相反的性质。系统架构的第一个任务就是定义这两个极端之间的映射，架构用一种更为技术性的方式来捕捉直觉的决定，它在设计和编码之前定义了内部的系统结构。架构设计同时为项目计划服务，它允许系统构建用适应变化的方法来控制复杂性，同时指导建立软件项目与架构对应的组织。</p>
<p>开放分布式处理（Open Distributed Processing, ODP）从5个标准的视点组织分析了系统的架构，描述了同一系统的重要方面。如图14-2所示，这些视点包括企业、逻辑信息、计算接口、分布式工程和技术选择。对于每个视点，确认架构需求的一致性是非常重要的。ODP促进了这个过程，因为它内嵌了一个普遍的一致性方法，简单的一致性清单包含识别架构中一致点所需的全部内容。</p>
<details><summary>图14-2　ODP视点</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135801.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135801.png';" /></details>

<h4 id="企业业务架构"><a href="#企业业务架构" class="headerlink" title="企业业务架构"></a>企业业务架构</h4><p>企业业务架构从IT的角度，对企业的业务结构、企业机构与业务的关系、企业内部的关系以及企业与外部机构的关系进行整理定义。企业业务架构包含如下内容。</p>
<p>（1）企业的业务和战略目标。描述企业的目标，包含近期目标、中期目标和长远的战略目标。</p>
<p>（2）企业的组织机构。明确描述企业的组织机构和职能，以及与企业相关的机构和个体，如客户、合作伙伴和供应商等。</p>
<p>（3）业务的分类。对企业的产品、服务和资源体系进行分类。这种分类包含了对相关产品、服务和资源的共性提取和总结。</p>
<p>（4）各类业务之间的关系。对产品、服务和资源的相互关联进行总结。业务之间的关系体现为跨业务的流程及资源共享等。</p>
<p>（5）组织机构与业务的关系。业务的执行是由机构来完成的，但是机构与业务并不一定是一一对应的关系。清楚地找出机构与业务的关系，将为应用与集成架构奠定可靠的基础。</p>
<p>（6）企业与外部机构的关系。对与企业相关的外部机构或个人就其类型、业务类别和业务往来模式等进行分类。</p>
<p>企业业务架构（企业视点）也是用高层企业对象来定义业务目的和系统策略。这些业务对象模型标识出系统的关键性约束，其中包括系统目标和重要的系统策略。</p>
<p>策略包含如下三类明确的表达方式。</p>
<p>●　责任：业务对象必须做什么。</p>
<p>●　许可：业务对象可以做什么。</p>
<p>●　禁止：业务对象不可以作什么。</p>
<p>在对业务问题进行分析时，不仅要考虑企业目前业务的情况，而且要考虑企业业务的发展，如新的服务或产品的推出、考虑组织机构的改变等，企业的业务流程的变化也是要考虑的因素。所有这些可能的变化（易变场景）都应该体现在企业的业务架构中。</p>
<p>企业业务架构在明确了企业的业务和战略目标之后，从业务和机构两个基本点出发进行基础性的分类组织工作，然后根据业务的分工和业务流程与组织机构实现映射，从而形成对企业业务的完整描述。一个典型的企业业务架构包含一系列逻辑对象图（通常用UML表示）和对象语义的平铺直叙的文字描述。</p>
<p>通过对企业业务架构的定义，就可以很清楚地知道由于企业业务特点、业务流程的特点和企业的组织机构等原因对IT系统所带来的自然分块和各个分块之间的边界关系，从而就可以知道怎样从技术架构上来满足和支持企业的业务架构。</p>
<p>企业业务架构的维护也是一个长期而反复的工作。企业业务架构的变化可以通过技术架构反映出来，技术架构的正确与否可以通过业务架构来检验，这样才能通过架构来保证IT服务于企业的业务和战略。</p>
<p>下面以一个测试结果报告系统（Test Results Reporting System, TRRS）为例，介绍一下它的企业业务架构。</p>
<p>TRRS的企业视点由一些UML用例组成，这些用例确定了TRRS社区的参与者以及他们之间策略上的联系。图14-3展示了这些来自应用软件开发者视点的UML用例。这三个在UML图中的用例表明，软件开发者可以通过多种途径使用TRRS，以决定软件产品的兼容性。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135833.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135833.png';" /></details>


<p>重要的企业策略关系到TRRS数据库中产品描述的完整性和责任。在TRRS处理中，可以使用UML对象约束语言（Object Constraint Language, OCL）来定义企业活动者的这些策略（如许可、禁止和义务等）。</p>
<h4 id="逻辑信息架构"><a href="#逻辑信息架构" class="headerlink" title="逻辑信息架构"></a>逻辑信息架构</h4><p>逻辑信息架构（信息视点）标识出系统必须知道什么。这种架构通过一个对象模型来表达，强调定义系统状态的属性。因为开放分布式处理是一种面向对象的方法，模型包含了关键信息的处理，如传统的对象概念。</p>
<p>软件架构对象并不是编程的对象，它表示对系统的约束和依赖。这些约束能够消除在把需求翻译成软件过程中的许多猜测性工作。架构师应该把他们的建模集中于系统中有高风险、高复杂性和模糊性的关键方面，而把直接的细节放在开发的环节中去。</p>
<p>下面以测试结果报告系统为例，介绍一下它的逻辑信息架构。</p>
<details><summary>图14-5　供应商信息的UML表示</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135921.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135921.png';" /></details>

<p>TRRS信息视点是由一组UML类模型组成，该信息视点定义了一些核心的概念，这些概念组成了TRRS系统的持久状态。图14-4是一个UML图，它展示了产品之间的互操作关系。一致性声明（Conformance Statements，如图14-5所示）提供了产品兼容性标准的保证。互操作性声明（Interoperability Statements）是一个类似的概念，和兼容性不同之处在于它不包含供应商对相互之间产品兼容性的保证。互操作性测试报告（Interoperability Test Report）包括了多产品互操作测试所得出的测试结果。互操作性产品（Interoperability Product）是特定的源于多供应商兼容性的解决方案。经验报告（Experience Report）是实例研究的文档，它记载了产品集成的成功经验。合起来，上述各个部分组成了TRRS数据库要储存的关键文档类型。</p>
<h4 id="计算接口架构"><a href="#计算接口架构" class="headerlink" title="计算接口架构"></a>计算接口架构</h4><p>计算接口对系统架构非常有帮助，但是它常常被架构师所忽略。它定义了顶层的应用程序接口，这些是完全工程化的子系统边界的接口。在实现时，开发者将对他们的模型在这些边界上进行编程，以消除多个开发者和小组的主要设计争端。这些接口的架构控制对于一个支持变化和控制复杂性的稳定的系统结构来说，是非常重要的。</p>
<p>开放分布式处理体系结构的一个ISO标准采用的是CORBA接口定义语言（IDL），IDL是一种基本记法，它完全独立于编程语言和操作系统。IDL可以被编译器自动翻译成Java、C++和C#等大多数流行的编程语言。</p>
<h4 id="分布式工程架构"><a href="#分布式工程架构" class="headerlink" title="分布式工程架构"></a>分布式工程架构</h4><p>分布式工程架构定义了底层结构的需求，而独立于所选择的技术。它很好地解决了一些最复杂的系统策略，其中包括物理位置、系统规模可变性和通信服务质量。</p>
<p>ODP的一个最大好处是关注点分离，幸运的是，前面的视点解决了许多其他的复杂问题，那些是分布式很少关注的，如API、系统策略和信息纲要。相反，这些其他的视点能够解决它们各自的设计要点，而独立于分布式的考虑。</p>
<p>在进行分布式工程架构建模时，必须考虑系统的各个方面，如对象复制、多线程和系统拓扑等。</p>
<h4 id="技术选择架构"><a href="#技术选择架构" class="headerlink" title="技术选择架构"></a>技术选择架构</h4><p>技术选择架构（技术视点）确定了实际的技术选择，所有其他视点都独立于这些决定。因为大多数架构设计是独立的，商业技术的发展可以很容易地适应。</p>
<p>一个系统的选择过程包括初始的概念性机制的确认，如持久性或者通信。概念性机制的特定属性可以从其他视点得到。具体的机制被标识出来，如DBMS、OODBMS。这些特定的参选产品是从可得到的技术中选出来的。基于对候选者的初始选择，这个过程根据产品价格、培训要求和维护风险之类的项目因素而反复进行。</p>
<p>架构师选择的原因是非常重要的，因为所有这些观点可以作为以后架构约束的理由。记录可以放在一个由架构小组维护的非正式项目记事本上，可以用于以后进行参考。</p>
<p>以测试结果报告系统为例，介绍一下它的技术选择架构。</p>
<p>TRRS技术视点包括了原型规划的三种方式（如图14-6所示）。我们经常选用这些原型来支持渐进的系统演化和可扩展性。而从一种方式到另一种方式的演化之所以能够发生，是由在实现时选用不同的技术和提供多层结构间互操作机制所造成的。</p>
<details><summary>图14-6　原型规划的三种方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140022.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140022.png';" /></details>

<p>阶段1是一种快速的原型，它由一个独立的Java应用程序以及一个平面文件数据库配置而成。阶段2使用分布式基础设施中的RMI或者IIOP技术，支持局域网上的多客户系统。阶段3支持数据库的可扩展性，这是通过把平面文件替换为JDBC接口及其操作的后端数据库来实现的。</p>
<p>在阶段3之外，TRRS还需要对数据库表项、数据库集成和适应因特网环境下的安全性等功能提供支持。其他的开发挑战包括提供体系结构的设计工具以及利用TRRS数据进行管理等，例如向软件开发者报告相关的TRRS产品表项。这些为软件体系结构引入了一个新的动态层面。</p>
<h3 id="实现模型"><a href="#实现模型" class="headerlink" title="实现模型"></a>实现模型</h3><p>最终用户和架构师应在一起审查并贯穿于用例（业务场景、质量场景、易变场景）始终来证实需求的有效。通常这个交流会出现新的或者需要修改的需求，对于需求的任何修改都要标注并结合到随后的其他架构活动中去。通过模型，管理层能够看到可视化的进展。</p>
<p>大多数系统可以采用快速原型技术生成模型。快速原型技术有利于快速获取产品设计的反馈信息，并对产品设计的可行性做出准确的评估、论证。</p>
<h3 id="架构原型"><a href="#架构原型" class="headerlink" title="架构原型"></a>架构原型</h3><p>在完成上述任务之后，从构建的草图进而发展成产品原型。架构原型是很好的需求验证工具，它能够帮助利益相关人检测系统锲合用户操作的程度。可以使用各种各样的办法构建架构原型，而非编码一种。例如，可以使用故事板来可视化地展现用户使用产品的过程，也可以使用原型工具来模拟过程，以此说明产品是如何运行的。架构原型只是快速构建，作为改进设计的手段，如果在构建架构原型过程中使用了编码，也要尽量避免在最终产品中使用这些代码。</p>
<p>架构框架（Framework）是对系统架构的一种可运行验证工具，通过对系统的API定义的编译以及编写小程序来模拟运行的系统。架构框架用于正式计算和工程体系架构，这包括穿越分布式边界的控制和定时。</p>
<p>使用CORBA技术，一个架构的规范能够被自动地编译成带有分布式stub和框架程序的一系列程序的头文件。通过在框架程序中插入虚拟代码来模拟处理过程，编写简单的客户程序用虚拟的数据来穿越边界发送请求。一些关键的，比如说：高风险的用例被替换的客户程序所模拟。原型的执行被计时以确保与工程约束相一致。</p>
<p>下面是一些架构师可以在架构原型中寻求解答的具体问题。</p>
<p>（1）主要组件的责任是否得到了良好定义？是否适当？</p>
<p>（2）主要组件间的协作是否得到了良好定义？</p>
<p>（3）耦合是否得以最小化？</p>
<p>（4）我们能否确定重用的潜在来源？</p>
<p>（5）接口定义和各项约束是否可接受？</p>
<p>（6）每个模块在执行过程中是否能访问到其所需的数据？是否能在需要时进行访问？</p>
<p>为了构建实际的系统，初始的架构原型需要进行演化。较好的情况是在经过2次或3次迭代之后，架构变得稳定。主要的抽象对象都已被找到；子系统和过程都已经完成；所有的接口都已经明确定义。</p>
<p>在系统架构开发过程中，利用架构原型，至少有下面的几个好处。</p>
<p>（1）在架构落实之前，让团队成员能自由发表他们自己的看法，并进行讨论，提出建议，对在架构原型中存在的问题进行及时改正。</p>
<p>（2）可以在系统的整体性能上，把握得更好。统一团队成员之间的思想看法和提高系统开发的成功率。</p>
<p>（3）它对系统内部的结构分析与设计也有帮助。</p>
<h3 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h3><p>无论什么项目，其最终目标都是要按期、按预算开发出满足用户需求的、高可靠、高性能的产品。在实现这个目标的过程中，项目规划起着至关重要的作用。项目规划是一份已通过批准的正式文档，它根据项目的目标，对项目实施进行的各项活动作出规定，以它为基准跟踪和控制项目，确定未来的行动方案和资源分配，引导项目的实施。项目规划的主要作用是将制定规划的假设和决定以及批准的范围、成本、进度的基线等用正式的文档记录保存。规划的复杂性取决于项目的复杂性，它体现了对客户需求的理解，便于高层管理、项目经理、项目组成员及项目相关人等之间进行交流沟通。</p>
<p>项目规划是基于当前已有的信息，包括过去的经验，当前的目标、范围、组织结构、资源等，工作活动、里程碑、质量目标和风险管理等，其中估算是项目规划的核心。随着项目的进展，信息的增多和理解的深入，估算会不断校正并逐渐地接近实际。项目计划是在规划基础上建立的一组实现任务的活动表，如进度计划、质量活动计划和配置管理计划等。项目管理者通过计划与规划的差异，不断优化和更新计划策略，使项目按规划的要求得以实现，计划的变更是可管理和可受控的。</p>
<p>项目规划是项目工作的纲领，要以此去指导项目的技术和管理活动。项目规划包括如下内容。</p>
<p>（1）项目的目的、范围、目标和对象。</p>
<p>（2）软件生存周期的选择。</p>
<p>（3）精选的供开发和维护软件用的规程、方法和标准。</p>
<p>（4）待开发的软件工作产品。</p>
<p>（5）软件工作产品的规模估计、软件项目的工作量和成本的估计。</p>
<p>（6）关键计算机资源的估计；项目的里程碑。</p>
<p>（7）风险的识别和评估。</p>
<p>（8）工程设施和支持工具计划。</p>
<p>软件项目计划的目标有：软件估计被文档化，以供跟踪软件项目使用。软件项目的活动和约定是有计划的，并形成文档，受影响的组和个人认同与软件项目规划的约定。</p>
<h3 id="并行开发"><a href="#并行开发" class="headerlink" title="并行开发"></a>并行开发</h3><h4 id="软件并行开发的内容及意义"><a href="#软件并行开发的内容及意义" class="headerlink" title="软件并行开发的内容及意义"></a>软件并行开发的内容及意义</h4><p>并行开发的意义在于提高软件生产率和改善软件质量。软件并行开发有效地组织可以重复的资源，并附加额外的控制管理技术，使软件开发尽量并行进行，从而达到加快软件开发速度、提高软件生产率、缩短软件开发周期的目的。同时，软件并行开发通过改善软件过程，达到提高软件质量的目的。软件并行开发以提高软件生产率为目的，对实现软件并行开发的各个方面做了必要的分析，并且给出了可行的解决方案，直接面对软件工程的实施，因此具有重要的应用价值。</p>
<p>软件并行开发研究的内容主要如下。</p>
<p>（1）软件过程及其模型。</p>
<p>（2）并行成分划分。</p>
<p>（3）并行控制。</p>
<p>（4）支持环境。</p>
<p>（5）交互机制与集成技术。</p>
<h4 id="并行开发的过程"><a href="#并行开发的过程" class="headerlink" title="并行开发的过程"></a>并行开发的过程</h4><p>要讨论软件并行开发的软件生存周期模型，需要把视野集中到软件开发过程中。把软件系统的开发过程划分为若干个可以并行的成分，这个成分称之为子开发过程。子开发过程是一个动态概念，和操作系统中的进程概念有类似之处。子开发过程可以定义为：子开发过程＝开发小组＋软件对象＋对软件对象的开发活动。或者说，子开发过程是一个开发小组对一个相对独立的软件对象的动态开发过程。</p>
<p>在此，我们把整个并行开发活动看作是一个并行系统，称为并行开发系统。子开发过程是对并行开发系统的一种动态描述，此系统中的实体是开发小组，实体属性是被开发的软件对象，行为是开发软件对象的活动。每个子开发过程完成一个子系统或一个模块的开发任务，当各个子开发过程都完成之后，进行系统集成和测试，最终完成整个系统的开发，如图14-7所示。</p>
<details><summary>图14-7　并行开发中的生命周期模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140149.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140149.png';" /></details>

<p>并行模块的划分是并行开发中的核心问题，模块独立性是衡量软件设计质量的关键。根据并行开发的特征，一个开发小组负责一个模块的开发，如果各模块之间的耦合度低，那么各并行开发过程之间交互作用将减少，为并行开发控制带来方便。有如下两种系统划分的方法。</p>
<p>（1）基于Petri网系统模型的动态划分方法。</p>
<p>（2）基于脚本的系统划分方法。</p>
<p>在软件并行开发中，软件过程并行控制（以下简称并行控制）是一个非常重要的问题。所谓并行控制，就是要用正确的方式调度并行操作，避免造成不一致性，使一个操作的执行不受其他操作的干扰。为保证开发出的系统内部各成分间的一致性、相容性，保证系统的正确性和可靠性，就要进行并行控制。通常的并行控制手段有加锁、时间戳、管程、Petri网和PV操作等手段。并行控制模型描述被控制对象的并行行为以及它们之间的关系，是并行控制的依据。</p>
<p>当各个产品开发过程分别完成后，应通过集成技术，把各子开发过程所开发的软件对象集成起来，作为一个统一的应用系统。在软件并行开发的软件生存周期模型中，系统集成和系统测试被分为两个阶段，如果不考虑硬件或系统软件的集成，两个阶段并没有明显的界限。所以，就应用软件系统而言，软件集成的主要问题是集成测试技术。通过集成测试技术，在现实可行的时间内，运用工具尽量去发现尽可能多的软件错误，以保证软件的质量。</p>
<h3 id="系统转换"><a href="#系统转换" class="headerlink" title="系统转换"></a>系统转换</h3><p>系统转换是指运用某一种方式由新的系统代替旧的系统的过程，也就是系统设备、系统数据和人员等方面的转换。</p>
<h4 id="系统转换的准备"><a href="#系统转换的准备" class="headerlink" title="系统转换的准备"></a>系统转换的准备</h4><p>在系统转换前，必须认真做好系统设备、数据、人员以及有关文件（如程序说明书、系统操作说明书等）的准备。</p>
<p>除此之外，还需要系统试运行这项准备工作。系统试运行是指在系统没有正式转换之前，选择一些子项目进行的实验运行。需要注意如下两方面的问题。</p>
<p>（1）系统试运行工作的代表性。指在系统试运行工作中所选择的子功能和数据应该尽量接近实际系统运行的需要。</p>
<p>（2）系统试运行中错误的修正。系统试运行过程中用户发现的一些问题，对待这些问题应该以系统分析中确定的系统目标为标准，认真分析产生问题的原因和类型，决定对系统的问题是否修订和如何进行修订。</p>
<h5 id="系统转换的方式"><a href="#系统转换的方式" class="headerlink" title="系统转换的方式"></a>系统转换的方式</h5><p>系统转换可分为直接转换、平行转换、分段转换和分批转换。</p>
<p>（1）直接转换。直接转换是当新系统安装完毕能够进行工作后，立即停止旧系统的运行，让新系统投入运行的转换方式。</p>
<p>（2）平行转换。平行转换是新旧系统共同工作一段时间，当证实新系统有较高的可靠性后，再停止旧系统工作的转换方式。</p>
<p>（3）分段转换。分段转换时一次只用新系统的部分功能去替换旧系统的相应部分，逐步完成新系统替换旧系统的转换方式。</p>
<p>（4）分批转换。分批转换是把新系统在小范围内使用，然后再全部推广的转换方式。</p>
<p>以上几种系统转换方式各有各的特点，应根据系统规模的大小、难易和复杂的程度以及企业的具体情况决定系统转换时采用哪种方式。</p>
<h4 id="系统转换的注意事项"><a href="#系统转换的注意事项" class="headerlink" title="系统转换的注意事项"></a>系统转换的注意事项</h4><p>在系统的转换过程中，无论采取哪种转换方式，都要注意以下问题。</p>
<p>（1）新系统的运行需要大量的基础数据，这些数据的整理与录入工作量很大，应及早准备，尽快完成。</p>
<p>（2）系统的转换不仅仅是机器的转换、程序的转换，更难的是人员的转换，应提前做好人员的培训工作。</p>
<p>（3）系统运行时会出现一些局部性的问题，这是正常现象。系统工作人员对此应有足够的准备，并做好记录。系统只出现局部性问题，说明系统是成功的；反之，如果出现致命问题，说明系统设计质量不好，整个系统甚至要重新设计。</p>
<h3 id="操作与维护"><a href="#操作与维护" class="headerlink" title="操作与维护"></a>操作与维护</h3><h4 id="操作与维护的内容"><a href="#操作与维护的内容" class="headerlink" title="操作与维护的内容"></a>操作与维护的内容</h4><p>一个系统交付使用后，系统的开发就结束了，系统转入正常的运行操作时期。从系统的生命周期看，只有系统投入正常的操作和维护后，才真正实现了系统。因此，可以说操作维护是系统过程的后阶段。</p>
<p>系统操作与维护的内容有数据管理与维护，包括数据收集、数据整理、数据录入以及数据的分发、数据库管理工作；机器设备的管理与维护，包括硬件维护、机器日常行政管理、系统操作记录和用户服务等；系统软件的管理与维护工作，应用软件的管理与维护工作，代码维护。</p>
<h4 id="系统维护与架构"><a href="#系统维护与架构" class="headerlink" title="系统维护与架构"></a>系统维护与架构</h4><p>系统架构的好坏，可维护性是一个重要方面，维护人员应参与架构的评审。系统的可维护性可以定性地定义为：维护人员理解、改正、改动和改进这个软件的难易程度，提高可维护性时开发管理系统所有步骤的关键目的。系统能否被很好地维护，可用系统的可维护性这一指标来衡量。系统的可维护性有如下几个评价指标。</p>
<p>●　可理解性</p>
<p>●　可测试性</p>
<p>●　可修改性</p>
<p>依据信息系统需要维护的原因不同，系统维护工作可以分为以下4种类型。</p>
<p>●　 $\color{green}{\text{更正性维护}}$ </p>
<p>●　 $\color{green}{\text{适应性维护}}$ </p>
<p>●　 $\color{green}{\text{完善性维护}}$ </p>
<p>●　 $\color{green}{\text{预防性维护}}$ </p>
<p>某个维护目标确定以后，维护人员必须先理解要维护的系统，然后建立一个维护方案。由于程序的修改涉及面较广，某处修改很可能会影响其他模块程序，所以建立维护方案后要加以考虑的重要问题是修改的影响范围和波及面的大小。然后按预定维护方案修改程序，若测试发现重大问题，则要重复上述步骤。若通过，则修改相应文档并交付使用，结束本次维护工作。必须强调的是，维护是对整个系统而言的。因此，除了修改程序、数据和代码等部分以外，必须同时修改涉及的所有文档。系统维护的步骤如图14-8所示。</p>
<details><summary>图14-8　系统维护步骤</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140406.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140406.png';" /></details>

<h3 id="系统移植"><a href="#系统移植" class="headerlink" title="系统移植"></a>系统移植</h3><h4 id="系统移植的形式"><a href="#系统移植的形式" class="headerlink" title="系统移植的形式"></a>系统移植的形式</h4><p>系统移植的方法有三种：第一种是不修改已有的软件，可以使用的方法有高位互换、仿真功能和虚拟机（Virtual Machine）功能；第二种是修改软件，就是把已有软件资源，即程序、数据、计算机应用方法及各种说明书转换为与新机器具有匹配性的软件；第三种是重编软件，有从逻辑设计开始、从程序设计开始和从编程开始三种开发方式。</p>
<h4 id="color-red-text-系统移植的工作阶段划分"><a href="#color-red-text-系统移植的工作阶段划分" class="headerlink" title="$\color{red}{\text{系统移植的工作阶段划分}}$"></a>$\color{red}{\text{系统移植的工作阶段划分}}$</h4><p>移植工作大体上分为计划阶段、准备阶段、转换阶段、测试阶段和验证阶段。为了有效地进行系统移植，就得使系统移植工作标准化；配备软件工具实现自动化；还要简化各阶段的工作。下面简要介绍一下系统移植的各阶段工作。</p>
<p>（1） $\color{green}{\text{计划阶段}}$ 。在计划阶段，要进行现有系统的调查整理，从移植技术、系统内容（是否进行系统提炼等）和系统运行三个方面，探讨如何转换成新系统，决定移植方法，确立移植工作体制及移植日程。</p>
<p>（2） $\color{green}{\text{准备阶段}}$ 。在准备阶段要进行移植方面的研究，准备转换所需的资料。该阶段的作业质量将对以后的生产效率产生很大的影响。</p>
<p>（3） $\color{green}{\text{转换阶段}}$ 。这一阶段是将程序设计和数据转换成新机器能根据需要工作的阶段。提高转换工作的精度，减轻下一阶段的测试负担是提高移植工作效率的基本内容。</p>
<p>（4） $\color{green}{\text{测试阶段}}$ 。这一阶段是进行程序单元、工作单元测试的阶段。在本阶段要核实程序能否在新系统中准确地工作。所以，当有不能准确工作的程序时，就要回到转换阶段重新工作。</p>
<p>（5） $\color{green}{\text{验证阶段}}$ 。这是测试完的程序使新系统工作，最后核实系统，准备正式运行的阶段。</p>
<h4 id="系统移植工具"><a href="#系统移植工具" class="headerlink" title="系统移植工具"></a>系统移植工具</h4><p>数据不能互换的系统移植时，完整的数据转换工具是必需的。主要有以下几种软件工具。</p>
<p>（1）分析工具：是分析现有软件资源，得到探讨移植方法有用信息的工具。</p>
<p>（2）生成工具：是编制作业控制语言、测试数据、转换工作所需文档的工具。</p>
<p>（3）转换工具：包括程序转换、数据转换和作业控制语言转换。</p>
<p>（4）数据应用工具：使用这种工具不用编文件就可以简便地存取磁带上的数据。</p>
<p>（5）测试、验证工具：作为可分类的工具包括静态、动态跟踪。</p>
<p>（6）管理工具：是管理资源及作业的工具。</p>
<p>系统移植工作需要的软件工具有很多种，配备工具最主要的是在决定移植的工作方法之后，配备移植所需的工具并明确工具的界限。即选出移植工作中的作业项目，使项目系列化、标准化。配备、开发移植所需的工具；对于那些用工具转换的项目，采取相应的措施，进行文档化，使任何人都能以相同的顺序开展工作。这样，就不必制作大量的工具，只将有效的工具组合起来，就可以提高效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch13-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch13-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch13-系统的可靠性设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:54" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:54+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 14:58:22" itemprop="dateModified" datetime="2021-10-21T14:58:22+08:00">2021-10-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="系统的可靠性设计"><a href="#系统的可靠性设计" class="headerlink" title="系统的可靠性设计"></a>系统的可靠性设计</h2><p>随着软件复杂度的增加，软件设计的正确性验证成本也越来越高。可靠和可信的计算模型首先在军事和高要求的商业系统中开始研究，可靠性和其他质量属性一样是衡量软件架构的重要指标。实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制。本章探讨软件可靠性的概念、建模与管理方法。</p>
<h3 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h3><h4 id="软件可靠性概述"><a href="#软件可靠性概述" class="headerlink" title="软件可靠性概述"></a>软件可靠性概述</h4><p>在现代军事和商用系统中，以软件为核心的产品得到了广泛的应用。随着系统中软件成分的不断增加，使得系统对软件的依赖性越来越强，对软件可靠性的要求也越来越高。目前，硬件可靠性测试技术和评估手段日趋成熟，硬件可靠性评估模型经过长期的实践积累，已经得到了业界的认可。但是，由于软件和硬件存在着巨大的差异性，硬件的可靠性测试和评估技术，并不能完全应用于对软件的可靠性的测试和评估中。因此，软件可靠性技术研究成为当今可靠性工程研究领域中一个重要领域。</p>
<p>国外从20世纪60年代后期开始加强对软件可靠性的研究工作，经过40多年的研究，推出了各种可靠性模型和预测方法，于1990年前后形成了较为系统的软件可靠性工程体系。同时，从20世纪80年代中期开始，西方各主要工业强国均确立了专门的研究计划和课题，如英国的AIVEY（软件可靠性和度量标准）计划、欧洲的ESPRIT（欧洲信息技术研究与发展战略）计划、SPMMS（软件生产和维护管理保障）课题和Eureka（尤里卡）计划等。每年，都有大量的人力物力投入到软件可靠性研究项目中，并取得了一定的成果。</p>
<p>国内对于软件可靠性的研究工作起步较晚，在软件可靠性量化理论、度量标准（指标体系）、建模技术、设计方法和测试技术等方面与国外差距较大。</p>
<p>目前，软件可靠性管理方面还没有建立起具有权威性的管理体系和规范。例如，如何描述软件可靠性，如何测试、评估、设计和提高等。由于目前国内外对于软件可靠性模型的研究多集中在软件的开发阶段及测试与评估阶段的可靠性模型，而且现有的模型也多来源于硬件可靠性评估，与软件可靠性评估存在较大的差距，所以从事软件可靠性测试与评估研究是一个有理论价值和实际意义的工作。总的来说，软件可靠性工程研究虽然得到了普遍的重视，但仍然不是很成熟，还处于发展阶段。</p>
<h4 id="软件可靠性的定义"><a href="#软件可靠性的定义" class="headerlink" title="软件可靠性的定义"></a>软件可靠性的定义</h4><p>可靠性（Reliability）是指产品在规定的条件下和规定的时间内完成规定功能的能力。</p>
<p>按照产品可靠性的形成，可靠性可分为固有可靠性和使用可靠性。固有可靠性是通过设计、制造赋予产品的可靠性；使用可靠性既受设计、制造的影响，又受使用条件的影响。一般使用可靠性总低于固有可靠性。</p>
<p>软件与硬件有很多不同点，但从可靠性的角度来看，它们主要有如下4个不同点。</p>
<p>（1）复杂性。软件内部逻辑高度复杂，硬件则相对简单，这就在很大程度上决定了设计错误是导致软件失效的主要原因，而导致硬件失效的可能性则很小。</p>
<p>（2）物理退化。软件不存在物理退化现象，硬件失效则主要是由于物理退化所致。这就决定了软件正确性与软件可靠性密切相关，一个正确的软件任何时刻均可靠。然而，一个正确的硬件元器件或系统，则可能在某个时刻失效。</p>
<p>（3）唯一性。软件是唯一的，软件复制不改变软件本身，而任何两个硬件不可能绝对相同。这就是为什么概率方法在硬件可靠性领域取得巨大成功，而在软件可靠性领域不令人满意的原因。</p>
<p>（4）版本更新较快。硬件的更新周期通常较慢，硬件产品一旦定型一般就不会更改，而软件产品通常受需求变更、软件缺陷修复的需要，造成软件版本更新较快，这也给软件可靠性评估带来较大的难度。</p>
<p>尽管这样，软件仍然是一种具有特殊属性的产品，因此，也可以按照上面的产品可靠性定义来框架性地描述软件的可靠性。</p>
<p>1983年，美国IEEE计算机学会对“软件可靠性”做出了更为明确的定义，随后，此定义经美国标准化研究所批准为美国的国家标准。在1989年，我国国家标准GB/T-11457也采用了这个定义。这个定义就是：在规定的条件下，在规定的时间内，软件不引起系统失效的概率，该概率是系统输入和系统使用的函数，也是软件中存在的缺陷函数；系统输入将确定是否会遇到已存在的缺陷（如果缺陷存在的话）。</p>
<p>简言之，就是在规定的时间周期内，在所述条件下程序执行所要求的功能的能力。显而易见，美国IEEE计算机学会关于“软件可靠性”的定义仍然沿用了“产品可靠性”的定义，但有了更具体的定位和更深入的描述。</p>
<p>下面来分析一下软件可靠性的框架性定义。</p>
<p>（1）规定的时间。</p>
<p>软件可靠性只是体现在其运行阶段，所以将“运行时间”作为“规定的时间”的度量。“运行时间”包括软件系统运行后工作与挂起（开启但空闲）的累计时间。由于软件运行的环境与程序路径选取的随机性，软件的失效为随机事件，所以运行时间属于随机变量。</p>
<p>（2）规定的条件。</p>
<p>规定的条件主要指软件的运行环境。它涉及软件系统运行时所需的各种支持要素，如支持硬件平台（服务器、台式机和网络平台等）、操作系统、数据库管理系统、中间件，以及其他支持软件、输入数据格式和范围及操作规程等。不同的环境条件下软件的可靠性是不同的，具体地说，规定的环境条件主要是描述软件系统运行时计算机的配置情况及对输入数据的要求，并假定其他一切因素都是理想的。有了明确规定的环境条件，还可以有效地判断软件失效的责任在用户方还是开发方。</p>
<p>（3）所要求的功能。</p>
<p>软件可靠性还与规定的任务和功能有关。由于要完成的任务不同，软件的运行情况会有所区别，则调用的子模块就不同（包括程序选择路径不同），其可靠性也就可能不同。所以，要准确度量软件系统的可靠性，必须先明确它的任务和功能。</p>
<p>（4）“软件可靠性”定义具有以下特点。</p>
<p>① 用内在的“缺陷”和外在的“失效”关系来描述可靠性，更能深刻地体现软件的本质特点。</p>
<p>② 定义使人们对软件可靠性进行量化评估成为可能。对于软件的可靠性这样一个质量特性，很难用一个明确直观的数值去体现。而依据这个定义，我们有可能通过分析影响可靠性的因素，用函数的形式，按照不同的目的建立各种数学模型去分析软件可靠性。</p>
<p>③ 用概率的方法去描述可靠性是比较科学的。前面讲到，软件失效是随机的外部表现，完全是一个随机事件，而软件缺陷是软件固有的没有损耗的内在特点。定义用规定时间内其操作不出现软件失效的概率，也就是输入未碰到软件缺陷的概率来描述可靠性，这种方法就是用概率来描述纯粹的随机事件，是比较合理的，也是可行的。</p>
<h4 id="软件可靠性的定量描述"><a href="#软件可靠性的定量描述" class="headerlink" title="软件可靠性的定量描述"></a>软件可靠性的定量描述</h4><p>从软件可靠性的定义可以看到，软件的可靠性可以基于使用条件、规定时间、系统输入、系统使用和软件缺陷等变量构建的数学表达式。下面从可靠性定义中的术语“规定时间”、“失效概率”开始，探讨软件可靠性的定量描述，并相应地引入一些概念。</p>
<h5 id="规定时间"><a href="#规定时间" class="headerlink" title="规定时间"></a>规定时间</h5><p>对于“规定时间”有三种概念：一种是自然时间，也就是日历时间，指我们日常计时用的年、月、周、日等自然流逝的时间段；一种是运行时间，指软件从启动开始，到运行结束的时间段；最后一种是执行时间，指软件运行过程中，中央处理器（CPU）执行程序指令所用的时间总和。</p>
<p>例如，某单位有一套供会计人员使用的财务软件，我们来关注一整天的时间，上午9:00上班开机运行，下午5:00下班退出程序。在这里，自然时间是一天，也就是24小时，运行时间是8个小时，而CPU处理程序的执行时间可能不到2小时，这要视会计的业务繁忙状况、使用软件的频度和软件本身的设计而定。</p>
<p>很明显，在这三种时间中，我们使用执行时间来度量软件的可靠性最为准确，效果也最好。如果运行的软件系统处于一种相对稳定的工作状态，可以根据一定的经验值，按一定的换算比例，对这三种时间进行折算。</p>
<h5 id="失效概率"><a href="#失效概率" class="headerlink" title="失效概率"></a>失效概率</h5><p>我们把软件从运行开始，到某一时刻t为止，出现失效的概率看作关于软件运行时间的一个随机函数，用F（t）表示。根据我们对软件可靠性的分析，函数F（t）有如下特征。</p>
<p>（1）F（0）＝0，即软件运行初始时刻失效概率为0。</p>
<p>（2）F（t）在时间域（0，+∞）上是单调递增的。</p>
<p>（3）F（+∞）＝1，即失效概率在运行时间不断增长时趋向于1，这也和“任何软件都存在缺陷”的思想相吻合。</p>
<p>为了简化分析，把F（t）看作关于时间t的一个连续函数，并且可导。</p>
<p>3．可靠度</p>
<p>我们用来表示可靠性最为直接的方式就是可靠度，根据可靠性的定义，可靠度就是软件系统在规定的条件下、规定的时间内不发生失效的概率。如果用F（t）来表示到t时刻止，软件不出现失效的概率，则可靠度的公式为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093411.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093411.png';" /></details>

<p>同样，我们知道R（0）＝1，R（+∞）＝0。</p>
<h5 id="失效强度"><a href="#失效强度" class="headerlink" title="失效强度"></a>失效强度</h5><p>失效强度（Failure Intensity）的物理解释就是单位时间软件系统出现失效的概率。在t时刻到t＋Δt时刻之间软件系统出现失效的平均概率为（F（t＋Δt）－F（t））/Δt，当Δt趋于很小时，就表现为t时刻的失效强度。用f（t）表示失效强度函数，则</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093437.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093437.png';" /></details>

<h5 id="失效率"><a href="#失效率" class="headerlink" title="失效率"></a>失效率</h5><p>失效率（Failure Rate）又称风险函数（Hazard Function），也可以称为条件失效强度，物理解释就是在运行至此软件系统未出现失效的情况下，单位时间软件系统出现失效的概率。具体用数学用语来描述，就是当软件在0～t时刻内没有发生失效的条件下，t时刻软件系统的失效强度。用λ（t）表示失效率，则</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093509.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093509.png';" /></details>

<h5 id="失效率-1"><a href="#失效率-1" class="headerlink" title="失效率"></a>失效率</h5><p>失效率（Failure Rate）又称风险函数（Hazard Function），也可以称为条件失效强度，物理解释就是在运行至此软件系统未出现失效的情况下，单位时间软件系统出现失效的概率。具体用数学用语来描述，就是当软件在0～t时刻内没有发生失效的条件下，t时刻软件系统的失效强度。用λ（t）表示失效率，则</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093530.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093530.png';" /></details>

<p>代入公式（13-1）可得从可靠度到失效率的转换表达式</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093547.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093547.png';" /></details>

<h5 id="可靠度与失效率之间的换算"><a href="#可靠度与失效率之间的换算" class="headerlink" title="可靠度与失效率之间的换算"></a>可靠度与失效率之间的换算</h5><p>我们知道，在0时刻，可靠度R（0）为1，对公式（13-4）一阶常微分方程求解可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093617.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093617.png';" /></details>

<p>假设软件系统的失效率为常数时，由公式13-5可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093632.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093632.png';" /></details>

<p>当失效率λ（t）与时间t之积，也就是tλ（t）＜0.05时，公式（13-6）可简化为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093702.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093702.png';" /></details>

<p>这样计算，误差在2.5％之内。</p>
<p>由公式（13-6）可得，从可靠度到失效强度的转换公式</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093747.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093747.png';" /></details>

<p>当可靠度R（t）＞0.95时，公式（13-6）可简化为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093808.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093808.png';" /></details>

<p>这样计算，误差在2.5％之内。</p>
<h5 id="平均无失效时间"><a href="#平均无失效时间" class="headerlink" title="平均无失效时间"></a>平均无失效时间</h5><p>平均无失效时间（Mean Time to Failure, MTTF）就是软件运行后，到下一次出现失效的平均时间。通常平均无失效时间更能直观地表明一个软件的可靠程度。用θ表示平均无失效时间MTTF，则可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093919.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093919.png';" /></details>

<p>代入关于失效率的换算公式，可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093934.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093934.png';" /></details>

<p>当失效率为一个常数时，可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093946.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093946.png';" /></details>

<p>当讨论完对软件可靠性的定量描述问题之后，需要对软件可靠度这个直接反映软件可靠性的度量指标作下列补充说明。</p>
<p>（1）描述的软件对象必须明确，即需指明它与其他软件的界限。</p>
<p>（2）软件失效必须明确定义。</p>
<p>（3）必须假设硬件无故障（失效）和软件有关变量的输入值正确。</p>
<p>（4）运行环境包括硬件环境、软件支持环境和确定的软件输入域。</p>
<p>（5）规定的时间必须指明时间基准，可以是自然时间（日历时间）、运行时间、执行时间（CPU时间）或其他时间基准。</p>
<p>（6）软件无失效运行的机会通常以概率度量，但也可以模糊数学中的可能性加以度量。</p>
<p>（7）上述定义是在时间域上进行的，这时软件可靠度是一种动态度量。也可以是在数据域上将软件可靠度定义为一种表态度量，表示软件成功执行一个回合的概率。软件回合（Run）是指软件在规定环境下的一个基本执行过程，如给定一组输入数据，到软件给定相应的输出数据这一过程。软件回合是软件运行最小的、不可分的执行单位，软件的运行过程由一系列软件回合组成。</p>
<p>（8）有时将软件运行环境简单地理解为软件运行剖面（Operational Profile）。欧空局（ESA）标准PSS-01-21（1991）“ESA软件产品保证要求”中，定义“软件运行剖面”为：“对系统使用条件的定义。系统的输入值都用其按时间的分布或按它们在可能输入范围内的出现概率的分布来定义”。简单来说，运行剖面定义了关于软件可靠性描述中的“规定条件”，也就是相当于可靠性测试中需要考虑的测试环境、测试数据等一系列问题。</p>
<h4 id="可靠性目标"><a href="#可靠性目标" class="headerlink" title="可靠性目标"></a>可靠性目标</h4><p>前面定量分析软件的可靠性时，使用失效强度来表示软件缺陷对软件运行的影响程度。然而在实际情况中，对软件运行的影响程度不仅取决于软件失效发生的概率，还和软件失效的严重程度有很大关系。这里引出另外一个概念——失效严重程度类（Failure Severity Class）。</p>
<p>失效严重程度类就是对用户具有相同程度影响的失效集合。</p>
<p>对失效严重程度的分级可以按照不同的标准进行，最为常见的是按对成本影响、对系统能力的影响等标准划分软件失效的严重程度类。</p>
<p>对成本的影响可能包括失效引起的额外运行成本、修复和恢复成本、现有或潜在的业务机会的损失等。由于失效严重程度类的影响分布很广泛，为了按照一定数量的等级去定义失效严重程度类，通常用数量级去划分等级。</p>
<p>表13-1给出了一个按照对成本的影响划分失效严重程度类的例子，这个例子涉及到的软件系统是某电子商务运营系统。</p>
<details><summary>表13-1　按照对成本的影响划分失效严重程度类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094025.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094025.png';" /></details>

<p>对系统能力的影响常常表现为关键数据的损失、系统异常退出、系统崩溃、导致用户操作无效等。对于不同性质的软件系统，相同的表现可能造成的失效严重程度是不同的，例如对可用性要求较高的系统，导致长时间停机的失效常常会划分到较高的严重级别中去。</p>
<p>表13-2给出了一个按照对系统能力的影响划分失效严重程度类的例子，这个例子涉及到的软件系统是某电信实时计费系统。</p>
<details><summary>表13-2　按照对系统能力的影响划分失效严重程度类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094046.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094046.png';" /></details>

<p>有了失效严重程度的划分，现在可以结合失效强度来定量地表示一个软件系统的可靠性目标了。</p>
<p>可靠性目标是指客户对软件性能满意程度的期望。通常用可靠度、故障强度和平均失效时间（MTTF）等指标来描述，根据不同项目的不同需要而定。建立定量的可靠性指标需要对可靠性、交付时间和成本进行平衡。为了定义系统的可靠性指标，必须确定系统的运行模式，定义故障的严重性等级，确定故障强度目标。</p>
<p>例如，对于表13-2的例子，可以根据经验和用户的需求确定软件系统需要达到的可靠程度，按照前面的公式，换算成失效强度和平均无失效时间，如表13-3所示。</p>
<details><summary>表13-3　可靠性目标参考表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094121.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094121.png';" /></details>

<h4 id="可靠性测试的意义"><a href="#可靠性测试的意义" class="headerlink" title="可靠性测试的意义"></a>可靠性测试的意义</h4><p>软件可靠性问题已被越来越多的软件工程专家所重视，人们已开始投入大量的人力、物力去研究软件可靠性的设计、评估和测试等课题。以下多个方面可以反映出软件可靠性问题对软件工程实践、乃至对生产活动和社会活动产生的深远影响。</p>
<p>（1）软件失效可能造成灾难性的后果。一个最显著的例子就是由于控制系统的Fortran程序中少了个逗点，致使控制系统未能发出正确的指令，最终使美国的一次宇宙飞行失败。而目前由于计算机和软件在各行各业中应用的日益广泛和深入，例如军用作战系统、民航指挥系统、银行支付系统和交通调控系统等，一旦发生严重级别的软件失效，轻则造成经济损失，重则危及人们的生命安全，危害国家安全。</p>
<p>（2）软件的失效在整个计算机系统失效中的比例较高。某研究机构曾经作过统计，在计算机系统的失效中，有80％和软件有关。原因是软件系统的内容结构太复杂了，一个较简单的程序，其所有的路径数就可能是一个天文数字。在软件开发的过程中，很难用全路径覆盖方式的测试去发现软件系统中隐藏的所有缺陷，也就是说，很难完全排除软件缺陷。</p>
<p>（3）相比硬件可靠性技术，软件可靠性技术很不成熟，这就加剧了软件可靠性问题的重要性。例如在硬件可靠性领域，故障树分析（Fault Tree Analysis, FTA）、失效模式与效应分析（Failure Made And Effect Analysis, FMEA）技术等比较成熟，容错技术也有广泛应用，但在软件可靠性领域，这些技术似乎尚未定型。</p>
<p>（4）与硬件元器件成本急剧下降形成鲜明对比的是，软件费用呈有增无减的势头，而软件可靠性问题是造成费用增长的主要原因之一。</p>
<p>（5）计算机技术获得日益广泛的应用，随着计算机应用系统中软件成分的不断增加，使得系统对于软件的依赖性越来越强，软件对生产活动和社会生活的影响越来越大，从而增加了软件可靠性问题在软件工程领域乃至整个计算机工程领域的重要性。</p>
<p>软件可靠性问题的重要性凸显了发展以发现软件可靠性缺陷为目的的可靠性设计与测试技术的迫切性。</p>
<h4 id="广义的可靠性测试与狭义的可靠性测试"><a href="#广义的可靠性测试与狭义的可靠性测试" class="headerlink" title="广义的可靠性测试与狭义的可靠性测试"></a>广义的可靠性测试与狭义的可靠性测试</h4><p>广义的软件可靠性测试是指为了最终评价软件系统的可靠性而运用建模、统计、试验、分析和评价等一系列手段对软件系统实施的一种测试。一个完整的软件可靠性测试包括图13-1所示的过程。</p>
<details><summary>图13-1　广义的软件可靠性测试</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094355.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094355.png';" /></details>

<p>狭义的软件可靠性测试是指为了获取可靠性数据，按预先确定的测试用例，在软件的预期使用环境中，对软件实施的一种测试。狭义的软件可靠性测试也叫“软件可靠性试验（Software Reliability Test）”，它是面向缺陷的测试，以用户将要使用的方式来测试软件，每一次测试代表用户将要完成的一组操作，使测试成为最终产品使用的预演。这就使得所获得的测试数据与软件的实际运行数据比较接近，可用于软件可靠性评价。</p>
<p>其实，软件可靠性测试是软件测试的一种形式，和易用性测试、性能测试、标准符合性测试等前面介绍的测试类型一样，是针对软件的某个重要质量特性，使用一定的测试用例对软件进行测试的过程。</p>
<p>可靠性测试是对软件产品的可靠性进行调查、分析和评价的一种手段。它不仅仅是为了用测试数据确定软件产品是否达到可靠性目标，还要对检测出的失效的分布、原因及后果进行分析，并给出纠正建议。总的来说，可靠性测试的目的可归纳为以下三个方面。</p>
<p>（1）发现软件系统在需求、设计、编码、测试和实施等方面的各种缺陷。</p>
<p>（2）为软件的使用和维护提供可靠性数据。</p>
<p>（3）确认软件是否达到可靠性的定量要求。</p>
<h3 id="软件可靠性建模"><a href="#软件可靠性建模" class="headerlink" title="软件可靠性建模"></a>软件可靠性建模</h3><h4 id="影响软件可靠性的因素"><a href="#影响软件可靠性的因素" class="headerlink" title="影响软件可靠性的因素"></a>影响软件可靠性的因素</h4><p>在讲到软件可靠性评估的时候，我们不得不提到软件可靠性模型。软件可靠性模型（Software Reliability Model）是指为预计或估算软件的可靠性所建立的可靠性框图和数学模型。建立可靠性模型是为了将复杂系统的可靠性逐级分解为简单系统的可靠性，以便于定量预计、分配、估算和评价复杂系统的可靠性。</p>
<p>为了构建软件的可靠性模型，首先要来分析一下影响软件可靠性的因素。影响软件可靠性的因素是纷杂而众多的，甚至包括技术以外的许多因素。首先必须考虑影响软件可靠性的主要因素：缺陷的引入、发现和清除。缺陷的引入主要取决于软件产品的特性和软件的开发过程特性。软件产品的特性指软件本身的性质，开发过程特性包括开发技术、开发工具、开发人员的水平、需求的变化频度等。缺陷的发现依靠用户对软件的操作方式、运行环境等，也就是运行剖面。缺陷的清除依赖于失效的发现和修复活动及可靠性方面的投入。</p>
<p>从技术的角度来看，影响软件可靠性的主要因素如下。</p>
<p>（1）运行剖面（环境）。软件可靠性的定义是相对运行环境而言的，一样的软件在不同的运行剖面下，其可靠性的表现是不一样的。</p>
<p>（2）软件规模。也就是软件的大小，一个只有数十行代码的软件和几千万行代码的软件是不能相提并论的。</p>
<p>（3）软件内部结构。结构对软件可靠性的影响主要取决于软件结构的复杂程度，一般来说，内部结构越复杂的软件，所包含的软件缺陷数就可能越多。</p>
<p>（4）软件的开发方法和开发环境。软件工程表明，软件的开发方法对软件的可靠性有显著影响。例如，与非结构方法相比，结构化方法可以明显减少软件的缺陷数。</p>
<p>（5）软件的可靠性投入。软件在生命周期中可靠性的投入包括开发者在可靠性设计、可靠性管理、可靠性测试和可靠性评价等方面投入的人力、资金、资源和时间等。经验表明，在早期重视软件可靠性并采取措施开发出来的软件，可靠性有明显的提高。</p>
<p>总之，有许许多多的因素影响着软件的可靠性，有些至今也无法确定它们与软件可靠性之间的定量关系，甚至定性关系也不甚清楚。</p>
<h4 id="软件可靠性建模方法"><a href="#软件可靠性建模方法" class="headerlink" title="软件可靠性建模方法"></a>软件可靠性建模方法</h4><p>一个软件可靠性模型通常（但不是绝对）由以下几部分组成。</p>
<p>（1）模型假设。模型是实际情况的简化或规范化，总要包含若干假设，例如测试的选取代表实际运行剖面，不同软件失效独立发生等。</p>
<p>（2）性能度量。软件可靠性模型的输出量就是性能度量，如失效强度、残留缺陷数等。在软件可靠性模型中性能度量通常以数学表达式给出。</p>
<p>（3）参数估计方法。某些可靠性度量的实际值无法直接获得，例如残留缺陷数，这时需通过一定的方法估计参数的值，从而间接确定可靠性度量的值。当然，对于可直接获得实际值的可靠性度量，就无需参数估计了。</p>
<p>（4）数据要求。一个软件可靠性模型要求一定的输入数据，即软件可靠性数据。不同类型的软件可靠性模型可能要求不同类型的软件可靠性数据。</p>
<p>绝大多数的模型包含三个共同假设。这些假设至今主宰着软件可靠性建模的研究发展，人们尚未找到克服这些假设局限性的有效方法。</p>
<p>（1）代表性假设。此假设认为软件测试用例的选取代表软件实际的运行剖面，甚至认为测试用例是独立随机地选取。此假设实质上是指可以用测试产生的软件可靠性数据预测运行阶段的软件可靠性行为。</p>
<p>（2）独立性假设。此假设认为软件失效是独立发生于不同时刻，一个软件失效的发生不影响另一个软件失效的发生。例如在概率范畴，假设相邻软件失效间隔构成一组独立随机变量，或假设一定时间内软件失效次数构成一个独立增量过程。在模糊数学范畴，则相邻软件失效间隔构成一组不相关的模糊变量。</p>
<p>（3）相同性假设。此假设认为所有软件失效的后果（等级）相同，即建模过程只考虑软件失效的具体发生时刻，不区分软件的失效严重等级。</p>
<p>软件可靠性模型要描述失效过程对上一节所分析的因素的一般依赖形式。由于这些因素大多数在本质上是概率性的，并且表现与时间相关联，所以通过失效数据的概率分布和随机过程随时间的变化的特性来整体区分软件可靠性模型。</p>
<p>我们常常通过下面估计或预测的方法来确定模型的参数。估计是通过收集到的失效数据进行统计分析，利用一定的推导过程归纳出模型的参数；预测则是使用软件产品自身的属性和开发过程来确定模型的参数，这种方法可以在开始执行程序前完成。</p>
<p>确定了模型的参数后，就可以来表示失效过程的很多不同的特性。例如，大多数模型都会对如下的内容进行解析表达。</p>
<p>（1）任何时间点所经历的平均失效数。</p>
<p>（2）一段时间间隔内的平均失效数。</p>
<p>（3）任何时间点的失效强度。</p>
<p>（4）失效区间的概率分布。</p>
<p>在对将来的故障行为进行预测时，应保证模型参数的值不发生变化。如果在进行预测时发现引入了新的错误，或修复行为使新的故障不断发生，就应停止预测，并等足够多的故障出现后，再重新进行模型参数的估计。否则，这样的变化会因为增加问题的复杂程度而使模型的实用性降低。</p>
<p>一般来说，软件可靠性模型是以在固定不变的运行环境中运行的不变的程序作为估测实体的。这也就是说，程序的代码和运行剖面都不发生变化，但它们往往总要发生变化的，于是在这种情况之下，就应采取分段处理的方式来进行工作。因此，模型主要集中注意力于排错。但是，也有的模型具有能处理缓慢地引进错误情况的能力。</p>
<p>对于一个已发行并正在运行的程序，应暂缓安装新的功能和对下一次发行的版本的修复。如果能保持一个不变的运行剖面，则程序的故障密度将显示为一个常数。</p>
<p>一般来说，一个好的软件可靠性模型增加了关于开发项目的交流，并对了解软件开发过程提供了一个共同的工作基础。它也增加了管理的透明度和其他令人感兴趣的东西。即使在特殊的情况之下，通过模型做出的预测并不是很精确的话，上面的这些优点也仍然是明显而有价值的。</p>
<p>要建立一个有用的软件可靠性模型必须有坚实的理论研究工作、有关工具的建造和实际工作经验的积累。通常这些工作要许多人一年的工作量。相反，要应用一个好的软件可靠性模型，则要求以极少的项目资源就可以在实际工作中产生好的效益。</p>
<p>一个好的软件可靠性模型应该具有如下重要特性。</p>
<p>（1）基于可靠的假设。</p>
<p>（2）简单。</p>
<p>（3）计算一些有用的量。</p>
<p>（4）给出未来失效行为的好的映射。</p>
<p>（5）可广泛应用。</p>
<h4 id="软件的可靠性模型分类"><a href="#软件的可靠性模型分类" class="headerlink" title="软件的可靠性模型分类"></a>软件的可靠性模型分类</h4><p>一个有效的软件可靠性模型应尽可能地将上面所述的因素在软件可靠性建模时加以考虑，尽可能简明地反映出来。自1972年第一个软件可靠性分析模型发表的30多年来，见之于文献的软件可靠性统计分析模型将近百种。这些可靠性模型大致可分为如下10类。</p>
<p>●　种子法模型。</p>
<p>●　失效率类模型。</p>
<p>●　曲线拟合类模型。</p>
<p>●　可靠性增长模型。</p>
<p>●　程序结构分析模型。</p>
<p>●　输入域分类模型。</p>
<p>●　执行路径分析方法模型。</p>
<p>●　非齐次泊松过程模型。</p>
<p>●　马尔可夫过程模型。</p>
<p>●　贝叶斯分析模型。</p>
<p>下面分别对这些模型进行简单介绍。</p>
<h5 id="种子法模型"><a href="#种子法模型" class="headerlink" title="种子法模型"></a>种子法模型</h5><p>这类模型利用捕获一再捕获抽样技术估计程序中的错误数，在程序中预先有意“播种”一些设定的错误“种子”，然后根据测试出的原始错误数和发现的诱导错误的比例，来估计程序中残留的错误数。其优点是简便易行，缺点是诱导错误的“种子”与实际的原始错误之间的类比性估量困难。</p>
<h5 id="失效率类模型"><a href="#失效率类模型" class="headerlink" title="失效率类模型"></a>失效率类模型</h5><p>这类模型用来研究程序的失效率，主要有下列内容。</p>
<p>●　Jelinski-Moranda的De-eutrophication模型。</p>
<p>●　Jelinski-Moranda的几何De-eutrophication模型。</p>
<p>●　Schick-Wolverton模型。</p>
<p>●　改进的Schick-Wolverton模型。</p>
<p>●　Moranda的几何泊松模型。</p>
<p>●　Goal和Okumoto不完全排错模型。</p>
<h5 id="曲线拟合类模型"><a href="#曲线拟合类模型" class="headerlink" title="曲线拟合类模型"></a>曲线拟合类模型</h5><p>这类模型用回归分析的方法研究软件复杂性、程序中的缺陷数、失效率、失效间隔时间，包括参数方法和非参数方法两种。</p>
<h5 id="可靠性增长模型"><a href="#可靠性增长模型" class="headerlink" title="可靠性增长模型"></a>可靠性增长模型</h5><p>这类模型预测软件在检错过程中的可靠性改进，用增长函数来描述软件的改进过程。这类模型如下。</p>
<p>●　Duane模型。</p>
<p>●　Weibull模型。</p>
<p>●　Wagoner的Weibull改进模型。</p>
<p>●　Yamada和Osaki的逻辑增长曲线。</p>
<p>●　Gompertz的增长曲线。</p>
<h5 id="程序结构分析模型"><a href="#程序结构分析模型" class="headerlink" title="程序结构分析模型"></a>程序结构分析模型</h5><p>程序结构模型是根据程序、子程序及其相互间的调用关系，形成一个可靠性分析网络。网络中的每一结点代表一个子程序或一个模块，网络中的每一有向弧代表模块间的程序执行顺序。假定各结点的可靠性是相互独立的，通过对每一个结点可靠性、结点间转换的可靠性和网络在结点间的转换概率，得出该持续程序的整体可靠性。这类模型如下。</p>
<p>●　Littewood马尔可夫结构模型。</p>
<p>●　Cheung的面向用户的马尔可夫模型。</p>
<h5 id="输入域分类模型"><a href="#输入域分类模型" class="headerlink" title="输入域分类模型"></a>输入域分类模型</h5><p>这类模型选取软件输入域中的某些样本“点”运行程序，根据这些样本点在“实际”使用环境中的使用概率的测试运行时的成功/失效率，推断软件的使用可靠性。这类模型的重点（亦是难点）是输入域的概率分布的确定及对软件运行剖面的正确描述。这类模型如下。</p>
<p>●　Nelson模型。</p>
<p>●　Bastani的基于输入域的随机过程模型。</p>
<h5 id="执行路径分析方法模型"><a href="#执行路径分析方法模型" class="headerlink" title="执行路径分析方法模型"></a>执行路径分析方法模型</h5><p>这类模型的分析方法与上面的模型相似，先计算程序各逻辑路径的执行概率和程序中错误路径的执行概率，再综合出该软件的使用可靠性。Shooman分解模型属于此类。</p>
<h5 id="非齐次泊松过程模型"><a href="#非齐次泊松过程模型" class="headerlink" title="非齐次泊松过程模型"></a>非齐次泊松过程模型</h5><p>非齐次泊松过程模型，即NHPP，是以软件测试过程中单位时间的失效次数为独立泊松随机变量，来预测在今后软件的某使用时间点的累计失效数。这类模型如下。</p>
<p>●　Musa的指数模型。</p>
<p>●　Goel和Okumoto的NHPP模型。</p>
<p>●　S型可靠性增长模型。</p>
<p>●　超指数增长模型。</p>
<p>●　Pham改进的NHPP模型。</p>
<h5 id="马尔可夫过程模型"><a href="#马尔可夫过程模型" class="headerlink" title="马尔可夫过程模型"></a>马尔可夫过程模型</h5><p>这类模型如下。</p>
<p>●　完全改错的线性死亡模型。</p>
<p>●　不完全改错的线性死亡模型。</p>
<p>●　完全改错的非静态线性死亡模型。</p>
<h5 id="贝叶斯模型"><a href="#贝叶斯模型" class="headerlink" title="贝叶斯模型"></a>贝叶斯模型</h5><p>这是利用失效率的试验前分布和当前的测试失效信息，来评估软件的可靠性。这是一类当软件可靠性工程师对软件的开发过程有充分的了解，软件的继承性比较好时具有良好效果的可靠性分析模型。这类模型如下。</p>
<p>●　连续时间的离散型马尔可夫链。</p>
<p>●　Shock模型。</p>
<p>另外，Musa和Okumoto依据模型的不同属性对可靠性模型进行以下分类。</p>
<p>●　时间域：有两种，自然或日历时间与执行（CPU）时间。</p>
<p>●　失效数类：取决于无限时间内发生的失效数是有限的还是无限的。</p>
<p>●　失效数分布：相对于时间系统失效数的统计分布形式，主要的两类是泊松分布型和二项分布型。</p>
<p>●　有限类：对有限失效数的类别适用，用时间表示的失效强度的函数形式。</p>
<p>●　无限类：对无限失效数的类别适用，用经验期望失效数表示的失效强度的函数形式。</p>
<h4 id="软件可靠性模型举例"><a href="#软件可靠性模型举例" class="headerlink" title="软件可靠性模型举例"></a>软件可靠性模型举例</h4><p>迄今已有数十种模型是根据上一小节中关于模型的分类方法进行的分类，下面将介绍Jelinski-Moranda模型的基本思想及其相关的历史背景。</p>
<p>Jelinski-Moranda模型（JM模型）是Z.Jelinski和P.Moranda于1972年提出的软件可靠性数学模型，是最具代表性的早期软件可靠性马尔可夫过程的数学模型。随后的许多工作都是在它的基础上对其中与软件开发实际不相适合的地方进行改进而提出来的，所以，JM模型是具有广泛影响的模型之一。</p>
<h5 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h5><p>M模型的基本假设如下。</p>
<p>（1）软件系统中的初始错误个数为一个未知的常数，用N0表示。</p>
<p>（2）可靠性测试中发现的错误立即被完全排除，并且排除过程不引入新的错误，排除时间忽略不计。因此，每次排错之后，N0就要减去1。</p>
<p>（3）在任何一个失效间隔区间，软件系统的失效率与系统中剩余的错误个数成正比，比例常数用φ表示。</p>
<p>其实，最初Jehnski和Moranda提出的模型假设只有最后一条，前面两个假设是后人根据使用过程中出现的问题归纳总结而来的。</p>
<h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><p>根据假设，每发生1次失效，错误数都要减去1，如果用t1，t2，…，ti表示从0时刻开始的每次失效间隔时间，那第i-1次失效到第i次失效之间的失效率为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134009.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134009.png';" /></details>

<p>根据在可靠性定量描述一节的讨论，知道失效强度函数为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134022.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134022.png';" /></details>

<p>可靠度函数为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134043.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134043.png';" /></details>

<p>失效概率分布函数为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134106.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134106.png';" /></details>

<h5 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h5><p>在可靠度函数表达式中含有两个未知参数φ和N0，下面运用统计学中的最大似然法来对参数φ和N0进行估算。</p>
<p>由公式（13-15）可得似然函数</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134146.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134146.png';" /></details>

<p>对公式（13-17）取对数，得到对数似然函数</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134202.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134202.png';" /></details>

<p>对公式（13-18）中的N0和φ求偏导，并令结果为0</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134228.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134228.png';" /></details>

<p>公式（13-19）可以写成</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134249.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134249.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134325.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134325.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134334.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134334.png';" /></details>

<p>再来解出另一个参数φ的估计值，令</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134348.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134348.png';" /></details>

<p>则从（13-20）中可解出</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134404.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134404.png';" /></details>

<p>代入N0的估计值，可解出φ的估计值</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134417.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134417.png';" /></details>

<p>需要说明的是，软件可靠性是一门正在发展中的分支学科，许多来源于硬件可靠性的理论在软件可靠性研究中并不适用，有关软件可靠性的模型并不成熟，并且应用范围也非常有限，软件可靠性的定量分析方法和数学模型要在实践中不断加以验证和修正，对于不同类型的软件，模型的假设、表示公式及应用方式也有很大的区别。</p>
<h4 id="软件可靠性测试概述"><a href="#软件可靠性测试概述" class="headerlink" title="软件可靠性测试概述"></a>软件可靠性测试概述</h4><p>软件测试者可以使用很多方法进行软件测试，如按行为或结构来划分输入域的划分测试，纯粹随机选择输入的随机测试，基于功能、路径、数据流或控制流的覆盖测试等。对于给定的软件，每种测试方法都局限于暴露一定数量和一些类别的缺陷。通过这些测试能够查找、定位、改正和消除某些缺陷，实现一定意义上的软件可靠性增长。但是，由于它们都是面向错误的测试，测试所得的结果数据不能直接用于软件可靠性评价，必须经过一定的分析处理后方可使用可靠性模型进行可靠性评价。</p>
<p>软件可靠性测试由可靠性目标的确定、运行剖面的开发、测试用例的设计、测试实施、测试结果的分析等主要活动组成。</p>
<p>软件可靠性测试还必须考虑对软件开发进度和成本的影响，最好是在受控的自动测试环境下，由专业测试机构完成。</p>
<p>软件可靠性测试是一种有效的软件测试和软件可靠性评价技术。尽管软件可靠性测试也不能保证软件中残存的缺陷数最少，但经过软件可靠性测试可以保证软件的可靠性达到较高的要求，对于开发高可靠性与高安全性软件系统很有帮助。</p>
<p>软件可靠性测试要在工程上获得广泛应用，还有许多实际问题需要解决。</p>
<h4 id="定义软件运行剖面"><a href="#定义软件运行剖面" class="headerlink" title="定义软件运行剖面"></a>定义软件运行剖面</h4><p>定义运行剖面首先需要为软件的使用行为建模，建模可以采用马尔可夫链来完成。用马尔可夫链将输入域编码为一个代表用户观点的软件使用的状态集。弧用来连接状态并表示由各种激励导致的转换，这些激励可能由硬件、人机接口或其他软件等产生。将转换概率分配给每个弧，用来代表一个典型用户最有可能施加给系统的激励。这种类型的马尔可夫链是一个离散的有限状态集，这类模型可以用有向图或转换矩阵表示。</p>
<p>定义运行剖面的下一步是开发使用模型，明确需要测试的内容。软件系统可能会有许多用户和用户类别，每类用户都可能以不同的方式使用系统。开发使用模型涉及到将输入域分层，有两种类型的分层形式：用户级分层和用法级分层。用户级分层依赖于谁或什么能激励系统；用法级分层依赖于在测试状态下系统能做什么。换句话说，用户级分层考虑各种类型的用户以及他们如何使用系统；用法级分层则要求考虑系统能够提供的所有功能。一旦用户和用法模型被开发出来，弧上的概率将被分配。这些概率估计主要是基于如下几个方面。</p>
<p>（1）从现有系统收集到的数据。</p>
<p>（2）与用户的交谈或对用户进行观察获得的信息。</p>
<p>（3）原型使用与测试分析的结果。</p>
<p>（4）相关领域专家的意见。</p>
<p>定义使用概率的最佳方法是使用实际的用户数据，如来自系统原型、前一版本的使用数据；其次是由该软件应用领域的用户和专家提供的预期使用数据；在没有任何数据可用的情况下，只能是将每个状态现有的弧分配相同的概率，这是最差的一种方法。</p>
<p>由于软件可靠性行为是相对于软件实际的运行剖面而言的，同一软件在不同运行剖面下其可靠性表现可能大不相同，所以用于可靠性测试准备的运行剖面的开发与定义必须充分分析和考虑软件的实际运行情况。</p>
<p>软件可靠性测试假设每个操作的数据输入都有同样的发生错误的概率，这样最频繁出现的操作和输入将表现出最高的故障率。对于特定的操作环境这是正确的，但无法贯穿系统的全部操作集合。典型的例子是飞机的飞行控制软件，在正常飞行、起飞、降落、地面运动和地面等待这5个状态中，尽管起飞和降落在运行剖面上只占有很小的百分比，但是它们却占有很大的故障比例。对于高安全性要求的软件，一个看起来很少使用的代码路径也可能带来灾难性的后果。因此，对于边界、跃迁情况和关键功能不应该用简单的运行剖面来对待，应该构造专门的运行剖面，补充统计模型之外的测试用例。在覆盖率水平不够时，可根据具体空白，进行适当的补充测试。如果补充测试发现了错误，就可分析这些错误，估计其对可靠性产生的影响。</p>
<p>一个产品有可能需要开发多个运行剖面，这取决于它所包含的运行模式和关键操作，通常需要为关键操作单独定义运行剖面。</p>
<h4 id="可靠性测试用例设计"><a href="#可靠性测试用例设计" class="headerlink" title="可靠性测试用例设计"></a>可靠性测试用例设计</h4><p>为了对软件可靠性进行良好的预计，必须在软件的运行域上对其进行测试。首先定义一个相应的剖面来镜像运行域，然后使用这个剖面驱动测试，这样可以使测试真实地反映软件的使用情况。</p>
<p>由于可能的输入几乎是无限的，测试必须从中选择出一些样本，即测试用例。测试用例要能够反映实际的使用情况，反映系统的运行剖面。将统计方法运用到运行剖面开发和测试用例生成中去，并为在运行剖面中的每个元素都定量地赋予一个发生概率值和关键因子，然后根据这些因素分配测试资源，挑选和生成测试用例。</p>
<p>在这种测试中，优先测试那些最重要或最频繁使用的功能，释放和缓解最高级别的风险，有助于尽早发现那些对可靠性有最大影响的故障，以保证软件的按期交付。</p>
<p>设计测试用例就是针对特定功能或组合功能设计测试方案，并编写成文档。测试用例的选择既要有一般情况，也应有极限情况以及最大和最小的边界值情况。因为测试的目的是暴露应用软件中隐藏的缺陷，所以在设计选取测试用例和数据时要考虑那些易于发现缺陷的测试用例和数据，结合复杂的运行环境，在所有可能的输入条件和输出条件中确定测试数据，来检查应用软件是否都能产生正确的输出。</p>
<p>一个典型的测试用例应该包括下列组成部分。</p>
<p>（1）测试用例标识。</p>
<p>（2）被测对象。</p>
<p>（3）测试环境及条件。</p>
<p>（4）测试输入。</p>
<p>（5）操作步骤。</p>
<p>（6）预期输出。</p>
<p>（7）判断输出结果是否符合标准。</p>
<p>（8）测试对象的特殊需求。</p>
<p>由于可靠性测试的主要目的是评估软件系统的可靠性，因此，除了常规的测试用例集仍然适用外，还要着重考虑和可靠性密切相关的一些特殊情况。在测试中，可以考虑进行“强化输入”，即比正常输入更恶劣（合理程度的恶劣）的输入。</p>
<p>表13-4给出了一些参考例子。</p>
<details><summary>表13-4　可靠性测试用例设计时重点考虑的一些特殊情况</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134610.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134610.png';" /></details>

<h4 id="可靠性测试的实施"><a href="#可靠性测试的实施" class="headerlink" title="可靠性测试的实施"></a>可靠性测试的实施</h4><p>在进行应用软件的可靠性测试前有必要检查软件需求与设计文档是否一致，检查软件开发过程中形成的文档的准确性、完整性以及与程序的一致性，检查所交付程序和数据以及相应的软件支持环境是否符合要求。</p>
<p>这些检查虽然增加了工作量，但对于在测试早期发现错误和提高软件的质量是非常必要的。</p>
<p>软件可靠性测试必须是受控测试，在运行此类测试时，为了保证统计数据的有效性，测试过程中的每个测试用例必须用相同的软件版本，新的软件版本意味着新测试的开始。</p>
<p>在有些情况下，不能进行纯粹的可靠性测试。因为客户的要求、合同的规定或者标准的约束，需要补充其他形式的非统计测试。这时的最佳选择是既执行可靠性测试，也执行非统计测试（如覆盖测试）。如果非统计测试在可靠性测试之前完成，由统计测试产生的统计数据仍然有效。但是在可靠性测试之后执行非统计测试，可能会影响软件可靠性评估的准确性。</p>
<p>软件可靠性测试同样依赖于软件的可测试性。可靠性测试的难点就在于判断测试用例的运行是成功还是失败。在控制系统及类似的软件中，失效由详细说明、时间（通常是CPU时间或时钟时间）来客观地定义。而在一般应用系统中，失效的定义更主观些，它不仅依赖于程序是否符合规格说明的要求，也取决于指定的性能是否能够达到用户的期望，但是否达到期望没有确定的标准。在一些科学计算中，计算结果只能由计算机给出，在这种情况下，如果软件只是输出了错误的结果而不是整个系统发生失效，错误就不可能被发现。此时可以将测试分成两个阶段进行。第一阶段运行较少量的测试用例，并对照规范进行仔细检查。第二阶段再运行大量测试用例。第二阶段不用人工检查输出的每项内容，而是找失效现象，包括错误信息、断电、崩溃和死机。也可把输出记录到文件中，采用搜索或过滤方法进行处理。如果软件有足够的可测试性，这种方法不会漏掉很多的严重失效。如果计算的正确性无法验证，就需要对软件进行一些形式化的证明。</p>
<p>开发方交付的任何软件文档中与可靠性质量特性有关的部分、程序以及数据都应当按照需求说明和质量需求进行测试。在项目合同、需求说明书和用户文档中规定的所有配置情况下，程序和数据都必须进行测试。</p>
<p>软件可靠性数据是可靠性评价的基础。为了获得更多的可靠性数据，应该使用多台计算机同时运行软件，以增加累计运行时间。应该建立软件错误报告、分析与纠正措施系统。按照相关标准的要求，制定和实施软件错误报告和可靠性数据收集、保存、分析和处理的规程，完整、准确地记录软件测试阶段的软件错误报告和收集可靠性数据。</p>
<p>用时间定义的软件可靠性数据可以分为4类，具体内容如下。</p>
<p>（1）失效时间数据。记录发生一次失效所累积经历的时间。</p>
<p>（2）失效间隔时间数据。记录本次失效与上一次失效间的间隔时间。</p>
<p>（3）分组时间内的失效数。记录某个时间区内发生了多少次失效。</p>
<p>（4）分组时间的累积失效数。记录到某个区间的累积失效数。</p>
<p>这4类数据可以互相转化。</p>
<p>在测试过程中必须真实地进行记录，每个测试记录必须包含如下信息。</p>
<p>（1）测试时间。</p>
<p>（2）含有测试用例的测试说明或标识。</p>
<p>（3）所有与测试有关的测试结果，包括失效数据。</p>
<p>（4）测试人员。</p>
<p>测试活动结束后要编写《软件可靠性测试报告》，对测试用例及测试结果在测试报告中加以总结归纳。编写时可以参考GJB 438A-97中提供的《软件测试报告》格式，并应根据情况进行剪裁。测试报告应具备如下内容。</p>
<p>（1）软件产品标识。</p>
<p>（2）测试环境配置（硬件和软件）。</p>
<p>（3）测试依据。</p>
<p>（4）测试结果。</p>
<p>（5）测试问题。</p>
<p>（6）测试时间。</p>
<p>把可靠性测试过程进行规范化，有利于获得真实有效的数据，为最终得到客观的可靠性评价结果奠定基础。</p>
<h3 id="软件可靠性评价"><a href="#软件可靠性评价" class="headerlink" title="软件可靠性评价"></a>软件可靠性评价</h3><h4 id="软件可靠性评价概述"><a href="#软件可靠性评价概述" class="headerlink" title="软件可靠性评价概述"></a>软件可靠性评价概述</h4><p>软件可靠性评价是软件可靠性活动的重要组成部分，既适用于软件开发过程，也可针对最终软件系统。在软件开发过程中使用软件可靠性评价，可以使用软件可靠性模型，估计软件当前的可靠性，以确认是否可以终止测试并发布软件，同时还可以预计软件要达到相应的可靠性水平所需要的时间和工作量，评价提交软件时的软件可靠性水平。对于最终软件产品，软件可靠性评价结合可靠性验证测试，确认软件的执行与需求的一致性，确定最终软件产品所达到的可靠性水平。</p>
<p>这一节阐述的软件可靠性评价工作是指选用或建立合适的可靠性数学模型，运用统计技术和其他手段，对软件可靠性测试和系统运行期间收集的软件失效数据进行处理，并评估和预测软件可靠性的过程。这个过程包含如下三个方面。</p>
<p>（1）选择可靠性模型。</p>
<p>（2）收集可靠性数据。</p>
<p>（3）可靠性评估和预测。</p>
<h4 id="怎样选择可靠性模型"><a href="#怎样选择可靠性模型" class="headerlink" title="怎样选择可靠性模型"></a>怎样选择可靠性模型</h4><p>在前面讨论了软件的可靠性模型以及一个举例，一些可靠性研究者试图寻找一个最好的模型，能适用于所有的软件系统，但这样的工作是徒劳的。因为对于不同的软件系统，出于不同的可靠性分析目的，模型的适用性是不一样的。但究竟怎样来为可靠性评价选用不同的模型，却又是一个不小的难题。</p>
<p>针对可靠性模型的构成以及使用模型来进行可靠性评价的目的，可以从以下几个方面进行比较和选择。</p>
<h5 id="模型假设的适用性"><a href="#模型假设的适用性" class="headerlink" title="模型假设的适用性"></a>模型假设的适用性</h5><p>模型假设是可靠性模型的基础，模型假设要符合软件系统的现有状况，或与假设冲突的因素在软件系统中应该是可忽略的。例如，有的模型假定检测或发现的软件缺陷是立即排除掉的，而且排除时间忽略不计，如果现有的软件系统对于严重程度类较低的软件缺陷不进行立即排错，那么这个模型显然是不适用的。</p>
<p>往往一个模型的假设有许多条，我们需要在选用模型的时候对每一条假设进行细致的分析，评估现有的软件系统中不符合假设的因素对可靠性评价的影响如何，以确定模型是否适合软件系统的可靠性评价工作。</p>
<h5 id="预测的能力与质量"><a href="#预测的能力与质量" class="headerlink" title="预测的能力与质量"></a>预测的能力与质量</h5><p>预测的能力与质量是指模型根据现在和历史的可靠性数据，预测将来的可靠性和失效概率的能力，以及预测结果的准确程度。显然，模型预测的能力与质量是比较难于评价的，但任何一个模型只有在实践中加以实验和不断改善，才能得到认可。所以，在满足其他条件的前提下，应尽量选用比较成熟、应用较广的模型作为分析模型。</p>
<h5 id="模型输出值能否满足可靠性评价需求"><a href="#模型输出值能否满足可靠性评价需求" class="headerlink" title="模型输出值能否满足可靠性评价需求"></a>模型输出值能否满足可靠性评价需求</h5><p>使用模型进行可靠性评价的最终目的，是想得到软件系统当前的可靠性定量数据，以及预测一定时间后的可靠性数据，可以根据可靠性测试目的来确定哪些模型的输出值满足可靠性评价需求。一般来说，最重要的几个需要精确估计的可靠性定量指标包括如下内容。</p>
<p>（1）当前的可靠度。</p>
<p>（2）平均无失效时间。</p>
<p>（3）故障密度。</p>
<p>（4）期望达到规定可靠性目标的日期。</p>
<p>（5）达到规定的可靠性目标的成本要求。</p>
<h5 id="模型使用的简便性"><a href="#模型使用的简便性" class="headerlink" title="模型使用的简便性"></a>模型使用的简便性</h5><p>模型使用的简便性一般包含如下三层含义。</p>
<p>（1）模型需要的数据在软件系统中应该易于收集，而且收集需要投入的成本不能超过可靠性计划的预算。</p>
<p>（2）模型应该简单易懂，进行可靠性分析的软件测试人员不会花费太多的时间去研究专业的数学理论，他们只需要知道哪些假设适用，需要收集哪些数据，能够得到哪些分析结果就可以了。</p>
<p>（3）模型应该便于使用，最好能用工具实现数据的输入。也就是说，测试人员除了输入可靠性数据外，不需要深入模型内部进行一些额外的工作。</p>
<p>尽管这样，由于可靠性研究理论在软件工程领域发展的限制，可供选择的可靠性模型极其有限，这已在相当大的程度上制约了可靠性测试的开展。</p>
<h4 id="可靠性数据的收集"><a href="#可靠性数据的收集" class="headerlink" title="可靠性数据的收集"></a>可靠性数据的收集</h4><p>面向缺陷的可靠性测试产生的测试数据经过分析后，可以得到非常有价值的可靠性数据，是可靠性评价所用数据的一个重要来源，这部分数据取决于定义的运行剖面和选取的测试用例集。可靠性数据主要是指软件失效数据，是软件可靠性评价的基础，主要是在软件测试、实施阶段收集的。在软件工程的需求、设计和开发阶段的可靠性活动，也会产生影响较大的其他可靠性数据。因此，可靠性数据的收集工作是贯穿于整个软件生命周期的。</p>
<p>由于软件开发过程中的特殊复杂性及许多潜在因素的影响，可靠性数据收集工作会极为困难。目前，关于数据的收集工作，存在许多有待解决的问题。</p>
<p>（1）可靠性数据的规范不统一，对软件进行度量的定义混乱不清。例如，时间、缺陷、失效和模型结构等的定义，就相当含糊，缺乏统一的标准。这样就使得在进行软件可靠性数据的收集时，目标不明确，甚至无从下手。</p>
<p>（2）数据收集工作的连续性不能保证。可靠性数据的收集是连续的、长期的过程，而且需要投入一定的资金、人力、时间，往往这些投入会在软件的开发计划中被忽略，以至于不能保证可靠性数据收集工作的正常进行。</p>
<p>（3）缺乏有效的数据收集手段。进行数据收集同样需要方便实用的工具，然而除了在可靠性测试方面有了一些可用的数据收集工具外，其他方面的工具还十分缺乏。</p>
<p>（4）数据的完整性不能保证。即使可靠性活动计划做得再周密，收集到的数据仍有可能是不完全的，而且遗漏的数据往往会影响到可靠性评价的结果。</p>
<p>（5）数据质量和准确性不能保证。不完全的排错及诊断，使收集的数据中含有不少虚假的成分，它们不能正确反映软件的真实状况。使用不准确的可靠性数据进行的可靠性评价，误差有可能会比利用可靠性模型进行预测产生的误差大一个数量级，这说明数据质量的重要性。</p>
<p>为了给软件可靠性评价提供一套准确、有效的可靠性数据，有必要在软件工程中重视软件可靠性数据的收集工作，采取一些措施尽量解决上述问题。在现有条件下，可行的一些办法如下。</p>
<p>（1）及早确定所采用的可靠性模型，以确定需要收集的可靠性数据，并明确定义可靠性数据规范中的一些术语和记录方法，如时间、失效、失效严重程度类的定义，制定标准的可靠性数据记录和统计表格等。</p>
<p>（2）制定可实施性较强的可靠性数据收集计划，指定专人负责，抽取部分开发人员、质量保证人员、测试人员、用户业务人员参加，按照统一的规范收集记录可靠性数据。</p>
<p>（3）重视软件测试特别是可靠性测试产生的测试数据的整理和分析，因为这部分数据是用模拟软件实际运行环境的方法、模拟用户实际操作的测试用例测试软件系统产生的数据，对软件可靠性评价和预测有较高的实用价值。</p>
<p>（4）充分利用数据库来完成可靠性数据的存储和统计分析。一方面减少数据管理的混乱，一方面提高数据处理的效率。</p>
<h4 id="软件可靠性的评估和预测"><a href="#软件可靠性的评估和预测" class="headerlink" title="软件可靠性的评估和预测"></a>软件可靠性的评估和预测</h4><p>软件可靠性的评估和预测的主要目的，是为了评估软件系统的可靠性状况和预测将来一段时间的可靠性水平。下面是一些常见的需要利用软件可靠性评价进行解答的问题。</p>
<p>（1）判断是否达到了可靠性目标，是否达到了软件付诸使用的条件，是否达到了中止测试的条件。</p>
<p>（2）如未能达到，要再投入多少时间、多少人力和多少资金，才能达到可靠性目标或投入使用。</p>
<p>（3）在软件系统投入实际运行一年或若干时间后，经过维护、升级、修改，软件能否达到交付或部分交付用户使用的可靠性水平。</p>
<p>目前有不少支持软件可靠性估计的软件工具，只要将收集的失效数据分类并录入，选择合适的可靠性模型就可以获得软件可靠性的评价结果。</p>
<p>然而，对于那些可靠性要求很高的系统，必须进行很多测试才能预计出高置信度的可靠性结果。即便如此，仍然可能没有任何失效发生。没有失效就无法估计可靠性，不能认为程序的可靠度是1.0。除非已经进行了完全的测试，否则程序不失效就无法做出估计，而完全的测试几乎总是不可能的。如果在测试期间没有失效发生，可以简单地假设测试是基于二项式分布的，这样就可以对可靠性作保守估计。也可以凭经验，根据无故障运行的测试用例的数量，在一定的置信度水平上，估计可靠性的等级。</p>
<p>软件可靠性评价技术和方法主要依据选用的软件可靠性模型，其来源于统计理论。软件可靠性评估和预测以软件可靠性模型分析为主，但也要在模型之外运用一些统计技术和手段对可靠性数据进行分析，作为可靠性模型的补充、完善和修正。这些辅助方法如下。</p>
<p>（1）失效数据的图形分析法。运行图形处理软件失效数据，可以直观地帮助我们进行分析。图形指标如下。</p>
<p>①累积失效个数图形。</p>
<p>②单位时间段内的失效数的图形。</p>
<p>③失效间隔时间图形。</p>
<p>（2）试探性数据分析技术（Exploratory Data Analysis, EDA）。对于失效数据图形进行一定的数字化分析，能发现和揭示出数据中的异常。对可靠性分析有用的信息如下。</p>
<p>①循环相关。</p>
<p>②短期内失效数的急剧上升。</p>
<p>③失效数集中的时间段。</p>
<p>这种分析方法常可以发现因排错引入新的缺陷、数据收集的质量问题及时间域的错误定义等问题。</p>
<p>还有其他一些分析方法，这里就不一一赘述了。</p>
<h3 id="软件的可靠性设计与管理"><a href="#软件的可靠性设计与管理" class="headerlink" title="软件的可靠性设计与管理"></a>软件的可靠性设计与管理</h3><h4 id="软件可靠性设计"><a href="#软件可靠性设计" class="headerlink" title="软件可靠性设计"></a>软件可靠性设计</h4><p>在测试阶段，利用测试手段收集测试数据，并利用软件可靠性模型，可以评估或预测软件的可靠性。这些软件可靠性测试活动虽然能通过查错—排错活动有限地改善软件可靠性，但不能从根本上提高软件的可靠性，也难以保证软件可靠性，并且修改由于设计导致的软件缺陷，有可能付出比较昂贵的代价。实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制。为了从根本上提高软件的可靠性，降低软件后期修改的成本和难度，人们提出了可靠性设计的概念。</p>
<p>可靠性设计其实就是在常规的软件设计中，应用各种方法和技术，使程序设计在兼顾用户的功能和性能需求的同时，全面满足软件的可靠性要求，即采用一些技术手段，把可靠性“设计”到软件中去。软件可靠性设计技术就是以提高和保障软件的可靠性为目的，在软件设计阶段运用的一种特殊的设计技术。</p>
<p>在软件工程中已有很多比较成熟的设计技术，如结构化设计、模块化设计、自顶向下设计及自底向上设计等，这些技术是为了保障软件的整体质量而采用的。在此基础上，为了进一步提高软件的可靠性，通常会采用一些特殊设计技术。虽然软件可靠性设计技术与普通的软件设计技术没有明显的界限，但软件可靠性设计仍要遵循一些自己的原则。</p>
<p>（1）软件可靠性设计是软件设计的一部分，必须在软件的总体设计框架中使用，并且不能与其他设计原则相冲突。</p>
<p>（2）软件可靠性设计在满足提高软件质量要求的前提下，以提高和保障软件可靠性为最终目标。</p>
<p>（3）软件可靠性设计应确定软件的可靠性目标，不能无限扩大化，并且排在功能度、用户需求和开发费用之后考虑。</p>
<p>可靠性设计概念被广为引用，但并没有多少人能提出非常实用并且广泛运用的可靠性设计技术。一般来说，被认可的且具有应用前景的软件可靠性设计技术主要有容错设计、检错设计和降低复杂度设计等技术。</p>
<h5 id="容错设计技术"><a href="#容错设计技术" class="headerlink" title="容错设计技术"></a>容错设计技术</h5><p>对于软件失效后果特别严重的场合，如飞机的飞行控制系统、空中交通管制系统及核反应堆安全控制系统等，可采用容错设计方法。常用的软件容错技术主要有恢复块设计、N版本程序设计和冗余设计三种方法。</p>
<p>（1） $\color{green}{\text{恢复块设计}}$ 。</p>
<p>程序的执行过程可以看成是由一系列操作构成的，这些操作又可由更小的操作构成。恢复块设计就是选择一组操作作为容错设计单元，从而把普通的程序块变成恢复块。被选择用来构造恢复块的程序块可以是模块、过程、子程序和程序段等。</p>
<p>一个恢复块包含有若干个功能相同、设计差异的程序块文本，每一时刻有一个文本处于运行状态。一旦该文本出现故障，则用备份文本加以替换，从而构成“动态冗余”。软件容错的恢复块方法就是使软件包含有一系列恢复块。</p>
<p>（2） $\color{green}{\text{N版本程序设计}}$ 。</p>
<p>N版本程序的核心是通过设计出多个模块或不同版本，对于相同初始条件和相同输入的操作结果，实行多数表决，防止其中某一软件模块/版本的故障提供错误的服务，以实现软件容错。为使此种容错技术具有良好的结果，必须注意以下两个方面。</p>
<p>①使软件的需求说明具有完全性和精确性。这是保证软件设计错误不相关的前提，因为软件的需求说明是不同设计组织和人员的唯一共同出发点。</p>
<p>②设计全过程的不相关性。它要求各个不同的软件设计人员彼此不交流，程序设计使用不同的算法、不同的编程语言、不同的编译程序、不同的设计工具、不同的实现方法和不同的测试方法。为了彻底保证软件设计的不相关性，甚至提出设计人员应具有不同的受教育背景，来自不同的地域、不同的国家。</p>
<p>（3） $\color{green}{\text{冗余设计}}$ 。</p>
<p>改善软件可靠性的一个重要技术是冗余设计。在硬件系统中，在主运行的系统之外备用额外的元件或系统，如果出现一个元件故障或系统故障，则立即更换冗余的元件或切换到冗余的系统，则该硬件系统仍可以维持运行。在软件系统中，冗余技术的运用有所区别。如果采用相同两套软件系统作为互为备份，其意义不大，因为在相同的运行环境中，一套软件出故障的地方，另外一套也一定会出现故障。软件的冗余设计技术实现的原理是在一套完整的软件系统之外，设计一种不同路径、不同算法或不同实现方法的模块或系统作为备份，在出现故障时可以使用冗余的部分进行替换，从而维持软件系统的正常运行。</p>
<p>从表面上看，设计开发完成同样功能但实现方法完全不同的两套软件系统，需要的费用可能接近于单个版本软件开发费用的两倍，但采用冗余技术设计软件所增加的额外费用肯定远低于重新设计一个版本软件的费用。这是因为大多数设计花费，例如文档、测试以及人力都是有可能复用的。冗余设计还有可能导致软件运行时所花费的存储空间、内存消耗以及运行时间有所增加，这就需要在可靠性要求和额外付出代价之间作出折衷。</p>
<h5 id="检错技术"><a href="#检错技术" class="headerlink" title="检错技术"></a>检错技术</h5><p>在软件系统中，对无需在线容错的地方、或不能采用冗余设计技术的部分，如果对可靠性要求较高，故障有可能导致严重的后果。一般采用检错技术，在软件出现故障后能及时发现并报警，提醒维护人员进行处理。检错技术实现的代价一般低于容错技术和冗余技术，但它有一个明显的缺点，就是不能自动解决故障，出现故障后如果不进行人工干预，将最终导致软件系统不能正常运行。</p>
<p>采用检错设计技术要着重考虑几个要素：检测对象、检测延时、实现方式和处理方式。</p>
<p>（1）检测对象：包含两个层次的含义，即检测点和检测内容。在设计时应考虑把检测点放在容易出错的地方和出错对软件系统影响较大的地方；检测内容选取那些有代表性的、易于判断的指标。</p>
<p>（2）检测延时：从软件发生故障到被自检出来是有一定延时的，这段延时的长短对故障的处理是非常重要的。因此，在软件检错设计时要充分考虑到检测延时。如果延时长到影响故障的及时报警，则需要更换检测对象或检测方式。</p>
<p>（3）实现方式：最直接的一种实现方式是判断返回结果，如果返回结果超出正常范围，则进行异常处理。计算运行时间也是一种常用的技术，如果某个模块或函数运行超过预期的时间，可以判断出现故障。另外，还有置状态标志位等多种方法，自检的实现方式要根据实际情况来选用。</p>
<p>（4）处理方式：大多数检错采用“查出故障—停止软件系统运行—报警”的处理方式，但也有采用不停止或部分停止软件系统运行的情况，这一般由故障是否需要实时处理来决定。</p>
<h5 id="降低复杂度设计"><a href="#降低复杂度设计" class="headerlink" title="降低复杂度设计"></a>降低复杂度设计</h5><p>前面讲到，软件和硬件最大的区别之一就是软件的内部结构比硬件复杂得多，我们用软件复杂度来定量描述软件的复杂程度。软件复杂性常分为模块复杂性和结构复杂性。模块复杂性主要包含模块内部数据流向和程序长度两个方面，结构复杂性用不同模块之间的关联程度来表示。软件复杂度可用涉及到模块复杂性和结构复杂性的一些统计指标来进行定量描述，在这里就不进行详细叙述了。</p>
<p>软件的复杂性与软件可靠性有着密切的关系，软件复杂性是产生软件缺陷的重要根源。有研究表明，当软件的复杂度超过一定界限时，软件缺陷数会急剧上升，软件的可靠性急剧下降。因此，在设计时就应考虑降低软件的复杂性，使之处于一个合理的阀值之内，这是提高软件可靠性的有效方法。</p>
<p>降低复杂度设计的思想就是在保证实现软件功能的基础上，简化软件结构，缩短程序代码长度，优化软件数据流向，降低软件复杂度，从而提高软件可靠性。</p>
<p>除了容错设计、检错设计和降低复杂度设计技术外，人们尝试着把硬件可靠性设计中比较成熟的技术，如故障树分析（FTA）、失效模式与效应分析（FMEA）等运用到软件可靠性设计领域，这些技术大多是运用一些分析、预测技术，在软件设计时就充分考虑影响软件可靠性的因素，并采取一些措施进行优化。由于软件与硬件内部性质的巨大差异，这些技术在软件可靠性设计领域的应用效果和范围极其有限。</p>
<h4 id="软件可靠性管理"><a href="#软件可靠性管理" class="headerlink" title="软件可靠性管理"></a>软件可靠性管理</h4><p>为了进一步提高软件可靠性，人们又提出了软件可靠性管理的概念，把软件可靠性活动贯穿于软件开发的全过程。</p>
<p>软件可靠性管理是软件工程管理的一部分，它以全面提高和保证软件可靠性为目标，以软件可靠性活动为主要对象，是把现代管理理论用于软件生命周期中的可靠性保障活动的一种管理形式。</p>
<p>软件可靠性管理的内容包括软件工程各个阶段的可靠性活动的目标、计划、进度、任务和修正措施等。</p>
<p>软件工程各个阶段可能进行的主要的软件可靠性活动如下所述。由于软件之间的差异较大，并且人们对可靠性的期望不同，对可靠性的投入不同，所以下面的每项活动并不是每一个软件系统的可靠性管理的必须内容，也不是软件可靠性管理的全部内容。</p>
<h5 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h5><p>（1）确定软件的可靠性目标。</p>
<p>（2）分析可能影响可靠性的因素。</p>
<p>（3）确定可靠性的验收标准。</p>
<p>（4）制定可靠性管理框架。</p>
<p>（5）制定可靠性文档编写规范。</p>
<p>（6）制定可靠性活动初步计划。</p>
<p>（7）确定可靠性数据收集规范。</p>
<h5 id="概要设计阶段"><a href="#概要设计阶段" class="headerlink" title="概要设计阶段"></a>概要设计阶段</h5><p>（1）确定可靠性度量。</p>
<p>（2）制定详细的可靠性验收方案。</p>
<p>（3）可靠性设计。</p>
<p>（4）收集可靠性数据。</p>
<p>（5）调整可靠性活动计划。</p>
<p>（6）明确后续阶段的可靠性活动的详细计划。</p>
<p>（7）编制可靠性文档。</p>
<h5 id="详细设计阶段"><a href="#详细设计阶段" class="headerlink" title="详细设计阶段"></a>详细设计阶段</h5><p>（1）可靠性设计。</p>
<p>（2）可靠性预测（确定可靠性度量估计值）。</p>
<p>（3）调整可靠性活动计划。</p>
<p>（4）收集可靠性数据。</p>
<p>（5）明确后续阶段的可靠性活动的详细计划。</p>
<p>（6）编制可靠性文档。</p>
<h5 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h5><p>（1）可靠性测试（含于单元测试）。</p>
<p>（2）排错。</p>
<p>（3）调整可靠性活动计划。</p>
<p>（4）收集可靠性数据。</p>
<p>（5）明确后续阶段的可靠性活动的详细计划。</p>
<p>（6）编制可靠性文档。</p>
<h5 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h5><p>（1）可靠性测试〔含于集成测试、系统测试〕。</p>
<p>（2）排错。</p>
<p>（3）可靠性建模。</p>
<p>（4）可靠性评价。</p>
<p>（5）调整可靠性活动计划。</p>
<p>（6）收集可靠性数据。</p>
<p>（7）明确后续阶段的可靠性活动的详细计划。</p>
<p>（8）编制可靠性文档。</p>
<h5 id="实施阶段"><a href="#实施阶段" class="headerlink" title="实施阶段"></a>实施阶段</h5><p>（1）可靠性测试（含于验收测试）。</p>
<p>（2）排错。</p>
<p>（3）收集可靠性数据。</p>
<p>（4）调整可靠性模型。</p>
<p>（5）可靠性评价。</p>
<p>（6）编制可靠性文档。</p>
<p>可靠性管理目前还停留在定性描述的水平上，很难用量化的指标来进行可靠性管理。可靠性管理规范的制定水平和实施效果也有待提高。怎样利用有限的可靠性投入，达到预期的可靠性目标是软件项目管理者常常要面对的难题。因此，可靠性管理研究是一个长期的课题。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><h4 id="系统故障模型"><a href="#系统故障模型" class="headerlink" title="系统故障模型"></a>系统故障模型</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090958.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090958.png';" /></details>


<h4 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907091247.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907091247.png';" /></details>

<h5 id="可靠性vs可用性"><a href="#可靠性vs可用性" class="headerlink" title="可靠性vs可用性"></a>可靠性vs可用性</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907091440.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907091440.png';" /></details>

<h4 id="串联系统与并联系统可靠度计算"><a href="#串联系统与并联系统可靠度计算" class="headerlink" title="串联系统与并联系统可靠度计算"></a>串联系统与并联系统可靠度计算</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142225.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142225.png';" /></details>

<p>可靠度：是相乘的可靠度</p>
<h5 id="模冗余系统与混合系统"><a href="#模冗余系统与混合系统" class="headerlink" title="模冗余系统与混合系统"></a>模冗余系统与混合系统</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142301.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142301.png';" /></details>


<h4 id="系统容错技术"><a href="#系统容错技术" class="headerlink" title="系统容错技术"></a>系统容错技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142422.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142422.png';" /></details>

<p>架构来说可靠性是很重要的</p>
<h5 id="容错系统"><a href="#容错系统" class="headerlink" title="容错系统"></a>容错系统</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142738.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142738.png';" /></details>

<h4 id="N版本程序设计-恢复块方法-防卫式程序设计"><a href="#N版本程序设计-恢复块方法-防卫式程序设计" class="headerlink" title="N版本程序设计_恢复块方法_防卫式程序设计"></a>N版本程序设计_恢复块方法_防卫式程序设计</h4><h5 id="N版本程序设计"><a href="#N版本程序设计" class="headerlink" title="N版本程序设计"></a>N版本程序设计</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142829.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142829.png';" /></details>

<ul>
<li>与通常软件开发过程不同的是，N版本程序设计增加了三个新的阶段:相异成份规范评审、相异性确认、背对背测试</li>
<li>N版本程序的同步、N版本程序之间的通信、表决算法(全等表决、非精确表决、Cosmetie表决)、一致比较问题、数据相异性</li>
<li>各版本的需求说明说不一致</li>
</ul>
<h5 id="恢复块方法"><a href="#恢复块方法" class="headerlink" title="恢复块方法"></a>恢复块方法</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142912.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142912.png';" /></details>

<ul>
<li>设计时应保证实现主块和后备块之间的独立性,避免相关错误的产生,使主块和备份块之间的共性错误降到最低程度。</li>
<li>必须保证验证测试程序的正确性。</li>
</ul>
<h5 id="防卫式程序设计"><a href="#防卫式程序设计" class="headerlink" title="防卫式程序设计"></a>防卫式程序设计</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142954.png';" /></details>
try-catch

+ 对于程序中存在的错误和不一致性，通过在程序中包含错误检查代码和错误恢复代码，使得一旦错误发生，程序能撤消错误状态,恢复到一个已知的正确状态中去
+ 实现策略:错误检测、破坏估计、错误恢复

#### 双机容错与集群技术

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143115.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143115.png';" /></details>


<p>互备：出现故障接管另一台服务器的业务</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143322.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143322.png';" /></details>



<h4 id="集群技术"><a href="#集群技术" class="headerlink" title="集群技术"></a>集群技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143447.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143447.png';" /></details>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch12-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch12-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch12-系统安全架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:37" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:37+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 09:29:38" itemprop="dateModified" datetime="2021-09-04T09:29:38+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="系统安全架构设计"><a href="#系统安全架构设计" class="headerlink" title="系统安全架构设计"></a>系统安全架构设计</h2><h3 id="信息系统安全架构的简单描述"><a href="#信息系统安全架构的简单描述" class="headerlink" title="信息系统安全架构的简单描述"></a>信息系统安全架构的简单描述</h3><p>信息安全的特征是为了保证信息的机密性、完整性、可用性、可控性和不可抵赖性。信息系统的安全保障是以风险和策略为基础，在信息系统的整个生命周期中提供包括技术、管理、人员和工程过程的整体安全，在信息系统中保障信息的这些安全特征，并实现组织机构的使命。许多信息系统的用户需要提供一种方法和内容对信息系统的技术框架、工程过程能力和管理能力提出安全性要求，并进行可比性的评估、设计和实施。</p>
<h4 id="信息安全的现状及其威胁"><a href="#信息安全的现状及其威胁" class="headerlink" title="信息安全的现状及其威胁"></a>信息安全的现状及其威胁</h4><p>随着社会信息化进程的加快，计算机及网络已经在各行各业中得到了广泛的应用，同时一些重要单位如政府机关、部队、企业财务和人事部门已经越来越依赖于计算机。毫无疑问，在不远的将来，计算机和网络的普及程度会比现在有更大的提高，这种普及将会产生两方面的效应：其一，各行各业的业务运转几乎完全依赖于计算机和网络，各种重要数据如政府文件、工资档案、财务账目和人事资料等将全部依托计算机和网络存储、传输；其二，大多数人对计算机的了解更加全面，有更多的计算机技术水平较高的人可以采用种种手段对信息资源进行攻击。目前，信息安全主要可能会受到的威胁可以总结为以下几个方面，如图12-1所示。</p>
<details><summary>图12-1　网络与信息安全风险</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085527.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085527.png';" /></details>

<p>对于信息系统来说，威胁可以是针对物理环境、通信链路、网络系统、操作系统、应用系统以及管理系统等方面。物理安全威胁，是指对系统所用设备的威胁，自然灾害、电源故障、操作系统引导失败或数据库信息丢失、设备被盗/被毁造成数据丢失或信息泄露。通信链路安全威胁，是指在传输线路上安装窃听装置或对通信链路进行干扰。网络安全威胁，互联网的开放性、国际性与无安全管理性，对内部网络形成严重的安全威胁。操作系统安全威胁，对系统平台最危险的威胁是在系统软件或硬件芯片中植入威胁，如“木马”和“陷阱门”、BIOS有万能密码。应用系统安全威胁，是指对于网络服务或用户业务系统安全的威胁，也受到“木马”和“陷阱门”的威胁。管理系统安全威胁，必须从人员管理上杜绝安全漏洞。</p>
<p>具体来讲，常见的安全威胁有如下几种。</p>
<p>（1）信息泄露：信息被泄露或透露给某个非授权的实体。</p>
<p>（2）破坏信息的完整性：数据被非授权地进行增删、修改或破坏而受到损失。</p>
<p>（3）拒绝服务：对信息或其他资源的合法访问被无条件地阻止。</p>
<p>（4）非法使用（非授权访问）：某一资源被某个非授权的人、或以非授权的方式使用。</p>
<p>（5）窃听：用各种可能的合法或非法的手段窃取系统中的信息资源和敏感信息。例如对通信线路中传输的信号进行搭线监听，或者利用通信设备在工作过程中产生的电磁泄露截取有用信息等。</p>
<p>（6）业务流分析：通过对系统进行长期监听，利用统计分析方法对诸如通信频度、通信的信息流向、通信总量的变化等参数进行研究，从而发现有价值的信息和规律。</p>
<p>（7）假冒：通过欺骗通信系统（或用户）达到非法用户冒充成为合法用户，或者特权小的用户冒充成为特权大的用户的目的。黑客大多是采用假冒进行攻击。</p>
<p>（8）旁路控制：攻击者利用系统的安全缺陷或安全性上的脆弱之处获得非授权的权利或特权。例如，攻击者通过各种攻击手段发现原本应保密，但是却又暴露出来的一些系统“特性”。利用这些“特性”，攻击者可以绕过防线守卫者侵入系统的内部。</p>
<p>（9）授权侵犯：被授权以某一目的使用某一系统或资源的某个人，却将此权限用于其他非授权的目的，也称作“内部攻击”。</p>
<p>（10）特洛伊木马：软件中含有一个察觉不出的或者无害的程序段，当它被执行时，会破坏用户的安全。这种应用程序称为特洛伊木马（Trojan Horse）。</p>
<p>（11）陷阱门：在某个系统或某个部件中设置了“机关”，使得当提供特定的输入数据时，允许违反安全策略。</p>
<p>（12）抵赖：这是一种来自用户的攻击，例如，否认自己曾经发布过的某条消息、伪造一份对方来信等。</p>
<p>（13）重放：所截获的某次合法的通信数据备份，出于非法的目的而被重新发送。</p>
<p>（14）计算机病毒：所谓计算机病毒，是一种在计算机系统运行过程中能够实现传染和侵害的功能程序。一种病毒通常含有两个功能：一种功能是对其他程序产生“感染”；另外一种或者是引发损坏功能、或者是一种植入攻击的能力。</p>
<p>（15）人员不慎：一个授权的人为了钱或利益、或由于粗心，将信息泄露给一个非授权的人。</p>
<p>（16）媒体废弃：信息被从废弃的磁盘或打印过的存储介质中获得。</p>
<p>（17）物理侵入：侵入者通过绕过物理控制而获得对系统的访问。</p>
<p>（18）窃取：重要的安全物品，如令牌或身份卡被盗。</p>
<p>（19）业务欺骗：某一伪系统或系统部件欺骗合法的用户或系统自愿地放弃敏感信息。</p>
<p>通过对网络面临的安全风险威胁和实施相应控制措施的支出进行合理的评价，提出有效合理的安全技术，形成提升网络信息的安全性质的安全方案，是安全架构设计的根本目标。在实际应用中，可以从安全技术的角度提取出5个方面的内容：认证鉴别、访问控制、内容安全、冗余恢复和审计响应。</p>
<h4 id="国内外影响较大的标准和组织"><a href="#国内外影响较大的标准和组织" class="headerlink" title="国内外影响较大的标准和组织"></a>国内外影响较大的标准和组织</h4><h5 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h5><p>有如下标准。</p>
<p>（1）可信计算机标准评估规则橘皮书（TCSEC，美国）</p>
<p>（2）欧洲ITSEC标准</p>
<p>（3）加拿大CTCPEC标准</p>
<p>（4）美国联邦准则（FC）</p>
<p>（5）美国信息技术安全评价通用准则（CC）</p>
<p>（6）ISO安全体系结构标准（IS07498-2-1989）〈信息处理系统开放系统互连基本参考模型第二部分安全体系结构〉</p>
<p>（7）美国国家安全局：信息保障技术框架（IATF）</p>
<p>2）我国的标准</p>
<p>（1）主管部门：公安部、信息产业部和国家技术标准局等</p>
<p>（2）主要技术标准如下。</p>
<p>●　GA163-1997（计算机信息系统安全专用产品分类原则）</p>
<p>●　GB17895-1999（计算机信息系统安全保护等级划分准则）</p>
<p>●　GB/T9387.2-1995（信息处理系统开放系统互连基本参考模型第二部分安全体系结构）</p>
<p>●　GB 15834.1-1995（信息处理数据加密实体鉴别机制第一部分：一般模型）</p>
<p>●　GB 4943-1995（信息技术设备的安全）</p>
<h5 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h5><p>1）国际标准化组织（ISO）</p>
<p>ISO的信息技术标准化委员会TC97在1984年1月，专门组织了一个分技术委员会SC20，负责制定数据加密技术的国际标准；之后在1987年，ISO的TC97和IEC的TCs47B/83合并成为ISO/IEC联合技术委员会（JTC1）；1990年4月，ISO将原来的数据加密分技术委员会SC20，更名为安全技术分技术委员会SC27，专门从事信息技术安全一般方法和技术的标准化工作。而ISO/TC68负责银行业务应用范围内有关信息安全标准的制定，它主要制定行业应用标准，在组织上和标准之间与SC27有着密切的联系。</p>
<p>由于信息技术的发展，开放系统互连的网络体系结构的广泛应用，信息技术安全标准化越来越受到人们的重视。在信息技术安全分委会的成立会上，研究了信息技术安全标准化的发展规划，明确了指导思想，确定了工作目标，制定了实施计划，提出了具体的措施，正在为建立完整的信息技术安全标准体系而积极组织开展研究工作和标准制定工作。</p>
<p>2）信息技术安全分技术委员会</p>
<p>1984年7月，在我国的全国计算机与信息处理标准化技术委员会下，建立了相应的数据加密分技术委员会，在国家技术监督局和原电子工业部的领导下，归口国内外的信息技术数据加密的标准化工作。随着信息技术的发展和工作范围的扩大，在原数据加密分委员会的基础上，于1997年8月改组成了信息技术安全分技术委员会（与ISO/IECJTC1/SC27信息技术的安全技术分委会对应）。它是一个具有广泛代表性、权威性和军民结合的信息安全标准化组织。其工作范围是负责信息和通信安全的通用框架、方法、技术和机制的标准化，归口管理国内外对应的标准化工作。其技术安全包括开放式安全体系结构、各种安全信息交换的语义规则、在有关的应用程序接口和协议引用安全功能接口等。</p>
<h3 id="系统安全体系架构规划框架及其方法"><a href="#系统安全体系架构规划框架及其方法" class="headerlink" title="系统安全体系架构规划框架及其方法"></a>系统安全体系架构规划框架及其方法</h3><p>安全技术体系架构是对组织机构信息技术系统的安全体系结构的整体描述。安全技术体系架构能力是拥有信息技术系统的组织机构根据其策略的要求和风险评估的结果，参考相关技术体系构架的标准和最佳实践，结合组织机构信息技术系统的具体现状和需求，建立的符合组织机构信息技术系统战略发展规划的信息技术系统整体体系框架；它是组织机构信息技术系统战略管理的具体体现。技术体系架构能力是组织机构执行安全技术整体能力的体现，它反映了组织机构在执行信息安全技术体系框架管理达到预定的成本、功能和质量目标上的度量。</p>
<p>安全技术体系架构过程的目标是建立可持续改进的安全技术体系架构的能力，信息技术系统千变万化，有各种各样的分类方式，为从技术角度建立一个通用的对象分析模型，在本书中将信息系统抽象成一个基本完备的信息系统分析模型，如图12-2所示。从信息技术系统分析模型出发，建立整个信息技术系统的安全架构。</p>
<details><summary>图12-2　信息技术系统分析模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085724.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085724.png';" /></details>

<p>一般来说，OSI参考模型将网络划分为物理、数据链路、网络、传输、会话、表示和应用7层，Andrew S.Tanenbau综合OSI参考模型和TCP/IP参考模型将网络划分为物理、数据链路、网络、传输、应用5层。在本模型中，首先需要做的就是对网络结构层次进行划分，考虑到安全评估是以安全风险威胁分析入手的，而且在实际的网络安全评估中会发现，主机和存储系统占据了大量的评估考察工作，虽然主机和存储系统都属于应用层，但本模型由于其重要性，特将其单列为一个层次，因此根据网络中风险威胁的存在实体划分出5个层次的实体对象：应用、存储、主机、网络和物理。</p>
<p>信息系统安全规划是一个非常细致和非常重要的工作，首先需要对企业信息化发展的历史情况进行深入和全面的调研，知道家底、掌握情况，针对信息系统安全的主要内容进行整体的发展规划工作。下面用图12-3表示信息系统安全体系的框架。</p>
<p>从图12-3可以看出，信息系统安全体系主要是由技术体系、组织机构体系和管理体系三部分共同构成的。技术体系是全面提供信息系统安全保护的技术保障系统，该体系由物理安全技术和系统安全技术两大类构成。组织体系是信息系统的组织保障系统，由机构、岗位和人事三个模块构成。机构分为领导决策层、日常管理层和具体执行层；岗位是信息系统安全管理部门根据系统安全需要设定的负责某一个或某几个安全事务的职位；人事是根据管理机构设定的岗位，对岗位上在职、待职和离职的员工进行素质教育、业绩考核和安全监管的机构。管理体系由法律管理、制度管理和培训管理三部分组成。</p>
<details><summary>图12-3　信息系统安全体系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085744.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085744.png';" /></details>

<p>信息系统安全体系清楚了之后，就可以针对以上描述的内容进行全面的规划。信息系统安全规划的层次方法与步骤可以有不同，但是规划内容与层次应该是相同。规划的具体环节、相互之间的关系和具体方法如图12-4所示。</p>
<details><summary>图12-4　信息系统安全规划框架图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085800.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085800.png';" /></details>


<h5 id="信息系统安全规划依托企业信息化战略规划"><a href="#信息系统安全规划依托企业信息化战略规划" class="headerlink" title="信息系统安全规划依托企业信息化战略规划"></a>信息系统安全规划依托企业信息化战略规划</h5><p>信息化战略规划是以整个企业的发展目标、发展战略和企业各部门的业务需求为基础，结合行业信息化方面的需求分析、环境分析和对信息技术发展趋势的掌握，定义出企业信息化建设的远景、使命、目标和战略，规划出企业信息化建设的未来架构，为信息化建设的实施提供一副完整的蓝图，全面系统地指导企业信息化建设的进程。信息系统安全规划依托企业信息化战略规划，对信息化战略的实施起到保驾护航的作用。信息系统安全规划的目标应该与企业信息化的目标是一致的，而且应该比企业信息化的目标更具体明确、更贴近安全。信息系统安全规划的一切论述都要围绕着这个目标展开和部署。</p>
<h5 id="信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑"><a href="#信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑" class="headerlink" title="信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑"></a>信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑</h5><p>信息系统安全规划的方法可以不同、侧重点可以不同，但都需要围绕技术安全、管理安全、组织安全进行全面的考虑。规划的内容基本上应该涵盖：确定信息系统安全的任务、目标、战略以及战略部门和战略人员，并在此基础上制定出物理安全、网络安全、系统安全、运营安全、人员安全的信息系统安全的总体规划。物理安全包括环境设备安全、信息设备安全、网络设备安全、信息资产设备的物理分布安全等。网络安全包括网络拓扑结构安全、网络的物理线路安全、网络访问安全（防火墙、入侵检测系统和VPN等）等。系统安全包括操作系统安全、应用软件安全和应用策略安全等。运营安全应在控制层面和管理层面保障，包括备份与恢复系统安全、入侵检测功能、加密认证功能、漏洞检查及系统补丁功能、口令管理等。人员安全包括安全管理的组织机构、人员安全教育与意识机制、人员招聘及离职管理、第三方人员安全管理等。</p>
<h5 id="信息系统安全规划以信息系统与信息资源的安全保护为核心"><a href="#信息系统安全规划以信息系统与信息资源的安全保护为核心" class="headerlink" title="信息系统安全规划以信息系统与信息资源的安全保护为核心"></a>信息系统安全规划以信息系统与信息资源的安全保护为核心</h5><p>信息系统安全规划的最终效果应该体现在对信息系统与信息资源的安全保护上，因此规划工作需要围绕着信息系统与信息资源的开发、利用和保护工作进行，要包括蓝图、现状、需求和措施4个方面。</p>
<p>（1）对信息系统与信息资源的规划需要从信息化建设的蓝图入手，知道企业信息化发展策略的总体目标和各阶段的实施目标，制定出信息系统安全的发展目标。</p>
<p>（2）对企业的信息化工作现状进行整体的、综合、全面的分析，找出过去工作中的优势与不足。</p>
<p>（3）根据信息化建设的目标提出未来几年的需求，这个需求最好可以分解成若干个小的方面，以便于今后的落实与实施。</p>
<p>（4）要写明在实施工作阶段的具体措施与办法，提高规划工作的执行力度。信息系统安全规划服务于企业信息化战略目标，信息系统安全规划做得好，企业信息化工作的实现就有了保障。信息系统安全规划是企业信息化发展战略的基础性工作，不是可有可无而是非常重要。由于企业信息化的任务与目标不同，所以信息系统安全规划包括的内容就不同，建设的规模就有很大的差异，因此信息系统安全规划无法从专业书籍或研究资料中找到非常有针对性的、有帮助的适用法则，也不可能给出一个规范化的信息系统安全规划的模板。在这里提出信息系统安全规划框架与方法，给出了信息系统安全规划工作的一种建设原则、建设内容、建设思路，具体规划还需要深入细致地进行本地化的调查与研究。</p>
<h3 id="网络安全体系架构设计"><a href="#网络安全体系架构设计" class="headerlink" title="网络安全体系架构设计"></a>网络安全体系架构设计</h3><p>介绍信息系统安全体系的目的，就是将普遍性安全原理与信息系统的实际相结合，形成满足信息系统安全需求的安全体系结构。</p>
<h4 id="OSI的安全体系架构概述"><a href="#OSI的安全体系架构概述" class="headerlink" title="OSI的安全体系架构概述"></a>OSI的安全体系架构概述</h4><p>国家标准《信息处理系统工程开放系统互联基本参考模型—第二部分：安全体系结构》（GB/T 9387.2-1995）（等同于ISO 7498-2），以及互联网安全体系结构（RFC 2401），是两个普遍适用的安全体系结构，目的在于保证开放系统进程与进程之间远距离安全交换信息。这些标准在参考模型的框架内，建立起一些指导原则与约束条件，从而提供了解决开放互联系统中安全问题的一致性方法。</p>
<p>OSI安全体系结构提供以下内容。</p>
<p>（1）提供安全服务与有关安全机制在体系结构下的一般描述，这些服务和机制必须是为体系结构所配备的。</p>
<p>（2）确定体系结构内部可以提供这些服务的位置。</p>
<p>（3）保证安全服务完全准确地得以配置，并且在信息系统的安全周期中一直维持，安全功能务必达到一定强度的要求。</p>
<p>国家标准《信息处理系统工程开放系统互联基本参考模型—第二部分：安全体系结构》（GB/T 9387.2-1995）（等同于ISO 7498-2），给出了基于OSI参考模型的7层协议之上的信息安全体系结构。其核心内容是：为了保证异构计算机进程与进程之间远距离交换信息的安全，它定义了该系统5大类安全服务，以及提供这些服务的8类安全机制及相应的OSI安全管理，并可根据具体系统适当地配置于OSI模型的7层协议中。图12-5所示的三维安全空间解释了这一体系结构。</p>
<p>在OSI 7层协议中除第5层（会话层）外，每一层均能提供相应的安全服务。实际上，最适合配置安全服务的是在物理层、网络层、运输层及应用层上，其他层都不宜配置安全服务。</p>
<p>ISO开放系统互联安全体系的5类安全服务包括鉴别、访问控制、数据机密性、数据完整性和抗抵赖性。</p>
<p>分层多点安全技术体系架构，也称为深度防御安全技术体系架构，它通过以下方式将防御能力分布至整个信息系统中。</p>
<details><summary>图12-5　信息安全体系结构示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085956.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085956.png';" /></details>

<p>（1）多点技术防御。在对手可以从内部或外部多点攻击一个目标的前提下，多点技术防御通过对以下多个防御核心区域的防御达到抵御所有方式的攻击的目的。</p>
<p>①网络和基础设施。为了确保可用性，局域网和广域网需要进行保护以抵抗各种攻击，如拒绝服务攻击等。为了确保机密性和完整性，需要保护在这些网络上传送的信息以及流量的特征以防止非故意的泄露。</p>
<p>②边界。为了抵御主动的网络攻击，边界需要提供更强的边界防御，例如流量过滤和控制以及入侵检测。</p>
<p>③计算环境。为了抵御内部、近距离的分布攻击，主机和工作站需要提供足够的访问控制。</p>
<p>（2）分层技术防御。即使最好的可得到的信息保障产品也有弱点，其最终结果将使对手能找到一个可探查的脆弱性，一个有效的措施是在对手和目标间使用多个防御机制。为了减少这些攻击成功的可能性和对成功攻击的可承担性，每种机制应代表一种唯一的障碍并同时包括保护和检测方法。例如，在外部和内部边界同时使用嵌套的防火墙并配合以入侵检测就是分层技术防御的一个实例。</p>
<p>支撑性基础设施为网络、边界和计算环境中信息保障机制运行基础的支撑性基础设施，包括公钥基础设施以及检测和响应基础设施。</p>
<p>（1）公钥基础设施。提供一种通用的联合处理方式，以便安全地创建、分发和管理公钥证书和传统的对称密钥，使它们能够为网络、边界和计算环境提供安全服务。这些服务能够对发送者和接收者的完整性进行可靠验证，并可以避免在未获授权的情况下泄露和更改信息。公钥基础设施必须支持受控的互操作性，并与各用户团体所建立的安全策略保持一致。</p>
<p>（2）检测和响应基础设施。检测和响应基础设施能够迅速检测并响应入侵行为。它也提供便于结合其他相关事件观察某个事件的“汇总”性能。另外，它也允许分析员识别潜在的行为模式或新的发展趋势。</p>
<p>必须提醒的是，信息系统的安全保障不仅仅依赖于技术，还需要集成的技术和非技术防御手段。一个可接受级别的信息保障依赖于人员、管理、技术和过程的综合。</p>
<p>图12-6描述了分层多点安全技术体系架构。</p>
<details><summary>图12-6　分层多点安全技术体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090039.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090039.png';" /></details>

<p>分层多点安全技术体系架构为信息系统安全保障提供了框架和进一步分析所需的重点区域划分。在具体的技术方案实践中，应从使命和需求的实际情况出发制定适合组织机构要求的技术体系和方案。</p>
<h4 id="鉴别框架"><a href="#鉴别框架" class="headerlink" title="鉴别框架"></a>鉴别框架</h4><p>鉴别（Authentication）的基本目的，就是防止其他实体占用和独立操作被鉴别实体的身份。鉴别提供了实体声称其身份的保证，只有在主体和验证者的关系背景下，鉴别才是有意义的。鉴别有两种重要的关系背景：一是实体由申请者来代表，申请者与验证者之间存在着特定的通信关系（如实体鉴别）；二是实体为验证者提供数据项来源。</p>
<p>鉴别的方式主要基于以下5种。</p>
<p>（1）已知的，如一个秘密的口令。</p>
<p>（2）拥有的，如IC卡、令牌等。</p>
<p>（3）不改变的特性，如生物特征。</p>
<p>（4）相信可靠的第三方建立的鉴别（递推）。</p>
<p>（5）环境（如主机地址等）。</p>
<p>鉴别信息（Artificial Intelligence, AI）是指申请者要求鉴别到鉴别过程结束所生成、使用和交换的信息。鉴别信息的类型有交换鉴别信息（交换AI）、申请鉴别信息（申请AI）和验证鉴别信息（验证AI）。</p>
<details><summary>图12-7　申请者、验证者、可信第三方之间的关系及三种鉴别信息类型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090111.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090111.png';" /></details>


<p>注意：在某些特定的情况下，可以不涉及可信任的第三方。</p>
<p>验证AI可以是主体的，也可以是可信任第三方的。</p>
<p>在某些情况下，为了产生交换AI，申请者需要与可信第三方进行交互。类似的，为了验证交换AI，验证者也需要同可信第三方进行交互。在这种情况下，可信第三方持有相关实体的验证AI，也可能使用可信第三方来传递交换AI。实体也可能需要持有鉴别可信第三方中所使用的鉴别信息。</p>
<p>鉴别服务分为以下阶段：安装阶段；修改鉴别信息阶段；分发阶段；获取阶段；传送阶段；验证阶段；停活阶段；重新激活阶段；取消安装阶段。</p>
<p>在安装阶段，定义申请AI和验证AI。修改鉴别信息阶段，实体或管理者申请AI和验证AI变更（如修改口令）。在分发阶段，为了验证交换AI，把验证AI分发到各实体（如申请者或验证者）以供使用。在获取阶段，申请者或验证者可得到为鉴别实例生成特定交换AI所需的信息，通过与可信第三方进行交互或鉴别实体间的信息交换可得到交换AI。例如，当使用联机密钥分配中心时，申请者或验证者可从密钥分配中心得到一些信息，如鉴别证书。在传送阶段，在申请者与验证者之间传送交换AI。在验证阶段，用验证AI核对交换AI。在停活阶段，将建立一种状态，使得以前能被鉴别的实体暂时不能被鉴别。在重新激活阶段，使在停活阶段建立的状态将被终止。在取消安装阶段，实体从实体集合中被拆除。</p>
<h4 id="访问控制框架"><a href="#访问控制框架" class="headerlink" title="访问控制框架"></a>访问控制框架</h4><p>访问控制（Access Control）决定开放系统环境中允许使用哪些资源、在什么地方适合阻止未授权访问的过程。在访问控制实例中，访问可以是对一个系统（即对一个系统通信部分的一个实体）或对一个系统内部进行的。</p>
<p>图12-8和图12-9说明了访问控制的基础性功能。</p>
<details><summary>图12-9　ADF示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090214.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090214.png';" /></details>

<p>ACI（访问控制信息）是用于访问控制目的的任何信息，其中包括上下文信息。ADI（访问控制判决信息）是在做出一个特定的访问控制判决时可供ADF使用的部分（或全部）ACI。ADF（访问控制判决功能）是一种特定功能，它通过对访问请求、ADI以及该访问请求的上下文使用访问控制策略规则而做出访问控制判决。AEF（访问控制实施功能）确保只有对目标允许的访问才由发起者执行。</p>
<p>涉及访问控制的有发起者、AEF、ADF和目标。发起者代表访问或试图访问目标的人和基于计算机的实体。目标代表被试图访问或由发起者访问的，基于计算机或通信的实体。例如，目标可能是OSI实体、文件或者系统。访问请求代表构成试图访问部分的操作和操作数。</p>
<p>当发起者请求对目标进行特殊访问时，AEF就通知ADF需要一个判决来做出决定。为了作出判决，给ADF提供了访问请求（作为判决请求的一部分）和下列几种访问控制判决信息（ADI）。</p>
<p>（1）发起者ADI（ADI由绑定到发起者的ACI导出）。</p>
<p>（2）目标ADI（ADI由绑定到目标的ACI导出）。</p>
<p>（3）访问请求ADI（ADI由绑定到访问请求的ACI导出）。</p>
<p>ADF的其他输入是访问控制策略规则（来自ADF的安全域权威机构）和用于解释ADI或策略的必要上下文信息。上下文信息包括发起者的位置、访问时间或使用中的特殊通信路径。基于这些输入，以及可能还有以前判决中保留下来的ADI信息，ADF可以做出允许或禁止发起者试图对目标进行访问的判决。该判决传递给AEF，然后AEF允许将访问请求传给目标或采取其他合适的行动。</p>
<p>在许多情况下，由发起者对目标的逐次访问请求是相关的。应用中的一个典型例子是在打开与同层目标的连接应用进程后，试图用相同（保留）的ADI执行几个访问。对一些随后通过连接进行通信的访问请求，可能需要给ADF提供附加的ADI以允许访问请求。在另一些情况中，安全策略可能要求对一个或多个发起者与一个或多个目标之间的某种相关访问请求进行限制。这时，ADF可能使用与多个发起者和目标有关的先前判决中所保留的ADI来对特殊访问请求作出判决。</p>
<p>如果得到AEF的允许，访问请求只涉及发起者与目标的单一交互。尽管发起者和目标之间的一些访问请求是完全与其他访问请求无关的，但常常是两个实体进入一个相关的访问请求集合中，如质询应答模式。在这种情况下，实体根据需要同时或交替地变更发起者和目标角色，可以由分离的AEF组件、ADF组件和访问控制策略对每一个访问请求执行访问控制功能。</p>
<h4 id="机密性框架"><a href="#机密性框架" class="headerlink" title="机密性框架"></a>机密性框架</h4><p>机密性（Confidentiality）服务的目的是确保信息仅仅是对被授权者可用。由于信息是通过数据表示的，而且数据可能导致关系的变化（如文件操作可能导致目录改变或可用存储区域的改变），因此信息能通过许多不同的方式从数据中导出。例如，通过理解数据的含义（如数据的值）导出；通过使用数据相关的属性（如存在性、创建的数据、数据大小、最后一次更新的日期等）进行推导；通过研究数据的上下文关系，即那些与之相关的其他数据实体导出；通过观察数据表达式的动态变化导出。</p>
<p>信息的保护通过确保数据被限制于授权者获得，或通过特定方式表示数据来获得，这种保护方式的语义是，数据只对那些拥有某种关键信息的人才是可访问的。有效的机密性保护要求必要的控制信息（如密钥和RCI等）是受到保护的，这种保护机制和用来保护数据的机制是不同的（如密钥可以通过物理手段保护等）。</p>
<p>在机密性框架中用到被保护的环境和被交叠保护的环境两个概念。在被保护环境中的数据，通过使用特别的安全机制（或多个机制）保护。在一个被保护环境中的所有数据以类似方法受到保护。当两个或更多的环境交叠的时候，交叠中的数据能被多重保护。可以推断，从一个环境移到另一个环境的数据的连续保护必然涉及到交叠保护环境。</p>
<p>机密性机制</p>
<p>数据的机密性可以依赖于所驻留和传输的媒体。因此，存储数据的机密性能通过使用隐藏数据语义（如加密）或将数据分片的机制来保证。数据在传输中的机密性能通过禁止访问的机制、通过隐藏数据语义的机制或通过分散数据的机制得以保证（如跳频等）。这些机制类型能被单独使用或者组合使用。</p>
<p>1）通过禁止访问提供机密性</p>
<p>通过禁止访问的机密性能通过在ITU-T Rec. 812或ISO/IEC 10181-3中描述的访问控制获得，以及通过物理媒体保护和路由选择控制获得。通过物理媒体保护的机密性保护可以采取物理方法保证媒体中的数据只能通过特殊的有限设备才能检测到。数据机密性通过确保只有授权的实体才能使这些机制本身有效的方式来实现。通过路由选择控制的机密性保护机制的目的，是防止被传输数据项表示的信息未授权泄露。在这一机制下只有可信和安全的设施才能路由数据，以达到支持机密性服务的目的。</p>
<p>2）通过加密提供机密性</p>
<p>这些机制的目的是防止数据泄露在传输或存储中。加密机制分为基于对称的加密机制和基于非对称加密的机密机制。</p>
<p>除了以下两种机密性机制外，还可以通过数据填充、通过虚假事件（如把在不可信链路上交换的信息流总量隐藏起来）、通过保护PDU头和通过时间可变域提供机密性。</p>
<h4 id="完整性框架"><a href="#完整性框架" class="headerlink" title="完整性框架"></a>完整性框架</h4><p>完整性（Integrity）框架的目的是通过阻止威胁或探测威胁，保护可能遭到不同方式危害的数据完整性和数据相关属性完整性。所谓完整性，就是数据不以未经授权方式进行改变或损毁的特征。</p>
<p>完整性服务有几种分类方式：根据防范的违规分类违规操作分为未授权的数据修改、未授权的数据创建、未授权的数据删除、未授权的数据插入和未授权的数据重放。依据提供的保护方法分为阻止完整性损坏和检测完整性损坏。依据是否包括恢复机制分为具有恢复机制的和不具有恢复机制的。</p>
<p>完整性机制的类型</p>
<p>由于保护数据的能力与正在使用的媒体有关。完整性机制是有区别的，包括如下类型。</p>
<p>（1）阻止对媒体访问的机制。包括物理隔离的、不受干扰的信道；路由控制；访问控制。</p>
<p>（2）用以探测对数据或数据项序列的非授权修改的机制。未授权修改包括未授权数据创建、数据删除以及数据重复。而相应的完整性机制包括密封、数字签名、数据重复（作为对抗其他类型违规的手段）、与密码变换相结合的数字指纹和消息序列号。</p>
<p>按照保护强度，完整性机制可分为不作保护；对修改和创建的探测；对修改、创建、删除和重复的探测；对修改和创建的探测并带恢复功能；对修改、创建、删除和重复的探测并带恢复功能。</p>
<h4 id="抗抵赖框架"><a href="#抗抵赖框架" class="headerlink" title="抗抵赖框架"></a>抗抵赖框架</h4><p>抗抵赖（Non-repudiation）服务包括证据的生成、验证和记录，以及在解决纠纷时随即进行的证据恢复和再次验证。</p>
<p>框架所描述的抗抵赖服务的目的是提供有关特定事件或行为的证据。事件或行为本身以外的其他实体可以请求抗抵赖服务。抗抵赖服务可以保护的行为实例有发送X.400消息；在数据库中插入记录、请求远程操作等。</p>
<p>当涉及消息内容的抗抵赖服务时，为提供原发证明，必须确认数据原发者身份和数据完整性。为提供递交证明，必须确认接收者身份和数据完整性。在某些情况下，还可能需要涉及上下文关系（如日期、时间、原发者/接收者的地点等）的证据。</p>
<p>抗抵赖服务提供下列可在试图抵赖的事件中使用的设备：证据生成、证据记录、验证生成的证据、证据的恢复和重验。</p>
<p>纠纷可以在纠纷两方之间直接通过检查证据解决。但是，纠纷也可能不得不通过仲裁者解决，该仲裁者评估并确定是否发生过有纠纷的行为或事件。</p>
<p>抗抵赖由4个独立的阶段组成：证据生成；证据传输、存储和恢复；证据验证；解决纠纷，如图12-10所示。</p>
<p>1）证据生成</p>
<p>在这个阶段中，证据生成请求者请求证据生成者为事件或行为生成证据。卷入事件或行为中的实体，称为证据实体，其卷入关系由证据建立。根据抗抵赖服务的类型，证据可由证据实体、或可能与可信第三方的服务一起生成、或者单独由可信第三方生成。</p>
<p>2）证据传输、存储和恢复</p>
<p>在这个阶段，证据在实体间传输或从存储器取出来或传到存储器。</p>
<details><summary>图12-10　参与生成、传输、存储/恢复和证实阶段的实体(注：本图是示意图，并非定义)</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090400.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090400.png';" /></details>

<p>3）证据验证</p>
<p>在这个阶段，证据在证据使用者的请求下被证据验证者验证。本阶段的目的是在出现纠纷的事件中，让证据使用者确信被提供的证据确实是充分的。可信第三方服务也可参与，以提供验证该证据的信息。</p>
<p>4）解决纠纷</p>
<p>在解决纠纷阶段，仲裁者有解决双方纠纷的责任。图12-11描述了纠纷解决阶段。</p>
<details><summary>图12-11　抗抵赖过程的纠纷解决阶段</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904092122.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904092122.png';" /></details>

<h3 id="数据库系统的安全设计"><a href="#数据库系统的安全设计" class="headerlink" title="数据库系统的安全设计"></a>数据库系统的安全设计</h3><p>在数据库系统中， 由于数据的集中管理，随之而来的是多用户存取，以及近年来跨网络的分布系统的急速发展。数据库的安全问题可以说已经构成信息系统最为关键的环节，而电子政务中所涉及的数据库密级更高、实时性更强。因此，有必要根据其特殊性完善安全策略，这些安全策略应该能保证数据库中的数据不会被有意地攻击或无意地破坏。不会发生数据的外泄、丢失和毁损，即实现了数据库系统安全的完整性、保密性和可用性。从数据库管理系统的角度而言，要采取的安全策略一般为用户管理、存取控制、数据加密、审计跟踪和攻击检测，从而解决数据库系统的运行安全和信息安全。</p>
<p>下面分别从数据库安全设计的评估标准和完整性设计两方面进行讨论。</p>
<h4 id="数据库安全设计的评估标准"><a href="#数据库安全设计的评估标准" class="headerlink" title="数据库安全设计的评估标准"></a>数据库安全设计的评估标准</h4><p>随着人们对安全问题的认识和对安全产品的要求不断提高，在计算机安全技术方面逐步建立了一套安全评估标准，以规范和指导安全信息的建立、安全产品的生产，并能较准确地评测产品的安全性能指标。在当前各国制定和采用的标准中，最重要的是1985年美国国防部颁布的“可信计算机系统评估标准（Trusted Computer System Evaluation Criteria, TCSEC）”桔皮书（简称为DoD85）。1991年，美国国家计算机安全中心（The National Computer Seaurity Center, NCSC）又颁布了“可信计算机评估标准关于可信数据库管理系统的解释（Trusted Database Interpretation, TDI）”。我国也于1994年2月发布了“中华人民共和国计算机信息系统安全保护条例”。在TCSEC中，将安全系统分为4大类7个等级。</p>
<p>TDI是TCSEC在数据库管理系统方面的扩充和解释，并从安全策略、责任、保护和文档4个方面进一步描述了每级的安全标准。按照TCSEC标准，D类产品是基本没有安全保护措施的产品，C类产品只提供了安全保护措施，一般不称为安全产品。B类以上产品是实行强制存取控制的产品，也是真正意义上的安全产品。所谓安全产品均是指安全级别在B1以上的产品，而安全数据库研究原型一般是指安全级别在B1级以上的以科研为目的，尚未产品化的数据库管理系统原型。</p>
<h4 id="数据库的完整性设计"><a href="#数据库的完整性设计" class="headerlink" title="数据库的完整性设计"></a>数据库的完整性设计</h4><p>数据库完整性是指数据库中数据的正确性和相容性。数据库完整性由各种各样的完整性约束来保证，因此可以说数据库完整性设计就是数据库完整性约束的设计。数据库完整性约束可以通过DBMS或应用程序来实现，基于DBMS的完整性约束作为模式的一部分存入数据库中。通过DBMS实现的数据库完整性按照数据库设计步骤进行设计，而由应用软件实现的数据库完整性则纳入应用软件设计。</p>
<h5 id="数据库完整性设计原则"><a href="#数据库完整性设计原则" class="headerlink" title="数据库完整性设计原则"></a>数据库完整性设计原则</h5><p>在实施数据库完整性设计时，需要把握以下基本原则。</p>
<p>（1）根据数据库完整性约束的类型确定其实现的系统层次和方式，并提前考虑对系统性能的影响。一般情况下，静态约束应尽量包含在数据库模式中，而动态约束由应用程序实现。</p>
<p>（2）实体完整性约束、参照完整性约束是关系数据库最重要的完整性约束，在不影响系统关键性能的前提下需尽量应用。用一定的时间和空间来换取系统的易用性是值得的。</p>
<p>（3）要慎用目前主流DBMS都支持的触发器功能，一方面由于触发器的性能开销较大；另一方面，触发器的多级触发不好控制，容易发生错误，非用不可时，最好使用Before型语句级触发器。</p>
<p>（4）在需求分析阶段就必须制定完整性约束的命名规范，尽量使用有意义的英文单词、缩写词、表名、列名及下划线等组合，使其易于识别和记忆，如CKC EMP REAL INCOME EMPLOYEE、PK EMPLOYEE、CKT EMPLOYEE。如果使用CASE工具，一般有默认的规则，可在此基础上修改使用。</p>
<p>（5）要根据业务规则对数据库完整性进行细致的测试，以尽早排除隐含的完整性约束间的冲突和对性能的影响。</p>
<p>（6）要有专职的数据库设计小组，自始至终负责数据库的分析、设计、测试、实施及早期维护。数据库设计人员不仅负责基于DBMS的数据库完整性约束的设计实现，还要负责对应用软件实现的数据库完整性约束进行审核。</p>
<p>（7）应采用合适的CASE工具来降低数据库设计各阶段的工作量。好的CASE工具能够支持整个数据库的生命周期，这将使数据库设计人员的工作效率得到很大提高，同时也容易与用户沟通。</p>
<h5 id="数据库完整性的作用"><a href="#数据库完整性的作用" class="headerlink" title="数据库完整性的作用"></a>数据库完整性的作用</h5><p>数据库完整性对于数据库应用系统非常关键，其作用主要体现在以下几个方面。</p>
<p>（1）数据库完整性约束能够防止合法用户使用数据库时向数据库中添加不合语义的数据。</p>
<p>（2）利用基于DBMS的完整性控制机制来实现业务规则，易于定义，容易理解，而且可以降低应用程序的复杂性，提高应用程序的运行效率。同时，基于DBMS的完整性控制机制是集中管理的，因此比应用程序更容易实现数据库的完整性。</p>
<p>（3）合理的数据库完整性设计，能够同时兼顾数据库的完整性和系统的效能。例如装载大量数据时，只要在装载之前临时使基于DBMS的数据库完整性约束失效，此后再使其生效，就能保证既不影响数据装载的效率又能保证数据库的完整性。</p>
<p>（4）在应用软件的功能测试中，完善的数据库完整性有助于尽早发现应用软件的错误。</p>
<p>（5）数据库完整性约束可分为6类：列级静态约束、元组级静态约束、关系级静态约束、列级动态约束、元组级动态约束和关系级动态约束。动态约束通常由应用软件来实现。不同DBMS支持的数据库完整性基本相同，Oracle支持的基于DBMS的完整性约束如表12-1所示。</p>
<details><summary>表12-1　Oracle支持的基于DBMS的完整性约束</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904092311.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904092311.png';" /></details>

<h5 id="数据库完整性设计示例"><a href="#数据库完整性设计示例" class="headerlink" title="数据库完整性设计示例"></a>数据库完整性设计示例</h5><p>一个好的数据库完整性设计，首先需要在需求分析阶段确定要通过数据库完整性约束实现的业务规则。然后在充分了解特定DBMS提供的完整性控制机制的基础上，依据整个系统的体系结构和性能要求，遵照数据库设计方法和应用软件设计方法，合理选择每个业务规则的实现方式。最后，认真测试，排除隐含的约束冲突和性能问题。基于DBMS的数据库完整性设计大体分为以下几个阶段。</p>
<p>1）需求分析阶段</p>
<p>经过系统分析员、数据库分析员和用户的共同努力，确定系统模型中应该包含的对象，如人事及工资管理系统中的部门、员工和经理等，以及各种业务规则。</p>
<p>在完成寻找业务规则的工作之后，确定要作为数据库完整性的业务规则，并对业务规则进行分类。其中作为数据库模式一部分的完整性设计按下面的过程进行，而由应用软件来实现的数据库完整性设计将按照软件工程的方法进行。</p>
<p>2）概念结构设计阶段</p>
<p>概念结构设计阶段是将依据需求分析的结果转换成一个独立于具体DBMS的概念模型，即实体关系图（Entity-Relationship Diagram, ERD）。在概念结构设计阶段就要开始数据库完整性设计的实质阶段，因为此阶段的实体关系将在逻辑结构设计阶段转化为实体完整性约束和参照完整性约束，到逻辑结构设计阶段将完成设计的主要工作。</p>
<p>3）逻辑结构设计阶段</p>
<p>此阶段就是将概念结构转换为某个DBMS所支持的数据模型，并对其进行优化，包括对关系模型的规范化。此时，依据DBMS提供的完整性约束机制，对尚未加入逻辑结构中的完整性约束列表，逐条选择合适的方式加以实现。</p>
<p>在逻辑结构设计阶段结束时，作为数据库模式一部分的完整性设计也就基本完成了。每种业务规则都可能有好几种实现方式，应该选择对数据库性能影响最小的一种，有时需通过实际测试来决定。</p>
<h4 id="案例：电子商务系统的安全性设计"><a href="#案例：电子商务系统的安全性设计" class="headerlink" title="案例：电子商务系统的安全性设计"></a>案例：电子商务系统的安全性设计</h4><p>本节以一个具体的电子商务系统——高性能的RADIUS，来阐明电子商务系统的安全设计的基本原理和设计方法。</p>
<h5 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h5><p>AAA（Authentication Authorization and Accounting，验证、授权和审记）是运行于宽带网络接入服务器上的客户端程序。AAA提供了一个用来对验证、授权和审记三种安全功能进行配置的一致的框架，实际上是对网络安全的一种管理。这里的网络安全主要指访问控制，包括哪些用户可以访问网络服务器？如何对正在使用网络资源的用户进行记账？下面简单介绍验证、授权和记账的作用。</p>
<p>（1）验证（Authentication）：验证用户是否可以获得访问权，认证信息包括用户名、用户密码和认证结果等。</p>
<p>（2）授权（Authorization）：授权用户可以使用哪些服务，授权包括服务类型及服务相关信息等。</p>
<p>（3）审记（Accounting）：记录用户使用网络资源的情况，用户IP地址、MAC地址掩码等。</p>
<p>RADIUS服务器负责接收用户的连接请求，完成验证并把用户所需的配置信息返回给BAS建立连接，从而可以获得访问其他网络的权限时，BAS就起到了认证用户的作用。BAS负责把用户之间的验证信息传递通过密钥的参与来完成。用户的密码加密以后才能在网上传递，以避免用户的密码在不安全的网络上被窃取。</p>
<p>例如，用户A请求得到某些服务（如PPP、Telnet和Rlogin等），但必须通过BAS，由BAS依据某种顺序与所连接服务器通信从而进行验证。用户A通过拨号进入BAS，然后BAS按配置好的验证方式（如PPP、PAP和CHAP等）要求用户A输入用户名和密码等信息。用户A终端出现提示，用户按提示输入。通过与BAS的连接，BAS得到这些信息。而后BAS把这些信息传递给响应验证或记账的服务器，并根据服务器的响应来决定用户是否可以获得他所请求的服务。</p>
<p>一个网络允许外部用户通过宽带网对其进行访问，这样用户在地理上可以分散。大量分散用户可以通过DSL Modem等从不同的地方对这个网络进行随机的访问，用户可以把自己的信息传递给这个网络，也可以从这个网络得到自己想要的信息。由于存在内外的双向数据流动，网络安全就成为很重要的问题，因此对信息进行有效管理是必要的。管理的内容包括用户是否可以获得访问权、用户可以允许使用哪些服务，以及如何对使用网络资源的用户进行计费。AAA很好地完成了这3项任务。</p>
<h5 id="软件架构设计"><a href="#软件架构设计" class="headerlink" title="软件架构设计"></a>软件架构设计</h5><p>RADIUS软件主要应用于宽带业务运营的支撑管理，是一个需要可靠运行且高安全级别的软件支撑系统。RADIUS软件的设计还需要考虑一个重要的问题，即系统高性能与可扩展性。</p>
<p>电信数据业务的开展随着我国宽带业务的开展，在宽带接入方式、宽带业务管理等诸多方面均会发生变化，以适应市场的发展。业务的发展对RADIUS软件架构的设计就是重中之重了，其设计将会直接影响系统可持续建设的质量与成本。通过深入分析，高性能的RADIUS软件架构核心如图12-12所示。</p>
<details><summary>图12-12　RADIUS软件架构核心逻辑性</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904092916.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904092916.png';" /></details>

<p>RADIUS软件架构分为三个层面：协议逻辑层、业务逻辑层和数据逻辑层。</p>
<p>协议逻辑层主要实现RFC框架中的内容，处理网络通信协议的建立、通信和停止方面的工作。在软件功能上，这个部分主要相当于一个转发引擎，起到分发处理的内容分发到不同的协议处理过程中，这一层的功能起到了协议与业务处理的分层处理的作用。</p>
<p>业务逻辑层的设计是RADIUS软件架构设计的核心部分，架构设计的好坏将直接关系到应用过程中能否适应RADIUS协议扩展部分的实现，更重要的是会直接影响到用户单位的业务能否顺利开展。协议处理进程主要是对转发引擎发来的包进行初步分析，并根据包的内容进一步分发到不同的业务逻辑处理进程。协议处理进程可以根据项目的情况，配置不同的协议进程数，提高包转发与处理的速度。业务逻辑进程分为认证、计费和授权三种类型，不同的业务逻辑进程可以接收不同协议进程之间的信息并进行处理。转发进程与协议进程之间采用共享内存的方法，实现进程之间的通信。协议进程与业务逻辑处理进程之间采用进程加线程的实现方法，这样实现的好处在于不需要对业务处理线程进行应用软件层面的管理，而由UNIX系统进行管理，进一步提高应用系统处理的效率与质量。</p>
<p>数据逻辑层需要对来自业务逻辑处理线程统一管理与处理数据库代理池的数据，由数据库代理池统一连接数据库，以减少对数据库系统的压力。同时减小了系统对数据库的依赖性，增强了系统适应数据库系统的能力。</p>
<p>RADIUS软件分层架构的实现，一是对软件风险进行了深入的分析，并且在软件实现的过程中得到更多的体现；二是可以构建一个或多个重用的构件单元，同时也可以继承原来的成果。BAS和RADIUS之间验证信息的传递是通过密钥的参与来完成的。从原来的窄带拨号上网到现在的宽带接入、无线接入，在信息加密方面从传统的MD5、PAP和CHAP方式增加了EAP-tls、P-ttls和EAP-sim等多种格式。基于分层架构的协议处理进程有自然的灵活性，可快速适应RFC指南中增加的内容。</p>
<p>RADIUS的功能，一是实际处理大量用户并发的能力，二是软件架构的可扩展性。负载均衡是提高RADIUS软件性能的有效方法，它主要完成以下任务。</p>
<p>（1）解决网络拥塞问题，就近提供服务，实现地理位置无关性。</p>
<p>（2）为用户提供更好的访问质量。</p>
<p>（3）提高服务器响应速度。</p>
<p>（4）提高服务器及其他资源的利用效率。</p>
<p>（5）避免了网络关键部位出现单点失效。</p>
<p>当同时在线的宽带用户量巨大时，BAS发送给后台RADIUS的用户数据更新包的数量会急剧增加，RADIUS服务器的处理能力就成为性能瓶颈。当包的数量大于RADIUS服务器的处理能力时，就会出现丢包，造成用户数据的丢失或不完整。</p>
<p>通过代理转发的方式，把从BAS发送过来的数据包平均转发到其他RADIUS服务器中进行处理，实现RADIUS服务器之间的负载均衡。</p>
<p>RADIUS高性能还体现在自我管理的功能，该功能包括UNIX守护管理监控和进程管理监控。在有故障时，服务进程能内部调度进程，以协调进程的工作情况。同时对RADIUS报文进行SNMP的代理管理，向综合网络管理平台实时发送信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch11-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch11-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch11-信息安全技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:20" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:20+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-15 19:01:58" itemprop="dateModified" datetime="2021-10-15T19:01:58+08:00">2021-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="信息安全技术"><a href="#信息安全技术" class="headerlink" title="信息安全技术"></a>信息安全技术</h2><h3 id="信息安全关键技术"><a href="#信息安全关键技术" class="headerlink" title="信息安全关键技术"></a>信息安全关键技术</h3><h4 id="加密和解密技术"><a href="#加密和解密技术" class="headerlink" title="加密和解密技术"></a>加密和解密技术</h4><p>计算机网络的广泛应用，产生了大量的电子数据，这些电子数据需要传输到网络的许多地方，并存储起来。对于这些数据，有意的计算机犯罪和无意的数据破坏成为最大的威胁。原则上来说，对电子数据的攻击有两种形式：一种称为 $\color{red}{\text{被动攻击}}$ ，就是非法地 $\color{green}{\text{从传输信道上截取信息}}$ ，或 $\color{green}{\text{从存储载体上偷窃}}$ 、 $\color{green}{\text{复制信息}}$ 。另一种称为 $\color{red}{\text{主动进攻}}$ ，就是对传输或存储的数据进行恶意的 $\color{green}{\text{删除}}$ 、 $\color{green}{\text{篡改}}$ 等。实践证明，密码技术是防止数据攻击的一种有效而经济的方法。</p>
<p>我们把消息的发送者称为信源；消息的目的地称为信宿；没有加密的消息称为明文；加密后的消息称为密文；用来传输消息的通道称为信道。通信时，明文M通过变换E得到密文C，即C＝E（u, v, …，W; m）。这个过程称为加密，参数u, v, …, w称为密钥。这里所说的变换E，就是加密算法。从密文C恢复到明文M，这个过程称为解密。解密算法D是加密算法E的逆运算。</p>
<p>加密密钥与解密密钥相同，或者加密密钥与解密密钥可以简单相互推导的密码体制称为对称密码体制。现代密码学修正了密钥的对称性，加密、解密密钥是不同的，也是不能（在有效的时间内）相互推导的，称为非对称密码体制。</p>
<h5 id="对称密钥密码体制及典型算法"><a href="#对称密钥密码体制及典型算法" class="headerlink" title="对称密钥密码体制及典型算法"></a>对称密钥密码体制及典型算法</h5><p>对称算法（Symmetric Algorithm），有时又称为传统密码算法，在大多数对称算法中，加密密钥和解密密钥是相同的，所以也称秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。</p>
<p>对称加密的优点在于算法实现的效率高、速度快。对称加密的缺点在于密钥的管理过于复杂。常用的对称加密算法有DES、IDEA等。</p>
<p>1）DES算法简介</p>
<p>DES （Data Encryption Standard，数据加密标准）是由IBM公司研制的一种加密算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准。二十年来，它一直活跃在国际保密通信的舞台上，扮演了十分重要的角色。</p>
<p>DES是一个分组加密算法，它以64位为分组对数据加密；同时DES也是一个对称算法。它的密匙长度是56位（因为每个第8位都用作奇偶校验），密匙可以是任意56位的数，而且可以任意时候改变。其保密性依赖于密钥。</p>
<p>DES算法分如下3个步骤进行。</p>
<p>（1）对给定的64位的明文x，通过一个初始置换函数IP来排列x，从而构造出长为64位的串X0，记X0为IP（X）＝L0R0，L0表示X0的前32位，R0表示X0的后32位。</p>
<p>（2）计算16次迭代，设前i－1次迭代结果为Xi－1＝Li－1Ri－1，则第i轮迭代运算为：</p>
<p>Li＝Ri－1　　Ri＝Li－1⊕f（Ri－1, ki）</p>
<p>其中，Li－1表示Xi－1的前32位，Ri－1表示Xi－1的后32位，⊕表示两位串的“异或”运算，f主要是由一个称为S盒的置换构成。Ki是一些由初始的56位经过密钥编排函数产生的48位长的块。</p>
<p>（3）对位串L16R16作逆置换IP-1得密文y，y＝IP-1（R16L16），置换IP-1是IP的逆置换。</p>
<p>DES算法的示意图如图11-1所示。</p>
<details><summary>图11-1　DES算法示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904083750.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904083750.png';" /></details>

<p>2）IDEA算法简介</p>
<p>国际数据加密算法（International Data Encryption Algorithm, IDEA）是1992年来学嘉等人设计的算法。该算法的前身是1990年公布的推荐加密标准（Proposed Encryption Standard, PES）算法。</p>
<p>IDEA分组长度为64b，密钥长度为128b。其使用的运算非常简单，只需要异或，模216加和模（216＋1）乘，这些算法都很容易使用硬件或者软件实现（而DES算法便于用硬件实现，难以用软件实现），所有运算都是使用基于16b数运行，很容易在现在的16b、32b、64b CPU上实现。由于这一特性，使用软件实现的IDEA算法的运算速度比DES算法要快。由于IDEA算法使用的密钥长度为128b，远远大于DES算法的56b，对于128b密钥来说，使用穷举法攻击的方法是不现实的。</p>
<h5 id="不对称密码加密算法"><a href="#不对称密码加密算法" class="headerlink" title="不对称密码加密算法"></a>不对称密码加密算法</h5><p>不对称密码体制又称为双密钥和公钥密码体制，是于1976年由Diffie和Hellman提出的。与对称密码体制相比，非对称密码体制有两个不同的密钥，其中一个密钥称为私钥，该密钥被秘密保存；另一个密钥公开，不需要保密。</p>
<p>公钥密码系统的工作方式为：任何人都可以将自己加密的公钥公布在网络或其他可以公开的地方。其他人欲传送信息给该接收方时，可使用该接收方所公布的公钥将信息加密之后传送给接收方。接收方收到加密后的信息时，就可以利用拥有的与此公钥相对应的私钥，将该加密信息解出来。所以公开密钥密码系统的通信双方，不需要事先通过安全秘密管道交换密钥，即可进行通信。</p>
<p>RSA密码体制是一个常用的非对称的密码体制，它是一个既能用于数据加密也能用于数字签名的算法。</p>
<p>RSA的安全性依赖于大素数分解。公钥和私钥都是两个大素数（大于100个十进制位）的函数。据猜测，从一个密钥和密文推断出明文的难度等同于分解两个大素数的积。</p>
<p>1）密钥对的产生</p>
<p>（1）选择两个大素数，p和q。</p>
<p>（2）计算n＝p*q。</p>
<p>（3）随机选择加密密钥e，e必须满足以下条件：</p>
<p>GCD（e, φ（N））＝1</p>
<p>其中，φ为Euler’s Function，φ（N）为小于N、且与N互质的整数的个数。在此，φ（N）＝（p－1）<em>（q－1）（也有些做法是取LCM（（p－1）</em>（q－1）））。</p>
<p>（4）利用Euclid算法计算解密密钥d，满足d＝e-1modφ（N）。</p>
<p>产生出加密公钥e、N与解密密钥d之后，使用者将e及N公开，就可以使用它们来执行加解密的工作了。</p>
<p>2）加密程序</p>
<p>使用者将其欲加密的信息M，在取得对方的公钥e及N之后，执行模（mod，即同余的运算，C＝MmodN，C等于M除以N的余数）指数运算，就可获得密文C。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904083931.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904083931.png';" /></details>

<p>3）解密程序</p>
<p>对方在收到密文C后，以自己的私钥执行下面的解密程序，解密时作如下计算：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904083947.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904083947.png';" /></details>

<p>即可获得明文M。</p>
<p>RSA可用于数字签名，方案是用（b）签名，用（a）验证。具体操作时考虑到安全性和M信息量较大等因素，一般是先作HASH运算。</p>
<p>RSA的安全性依赖于大数分解，由于进行的都是大数计算，使得RSA最快的情况也是DES百分之一。无论是软件还是硬件实现，速度慢一直是RSA的缺陷，因此一般来说，RSA只用于少量数据加密。</p>
<h4 id="散列函数与数字签名"><a href="#散列函数与数字签名" class="headerlink" title="散列函数与数字签名"></a>散列函数与数字签名</h4><h5 id="MD5散列算法"><a href="#MD5散列算法" class="headerlink" title="MD5散列算法"></a>MD5散列算法</h5><p>散列函数是一种公开的数学函数。散列函数运算的输入信息叫做报文，运算后所得到的结果叫做散列码或者叫做消息摘要。散列函数h＝H（M）具有如下一些特点。</p>
<p>（1）不同内容的报文具有不同的散列码，给定M，要找到另一消息M，使H（M）＝H（M′）很难。</p>
<p>（2）散列函数是单向的，给出M，容易计算出h。给定h，根据h＝H（M）反推M却很难。</p>
<p>（3）对于任何一个报文，无法预知它的散列码。</p>
<p>（4）散列码具有固定的长度，不管原始报文的长度如何，通过散列函数运算后的散列码都具有一样的长度。</p>
<p>由于散列函数具有这些特征，因此散列函数可以用来检测报文的可靠性。接收者对收到的报文用与发送者相同的散列函数进行运算，如果得到与发送者相同的散列码，则可以认为报文没有被篡改，否则报文就是不可信的。</p>
<p>常见的散列函数有MD5、SHA和HMAC等。</p>
<p>MD5（Message Digest 5）是一种非常著名的散列算法，已经成为国际标准。它是在MD4的基础上改进的算法，是具有更好的安全性能的散列算法。MD5散列算法对输入的任意长度消息产生128位（16字节）长度的散列值（或称消息摘要）。MD5算法包括以下4个步骤。</p>
<p>（1）附加填充位。首先对输入的报文进行填位补充，使填充后的数据长度模512后余448。如果数据长度正好模512余448，则需增加512个填充位，也就是说填充的个数为1～512位。填充位第一个位为1，其余全部为0。</p>
<p>（2）补足长度。将数据长度表示为二进制，如果长度超过64位，则截取其低64位；如果长度不足64位，则在其高位补0。将这个64位的报文长度补在经过填充的报文后面，使得最后的数据为512位的整数倍。</p>
<p>（3）初始化MD缓存器。MD5运算要用到一个128位的MD5缓存器，用来保存中间变量和最终结果。该缓存器又可看成是4个32位的寄存器A、B、C、D，初始化为：</p>
<p>A:01 23 45 67　B: 89 ab cd ef　C: fe dc ba 98　D: 76 54 32 10</p>
<p>（4）处理数据段。首先定义4个非线性函数F、G、H、I，对输入的报文运算以512位数据段为单位进行处理。对每一个数据段都要进行4轮的逻辑处理，在4轮中分别使用4个不同的函数F、G、H、I。每一轮以ABCD和当前的512位的块为输入，处理后送入ABCD（128位）。</p>
<h5 id="数字签名与数字水印"><a href="#数字签名与数字水印" class="headerlink" title="数字签名与数字水印"></a>数字签名与数字水印</h5><h6 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h6><p>数字签名可以解决否认、伪造、篡改及冒充等问题。具体要求：发送者事后不能否认发送的报文签名、接收者能够核实发送者发送的报文签名、接收者不能伪造发送者的报文签名、接收者不能对发送者的报文进行部分篡改、网络中的某一用户不能冒充另一用户作为发送者或接收者。凡是需要对用户的身份进行判断的情况都可以使用数字签名，例如加密信件、商务信函、订货购买系统、远程金融交易和自动模式处理等。</p>
<p>数字签名方案一般包括三个过程：系统的初始化过程、签名产生过程和签名验证过程。在签名产生的过程中，用户利用给定的算法对消息产生签名；在签名验证过程中，验证者利用公开验证方法对给定消息的签名进行验证，得出签名的有效性。</p>
<p>实现数字签名的方法有很多，目前采用得比较多的是非对称加密技术和对称加密技术。虽然这两种技术的实施步骤不尽相同，但大体的工作程序是一样的。用户首先可以下载或者购买数字签名软件，然后安装在个人计算机上。在产生密钥对后，软件自动向外界传送公开密钥。由于公共密钥的存储需要，所以需要建立一个鉴定中心（Certification Authority, CA）完成个人信息及其密钥的确定工作。用户在获取公开密钥时，首先向鉴定中心请求数字确认，鉴定中心确认用户身份后，发出数字确认，同时鉴定中心向数据库发送确认信息。然后用户使用私有密钥对所传信息签名，保证信息的完整性、真实性，也使发送方无法否认信息的发送，之后发向接收方；接收方接收到信息后，使用公开密钥确认数字签名，在使用这种技术时，签名者必须注意保护好私有密钥，因为它是公开密钥体系安全的重要基础。如果密钥丢失，应该立即报告鉴定中心取消认证，将其列入确认取消列表之中。其次，鉴定中心必须能够迅速确认用户的身份及其密钥的关系。一旦接收到用户请求，鉴定中心要立即认证信息的安全性并返回信息。</p>
<p>目前已经有大量的数字签名算法，如RSA、E1Gama1、Fiat-Shamir、美国的数字签名标准/算法（DSS/DSA）、椭圆曲线等多种。</p>
<h6 id="数字水印"><a href="#数字水印" class="headerlink" title="数字水印"></a>数字水印</h6><p>随着数字技术和因特网的发展，各种形式的多媒体数字作品（如图像、视频和音频等）纷纷以网络形式发表，其版权保护成为一个迫切需要解决的问题。数字水印（Digital Watermarking）是实现版权保护的有效办法，如今已成为多媒体信息安全研究领域的一个热点，也是信息隐藏技术研究领域的重要分支。该技术是通过在原始数据中嵌入秘密信息——水印（Watermark）来证实该数据的所有权。这种被嵌入的水印可以是一段文字、标识或序列号等，而且这种水印通常是不可见或不可察的，它与原始数据（如图像、音频和视频数据）紧密结合并隐藏其中，在经过一些不破坏源数据使用价值或商用价值的操作后仍能保存下来。数字水印技术必须具有较强的鲁棒性、安全性和透明性。</p>
<p>（1）典型数字水印系统模型。</p>
<p>图11-2为水印信号嵌入模型，其功能是将水印信号加入原始数据中；图11-3为水印信号检测模型，用来判断某一数据中是否含有指定的水印信号。</p>
<details><summary>图11-3　水印信号检测模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904084113.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904084113.png';" /></details>

<h6 id="数字水印主要应用领域。"><a href="#数字水印主要应用领域。" class="headerlink" title="数字水印主要应用领域。"></a>数字水印主要应用领域。</h6><p>①版权保护。即数字作品的所有者可用密钥产生一个水印，并将其嵌入原始数据，然后公开发布他的水印版本作品。当该作品被盗版或出现版权纠纷时，所有者即可利用图11-2或图11-3的方法从盗版作品或水印版作品中获取水印信号作为依据，从而保护所有者的权益。</p>
<p>②加指纹。为避免未经授权的复制制作和发行，出品人可以将不同用户的ID或序列号作为不同的水印（指纹）嵌入作品的合法备份中。一旦发现未经授权的备份，就可以根据此备份所恢复出的指纹来确定它的来源。</p>
<p>③标题与注释。即将作品的标题、注释等内容（如一张照片的拍摄时间和地点等）以水印形式嵌入该作品中，这种隐式注释不需要额外的带宽，且不易丢失。</p>
<p>④篡改提示。当数字作品被用于法庭、医学、新闻及商业时，常需确定它们的内容是否被修改、伪造或特殊处理过。为实现该目的，通常可将原始图像分成多个独立块，再将每个块加入不同的水印。同时可通过检测每个数据块中的水印信号，来确定作品的完整性。与其他水印不同的是，这类水印必须是脆弱的，并且检测水印信号时，不需要原始数据。</p>
<p>⑤使用控制。这种应用的一个典型例子是DVD防复制系统，即将水印信息加入DVD数据中，这样DVD播放机即可通过检测DVD数据中的水印信息而判断其合法性和可复制性。从而保护制造商的商业利益。</p>
<p>典型数字水印算法有空域算法、变换域算法、压缩域算法、NEC算法和生理模型算法等。</p>
<h4 id="密钥分配中心与公钥基础设施"><a href="#密钥分配中心与公钥基础设施" class="headerlink" title="密钥分配中心与公钥基础设施"></a>密钥分配中心与公钥基础设施</h4><p>在现代密码系统中，算法本身的保密已经不重要了，对于数据的保密在很大程度上、甚至完全依赖于对密钥的保密。只要密钥能够保密，即使加密算法公开，甚至加密设备丢失，也不会对加密系统的坚固性和正常使用产生多大影响。相反，如果密钥丢失，则不但非法用户可以窃取机密数据，而且合法用户面对密文却如读天书，无法提取有效的信息。因此，在密码系统中，如何高效地分配密钥、安全地管理密钥对保证数据安全来说至关重要。</p>
<h5 id="密钥分配中心"><a href="#密钥分配中心" class="headerlink" title="密钥分配中心"></a>密钥分配中心</h5><p>一个信息系统中任意两个用户之间都可以自己协商来选择不同的密钥，显然，对于总共有N个用户的系统，每个用户都要保存N×（N－1）个密钥。在用户数量较少时，这样来分配密钥还是比较简单、易用的，但是一旦用户数量多起来，系统中要保存的密钥会急剧增多，让每个用户自己高效、安全地管理数量庞大的密钥实际上是不可能的。</p>
<p>有一种非常有效的密钥自动分配方案是密钥分配中心（Key Distribution Center, KDC）技术。</p>
<p>在KDC方案中，每一个用户都只保存自己的私钥SK和KDC的公钥PKKDC，而在通信时再从KDC获得其他用户的公钥或者仅仅在某一次通信中可以使用的对称密钥加密算法的临时密钥K。</p>
<p>假设A和B都是KDC的注册用户，他们分别拥有私钥SKA、SKB。设用对称密钥来加密他们之间的这次对话，那么密钥的分配过程如下。</p>
<p>首先，A向密钥分配中心发送SKA（A, B），表示自己想与B会话。该请求用自己的私钥SKA加密，KDC收到A的请求，用A的公钥来验证请求是由A发出的后，根据某种算法来生成供A、B之间会话使用的对称密钥K。KDC向A返回PKA（K, PKB（A, K）），该应答是用A的公钥加密的，只有A能解读。A用自己的私钥解密应答，得到密钥K，并将PKB（A, K）发送给B，表明A欲与B进行会话。B用自己的私钥解密得到会话密钥K。</p>
<p>至此，完成一次密钥分配。</p>
<p>2．数字证书和公开密钥基础设施</p>
<p>数字签名和公钥加密都是基于不对称加密技术的，存在的问题有：如何保证公开密钥的持有者是真实的；大规模信息系统环境下公开密钥如何产生、分发和管理。</p>
<p>要解决以上问题，就要用到数字证书和PKI。</p>
<p>1）数字证书</p>
<p>数字证书提供了一个在公钥和拥有相应私钥的实体之间建立关系的机制。目前最常用的数字证书格式是由国际标准ITU-T X.509 V3版本定义的。</p>
<p>数字证书中采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己保存私钥，用它进行解密和签名；同时设定一个公钥，并由本人公开，为一组用户所共享，用于加密和验证签名。</p>
<p>数字证书是用户在系统中作为确认身份的证据。在通信的各个环节中，参与通信的各方通过验证对方数字证书，从而确认对方身份的真实性和有效性，从而解决相互间的信任问题。</p>
<p>数字证书的内容一般包括：唯一标识证书所有者的名称、唯一标识证书签发者的名称、证书所有者的公开密钥、证书签发者的数字签名、证书的有效期及证书的序列号等。</p>
<p>2）公钥基础设施</p>
<p>PKI（Public Key Infrastructure，公钥基础设施）的目标是向广大的信息系统用户和应用程序提供公开密钥的管理服务。</p>
<p>PKI的结构模型中有三类实体：管理实体、端实体和证书库。管理实体是PKI的核心，是服务的提供者；端实体是PKI的用户，是服务的使用者；证书库是一个分布式的数据库，用于证书和CRL的存放和检索。</p>
<p>CA和RA是两种管理实体。CA是框架中唯一能够发布和撤销证书的实体，维护证书的生命周期；RA负责处理用户请求，在验证了请求的有效性后，代替用户向CA提交。RA可以单独实现，也可以合并在CA中实现。作为管理实体，CA和RA以证书方式向端实体提供公开密钥的分发服务。</p>
<p>持有者和验证者是两种端实体。持有者是证书的拥有者，是证书所声明的事实上的主体。持有者向管理实体申请并获得证书，也可以在需要时请求撤销或更新证书。持有者使用证书声明自己的身份，从而获得相应的权力。验证者确认持有者所提供的证书的有效性和对方是否为该证书的真正拥有者，只有在成功鉴别之后才可与对方进行更进一步的交互。</p>
<p>由于证书库的存取对象为证书和CRL，其完整性由数字签名来保证，因此不需要额外的安全机制。</p>
<p>不同的实体间通过PKI操作完成证书的请求、确认、发布、撤销、更新和获取等过程。PKI操作分为存取操作和管理操作两类。其中，存取操作包括管理实体或端实体把证书和CRL存放到证书库、从证书库中读取证书和CRL；管理操作则是管理实体与端实体之间或管理实体与管理实体之间的交互，是为了完成证书的各项管理任务和建立证书链。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>访问控制是通过某种途径限制和允许对资源的访问能力以及范围的一种方法。它是针对越权使用系统资源的保护措施，通过限制对文件等资源的访问，防止非法用户的侵入或者合法用户的不当操作造成的破坏，从而保证信息系统资源的合法使用。</p>
<p>访问控制技术可以通过对计算机系统的控制，自动、有效地防止对系统资源进行非法访问或者不当的使用，检测出一部分安全侵害，同时可以支持应用和数据的安全需求。</p>
<p>访问控制技术并不能取代身份认证，它是建立在身份认证的基础之上的。</p>
<h5 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h5><p>在网络通信中，需要确定通信双方的身份，这就需要身份认证技术。在有安全需求的应用系统中，识别用户的身份是系统的基本要求，认证是安全系统中不可缺少的一部分。识别用户的身份有两种不同的形式：一种是身份认证，要求对用户所有的权限角色或自身的身份进行认证；一种是身份鉴定，要求对使用者本身的身份进行检查。</p>
<p>认证的方法多种多样，其安全强度也不相同。具体方法可归结为3大类：根据用户知道什么、拥有什么、是什么来进行认证。用户知道什么，一般就是口令；用户拥有什么，通常为私钥或令牌：用户是什么，这是一种基于生物识别技术的认证。</p>
<p>1）用户名和口令认证</p>
<p>简单认证方式主要是通过一个客户与服务器共知的口令（或与口令相关的数据，如散列、密文等）进行验证。根据处理形式的不同，有3种简单认证的方式：验证数据的明文传送、利用单向散列函数处理验证数据、利用单向散列函数和随机数处理验证数据，这3种方式的安全强度依次增加，处理复杂度也依次增高。</p>
<p>2）使用令牌认证</p>
<p>在使用令牌进行认证的系统中，进行验证的密钥存储于令牌中。对密钥的访问用口令进行控制。令牌是一个像IC卡一样可以加密存储并运行相应加密算法的设备，这种简单认证可以快速、方便地实现用户身份认证，但是认证的安全强度不高。通过令牌可以完成对用户必须拥有某物的验证。令牌的实现分为质询响应令牌和时间戳令牌，其中使用较多的是时间戳令牌。</p>
<p>质询响应令牌的工作原理是：在进行身份认证时，认证服务器首先发送一个随机数到客户机的登录程序。用户将这个随机数读出，输入令牌，并输入令牌的PIN码（实际就是口令），得以访问令牌。令牌对输入的随机数用存储的私钥进行签名，并把结果用Base64编码输出。用户把令牌的输出填入客户机的验证程序中，数据传输到认证的服务器端，在服务器端将使用用户的公钥对签名进行验证，以确定是否允许客户通过登录认证。在该方案中，由于使用数字签名进行登录认证，系统的安全强度大大增加：私钥采用令牌存储的方式解决了私钥自身的安全问题。令牌是一个可移动的设备，可以随身携带，而且令牌有PIN码保护，对令牌的非法访问超过一定的次数后，令牌会死锁。</p>
<p>时间戳令牌解决了质询响应令牌中随机数的问题，时间戳令牌利用时间代替上面的随机数。时间戳令牌每时每刻都在工作，一般每分钟产生一个登录数据，用户只需输入PIN码。登录数据被传送到认证的服务器端，服务器利用当前时间对登录数据进行验证，完成用户的登录过程。使用时间戳令牌需要重点考虑时间同步问题，由于令牌的时钟和认证服务器的时钟不同步，产生的验证码并不会通过验证。解决方法是在验证服务器上进行多次试探验证，在一个时间范围内试探，如果成功则在服务器上存储令牌时钟与服务器时钟的偏移量，以便下次登录时使用。目前，在安全性要求较高的认证系统中，多是采用这种方案。</p>
<p>采用PIN码与令牌实现了双因素验证，根据用户知道什么、拥有什么进行认证，也提供了一个保密认证密钥的方法。但是实现双因素验证需要用户输入数据，给用户的操作增加了麻烦。</p>
<p>3）生物识别与三因素认证</p>
<p>现在兴起了一种基于生物识别技术的认证，主要是根据认证者的图像、指纹、气味和声音等作为认证数据。基于用户知道什么（口令）、拥有什么（私钥和令牌）、是什么（生物特征）的3因素认证是目前强认证中使用最多的手段。在安全性要求较高的系统中，认证必须能对用户进行身份鉴定。要将用户知道什么、拥有什么、是什么结合起来，同时对认证用的密钥进行保护。</p>
<h5 id="访问控制技术"><a href="#访问控制技术" class="headerlink" title="访问控制技术"></a>访问控制技术</h5><p>根据控制手段和具体目的的不同，通常将访问控制技术划分为如下几个方面：入网访问控制、网络权限控制、目录级安全控制、属性安全控制以及网络服务器的安全控制等。</p>
<p>入网访问控制为网络访问提供了第一层访问控制。它控制哪些用户能够登录到服务器并获取网络资源，控制准许用户入网的时间和准许入网的工作站等。基于用户名和口令的用户的入网访问控制可分为三个步骤：用户名的识别与验证、用户口令的识别与验证、用户账号的默认限制检查。三个步骤中只要任何一个未通过校验，该用户便不能进入该网络。可以说，对网络用户的用户名和口令进行验证是防止非法访问的第一道防线。但由于用户名口令验证方式容易被攻破，目前很多网络都开始采用基于数字证书的验证方式。</p>
<p>网络权限控制是针对网络非法操作所提出的一种安全保护措施。能够访问网络的合法用户被划分为不同的用户组，用户和用户组被赋予一定的权限。访问控制机制明确了用户和用户组可以访问哪些目录、子目录、文件和其他资源；以及指定用户对这些文件、目录、设备能够执行哪些操作。它有两种实现方式，“受托者指派”和“继承权限屏蔽”。“受托者指派”控制用户和用户组如何使用网络服务器的目录、文件和设备；“继承权限屏蔽”相当于一个过滤器，可以限制子目录从父目录那里继承哪些权限。可以根据访问权限将用户分为以下几类：特殊用户（即系统管理员）；一般用户，系统管理员根据他们的实际需要为他们分配操作权限；审计用户，负责网络的安全控制与资源使用情况的审计。用户对网络资源的访问权限可以用访问控制表来描述。</p>
<p>目录级安全控制是针对用户设置的访问控制，控制用户对目录、文件、设备的访问。用户在目录一级指定的权限对所有文件和子目录有效，用户还可以进一步指定对目录下的子目录和文件的权限。对目录和文件的访问权限一般有8种：系统管理员权限、读权限、写权限、创建权限、删除权限、修改权限、文件查找权限和访问控制权限。8种访问权限的有效组合可以让用户有效地完成工作，同时又能有效地控制用户对服务器资源的访问，从而加强了网络和服务器的安全性。</p>
<p>属性安全控制在权限安全控制的基础上提供更进一步的安全性。当用户访问文件、目录和网络设备时，网络系统管理员应该给出文件、目录的访问属性，网络上的资源都应预先标出安全属性，用户对网络资源的访问权限对应一张访问控制表，用以表明用户对网络资源的访问能力。属性设置可以覆盖已经指定的任何受托者指派和有效权限。属性能够控制以下几个方面的权限：向某个文件写数据、复制文件、删除目录或文件、查看目录和文件、执行文件、隐含文件、共享、系统属性等，避免发生非法访问的现象。</p>
<p>因为网络允许用户在服务器控制台上执行一系列操作，所以用户使用控制台就可以执行装载和卸载模块、安装和删除软件等操作，这就需要网络服务器有安全控制。网络服务器的安全控制包括可以设置口令锁定服务器控制台，从而防止非法用户修改、删除重要信息或破坏数据。具体包括设定服务器登录时间限制、非法访问者检测和关闭的时间间隔等。</p>
<h4 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h4><h5 id="IPSec协议简述"><a href="#IPSec协议简述" class="headerlink" title="IPSec协议简述"></a>IPSec协议简述</h5><p>为了满足Internet的安全需求，因特网工程任务组（ $\color{green}{\text{IETF}}$ ）于1998年11月颁布IP层安全标准IP SECURITY协议（IPSec），IPSec在IP层上对数据包进行高强度的安全处理提供数据源验证、无连接数据完整性、数据机密性、抗重播和有限通信流机密性等安全服务。</p>
<p>1）IPSec协议工作原理</p>
<p>IPSec通过使用两种通信安全协议来为数据报提供高质量的安全性：认证头（AH）协议和封装安全载荷（ESP）协议，以及像Internet密钥交换（Internet Key Exchange, IKE）协议这样的密钥管理过程和协议。其中AH协议提供数据源认证、无连接的完整性以及一个可选的抗重放服务。ESP协议提供数据保密性、有限的数据流保密性、数据源验证、无连接的完整性以及抗重放服务。IPSec允许系统或网络用户控制安全服务提供的粒度。IPSec的安全服务是由通信双方建立的安全关联（Security Association, SA）来提供的，SA为通信提供了安全协议、模式、算法和应用于单向IP流的密钥等安全信息。每一个IPSec节点包含一个局部的安全策略库（Security Polioy Database, SPD），系统在处理输入、输出IP流时必须参考该策略库，并根据从SPD中提取的策略对IP流进行不同的处理：拒绝、绕过、进行IPSec保护。如果策略决定IP流需要经过IPSec处理，则根据SPD与SAD的对应关系，找到相应的SA，并对IP包进行指定的IPSec处理。SA由一个三元组唯一地标识，该三元组包含一个安全参数索引（Security Parameter Index, SPI），一个用于输出处理SA的目的IP地址或者一个用于输入处理SA的源IP地址以及一个特定的协议（例如AH或者ESP）。SPI是为了唯一标识SA而生成的一个32位整数。它在AH和ESP头中传输，IPSec数据报的接收方易于识别SPI并利用它连同源或者目的IP地址和协议来搜索SAD，以确定与该数据报相关联的SA或者SA束。SA中所选用的安全协议、SA模式、SA的两端及安全协议内所要求的服务等具体地决定了怎样为通信流提供安全服务。但是，最终安全服务的具体实施是通过使用AH和ESP协议。</p>
<p>2）IPSec协议实现模式</p>
<p>IPSec协议既可用来保护一个完整的IP载荷，也可用来保护某个IP载荷的上层协议。这两方面第11章　信息安全技术</p>
<p>11.1　信息安全关键技术</p>
<p>11.1.1　加密和解密技术</p>
<p>计算机网络的广泛应用，产生了大量的电子数据，这些电子数据需要传输到网络的许多地方，并存储起来。对于这些数据，有意的计算机犯罪和无意的数据破坏成为最大的威胁。原则上来说，对电子数据的攻击有两种形式：一种称为被动攻击，就是非法地从传输信道上截取信息，或从存储载体上偷窃、复制信息。另一种称为主动进攻，就是对传输或存储的数据进行恶意的删除、篡改等。实践证明，密码技术是防止数据攻击的一种有效而经济的方法。</p>
<p>我们把消息的发送者称为信源；消息的目的地称为信宿；没有加密的消息称为明文；加密后的消息称为密文；用来传输消息的通道称为信道。通信时，明文M通过变换E得到密文C，即C＝E（u, v, …，W; m）。这个过程称为加密，参数u, v, …, w称为密钥。这里所说的变换E，就是加密算法。从密文C恢复到明文M，这个过程称为解密。解密算法D是加密算法E的逆运算。</p>
<p>加密密钥与解密密钥相同，或者加密密钥与解密密钥可以简单相互推导的密码体制称为对称密码体制。现代密码学修正了密钥的对称性，加密、解密密钥是不同的，也是不能（在有效的时间内）相互推导的，称为非对称密码体制。</p>
<p>1．对称密钥密码体制及典型算法</p>
<p>对称算法（Symmetric Algorithm），有时又称为传统密码算法，在大多数对称算法中，加密密钥和解密密钥是相同的，所以也称秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。</p>
<p>对称加密的优点在于算法实现的效率高、速度快。对称加密的缺点在于密钥的管理过于复杂。常用的对称加密算法有DES、IDEA等。</p>
<p>1）DES算法简介</p>
<p>DES （Data Encryption Standard，数据加密标准）是由IBM公司研制的一种加密算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准。二十年来，它一直活跃在国际保密通信的舞台上，扮演了十分重要的角色。</p>
<p>DES是一个分组加密算法，它以64位为分组对数据加密；同时DES也是一个对称算法。它的密匙长度是56位（因为每个第8位都用作奇偶校验），密匙可以是任意56位的数，而且可以任意时候改变。其保密性依赖于密钥。</p>
<p>DES算法分如下3个步骤进行。</p>
<p>（1）对给定的64位的明文x，通过一个初始置换函数IP来排列x，从而构造出长为64位的串X0，记X0为IP（X）＝L0R0，L0表示X0的前32位，R0表示X0的后32位。</p>
<p>（2）计算16次迭代，设前i－1次迭代结果为Xi－1＝Li－1Ri－1，则第i轮迭代运算为：</p>
<p>Li＝Ri－1　　Ri＝Li－1⊕f（Ri－1, ki）</p>
<p>其中，Li－1表示Xi－1的前32位，Ri－1表示Xi－1的后32位，⊕表示两位串的“异或”运算，f主要是由一个称为S盒的置换构成。Ki是一些由初始的56位经过密钥编排函数产生的48位长的块。</p>
<p>（3）对位串L16R16作逆置换IP-1得密文y，y＝IP-1（R16L16），置换IP-1是IP的逆置换。</p>
<p>DES算法的示意图如图11-1所示。</p>
<p>alt</p>
<p>图11-1　DES算法示意图</p>
<p>2）IDEA算法简介</p>
<p>国际数据加密算法（International Data Encryption Algorithm, IDEA）是1992年来学嘉等人设计的算法。该算法的前身是1990年公布的推荐加密标准（Proposed Encryption Standard, PES）算法。</p>
<p>IDEA分组长度为64b，密钥长度为128b。其使用的运算非常简单，只需要异或，模216加和模（216＋1）乘，这些算法都很容易使用硬件或者软件实现（而DES算法便于用硬件实现，难以用软件实现），所有运算都是使用基于16b数运行，很容易在现在的16b、32b、64b CPU上实现。由于这一特性，使用软件实现的IDEA算法的运算速度比DES算法要快。由于IDEA算法使用的密钥长度为128b，远远大于DES算法的56b，对于128b密钥来说，使用穷举法攻击的方法是不现实的。</p>
<p>2．不对称密码加密算法</p>
<p>不对称密码体制又称为双密钥和公钥密码体制，是于1976年由Diffie和Hellman提出的。与对称密码体制相比，非对称密码体制有两个不同的密钥，其中一个密钥称为私钥，该密钥被秘密保存；另一个密钥公开，不需要保密。</p>
<p>公钥密码系统的工作方式为：任何人都可以将自己加密的公钥公布在网络或其他可以公开的地方。其他人欲传送信息给该接收方时，可使用该接收方所公布的公钥将信息加密之后传送给接收方。接收方收到加密后的信息时，就可以利用拥有的与此公钥相对应的私钥，将该加密信息解出来。所以公开密钥密码系统的通信双方，不需要事先通过安全秘密管道交换密钥，即可进行通信。</p>
<p>RSA密码体制是一个常用的非对称的密码体制，它是一个既能用于数据加密也能用于数字签名的算法。</p>
<p>RSA的安全性依赖于大素数分解。公钥和私钥都是两个大素数（大于100个十进制位）的函数。据猜测，从一个密钥和密文推断出明文的难度等同于分解两个大素数的积。</p>
<p>1）密钥对的产生</p>
<p>（1）选择两个大素数，p和q。</p>
<p>（2）计算n＝p*q。</p>
<p>（3）随机选择加密密钥e，e必须满足以下条件：</p>
<p>GCD（e, φ（N））＝1</p>
<p>其中，φ为Euler’s Function，φ（N）为小于N、且与N互质的整数的个数。在此，φ（N）＝（p－1）<em>（q－1）（也有些做法是取LCM（（p－1）</em>（q－1）））。</p>
<p>（4）利用Euclid算法计算解密密钥d，满足d＝e-1modφ（N）。</p>
<p>产生出加密公钥e、N与解密密钥d之后，使用者将e及N公开，就可以使用它们来执行加解密的工作了。</p>
<p>2）加密程序</p>
<p>使用者将其欲加密的信息M，在取得对方的公钥e及N之后，执行模（mod，即同余的运算，C＝MmodN，C等于M除以N的余数）指数运算，就可获得密文C。</p>
<p>alt</p>
<p>然后通过网络传送至通信的对方。</p>
<p>3）解密程序</p>
<p>对方在收到密文C后，以自己的私钥执行下面的解密程序，解密时作如下计算：</p>
<p>alt</p>
<p>即可获得明文M。</p>
<p>RSA可用于数字签名，方案是用（b）签名，用（a）验证。具体操作时考虑到安全性和M信息量较大等因素，一般是先作HASH运算。</p>
<p>RSA的安全性依赖于大数分解，由于进行的都是大数计算，使得RSA最快的情况也是DES百分之一。无论是软件还是硬件实现，速度慢一直是RSA的缺陷，因此一般来说，RSA只用于少量数据加密。</p>
<p>11.1.2　散列函数与数字签名</p>
<p>1．MD5散列算法</p>
<p>散列函数是一种公开的数学函数。散列函数运算的输入信息叫做报文，运算后所得到的结果叫做散列码或者叫做消息摘要。散列函数h＝H（M）具有如下一些特点。</p>
<p>（1）不同内容的报文具有不同的散列码，给定M，要找到另一消息M，使H（M）＝H（M′）很难。</p>
<p>（2）散列函数是单向的，给出M，容易计算出h。给定h，根据h＝H（M）反推M却很难。</p>
<p>（3）对于任何一个报文，无法预知它的散列码。</p>
<p>（4）散列码具有固定的长度，不管原始报文的长度如何，通过散列函数运算后的散列码都具有一样的长度。</p>
<p>由于散列函数具有这些特征，因此散列函数可以用来检测报文的可靠性。接收者对收到的报文用与发送者相同的散列函数进行运算，如果得到与发送者相同的散列码，则可以认为报文没有被篡改，否则报文就是不可信的。</p>
<p>常见的散列函数有MD5、SHA和HMAC等。</p>
<p>MD5（Message Digest 5）是一种非常著名的散列算法，已经成为国际标准。它是在MD4的基础上改进的算法，是具有更好的安全性能的散列算法。MD5散列算法对输入的任意长度消息产生128位（16字节）长度的散列值（或称消息摘要）。MD5算法包括以下4个步骤。</p>
<p>（1）附加填充位。首先对输入的报文进行填位补充，使填充后的数据长度模512后余448。如果数据长度正好模512余448，则需增加512个填充位，也就是说填充的个数为1～512位。填充位第一个位为1，其余全部为0。</p>
<p>（2）补足长度。将数据长度表示为二进制，如果长度超过64位，则截取其低64位；如果长度不足64位，则在其高位补0。将这个64位的报文长度补在经过填充的报文后面，使得最后的数据为512位的整数倍。</p>
<p>（3）初始化MD缓存器。MD5运算要用到一个128位的MD5缓存器，用来保存中间变量和最终结果。该缓存器又可看成是4个32位的寄存器A、B、C、D，初始化为：</p>
<p>A:01 23 45 67　B: 89 ab cd ef　C: fe dc ba 98　D: 76 54 32 10</p>
<p>（4）处理数据段。首先定义4个非线性函数F、G、H、I，对输入的报文运算以512位数据段为单位进行处理。对每一个数据段都要进行4轮的逻辑处理，在4轮中分别使用4个不同的函数F、G、H、I。每一轮以ABCD和当前的512位的块为输入，处理后送入ABCD（128位）。</p>
<p>2．数字签名与数字水印</p>
<p>1）数字签名</p>
<p>数字签名可以解决否认、伪造、篡改及冒充等问题。具体要求：发送者事后不能否认发送的报文签名、接收者能够核实发送者发送的报文签名、接收者不能伪造发送者的报文签名、接收者不能对发送者的报文进行部分篡改、网络中的某一用户不能冒充另一用户作为发送者或接收者。凡是需要对用户的身份进行判断的情况都可以使用数字签名，例如加密信件、商务信函、订货购买系统、远程金融交易和自动模式处理等。</p>
<p>数字签名方案一般包括三个过程：系统的初始化过程、签名产生过程和签名验证过程。在签名产生的过程中，用户利用给定的算法对消息产生签名；在签名验证过程中，验证者利用公开验证方法对给定消息的签名进行验证，得出签名的有效性。</p>
<p>实现数字签名的方法有很多，目前采用得比较多的是非对称加密技术和对称加密技术。虽然这两种技术的实施步骤不尽相同，但大体的工作程序是一样的。用户首先可以下载或者购买数字签名软件，然后安装在个人计算机上。在产生密钥对后，软件自动向外界传送公开密钥。由于公共密钥的存储需要，所以需要建立一个鉴定中心（Certification Authority, CA）完成个人信息及其密钥的确定工作。用户在获取公开密钥时，首先向鉴定中心请求数字确认，鉴定中心确认用户身份后，发出数字确认，同时鉴定中心向数据库发送确认信息。然后用户使用私有密钥对所传信息签名，保证信息的完整性、真实性，也使发送方无法否认信息的发送，之后发向接收方；接收方接收到信息后，使用公开密钥确认数字签名，在使用这种技术时，签名者必须注意保护好私有密钥，因为它是公开密钥体系安全的重要基础。如果密钥丢失，应该立即报告鉴定中心取消认证，将其列入确认取消列表之中。其次，鉴定中心必须能够迅速确认用户的身份及其密钥的关系。一旦接收到用户请求，鉴定中心要立即认证信息的安全性并返回信息。</p>
<p>目前已经有大量的数字签名算法，如RSA、E1Gama1、Fiat-Shamir、美国的数字签名标准/算法（DSS/DSA）、椭圆曲线等多种。</p>
<p>2）数字水印</p>
<p>随着数字技术和因特网的发展，各种形式的多媒体数字作品（如图像、视频和音频等）纷纷以网络形式发表，其版权保护成为一个迫切需要解决的问题。数字水印（Digital Watermarking）是实现版权保护的有效办法，如今已成为多媒体信息安全研究领域的一个热点，也是信息隐藏技术研究领域的重要分支。该技术是通过在原始数据中嵌入秘密信息——水印（Watermark）来证实该数据的所有权。这种被嵌入的水印可以是一段文字、标识或序列号等，而且这种水印通常是不可见或不可察的，它与原始数据（如图像、音频和视频数据）紧密结合并隐藏其中，在经过一些不破坏源数据使用价值或商用价值的操作后仍能保存下来。数字水印技术必须具有较强的鲁棒性、安全性和透明性。</p>
<p>（1）典型数字水印系统模型。</p>
<p>图11-2为水印信号嵌入模型，其功能是将水印信号加入原始数据中；图11-3为水印信号检测模型，用来判断某一数据中是否含有指定的水印信号。</p>
<p>alt</p>
<p>图11-3　水印信号检测模型</p>
<p>（2）数字水印主要应用领域。</p>
<p>①版权保护。即数字作品的所有者可用密钥产生一个水印，并将其嵌入原始数据，然后公开发布他的水印版本作品。当该作品被盗版或出现版权纠纷时，所有者即可利用图11-2或图11-3的方法从盗版作品或水印版作品中获取水印信号作为依据，从而保护所有者的权益。</p>
<p>②加指纹。为避免未经授权的复制制作和发行，出品人可以将不同用户的ID或序列号作为不同的水印（指纹）嵌入作品的合法备份中。一旦发现未经授权的备份，就可以根据此备份所恢复出的指纹来确定它的来源。</p>
<p>③标题与注释。即将作品的标题、注释等内容（如一张照片的拍摄时间和地点等）以水印形式嵌入该作品中，这种隐式注释不需要额外的带宽，且不易丢失。</p>
<p>④篡改提示。当数字作品被用于法庭、医学、新闻及商业时，常需确定它们的内容是否被修改、伪造或特殊处理过。为实现该目的，通常可将原始图像分成多个独立块，再将每个块加入不同的水印。同时可通过检测每个数据块中的水印信号，来确定作品的完整性。与其他水印不同的是，这类水印必须是脆弱的，并且检测水印信号时，不需要原始数据。</p>
<p>⑤使用控制。这种应用的一个典型例子是DVD防复制系统，即将水印信息加入DVD数据中，这样DVD播放机即可通过检测DVD数据中的水印信息而判断其合法性和可复制性。从而保护制造商的商业利益。</p>
<p>典型数字水印算法有空域算法、变换域算法、压缩域算法、NEC算法和生理模型算法等。</p>
<p>11.1.3　密钥分配中心与公钥基础设施</p>
<p>在现代密码系统中，算法本身的保密已经不重要了，对于数据的保密在很大程度上、甚至完全依赖于对密钥的保密。只要密钥能够保密，即使加密算法公开，甚至加密设备丢失，也不会对加密系统的坚固性和正常使用产生多大影响。相反，如果密钥丢失，则不但非法用户可以窃取机密数据，而且合法用户面对密文却如读天书，无法提取有效的信息。因此，在密码系统中，如何高效地分配密钥、安全地管理密钥对保证数据安全来说至关重要。</p>
<p>1．密钥分配中心</p>
<p>一个信息系统中任意两个用户之间都可以自己协商来选择不同的密钥，显然，对于总共有N个用户的系统，每个用户都要保存N×（N－1）个密钥。在用户数量较少时，这样来分配密钥还是比较简单、易用的，但是一旦用户数量多起来，系统中要保存的密钥会急剧增多，让每个用户自己高效、安全地管理数量庞大的密钥实际上是不可能的。</p>
<p>有一种非常有效的密钥自动分配方案是密钥分配中心（Key Distribution Center, KDC）技术。</p>
<p>在KDC方案中，每一个用户都只保存自己的私钥SK和KDC的公钥PKKDC，而在通信时再从KDC获得其他用户的公钥或者仅仅在某一次通信中可以使用的对称密钥加密算法的临时密钥K。</p>
<p>假设A和B都是KDC的注册用户，他们分别拥有私钥SKA、SKB。设用对称密钥来加密他们之间的这次对话，那么密钥的分配过程如下。</p>
<p>首先，A向密钥分配中心发送SKA（A, B），表示自己想与B会话。该请求用自己的私钥SKA加密，KDC收到A的请求，用A的公钥来验证请求是由A发出的后，根据某种算法来生成供A、B之间会话使用的对称密钥K。KDC向A返回PKA（K, PKB（A, K）），该应答是用A的公钥加密的，只有A能解读。A用自己的私钥解密应答，得到密钥K，并将PKB（A, K）发送给B，表明A欲与B进行会话。B用自己的私钥解密得到会话密钥K。</p>
<p>至此，完成一次密钥分配。</p>
<p>2．数字证书和公开密钥基础设施</p>
<p>数字签名和公钥加密都是基于不对称加密技术的，存在的问题有：如何保证公开密钥的持有者是真实的；大规模信息系统环境下公开密钥如何产生、分发和管理。</p>
<p>要解决以上问题，就要用到数字证书和PKI。</p>
<p>1）数字证书</p>
<p>数字证书提供了一个在公钥和拥有相应私钥的实体之间建立关系的机制。目前最常用的数字证书格式是由国际标准ITU-T X.509 V3版本定义的。</p>
<p>数字证书中采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己保存私钥，用它进行解密和签名；同时设定一个公钥，并由本人公开，为一组用户所共享，用于加密和验证签名。</p>
<p>数字证书是用户在系统中作为确认身份的证据。在通信的各个环节中，参与通信的各方通过验证对方数字证书，从而确认对方身份的真实性和有效性，从而解决相互间的信任问题。</p>
<p>数字证书的内容一般包括：唯一标识证书所有者的名称、唯一标识证书签发者的名称、证书所有者的公开密钥、证书签发者的数字签名、证书的有效期及证书的序列号等。</p>
<p>2）公钥基础设施</p>
<p>PKI（Public Key Infrastructure，公钥基础设施）的目标是向广大的信息系统用户和应用程序提供公开密钥的管理服务。</p>
<p>PKI的结构模型中有三类实体：管理实体、端实体和证书库。管理实体是PKI的核心，是服务的提供者；端实体是PKI的用户，是服务的使用者；证书库是一个分布式的数据库，用于证书和CRL的存放和检索。</p>
<p>CA和RA是两种管理实体。CA是框架中唯一能够发布和撤销证书的实体，维护证书的生命周期；RA负责处理用户请求，在验证了请求的有效性后，代替用户向CA提交。RA可以单独实现，也可以合并在CA中实现。作为管理实体，CA和RA以证书方式向端实体提供公开密钥的分发服务。</p>
<p>持有者和验证者是两种端实体。持有者是证书的拥有者，是证书所声明的事实上的主体。持有者向管理实体申请并获得证书，也可以在需要时请求撤销或更新证书。持有者使用证书声明自己的身份，从而获得相应的权力。验证者确认持有者所提供的证书的有效性和对方是否为该证书的真正拥有者，只有在成功鉴别之后才可与对方进行更进一步的交互。</p>
<p>由于证书库的存取对象为证书和CRL，其完整性由数字签名来保证，因此不需要额外的安全机制。</p>
<p>不同的实体间通过PKI操作完成证书的请求、确认、发布、撤销、更新和获取等过程。PKI操作分为存取操作和管理操作两类。其中，存取操作包括管理实体或端实体把证书和CRL存放到证书库、从证书库中读取证书和CRL；管理操作则是管理实体与端实体之间或管理实体与管理实体之间的交互，是为了完成证书的各项管理任务和建立证书链。</p>
<p>11.1.4　访问控制</p>
<p>访问控制是通过某种途径限制和允许对资源的访问能力以及范围的一种方法。它是针对越权使用系统资源的保护措施，通过限制对文件等资源的访问，防止非法用户的侵入或者合法用户的不当操作造成的破坏，从而保证信息系统资源的合法使用。</p>
<p>访问控制技术可以通过对计算机系统的控制，自动、有效地防止对系统资源进行非法访问或者不当的使用，检测出一部分安全侵害，同时可以支持应用和数据的安全需求。</p>
<p>访问控制技术并不能取代身份认证，它是建立在身份认证的基础之上的。</p>
<p>1．身份认证技术</p>
<p>在网络通信中，需要确定通信双方的身份，这就需要身份认证技术。在有安全需求的应用系统中，识别用户的身份是系统的基本要求，认证是安全系统中不可缺少的一部分。识别用户的身份有两种不同的形式：一种是身份认证，要求对用户所有的权限角色或自身的身份进行认证；一种是身份鉴定，要求对使用者本身的身份进行检查。</p>
<p>认证的方法多种多样，其安全强度也不相同。具体方法可归结为3大类：根据用户知道什么、拥有什么、是什么来进行认证。用户知道什么，一般就是口令；用户拥有什么，通常为私钥或令牌：用户是什么，这是一种基于生物识别技术的认证。</p>
<p>1）用户名和口令认证</p>
<p>简单认证方式主要是通过一个客户与服务器共知的口令（或与口令相关的数据，如散列、密文等）进行验证。根据处理形式的不同，有3种简单认证的方式：验证数据的明文传送、利用单向散列函数处理验证数据、利用单向散列函数和随机数处理验证数据，这3种方式的安全强度依次增加，处理复杂度也依次增高。</p>
<p>2）使用令牌认证</p>
<p>在使用令牌进行认证的系统中，进行验证的密钥存储于令牌中。对密钥的访问用口令进行控制。令牌是一个像IC卡一样可以加密存储并运行相应加密算法的设备，这种简单认证可以快速、方便地实现用户身份认证，但是认证的安全强度不高。通过令牌可以完成对用户必须拥有某物的验证。令牌的实现分为质询响应令牌和时间戳令牌，其中使用较多的是时间戳令牌。</p>
<p>质询响应令牌的工作原理是：在进行身份认证时，认证服务器首先发送一个随机数到客户机的登录程序。用户将这个随机数读出，输入令牌，并输入令牌的PIN码（实际就是口令），得以访问令牌。令牌对输入的随机数用存储的私钥进行签名，并把结果用Base64编码输出。用户把令牌的输出填入客户机的验证程序中，数据传输到认证的服务器端，在服务器端将使用用户的公钥对签名进行验证，以确定是否允许客户通过登录认证。在该方案中，由于使用数字签名进行登录认证，系统的安全强度大大增加：私钥采用令牌存储的方式解决了私钥自身的安全问题。令牌是一个可移动的设备，可以随身携带，而且令牌有PIN码保护，对令牌的非法访问超过一定的次数后，令牌会死锁。</p>
<p>时间戳令牌解决了质询响应令牌中随机数的问题，时间戳令牌利用时间代替上面的随机数。时间戳令牌每时每刻都在工作，一般每分钟产生一个登录数据，用户只需输入PIN码。登录数据被传送到认证的服务器端，服务器利用当前时间对登录数据进行验证，完成用户的登录过程。使用时间戳令牌需要重点考虑时间同步问题，由于令牌的时钟和认证服务器的时钟不同步，产生的验证码并不会通过验证。解决方法是在验证服务器上进行多次试探验证，在一个时间范围内试探，如果成功则在服务器上存储令牌时钟与服务器时钟的偏移量，以便下次登录时使用。目前，在安全性要求较高的认证系统中，多是采用这种方案。</p>
<p>采用PIN码与令牌实现了双因素验证，根据用户知道什么、拥有什么进行认证，也提供了一个保密认证密钥的方法。但是实现双因素验证需要用户输入数据，给用户的操作增加了麻烦。</p>
<p>3）生物识别与三因素认证</p>
<p>现在兴起了一种基于生物识别技术的认证，主要是根据认证者的图像、指纹、气味和声音等作为认证数据。基于用户知道什么（口令）、拥有什么（私钥和令牌）、是什么（生物特征）的3因素认证是目前强认证中使用最多的手段。在安全性要求较高的系统中，认证必须能对用户进行身份鉴定。要将用户知道什么、拥有什么、是什么结合起来，同时对认证用的密钥进行保护。</p>
<p>2．访问控制技术</p>
<p>根据控制手段和具体目的的不同，通常将访问控制技术划分为如下几个方面：入网访问控制、网络权限控制、目录级安全控制、属性安全控制以及网络服务器的安全控制等。</p>
<p>入网访问控制为网络访问提供了第一层访问控制。它控制哪些用户能够登录到服务器并获取网络资源，控制准许用户入网的时间和准许入网的工作站等。基于用户名和口令的用户的入网访问控制可分为三个步骤：用户名的识别与验证、用户口令的识别与验证、用户账号的默认限制检查。三个步骤中只要任何一个未通过校验，该用户便不能进入该网络。可以说，对网络用户的用户名和口令进行验证是防止非法访问的第一道防线。但由于用户名口令验证方式容易被攻破，目前很多网络都开始采用基于数字证书的验证方式。</p>
<p>网络权限控制是针对网络非法操作所提出的一种安全保护措施。能够访问网络的合法用户被划分为不同的用户组，用户和用户组被赋予一定的权限。访问控制机制明确了用户和用户组可以访问哪些目录、子目录、文件和其他资源；以及指定用户对这些文件、目录、设备能够执行哪些操作。它有两种实现方式，“受托者指派”和“继承权限屏蔽”。“受托者指派”控制用户和用户组如何使用网络服务器的目录、文件和设备；“继承权限屏蔽”相当于一个过滤器，可以限制子目录从父目录那里继承哪些权限。可以根据访问权限将用户分为以下几类：特殊用户（即系统管理员）；一般用户，系统管理员根据他们的实际需要为他们分配操作权限；审计用户，负责网络的安全控制与资源使用情况的审计。用户对网络资源的访问权限可以用访问控制表来描述。</p>
<p>目录级安全控制是针对用户设置的访问控制，控制用户对目录、文件、设备的访问。用户在目录一级指定的权限对所有文件和子目录有效，用户还可以进一步指定对目录下的子目录和文件的权限。对目录和文件的访问权限一般有8种：系统管理员权限、读权限、写权限、创建权限、删除权限、修改权限、文件查找权限和访问控制权限。8种访问权限的有效组合可以让用户有效地完成工作，同时又能有效地控制用户对服务器资源的访问，从而加强了网络和服务器的安全性。</p>
<p>属性安全控制在权限安全控制的基础上提供更进一步的安全性。当用户访问文件、目录和网络设备时，网络系统管理员应该给出文件、目录的访问属性，网络上的资源都应预先标出安全属性，用户对网络资源的访问权限对应一张访问控制表，用以表明用户对网络资源的访问能力。属性设置可以覆盖已经指定的任何受托者指派和有效权限。属性能够控制以下几个方面的权限：向某个文件写数据、复制文件、删除目录或文件、查看目录和文件、执行文件、隐含文件、共享、系统属性等，避免发生非法访问的现象。</p>
<p>因为网络允许用户在服务器控制台上执行一系列操作，所以用户使用控制台就可以执行装载和卸载模块、安装和删除软件等操作，这就需要网络服务器有安全控制。网络服务器的安全控制包括可以设置口令锁定服务器控制台，从而防止非法用户修改、删除重要信息或破坏数据。具体包括设定服务器登录时间限制、非法访问者检测和关闭的时间间隔等。</p>
<p>11.1.5　安全协议</p>
<p>1．IPSec协议简述</p>
<p>为了满足Internet的安全需求，因特网工程任务组（IETF）于1998年11月颁布IP层安全标准IP SECURITY协议（IPSec），IPSec在IP层上对数据包进行高强度的安全处理提供数据源验证、无连接数据完整性、数据机密性、抗重播和有限通信流机密性等安全服务。</p>
<p>1）IPSec协议工作原理</p>
<p>IPSec通过使用两种通信安全协议来为数据报提供高质量的安全性：认证头（AH）协议和封装安全载荷（ESP）协议，以及像Internet密钥交换（Internet Key Exchange, IKE）协议这样的密钥管理过程和协议。其中AH协议提供数据源认证、无连接的完整性以及一个可选的抗重放服务。ESP协议提供数据保密性、有限的数据流保密性、数据源验证、无连接的完整性以及抗重放服务。IPSec允许系统或网络用户控制安全服务提供的粒度。IPSec的安全服务是由通信双方建立的安全关联（Security Association, SA）来提供的，SA为通信提供了安全协议、模式、算法和应用于单向IP流的密钥等安全信息。每一个IPSec节点包含一个局部的安全策略库（Security Polioy Database, SPD），系统在处理输入、输出IP流时必须参考该策略库，并根据从SPD中提取的策略对IP流进行不同的处理：拒绝、绕过、进行IPSec保护。如果策略决定IP流需要经过IPSec处理，则根据SPD与SAD的对应关系，找到相应的SA，并对IP包进行指定的IPSec处理。SA由一个三元组唯一地标识，该三元组包含一个安全参数索引（Security Parameter Index, SPI），一个用于输出处理SA的目的IP地址或者一个用于输入处理SA的源IP地址以及一个特定的协议（例如AH或者ESP）。SPI是为了唯一标识SA而生成的一个32位整数。它在AH和ESP头中传输，IPSec数据报的接收方易于识别SPI并利用它连同源或者目的IP地址和协议来搜索SAD，以确定与该数据报相关联的SA或者SA束。SA中所选用的安全协议、SA模式、SA的两端及安全协议内所要求的服务等具体地决定了怎样为通信流提供安全服务。但是，最终安全服务的具体实施是通过使用AH和ESP协议。</p>
<p>2）IPSec协议实现模式</p>
<p>IPSec协议既可用来保护一个完整的IP载荷，也可用来保护某个IP载荷的上层协议。这两方面的保护分别由IPSec的两种不同“模式”来提供，如图11-4所示。</p>
<details><summary>图11-4　IPSec数据报结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904084355.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904084355.png';" /></details>

<p>其中，传输模式用来保护上层协议，而隧道模式用来保护整个IP数据报。在传输模式中，IP头与上层协议头之间需插入一个特殊的IPSec头：而在隧道模式中，要保护的整个IP包都需封装到另一个IP数据包里，同时在外部与内部IP头之间插入一个IPSec头。两种IPSec协议（AH和ESP）均能同时以传输模式或隧道模式工作。由构建方法所决定，对传输模式所保护的数据包而言，其通信终点必须是一个加密的终点。在后一种情况下，通信终点便是由受保护的内部头指定的地点，而加密终点则是那些由外部IP头指定的地点。在IPSec处理结束的时候，安全网关会剥离出内部IP包，再将那个包转发到它最终的目的地。</p>
<p>3）IPsec协议安全性分析</p>
<p>IPSec的安全性可以归纳为如下方面。</p>
<p>（1）当IPSec在路由器或防火墙中实现时，它提供很强的安全保证，可以应用于所有跨越网络边界的通信。一个实体内部的通信量不会引起与安全处理相关的开销。</p>
<p>（2）如果所有来自外部的通信必须使用IP，且防火墙是Internet与组织的唯一入口，则IPSec是不能被绕过的。</p>
<p>（3）IPSec位于传输层（TCP、UDP）之下，因此对应用程序是透明的。当IPSec在防火墙或是路由器上实现时，没有必要在用户或是服务器上更改软件。即使IPSec在末端系统、更高层软件（包括应用程序）上运行，也不会受到影响。</p>
<p>（4）IPSec对最终用户是透明的。没有必要培训用户掌握安全机制，也没有必要基于每个用户来发行关键资料，在用户离开组织时再撤回关键资料。</p>
<p>如果需要，IPSec可以为单个用户提供安全保证。这适用于站点外的工作人员，并适用于在组织内设置保密的专用子网，以用于敏感的应用程序。</p>
<h5 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h5><p>SSL协议（Secure Socket Layer）是Natscape推出的一种网络安全协议，是在传输过程通信协议（TCP/IP）上实现的一种安全协议。在SSL中，采用了公开密钥和私有密钥两种加密方式，它对计算机之间的整个会话进行加密。SSL的安全服务位于TCP和应用层之间，可为应用层，如HTTP、FPT、SMTP提供安全业务，服务对象主要是Web应用，即客户浏览器和服务器。它的基本目标是在通信双方之间建立安全的连接，可运行在任何可靠的通信协议之上、应用层协议之下。</p>
<p>1）SSL协议工作原理</p>
<p>在SSL中，所有数据被封装在记录中，记录层把从上层获得的数据分成可管理的块、可选的压缩数据、应用MAC（Message Authentication Code）、加密、增加SSL首部、在TCP报文段中传输结果单元。被接收的数据被解密、验证、解压和重新装配，然后交付给更高级的用户。SSL中两个重要的概念是SSL连接和SSL会话。</p>
<p>连接是提供恰当类型服务的传输。对于SSL，这样的连接是点到点的关系。连接是短暂的，每个连接与一个会话相联系。连接状态由服务器和客户的随机数、服务器写MAC密码、客户写MAC密码、服务器写密钥、客户写密钥、初始化向量、序号等参数来定义。</p>
<p>SSL的会话是客户和服务器之间的关联，会话通过握手协议来创建。会话定义了加密安全参数的一个集合，该集合可以被多个连接所共享。会话可以用来避免为每个连接进行昂贵的新安全参数的协商。每个会话由会话标识符、对方的证书、压缩方法、密文规约、主密钥和可重用标志等参数来定义。</p>
<p>2）SSL协议工作过程</p>
<p>SSL客户和服务器首次开始通信时，它们就协议版本、加密算法、是否验证及密钥等进行协商，这一过程由握手协议完成。握手过程结束后，客户端与服务器端开始交换应用层数据。握手协商过程主要包括以下几个阶段：</p>
<p>（1）建立安全能力</p>
<p>（2）服务器身份验证和密钥交换</p>
<p>（3）客户机验证和密钥交换</p>
<p>（4）完成</p>
<p>该阶段完成安全连接的建立。</p>
<p>3）SSL协议安全性分析</p>
<p>（1）防止窃听及中间人攻击。</p>
<p>（2）防止剪贴攻击。</p>
<p>（3）防止重放攻击及短包攻击。</p>
<h5 id="PGP协议"><a href="#PGP协议" class="headerlink" title="PGP协议"></a>PGP协议</h5><p>PGP（Pretty Good Privacy）是由Hil Zimmermann提出的方案，是针对电子邮件在Internet上通信的安全问题而设计的一种混合加密系统。PGP包含4个密码单元，即单钥密码（IDEA）、双钥密码（RSA）、单向杂凑算法（MD-5）和一个随机数生成算法。该协议规定公钥密码和分组密码是在同一个系统中。PGP的用户拥有一张公钥列表，列出了所需要通信的用户及其公钥。PGP应用程序具有很多优点，如速度快、效率高，同时具有很好的可移植性。</p>
<p>2）PGP协议的加密过程</p>
<p>PGP的加密过程是：先根据一些随机的环境数据（例如键盘的敲击间隔）产生一个密钥，用IDEA算法对明文加密。接着用接收者的RSA公钥对这个IDEA密钥进行加密，然后把这两种加密的结果作为密文发送出去。接收方接到密文后，先用自己的RSA私钥解密得到IDEA密钥，再用这个IDEA密钥对密文进行解密。也就是说，PGP没有用RSA算法直接对明文加密，而是对IDEA密钥进行加密。</p>
<p>对于数字签名，PGP先根据明文的内容利用Hash函数（散列算法）计算出一个128位的摘要，这个摘要就像是明文的一个精华，明文中任何改变都会导致这个精华的改变，并且从这个精华无法推导出明文的内容。发送者用自己的私钥对这个精华进行签名。因此在邮件传送过程中，任何对明文内容的改变都会导致摘要内容与签名的摘要内容不相符，以至签名的内容无效。由于IDEA算法的速度很快，所以不会因为邮件的数据量大而耽误时间；而IDEA的密钥位数较少，所以对它使用RSA算法在速度上也不会有太大影响。又因为IDEA的密码是以RSA加密的形式传送的，使得PGP既避免了IDEA的密钥管理缺陷，又避免了RSA的大量运算。 $\color{green}{\text{PGP}}$ 的这些优点使其在 $\color{green}{\text{邮件发送领域}}$ 具有广泛的应用。</p>
<p>使用PGP传递公钥的过程如下：假设用户A拥有用户B和用户C的公钥，用户B只拥有用户A的公钥，用户C也只拥有用户A的公钥。因为用户A和用户B、用户A和用户C都拥有对方的公钥，所以他们之间可以安全通信。但是用户B和用户C是不能直接通信的。用户B和用户C都知道用户A拥有对方的公钥，如果他们都同时信任用户A，可以从用户A处获得对方的公钥。即用户A利用自己的私钥分别对用户B和用户C的公钥签名，然后分别发给用户B和用户C，这样用户B和用户C就可以安全通信了。这是一个比较简单的情况，如果用户B和用户C要经过多个用户才能获得对方的公钥，这就给用户B和用户C的正常通信带来了麻烦。同时，安全也会随着链式信任网的扩大而急速下降。</p>
<h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><h5 id="备份的类型"><a href="#备份的类型" class="headerlink" title="备份的类型"></a>备份的类型</h5><p>随着计算机的日益普及以及信息技术的飞速发展，人们已经逐渐认识到信息安全的重要性。但是作为信息安全的重要成员——数据备份却常常被人们遗忘，这样导致的后果就是大量的有用信息被丢失，造成的后果有时是毁灭性的。</p>
<p>导致数据被破坏、丢失的原因很多，如硬盘的损坏、病毒的侵入等。而作为一名合格的系统管理员，关键要做到的就是保证数据的完整性以及准确性。如何才能真正做到这一点呢，这是一项非常艰巨但又非常重要的工作。一般情况下，采取的措施包括安装防火墙、杀毒软件等。但是，事情总不像人们想象的那么完美，数据的安全性和准确性一直都面临着极大的考验。因此，数据备份就显得十分有必要，同时它也是防止“主动攻击”的最重要一道防线。</p>
<p>数据备份包括以下几种类型，在不同的情况下，应该根据具体情况，选出最合适的方法。</p>
<p>（1）完全备份。是指备份全部选中的文件夹，并不依赖文件的存档属性来确定备份哪些文件（在备份过程中，任何现有的标记都被清除，每个文件都被标记为已备份。换言之，即清除存档属性）。完全备份的特点是备份所需时间最长，但恢复时间最短，操作最方便可靠。</p>
<p>（2）差异备份。也称差分备份，它是针对完全备份的，即备份上一次的完全备份后发生变化的所有文件。换句话说，没有发生变化的就不需要备份（差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，即备份后不标记为已备份文件。换言之，不清除存档属性）。差异备份的特点是备份时间较长，占用空间较多，但恢复时间较短。</p>
<p>（3）增量备份。是针对上一次备份（无论是哪种备份，这也是与差分备份不同的），即上一次备份后，所有发生变化的文件（增量备份过程中，只备份有标记的选中的文件和文件夹，它清除标记，即备份后标记文件。换言之，清除存档属性）。增量备份的特点是备份时间较短，占用空间较少，但恢复时间较长。</p>
<p>（4）按需备份。也就是说，它是根据需要有选择地进行数据备份。很明显，它的特点就是有很好的选择性。</p>
<h5 id="异地备份"><a href="#异地备份" class="headerlink" title="异地备份"></a>异地备份</h5><p>数据异地备份是容灾系统的核心技术，它不同于上述介绍的备份方法，它的特点是具有异地性。它对于保证数据的一致性、可靠性及系统的可扩展性具有举足轻重的作用，通过有效的数据复制，实现远程的业务数据与本地业务数据的同步，确保一旦本地系统出现故障，远程的容灾中心能够迅速进行完整的业务接管。</p>
<p>异地备份在金融业中有着典型的应用，它为保证金融业的正常运行做出了巨大的贡献。在“9.11”期间，美国的金融业虽然遭受了巨大的损失，但是还能够正常运行，为什么这么巨大的灾难也没有给美国金融业带来致命的打击呢？就是因为他们对数据的异地备份做得非常好，才没有导致金融业的全面崩溃。</p>
<p>在进行异地备份时，要注意以下几个问题。</p>
<p>（1）在进行异地备份前，要集中精力进行杀毒查毒工作，避免让备份带上病毒。</p>
<p>（2）对于软盘，要保证磁片质量，非常有必要定期对其进行质量检查。</p>
<p>（3）对于CD-RW光盘，它的一个最大的缺点就是兼容性不好，因此最好就是由哪台刻录机刻录的盘片，就在哪台刻录机上继续刻录、改写等操作。</p>
<p>（4）对于移动硬盘，要做磁盘检查，保证其性能良好。</p>
<h5 id="自动备份软件"><a href="#自动备份软件" class="headerlink" title="自动备份软件"></a>自动备份软件</h5><p>随着人们对数据备份意识的逐渐增强，各种自动备份软件也应运而生，给我们提供了很多数据备份的选择方案，下面主要介绍几种。</p>
<p>1）自动备份精灵</p>
<p>自动备份精灵是为方便我们的备份工作而特别设计开发的软件，其最大的优点是支持网络自动备份和本机自动备份。一方面，自动备份精灵可以帮助我们定时备份数据，可以设置关机备份数据，也可以手动备份。另一方面，它也允许我们自由地选择需要备份文件的源路径和目的路径，可以查看备份日志等。</p>
<p>2）利用GHOST实现自动备份</p>
<p>Ghost是最著名的硬盘复制备份工具，因为它可以将一个硬盘中的数据完全相同地复制到另一个硬盘中，因此大家就将Ghost这个软件称为“硬盘克隆”。Ghost不但有硬盘到硬盘的克隆功能，还有硬盘分区、硬盘备份、系统安装、网络安装和升级系统等功能。1998年6月，出品Ghost的Binary公司被著名的Symantec公司并购，因此该软件的后续版本就改称为Norton Ghost，成为Norton系列工具软件中的一员。</p>
<p>3）使用DiskWin实现自动备份</p>
<p>DiskWin主要是针对企业的备份软件。它很好地解决了企业数据备份问题。将所有员工机的文件自动备份到服务器；管理员定义每一员工机强制备份的工作文件类型和备份时间。可规定公司不同的部门备份不同的文件类型，如公司销售部备份Word文件和电子邮件，公司软件开发部备份程序代码文件，设计部备份PhotoShop设计图片等；全盘搜索每一员工机变化的文件，保证每天新增或者变化的工作文件一个不多，一个不少，全部压缩打包，自动上传到服务器。具备多个备份的文件无论怎样重命名都只备份一个；客户端可以设置隐藏运行，无论是搜索文件还是上传备份可以不出现任何提示，对员工正常工作无任何干扰，就好像这个软件根本不存在一样。</p>
<h5 id="几种新型的备份解决方案"><a href="#几种新型的备份解决方案" class="headerlink" title="几种新型的备份解决方案"></a>几种新型的备份解决方案</h5><p>对重要数据进行备份，就是为了在发生意外时能够及时进行恢复，使损失降低到最低。但是，如果备份文件存放不好，或者是备份策略不恰当，所付出的努力将付之东流。为了避免发生这种情况，我们就应该采取正确的备份方案。</p>
<p>一个优秀的备份解决方案应该做到以下几点。</p>
<p>（1）最大限度地降低对应用数据流量的影响，从而保证通信性能。</p>
<p>（2）最大限度地降低服务器的负载，保证服务器的性能；</p>
<p>（3）优化备份资源的使用，包括服务器、驱动器等。</p>
<p>在现代化的企业环境中，随着应用系统负载的增加，服务器的数量也在增加。但是由于磁带设备的分散特性，并且它们相互独立、不能执行全局统一的备份策略；需要的磁带机数量与应用服务器的数量成正比，所以要花费很高的维护成本。</p>
<p>下面介绍几种新型的备份解决方案。</p>
<p>1）网络备份模式</p>
<p>网络备份模式的原理是把一个磁带设备放置在LAN上，供多个服务器共享。由于网络设备模式对磁带进行统一的调度和使用，因此可以提高磁带的利用率和可管理性。需要管理的磁带驱动器的大幅度减少有助于降低成本，网络备份是一种非常好的企业备份模式。</p>
<p>如果普通备份的时间比较长，则可以安装一套独立的局域网，并在每套要备份的系统中连接一网卡，从而可以使备份数据与生产数据相互独立，互不影响。</p>
<p>在一个典型的基于LAN的备份模式中，生产数据和备份数据都是通过相同的LAN进行传输，这样需要备份的海量数据就会增加LAN上的流量，导致应用性能的降低。备份通常是在下班的时间进行，这样可以最大限度地减少对生产流量的影响。然而不断增长的数据量会导致备份时间的延长，而且随着企业业务的全球化，对系统的正常运行的要求也越来越高，可以用来备份的时间也越来越短。</p>
<p>为了在一个共同的LAN中消除这些潜在的冲突，可以将应用和备份隔离开来，这就是利用存储网络的方法。</p>
<p>另外，备份需要增加服务器的操作。服务器通常忙于处理大量对延迟和性能非常敏感的数据，数据的移动和调度需要占用额外的CPU周期，而进行备份通常会对应用本身的性能造成很大的影响，因此可以采用SCSI扩展复制命令的备份方法加以解决。</p>
<p>2）用存储网络备份</p>
<p>这个方案是让每个应用服务器都可以通过一个专用的存储网络，直接将数据备份到某个磁带设备，而不需要经过专门的备份服务器。利用通用的共享存储设备，每个应用服务器都可以充当一个介质服务器，因为它们可以直接将数据发送到磁带。每个服务器确定一个专门的磁带驱动器，并在备份过程中独自占有该磁带驱动器。用户还可以利用对磁带库中磁带驱动器的专有访问权限对应用服务器进行配置，而不是使用共享过程。</p>
<p>经过存储网络传输的数据可以隔离备份数据和应用数据，从而减少LAN上的流量。一个磁带也可以被多个应用共享，并且可以将多个备份流量合并到所管理的磁带库和驱动器中。此时，LAN仍可以用于在备份的服务器和客户端之间传输元数据和跟踪数据备份的状态，但是实际的备份数据将通过存储网络传输。利用网络存储备份可以隔离应用数据和备份数据，但是不能减轻服务器的CPU负载，因为它们仍然需要从磁带读取备份数据。</p>
<p>3）磁带和磁带之间直接传输数据的备份</p>
<p>为了减轻服务器在备份时的CPU负载，需要在数据不经过服务器本身的情况下，将备份数据从磁盘发送到磁带，这是通过在磁盘和磁带之间直接传输数据的机制（即SCSI扩展复制命令的方法）来实现的。在这种方式中，执行SCSI扩展复制命令的组件可能位于存储网络的交换阵列或者是服务器软件中，数据的副本会智能地从磁盘发送到磁带，而不需要经过服务器。复制并传输所要备份的数据对服务器CPU的负载影响非常小，这是因为服务器并不需要参与备份数据的任何具体操作，可以大大地减轻服务器的负担，保证服务器的性能不会受到备份的影响。</p>
<h4 id="计算机病毒与免疫"><a href="#计算机病毒与免疫" class="headerlink" title="计算机病毒与免疫"></a>计算机病毒与免疫</h4><h5 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h5><p>从计算机病毒刚诞生之际，它就给人们带来了麻烦，随着网络的发展，其破坏力越来越强，计算机病毒已成为危害个人系统及网络安全的一大隐患，正如生物学上的病毒能够使我们生病一样，计算机病毒会破坏计算机的正常工作。计算机病毒的一些典型破坏包括影响用户的工作（如妨碍鼠标、键盘的操作，间隔性地在用户的屏幕上显示一段文字或播放一段音乐），破坏用户系统上的一些程序（如使得Microsoft Word不能正常运行），大量占用系统的资源，使系统无法正常工作（蠕虫病毒的典型做法），破坏用户的数据（如删除用户的文件，格式化硬盘），有时也会破坏系统的硬件。</p>
<p>1）计算机病毒的定义</p>
<p>提到病毒，人们通常就会想到一些恶意的、时常破坏机器上的程序、数据的小程序。但如何给病毒下一个科学的、精确的定义呢？病毒的定义最早由F.B.Cohen于1984年提出，在他的经典文章Computer Viruses-Theory and Experiments（计算机病毒一理论与实践）中，描述如下：</p>
<p>“计算机病毒是这样的一种程序，它通过修改其他程序使之含有该程序本身或它的一个变体。病毒具有感染力，它可借助其使用者的权限感染他们的程序，在一个计算机系统中或网络中得以繁殖、传播。每个被感染的程序也像病毒一样可以感染其他程序，从而使更多的程序受到感染。”</p>
<p>2）病毒的基本特征</p>
<p>●　感染性</p>
<p>●　潜伏性</p>
<p>●　可触发性</p>
<p>●　破坏性</p>
<p>●　人为性</p>
<p>●　衍生性</p>
<p>3）计算机病毒的分类</p>
<p>分类的方式、角度是多种多样的，从病毒的工作机制角度主要分为以下5类。</p>
<p>●　引导区病毒（boot sector virus）</p>
<p>●　文件感染病毒（file infector virus）</p>
<p>●　宏病毒（Marco virus）</p>
<p>●　特洛伊木马（Trojan/Trojan Horse）</p>
<p>●　蠕虫病毒（Worm）</p>
<h5 id="计算机病毒免疫的原理"><a href="#计算机病毒免疫的原理" class="headerlink" title="计算机病毒免疫的原理"></a>计算机病毒免疫的原理</h5><p>我们知道，计算机病毒的传染模块一般包括传染条件判断和实施传染两个部分，在病毒被激活的状态下，病毒程序通过判断传染条件的满足与否，以决定是否对目标对象进行传染。一般情况下，病毒程序在传染完一个对象后，都要给被传染对象加上传染标识，传染条件的判断就是检测被攻击对象是否存在这种标识，若存在这种标识，则病毒程序不对该对象进行传染；若不存在这种标识，则病毒程序就对该对象实施传染。由于这种原因，人们自然会想到是否能在正常对象中加上这种标识，就可以不受病毒的传染，起到免疫的作用呢？</p>
<p>从实现计算机病毒免疫的角度看病毒的传染，可以将病毒的传染分成两种。第一种是像香港病毒、1575病毒这样，在传染前先检查待传染的扇区或程序里是否含有病毒代码，如果没有找到则进行传染，如果找到了则不再进行传染。这种用作判断是否为病毒自身的病毒代码被称作传染标志或免疫标志。第二种是在传染时不判断是否存在免疫标志，病毒只要找到一个可传染对象就进行一次传染。就像黑色星期五那样，一个文件可能被黑色星期五反复传染多次，滚雪球一样越滚越大（需要说明的是，黑色星期五病毒的程序中具有判别传染标志的代码，由于程序设计错误，使判断失败，形成现在的情况，对文件会反复感染，传染标志形同虚设）。</p>
<p>目前常用的免疫方法有如下两种。</p>
<p>1）针对某一种病毒进行的计算机病毒免疫</p>
<p>例如对小球病毒，在DOS引导扇区的1FCH处填上1357H，小球病毒一旦检查到这个标志就不再对它进行传染了。对于1575文件型病毒，免疫标志是文件尾的内容为0CH和OAH的两个字节，1575病毒若发现文件尾含有这两个字节，则不进行传染。这种方法的优点是可以有效地防止某一种特定病毒的传染。但缺点很严重，主要有以下几点。</p>
<p>（1）对于没有设感染标识的病毒不能达到免疫的目的。有的病毒只要在激活的状态下，会无条件的把病毒传染给被攻击对象，而不论这种对象是否已经被感染过或者是否具有某种标识。</p>
<p>（2）当出现这种病毒的变种不再使用这个免疫标志时或出现新病毒时，免疫标志发挥不了作用。</p>
<p>（3）某些病毒的免疫标志不容易仿制，非要加上这种标志不可，则对原来的文件要做大的改动。例如对大麻病毒就不容易做免疫标志。</p>
<p>（4）由于病毒的种类较多，又由于技术上的原因，不可能对一个对象加上各种病毒的免疫标识，这就使得该对象不能对所有的病毒具有免疫作用。</p>
<p>（5）这种方法能阻止传染，却不能阻止病毒的破坏行为，仍然放任病毒驻留在内存中。目前使用这种免疫方法的商品化反病毒软件已不多见了。</p>
<p>2）基于自我完整性检查的计算机病毒的免疫方法</p>
<p>目前这种方法只能用于文件而不能用于引导扇区。这种方法的原理是：为可执行程序增加一个免疫外壳，同时在免疫外壳中记录有关用于恢复自身的信息。免疫外壳占1～3KB。执行具有这种免疫功能的程序时，免疫外壳首先得到运行，检查自身的程序大小、校验生成日期和时间等情况，没有发现异常时才转去执行受保护的程序。</p>
<p>但是，它仍存在如下一些缺点和不足。</p>
<p>（1）每个受到保护的文件都要增加1～3KB，需要额外的存储空间。</p>
<p>（2）现在使用中的一些校验码算法不能满足防病毒的需要，被某些种类的病毒感染的文件不能被检查出来。</p>
<p>（3）无法对付覆盖方式的文件型病毒。</p>
<p>（4）有些类型的文件不能使用外加免疫外壳的防护方法，这样将使那些文件不能正常执行。</p>
<p>当某些尚不能被病毒检测软件检查出来的病毒感染了文件，而该文件又被免疫外壳包在里面时，这个病毒就像穿了“保护盔甲”，使查毒软件查不到它，而它却能在得到运行机会时跑出来继续传染扩散。</p>
<h3 id="信息安全管理和评估"><a href="#信息安全管理和评估" class="headerlink" title="信息安全管理和评估"></a>信息安全管理和评估</h3><h4 id="安全管理技术"><a href="#安全管理技术" class="headerlink" title="安全管理技术"></a>安全管理技术</h4><p>由于数据在网络上进行传输时，可能会存在各种攻击，因此，必须加强对网络安全的管理。概括性地说，安全管理技术就是监督、组织和控制网络通信服务以及信息处理所必需的各种技术手段和措施的总称。其目标是确保计算机网络的持续正常运行，并在计算机网络运行出现异常时能及时响应和排除故障。</p>
<h5 id="安全管理的发展现状"><a href="#安全管理的发展现状" class="headerlink" title="安全管理的发展现状"></a>安全管理的发展现状</h5><p>在20世纪90年代中后期，随着因特网的发展以及社会信息化程度越来越高，各种安全设备在网络中的应用也越来越多，市场上开始出现了独立的安全管理产品。</p>
<p>相对而言，国外计算机网络安全管理的需求多样，起步较早，已经形成了较大规模的市场，有一部分产品逐渐在市场上获得了用户的认可。近年来，国内厂商也开始推出网络安全管理产品，但一般受技术实力限制，大多是针对自己的安全设备开发的集中管理软件、安全审计系统等。</p>
<p>由于各种网络安全产品的作用体现在网络中的不同方面，统一的网络安全管理平台必然要求对网络中部署的安全设备进行协同管理，这是统一安全管理平台的最高追求目标。</p>
<h5 id="网络安全管理技术简介"><a href="#网络安全管理技术简介" class="headerlink" title="网络安全管理技术简介"></a>网络安全管理技术简介</h5><p>安全管理（Security Management, SM），不管是对于个人管理，还是对企业管理（Enterprise　Management），都是十分重要的。从信息管理的角度看，安全管理涉及到策略与规程、安全缺陷以及保护所需的资源、防火墙、密码加密问题、鉴别与授权、客户机/服务器认证系统、报文传输安全以及对病毒攻击的保护等。</p>
<p>实际上，安全管理不是一个简单的软件系统，它包括的内容非常多，主要涵盖了安全设备的管理、安全策略管理、安全风险控制和安全审计等几个方面。</p>
<p>（1）安全设备管理：是指对网络中所有的安全产品，如防火墙、VPN、防病毒、入侵检测（网络、主机）和漏洞扫描等产品实现统一管理、统一监控。</p>
<p>（2）安全策略管理：是指管理、保护及自动分发全局性的安全策略，包括对安全设备、操作系统及应用系统的安全策略的管理。</p>
<p>（3）安全分析控制：确定、控制并消除或缩减系统资源的不定事件的总过程，包括风险分析、选择、实现与测试、安全评估及所有的安全检查（含系统补丁程序检查）。</p>
<p>（4）安全审计：对网络中的安全设备、操作系统及应用系统的日志信息收集汇总，实现对这些信息的查询和统计；并通过对这些集中信息的进一步分析，可以得出更深层次的安全分析结果。</p>
<h5 id="安全管理主要解决以下问题"><a href="#安全管理主要解决以下问题" class="headerlink" title="安全管理主要解决以下问题"></a>安全管理主要解决以下问题</h5><p>1）集中化的安全策略管理（Centralized Security Policy Management, CSPM）</p>
<p>企业的安全保障需要自上而下地制定安全策略，这些安全策略会被传送并装配到不同的执行点（Enforcement Point）中。</p>
<p>2）实时安全监视（Real-Time Security Awareness, RTSA）</p>
<p>企业用户实时了解企业网络内的安全状况。</p>
<p>3）安全联动机制（Contain Mechanism, CM）</p>
<p>安全设备之间需要具备有中心控制或无中心控制的安全联动机制，即当IDS发现在某网段有入侵动作时，它需要通知防火墙阻断此攻击。</p>
<p>4）配置与补丁管理（Configuration and Patching Management）</p>
<p>企业用户可以通过对已发现的安全缺陷快速反应，大大提高自己抵抗风险的能力。</p>
<p>5）统一的权限管理（Privilege Management across the Enterprise）</p>
<p>通过完善的权限管理和身份认证实现对网络资源使用的有效控制和审计。</p>
<h4 id="安全性规章"><a href="#安全性规章" class="headerlink" title="安全性规章"></a>安全性规章</h4><h5 id="信息系统安全制度"><a href="#信息系统安全制度" class="headerlink" title="信息系统安全制度"></a>信息系统安全制度</h5><p>一段时间以来，国际和国内一些著名网站被“黑”的事件引起了社会多方的关注。计算机信息系统的安全问题越来越受到重视，因为安全问题将影响到电子商务、国家信息甚至是国防等各个方面。针对大幅度上升的黑客攻击、病毒传播和有害信息传播等计算机违法犯罪活动，有关部门出台了一系列的信息系统安全法规与制度，从而进一步保证了信息系统的安全运行。</p>
<p>1）计算机信息系统安全保护等级划分标准</p>
<p>《计算机信息系统安全保护等级划分标准》规定，从2001年1月1日起对计算机信息系统安全保护实行等级划分，此举标志着我国计算机信息系统安全保护纳入了等级管理的轨道。</p>
<p>由公安部提出并组织制定、国家质量技术监督局发布的强制性国家标准《计算机信息系统安全保护等级划分准则》，将计算机信息系统的安全保护等级划分为用户自主保护级、系统审计保护级、安全标记保护级、结构化保护级和访问验证保护级5个级别。用户可以根据自己计算机信息系统的重要程度确定相应的安全保护级别，并针对相应级别进行建设。</p>
<p>实行安全等级保护制度后，公安机关能够通过规范、科学、公正的评定和监督管理，全面、及时地预防和发现计算机信息系统建设和使用中存在的安全风险和安全漏洞，有利于提高公安机关对计算机信息系统安全保护的监督管理水平。此外，实行这一制度还有利于提高信息安全产业化发展水平，为安全产品的普及使用提供广阔的市场和发展空间。</p>
<p>2）计算机信息安全保护条例</p>
<p>根据公安部的有关规定，计算机信息系统安全保护包括以下几个方面。</p>
<p>（1）实体安全：包括周围危险建筑与设施、监控系统、防火措施、防水措施、机房环境、防雷措施、备用电源、防静电措施、用电质量和防盗措施等。</p>
<p>（2）网络通信安全：包括通信设备的场所标志、重要的通信线路及通信控制装置备份、加密措施、网络运行状态安全审计跟踪措施、网络系统访问控制措施和工作站身份识别措施等。</p>
<p>（3）软件与信息安全：包括操作系统及数据库访问控制措施、应用软件、系统信息能防止恶意攻击和非法存取、数据库及系统状态监控、防护措施、用户身份识别措施、系统用户信息异地备份等。</p>
<p>（4）管理组织与制度安全：包括专门的安全防范组织和计算机安全员、健全的安全管理规章制度、详尽的工作手册和完整的工作记录、定期进行风险分析，制定灾难处理对策、建立安全培训制度、制定人员的安全管理制度等。</p>
<p>（5）安全技术措施：包括灾难恢复的技术措施、开发工作与业务工作分离的措施、应用业务、系统安全审计功能、系统操作日志、服务器备份措施、计算机防病毒措施等。</p>
<h5 id="计算机防毒制度"><a href="#计算机防毒制度" class="headerlink" title="计算机防毒制度"></a>计算机防毒制度</h5><p>为了加强计算机病毒的防治管理工作，2000年公安部发布了《计算机病毒防治管理办法》，规定各级公安机关负责本行政区域内的计算机病毒防治管理工作。</p>
<p>规定禁止制作、传播计算机病毒，向社会发布虚假计算机病毒疫情，承担计算机病毒的认定工作的机构应由公安部公共信息网络安全监察部门批准，计算机信息系统的使用单位应当履行防治计算机病毒的职责。</p>
<h3 id="信息安全保障体系"><a href="#信息安全保障体系" class="headerlink" title="信息安全保障体系"></a>信息安全保障体系</h3><p>对一个信息网络，必须从总体上规划，建立一个科学全面的信息安全保障体系，从而实现信息系统的整体安全。一个全面的信息安全保障体系，应该能够解决信息系统存在的大部分安全威胁。目前的信息安全威胁主要有：针对系统稳定性和可靠性的破坏行为，包括从外部网络针对内部网络的攻击入侵行为和病毒破坏等；大量信息设备的使用、维护和管理问题，包括违反规定的计算机、打印机和其他信息基础设施的滥用，以及信息系统违规使用软件和硬件的行为；知识产权和内部机密材料等有价值信息存储、使用和传输的保密性、完整性和可靠性存在可能的威胁，其中尤其以信息的保密性存在威胁的可能性最大。</p>
<p>针对这些复杂且技术手段各异的信息安全威胁，要建立一个完整的信息安全保障体系，包含以下几个方面的内容。</p>
<p>1）建立统一的身份认证体系</p>
<p>身份认证是信息交换最基础的要素，如果不能确认交换双方的实体身份，那么信息的安全就根本无从得到保证。身份认证的含义是广泛的，其泛指一切实体的身份，包括人、计算机、设备和应用程序等，只有确认了所有这些信息在存储、使用和传输中可能涉及的实体，信息的安全性才有可能得到基本保证。</p>
<p>2）建立统一的信息安全管理体系</p>
<p>建立对所有信息实体有效的信息安全管理体系，对信息网络系统中的所有计算机、输出端口、存储设备、网络、应用程序和其他设备进行有效集中的管理，从而有效管理和控制信息网络中存在的安全风险。信息安全管理体系的建立主要集中在技术性系统的建立上，同时，也应该建立相应的管理制度，才能使信息安全管理系统得到有效实施。</p>
<p>3）建立规范的信息安全保密体系</p>
<p>信息的保密性是一个大型信息应用网络不可缺少的需求，所以，必须建立符合规范的信息安全保密体系。这个体系不仅仅应该提供完善的技术解决方案，也应该建立相应的信息保密管理制度。</p>
<p>4）建立完善的网络边界防护体系</p>
<p>重要的信息网络一般会跟公共的互联网进行一定程度的分离，在内部信息网络和互联网之间存在一个网络边界。必须建立完善的网络边界防护体系，使得内部网络既能够与外部网络进行信息交流，同时也能防止从外网发起的对内部网络的攻击等安全威胁。</p>
<p>此外，要加快信息安全立法，建立信息安全法制体系，这样才能做到有法可依、有法必依。建立国家信息安全组织管理体系，加强国家信息安全机构及职能；建立高效能的、职责分工明确的行政管理和业务组织体系；建立信息安全标准和评估体系；建立国家信息安全技术保障体系，使用科学技术实施安全的防护保障。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><h4 id="信息系统安全属性"><a href="#信息系统安全属性" class="headerlink" title="信息系统安全属性"></a>信息系统安全属性</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231922.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231922.png';" /></details>

<p>不可抵赖性：数字签名</p>
<h4 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h4><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906232249.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906232249.png';" /></details>

<p>rar加密是对称加密，解密输入的密码和加密的密码一致</p>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906232302.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906232302.png';" /></details>

<p>加密速度慢，适合小数据</p>
<h4 id="信息摘要"><a href="#信息摘要" class="headerlink" title="信息摘要"></a>信息摘要</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906232904.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906232904.png';" /></details>

<p>原始信息发生变化，摘要也会发生变化</p>
<p>使用单向散列函数</p>
<h4 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906233235.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906233235.png';" /></details>

<p>用A的私钥加密，叫数字签名，A的公钥解密叫做验证过程</p>
<p>数字签名+信息摘要结合起来使用</p>
<h4 id="数字证书与PGP"><a href="#数字证书与PGP" class="headerlink" title="数字证书与PGP"></a>数字证书与PGP</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906233527.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906233527.png';" /></details> 

<p>传公钥的时候被截获</p>
<h4 id="设计邮件加密系统"><a href="#设计邮件加密系统" class="headerlink" title="设计邮件加密系统"></a>设计邮件加密系统</h4><p>要求邮件以加密方式传输，邮件最大附件内容可达50OMB，发送者不可抵赖，若邮件被第三方截获,第三方无法篡改。</p>
<p>信息摘要+数字签名+数据证书</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907083954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907083954.png';" /></details>

<h4 id="PKI公钥体系"><a href="#PKI公钥体系" class="headerlink" title="PKI公钥体系"></a>PKI公钥体系</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084024.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084024.png';" /></details>

<p>基于非对称，类似数字证书</p>
<ul>
<li>证书颁发机构（CA, Certificate Authority）</li>
</ul>
<h4 id="PKI公钥系分层情况"><a href="#PKI公钥系分层情况" class="headerlink" title="PKI公钥系分层情况"></a>PKI公钥系分层情况</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084245.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084245.png';" /></details>

<ul>
<li>密匙管理中心，（kmc，key management center）</li>
<li>公钥基础设施 （pki，Public Key Infrastructure ）</li>
<li>注册机构（RA，register Authority）</li>
</ul>
<h4 id="信息系统安全保证层次"><a href="#信息系统安全保证层次" class="headerlink" title="信息系统安全保证层次"></a>信息系统安全保证层次</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084347.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084347.png';" /></details>

<p>访问控制：权限这一层</p>
<p>强制访问控制：分层</p>
<p>基于任务的访问控制:OA</p>
<h4 id="安全审核与安全系统设计原则"><a href="#安全审核与安全系统设计原则" class="headerlink" title="安全审核与安全系统设计原则"></a>安全审核与安全系统设计原则</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084752.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084752.png';" /></details>

<p>安全审计:从日志了解</p>
<h4 id="各个网络层次的安全保障"><a href="#各个网络层次的安全保障" class="headerlink" title="各个网络层次的安全保障"></a>各个网络层次的安全保障</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084954.png';" /></details>

<h4 id="网络威胁与共计"><a href="#网络威胁与共计" class="headerlink" title="网络威胁与共计"></a>网络威胁与共计</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907085356.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907085356.png';" /></details>

<p>业务流分析：跟窃听比有分析的成分</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907085530.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907085530.png';" /></details>


<h4 id="DOS和DDOS共计"><a href="#DOS和DDOS共计" class="headerlink" title="DOS和DDOS共计"></a>DOS和DDOS共计</h4><p>破坏可用性</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907085934.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907085934.png';" /></details>


<h4 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090013.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090013.png';" /></details>


<h4 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090340.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090340.png';" /></details>

<h4 id="计算机病毒与木马"><a href="#计算机病毒与木马" class="headerlink" title="计算机病毒与木马"></a>计算机病毒与木马</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090736.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090736.png';" /></details>



<h4 id="法律法规知识-保护年限"><a href="#法律法规知识-保护年限" class="headerlink" title="法律法规知识(保护年限)"></a>法律法规知识(保护年限)</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143758.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143758.png';" /></details>

<h4 id="法律法规知识-知识产权人确定"><a href="#法律法规知识-知识产权人确定" class="headerlink" title="法律法规知识(知识产权人确定)"></a>法律法规知识(知识产权人确定)</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144046.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144046.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144247.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144247.png';" /></details>

<h4 id="侵权判定"><a href="#侵权判定" class="headerlink" title="侵权判定"></a>侵权判定</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144431.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144431.png';" /></details>


<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144610.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144610.png';" /></details>


<h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144854.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144854.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144915.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144915.png';" /></details>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/index/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/index/">1</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/index/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/31/">31</a><a class="extend next" rel="next" href="/index/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">310</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


</body>
</html>
