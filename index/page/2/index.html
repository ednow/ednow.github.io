<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ednow">
<meta property="og:url" content="http://ednow.github.io/index/page/2/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ednow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ednow.github.io/index/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/24/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ch1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/24/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ch1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">王道-计算机网络-ch1-计算机网络体系结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-24 09:08:58" itemprop="dateCreated datePublished" datetime="2021-07-24T09:08:58+08:00">2021-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-27 09:46:35" itemprop="dateModified" datetime="2021-07-27T09:46:35+08:00">2021-07-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>【考纲内容】</p>
<p>(一）计算机网络概述</p>
<p>计算机网络的概念、组成与功能;</p>
<p>计算机网络的分类</p>
<p>计算机网络的性能指标</p>
<p>(二）计算机网络体系结构与参考模型</p>
<p>计算机网络分层结构;计算机网络协议、接口、服务的概念</p>
<p>ISO/OSI参考模型和 TCP/IP模型</p>
<p>【复习提示】</p>
<p>本章主要介绍计算机网络体系结构的基本概念，读者可以在理解的基础上适当地记忆。重点掌握网络的分层结构（包括5层和7层结构)，尤其是ISO/OSI参考模型各层的功能及相关协议、接口和服务等概念。掌握有关网络的各种性能指标，特别是时延、带宽、速率和吞吐量等的计算。</p>
<p>OSI参考模型的功能</p>
<table>
<thead>
<tr>
<th>层</th>
<th>物理寻址</th>
<th>流量控制</th>
<th>差错校验</th>
<th>拥塞控制</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>处理信号通过介质的传输</td>
</tr>
<tr>
<td>数据链路层</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{red}{\times}$(王道)</td>
<td>保证数据正确的顺序和完整性;链路连接的建立、拆除、分离;帧界定和帧同步;差错检测;物理寻址;数据重发</td>
</tr>
<tr>
<td>网络层</td>
<td></td>
<td></td>
<td></td>
<td>$\color{green}{\checkmark}$</td>
<td>控制报文通过网络的路由选择；提供面向连接和无连接的服务</td>
</tr>
<tr>
<td>传输层</td>
<td></td>
<td>$\color{green}{\checkmark}$</td>
<td></td>
<td>$\color{green}{\checkmark}$</td>
<td>仅提供面向连接的服务</td>
</tr>
<tr>
<td>会话层</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>应用层</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>提供用户和网络的接</td>
</tr>
</tbody></table>
<p>(raw page:课本的页码，pp:pdf page, pdf书籍阅读器的index)</p>
<blockquote>
<p>(王相林.rp.159)$\color{red}{\text{流量控制}}$是对一条通信路径上的流量进行控制，其目的是保证发送者的发送速度不超过接收者的接收速度。流量控制只设计一个发送者和一个接收者，涉及两个节点，可以是相邻节点之间，也可以是端节点之间，分别对应$\color{green}{\text{数据链路层}}$的相邻节点之间的流量控制，以及$\color{green}{\text{运输层}}$的端节点之间的流量控制。流量控制只涉及两个网络节点，属于是局部控制。<br>(王相林.rp.159)$\color{red}{\text{拥塞控制}}$是对整个通信子网的流量进行控制，其目的是保证通信子网的流量与网络可提供资源相匹配，不出现网络系统性能恶化、甚至崩溃的局面。拥塞控制涉及网络中多个节点（主机、路由器、交换机），属于是全局控制。拥塞控制的最终目标是，防止由于网络中PDU过载而使网络的吞吐量下降，合理分配网络资源；避免死锁；匹配速度传输速度。拥塞控制涉及的网络层次有：$\color{green}{\text{数据链路层}}$、$\color{green}{\text{网络层}}$和$\color{green}{\text{运输层}}$，而这些层次上对拥塞控制产生影响的策略，见表5-3。<br>流量控制涉及的层次有数据链路层和运输层。流量控制一般是由接收方根据自己缓冲区的大小和接收数据的情况，给发送方反馈流量控制信息，也就是说，是由接收方控制发送方发送数据的速率。流量控制与拥寒控制是相关的，若局部的流量控制做得很好，可以对全局的拥塞控制起到缓解的作用。</p>
</blockquote>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725152627.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725152627.png';" /></details>


<p>五层协议栈（Five-layer Internet protocol stack）</p>
<table>
<thead>
<tr>
<th>名称(name)</th>
<th>协议（protocols)</th>
<th>分组名称（packet name）</th>
</tr>
</thead>
<tbody><tr>
<td>应用层（Application Layer）</td>
<td>HTTP（WEB文档的请求和传送）<br /> SMTP（电子邮件）<br /> FTP（端系统间文件传送）</td>
<td>报文（message）</td>
</tr>
<tr>
<td>传输层（Transport Layer）</td>
<td>TCP<br />   UDP</td>
<td>报文段(segment);报文段(TCP);用户数据报(UDP)</td>
</tr>
<tr>
<td>网络层（Network Layer）</td>
<td>IP层</td>
<td>数据报(datagram)</td>
</tr>
<tr>
<td>链路层（Link Layer）</td>
<td>以太网<br />    WiFi<br />               电缆接入网的DOCSIS协议</td>
<td>帧(frame)</td>
</tr>
<tr>
<td>物理层（physical Layer）</td>
<td></td>
<td>比特(bit)</td>
</tr>
</tbody></table>
<p>物理设备</p>
<table>
<thead>
<tr>
<th>设备名</th>
<th>工作层</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>集线器(HUB)</td>
<td>物理层</td>
<td>多端口中继器</td>
</tr>
<tr>
<td>交换机(Switch)</td>
<td>数据链路层</td>
<td>多端口网桥</td>
</tr>
<tr>
<td>路由器(Router)</td>
<td>网络层</td>
<td>实现了网络模型的下三层，即物理层、数据链路层和网络层</td>
</tr>
</tbody></table>
<h3 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h3><h4 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h4><p>一般认为，计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。简而言之，计算机网络就是一些$\color{green}{\text{互联的}}$、$\color{green}{\text{自治}}$的$\color{green}{\text{计算机系统}}$的$\color{green}{\text{集合}}$。</p>
<p>在计算机网络发展的不同阶段，人们对计算机网络给出了不同的定义，这些定义反映了当时网络技术发展的水平。这些定义可分为以下三类。</p>
<h5 id="广义观点"><a href="#广义观点" class="headerlink" title="广义观点"></a>广义观点</h5><p>这种观点认为，只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，都是计算机网络。广义的观点定义了一个计算机通信网络，它在物理结构上具有计算机网络的雏形，但资源共享能力弱，是计算机网络发展的低级阶段。</p>
<h5 id="资源共享观点"><a href="#资源共享观点" class="headerlink" title="资源共享观点"></a>资源共享观点</h5><p>这种观点认为，计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。该定义包含三层含义:①目的——资源共享;②组成单元——分布在不同地理位置的多台独立的“自治计算机”;③网络中的计算机必须遵循的统一规则——网络协议。该定义符合目前计算机网络的基本特征。</p>
<h5 id="用户透明性观点"><a href="#用户透明性观点" class="headerlink" title="用户透明性观点"></a>用户透明性观点</h5><p>这种观点认为，存在一个能为用户自动管理资源的网络操作系统，它能够调用用户所需要的资源，而整个网络就像一个大的计算机系统一样对用户是透明的。用户使用网络就像使用一台单一的超级计算机，无须了解网络的存在、资源的位置信息。用户透明性观点的定义描述了一个分布式系统，它是网络未来发展追求的目标。</p>
<h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><p>从不同的角度，可以将计算机网络的组成分为如下几类。</p>
<p>1)从组成部分上看，一个完整的计算机网络主要由$\color{green}{\text{硬件}}$、$\color{green}{\text{软件}}$、$\color{green}{\text{协议}}$三大部分组成，缺一不可。硬件主要由主机（也称端系统)、通信链路（如双绞线、光纤)、交换设备（如路由器、交换机等）和通信处理机（如网卡）等组成。软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件（如网络操作系统、邮件收发程序、FTP程序、聊天程序等)。软件部分多属于应用层。协议是计算机网络的核心，如同交通规则制约汽车驾驶一样，协议规定了网络传输数据时所遵循的规范。</p>
<p>2）从工作方式上看，计算机网络（这里主要指Internet，即因特网）可分为$\color{green}{\text{边缘部分}}$和$\color{green}{\text{核心部分}}$。边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信(如传输数据、音频或视频）和资源共享;核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。图1.1给出了这两部分的示意图。</p>
<p>3）从功能组成上看，计算机网络由$\color{green}{\text{通信子网}}$和$\color{green}{\text{资源子网}}$组成。通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。资源子网是实现资源共享功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724094736.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724094736.png';" /></details>

<h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><p>计算机网络的功能很多，现今的很多应用都与网络有关。主要有以下五大功能。</p>
<h5 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h5><p>它是计算机网络最基本和最重要的功能，用来实现联网计算机之间各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。例如，文件传输、电子邮件等应用，离开了计算机网络将无法实现。</p>
<h5 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h5><p>资源共享可以是软件共享、数据共享，也可以是硬件共享。它使计算机网络中的资源互通有无、分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率。</p>
<h5 id="分布式处理"><a href="#分布式处理" class="headerlink" title="分布式处理"></a>分布式处理</h5><p>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源以提高整个系统的利用率。</p>
<h5 id="提高可靠性"><a href="#提高可靠性" class="headerlink" title="提高可靠性"></a>提高可靠性</h5><p>计算机网络中的各台计算机可以通过网络互为替代机。</p>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>将工作任务均衡地分配给计算机网络中的各台计算机。</p>
<p>除以上几大主要功能外，计算机网络还可以实现电子化办公与服务、远程教育、娱乐等功能，满足了社会的需求，方便了人们学习、工作和生活，具有巨大的经济效益。</p>
<h4 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h4><h5 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h5><p>1)广域网（WAN)。广域网的任务是提供长距离通信，运送主机所发送的数据，其覆盖范围通常是直径为几十千米到几千千米的区域，因而有时也称远程网。广域网是因特网的核心部分。连接广域网的各结点交换机的链路一般都是高速链路，具有较大的通信容量。</p>
<p>2）城域网(MAN)。城域网的覆盖范围可以跨越几个街区甚至整个城市，覆盖区域的直径范围是5~50km。城域网大多采用以太网技术，因此有时也常并入局域网的范围讨论。</p>
<p>3）局域网（LAN)。局域网一般用微机或工.作站通过高速线路相连，覆盖范围较小，通常是直径为几十米到几千米的区域。局域网在计算机配置的数量上没有太多的限制，少的可以只有两台，多的可达几百台。传统上，局域网使用广播技术，而广域网使用交换技术。</p>
<p>4）个人区域网(PAN)。个人区域网是指在个人工作的地方将消费电子设备（如平板电脑、智能手机等）用无线技术连接起来的网络，也常称为无线个人区域网（WPAN)，覆盖区域的直径约为10m。</p>
<blockquote>
<p>注意:若中央处理器之间的距离非常近(如仅1m的数量级或甚至更小)，则一般称为多处理器系统，而不称为计算机网络。</p>
</blockquote>
<h5 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h5><p>1)广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组。局域网基本上都采用广播式通信技术，广域网中的无线、卫星通信网络也采用广播式通信技术。</p>
<p>2）点对点网络。每条物理线路连接一对计算机。若通信的两台主机之间没有直接连接的线路，则它们之间的分组传输就要通过中间结点进行接收、存储和转发，直至目的结点。是否采用分组存储转发与路由选择机制是点对点式网络与广播式网络的重要区别，广域网基本都属于点对点网络。</p>
<h5 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h5><p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系（如总线形、环形)表示的网络结构，主要指通信子网的拓扑结构。</p>
<p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系（如总线形、环形)表示的网络结构，主要指通信子网的拓扑结构。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724095447.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724095447.png';" /></details>

<p>1）总线形网络。用单根传输线把计算机连接起来。总线形网络的优点是建网容易、增/减结点方便、节省线路。缺点是重负载时通信效率不高、总线任意一处对故障敏感。</p>
<p>2）星形网络。每个终端或计算机都以单独的线路与中央设备相连。中央设备早期是计算机，现在一般是交换机或路由器。星形网络便于集中控制和管理，因为端用户之间的通信必须经过中央设备。缺点是成本高、中心设备对故障敏感。</p>
<p>3）环形网络。所有计算机接口设备连接成一个环。环形网络最典型的例子是$\color{green}{\text{令牌环局域网}}$。环可以是单环，也可以是双环，环中信号是单向传输的。</p>
<p>4）网状网络。一般情况下，每个结点至少有两条路径与其他结点相连，多用在广域网中。其有规则型和非规则型两种。其优点是可靠性高，缺点是控制复杂、线路成本高。以上4种基本的网络拓扑结构可以互联为更复杂的网络。</p>
<p>以上4种基本的网络拓扑结构可以互联为更复杂的网络。</p>
<h5 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h5><p>1）公用网（Public Network)。指电信公司出资建造的大型网络。“公用”的意思是指所有愿意按电信公司的规定交纳费用的人都可以使用这种网络，因此也称公众网。</p>
<p>2）专用网（Private Network)。指某个部门为满足本单位特殊业务的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如铁路、电力、军队等部门的专用网。</p>
<h5 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h5><p>交换技术是指各台主机之间、各通信设备之间或主机与通信设备之间为交换信息所采用的数据格式和交换装置的方式。按交换技术可将网络分为如下几种。</p>
<p>1)电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网是传统电话网络。该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送、时延小。缺点是线路利用率低、不能充分利用线路容量、不便于进行差错控制。</p>
<p>2)报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。报文交换网络也称存储-转发网络，主要特点是整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一个结点。优点是可以较为充分地利用线路容量，可以实现不同链路之间不同数据传输速率的转换，可以实现格式转换，可以实现一对多、多对一的访问，可以实现差错控制。缺点是增大了资源开销（如辅助信息导致处理时间和存储资源的开销)，增加了缓冲时延，需要额外的控制机制来保证多个报文的顺序不乱序，缓冲区难以管理（因为报文的大小不确定，接收方在接收到报文之前不能预知报文的大小)。</p>
<p>3）分组交换网络，也称包交换网络。其原理是，将数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包)，以存储-转发方式传输。其主要特点是单个分组（它只是整个报文的一部分）传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点:缓冲易于管理;包的平均时延更小，网络占用的平均缓冲区更少;更易于标准化;更适合应用。现在的主流网络基本上都可视为分组交换网络。</p>
<blockquote>
<p>报文交换和分组交换的区别：整个报文在网络中传递，分组交换报文被分割了</p>
</blockquote>
<h5 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h5><p>传输介质可分为有线和无线两大类，因此网络可以分为有线网络和无线网络。有线网络又分为双绞线网络、同轴电缆网络等。无线网络又可分为蓝牙、微波、无线电等类型。</p>
<h4 id="计算机网络的标准化工作及相关组织"><a href="#计算机网络的标准化工作及相关组织" class="headerlink" title="*计算机网络的标准化工作及相关组织"></a>*计算机网络的标准化工作及相关组织</h4><p>计算机网络的标准化对计算机网络的发展和推广起到了极为重要的作用。</p>
<p>因特网的所有标准都以RFC (Request For Comments）的形式在因特网上发布，但并非每个RFC都是因特网标准，RFC要上升为因特网的正式标准需经过以下4个阶段。</p>
<p>1)）因特网草案（ Internet Draft)。这个阶段还不是RFC文档。</p>
<p>2）建议标准（Proposed Standard)。从这个阶段开始就成为RFC文档。3）草案标准（Draft Standard)。</p>
<p>4）因特网标准(Internet Standard)。</p>
<p>此外，还有试验的RFC和提供信息的RFC。各种RFC之间的关系如图1.3所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724095943.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724095943.png';" /></details>

<p>在国际上，负责制定、实施相关网络标准的标准化组织众多，主要有如下几个:</p>
<ul>
<li>国际标准化组织(ISO)。其制定的主要网络标准或规范有OSI参考模型、HDLC等。</li>
<li>国际电信联盟(ITU)。其前身为国际电话电报咨询委员会(CCITT)，其下属机构ITU-T制定了大量有关远程通信的标准。</li>
<li>国际电气电子工程师协会（IEEE)。世界上最大的专业技术团体，由计算机和工程学专业人士组成。IEEE在通信领域最著名的研究成果是802标准。</li>
</ul>
<h4 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h4><p>性能指标从不同方面度量计算机网络的性能。常用的性能指标如下。</p>
<p>1）带宽（Bandwidth)。本来表示通信线路允许通过的信号频带范围，单位是赫兹（Hz)。而在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“最高数据传输速率”的同义语，单位是比特/秒( b/s）。</p>
<p>2）时延(Delay)。指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成:发送时延、传播时延、处理时延和排队时延。</p>
<ul>
<li>发送时延。结点将分组的所有比特推向（传输）链路所需的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间，因此也称传输时延。计算公式为：发送时延=分组长度/信道宽度</li>
<li>传播时延。电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的一端传播到另一端所需的时间。计算公式为：传播时延=信道长度/电磁波在信道上的传播速率</li>
<li>处理时延。数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等。</li>
<li>排队时延。分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</li>
</ul>
<p>因此，数据在网络中经历的总时延就是以上4部分时延之和:</p>
<p>总时延一发送时延＋传播时延＋处理时延＋排队时延</p>
<blockquote>
<p>注意:做题时，排队时延和处理时延一般可忽略不计（除非题目另有说明)。另外，对于高速链路，提高的仅是数据发送速率而非比特在链路上的传播速率。提高数据的发送速率只是为了减少数据的发送时延。</p>
</blockquote>
<p>3）时延带宽积。指发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特，因此又称以比特为单位的链路长度，即时延带宽积=传播时延×信道带宽。</p>
<p>如图1.4所示，考虑一个代表链路的圆柱形管道，其长度表示链路的传播时延，横截面积表示链路带宽，则时延带宽积表示该管道可以容纳的比特数量。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724100452.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724100452.png';" /></details>

<p>4)）往返时延(Round-Trip Time，RTT)。指从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认)，总共经历的时延。在互联网中，往返时延还包括各中间结点的处理时延、排队时延及转发数据时的发送时延。</p>
<p>5）吞吐量(Throughput)。指单位时间内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络额定速率的限制。</p>
<p>6）速率(Speed)。网络中的速率是指连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据传输速率、数据率或比特率，单位为 bl/s （比特/秒)(或bit/s，有时也写为bps)。数据率较高时，可用kb/s (k = 103)、Mb/s (M = 10°）或Gb/s (G = 10’)表示。在计算机网络中，通常把最高数据传输速率称为带宽。</p>
<p>7)信道利用率。指出某一信道有百分之多少的时间是有数据通过的，即信道利用率=有数据通过时间/(有+无)数据通过时间。</p>
<blockquote>
<p>结合计网期末考的概念：传输时延，重点在<code>输送</code>，传播实验，重点在<code>广播</code>（$\color{red}{\text{Q}}$：好像王道的传播和自顶向下的传播不是指一个东西）<br>注意带宽的单位是$\text{比特}/s=b/s$,不可以是$\text{字节}/s=B/s$！！</p>
</blockquote>
<p>网络的<a target="_blank" rel="noopener" href="https://blog.csdn.net/wanghaobo920/article/details/11877589">报文流和字节流</a>，程序中的<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/89316568.html">字符流和字节流</a></p>
<p><a target="_blank" rel="noopener" href="https://www.javapedia.net/JMS/1106">字节流和报文流</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/100037179">jms和socket</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hzq3554055/p/12004633.html">jms和amqp和rabbitmq的区别</a></p>
<h3 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h3><h4 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h4><p>两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对计算机网络的体系结构以分层的方式进行建模。</p>
<p>我们把计算机网络的各层及其协议的集合称为网络的体系结构（Architecture)。换言之，计算机网络的体系结构就是这个计算机网络及其所应完成的功能的精确定义，它是计算机网络中的层次、各层的协议及层间接口的集合。需要强调的是，这些功能究竟是用何种硬件或软件完成的,则是一个遵循这种体系结构的实现(Implementation)问题。体系结构是抽象的，而实现是具体的，是真正在运行的计算机硬件和软件。</p>
<p>计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分成若干较容易实现的层次。分层的基本原则如下:</p>
<p>1）每层都实现一种相对独立的功能，降低大系统的复杂度。</p>
<p>2）各层之间界面自然清晰，易于理解，相互交流尽可能少。</p>
<p>3）各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现。</p>
<p>4）保持下层对上层的独立性，上层单向使用下层提供的服务。</p>
<p>5）整个分层结构应能促进标准化工作。</p>
<p>由于分层后各层之间相对独立，灵活性好，因而分层的体系结构易于更新（替换单个模块)易于调试，易于交流，易于抽象，易于标准化。但层次越多，有些功能在不同层中难免重复出现，产生额外的开销，导致整体运行效率越低。层次越少，就会使每层的协议太复杂。因此，在分层时应考虑层次的清晰程度与运行效率间的折中、层次数量的折中。</p>
<p>依据一定的规则，将分层后的网络从低层到高层依次称为第1层、第2层……第n层，通常还为每层取一个特定的名称，如第1层的名称为$\color{green}{\text{物理层}}$。</p>
<p>在计算机网络的分层结构中，第n层中的活动元素通常称为第n层实体。具体来说，实体指任何可发送或接收信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为$\color{green}{\text{对等层}}$，同一层的实体称为$\color{green}{\text{对等实体}}$。第n层实体实现的服务为第n +1层所利用。在这种情况下，第n层称为$\color{green}{\text{服务提供者}}$，第n+1层则服务于$\color{green}{\text{用户}}$。</p>
<p>每一层还有自己传送的数据单位，其名称、大小、含义也各有不同。</p>
<p>在计算机网络体系结构的各个层次中，每个报文都分为两部分:一是数据部分，即SDU;二是控制信息部分，即 PCI，它们共同组成PDU。</p>
<p>服务数据单元(SDU):为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。</p>
<p>协议控制信息(PCI):控制协议操作的信息。第n层的协议控制信息记为n-PCI。</p>
<p>协议数据单元(PDU):对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据单元记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为$\color{green}{\text{比特}}$，数据链路层的PDU称为$\color{green}{\text{帧}}$，网络层的PDU称为$\color{green}{\text{分组}}$，传输层的PDU称为$\color{green}{\text{报文段}}$。</p>
<p>在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI,就变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反的处理，因此可知三者的关系为n-SDU + n-PCI = n-PDU=(n- 1)-SDU，其变换过程如图1.5所示。</p>
<details><summary>图1.5网络各层数据单元的联系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724162854.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724162854.png';" /></details>

<p>1)第n层的实体不仅要使用第n-1层的服务来实现自身定义的功能，还要向第n+1层提供本层的服务，该服务是第n层及其下面各层提供的服务总和。</p>
<p>2）最低层只提供服务，是整个层次结构的基础;中间各层既是下一层的服务使用者，又是上一层的服务提供者;最高层面向用户提供服务。</p>
<p>3)上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务;下一层所提供服务的实现细节对上一层透明。</p>
<p>4）两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方。</p>
<blockquote>
<p>也就是在物理上还是经过了下一层</p>
</blockquote>
<h4 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h4><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><p>协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则。这些规则明确规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议(Network Protocol)，它是控制两个(或多个）对等实体进行通信的规则的集合，是水平的。不对等实体之间是没有协议的，比如用TCP/IP 协议栈通信的两个结点，结点A的传输层和结点B的传输层之间存在协议，但结点A的传输层和结点B的网络层之间不存在协议。网络协议也简称为协议。</p>
<p>协议由语法、语义和同步三部分组成。语法规定了传输数据的格式;语义规定了所要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答;同步规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。一个完整的协议通常应具有线路管理（建立、释放连接)、差错控制、数据转换等功能。</p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点(Service Access Point，SAP）进行交互。服务是通过SAP提供给上层使用的，第n层的SAP就是第n+1层可以访问第n层服务的地方。每个SAP都有一个能够标识它的地址。SAP是一个抽象的概念，它实际上是一个逻辑接口（类似于邮政信箱)，但和通常所说的两个设备之间的硬件接口是很不一样的。</p>
<h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>服务是指下层为紧邻的上层提供的功能调用，它是垂直的。对等实体在协议的控制下，使得本层能为上一层提供服务，但要实现本层协议还需要使用下一层所提供的服务。</p>
<p>上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI参考模型中称为服务原语。OSI参考模型将原语划分为4类:(原语的主语用绿色高亮)</p>
<p>1）请求(Request)。由$\color{green}{\text{服务用户}}$发往服务提供者，请求完成某项工作。</p>
<p>2）指示(Indication)。由$\color{green}{\text{服务提供者}}$发往服务用户，指示用户做某件事情。</p>
<p>3）响应(Response)。由$\color{green}{\text{服务用户}}$发往服务提供者，作为对指示的响应。</p>
<p>4）证实(Confirmation)。由$\color{green}{\text{服务提供者}}$发往服务用户，作为对请求的证实。</p>
<p>这4类原语用于不同的功能，如建立连接、传输数据和断开连接等。有应答服务包括全部4类原语，而无应答服务则只有请求和指示两类原语。<br>4类原语的关系如图1.6所示。</p>
<details><summary>4类原语的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724163436.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724163436.png';" /></details>

<p>一定要注意，协议和服务在概念上是不一样的。首先，只有本层协议的实现才能保证向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议，即下面的协议对上层的服务用户是透明的。其次，协议是“$\color{green}{\text{水平的}}$”，即协议是控制对等实体之间通信的规则。但服务是“$\color{green}{\text{垂直的}}$”，即服务是由下层通过层间接口向上层提供的。另外，并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才称为服务。</p>
<p>协议、接口、服务三者之间的关系如图1.7所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724163750.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724163750.png';" /></details>

<p>计算机网络提供的服务可按以下三种方式分类。</p>
<p>( 1)面向连接服务与无连接服务</p>
<p>在面向连接服务中，通信前双方必须先建立连接，分配相应的资源（如缓冲区)，以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可以分为连接建立、数据传输和连接释放三个阶段。例如TCP就是一种面向连接服务的协议。</p>
<p>在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包（报文分组）传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务。这种服务常被描述为“尽最大努力交付”(Best-Effort-Delivery)，它并不保证通信的可靠性。例如$\color{green}{\text{IP}}$、$\color{green}{\text{UDP}}$就是一种无连接服务的协议。</p>
<p>(2)可靠服务和不可靠服务</p>
<p>可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。</p>
<p>不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。</p>
<p>对于提供不可靠服务的网络，其网络的正确性、可靠性要由应用或用户来保障。例如，用户收到信息后要判断信息的正确性，如果不正确，那么用户要把出错信息报告给信息的发送者，以便发送者采取纠正措施。通过用户的这些措施，可以把不可靠的服务变成可靠的服务。</p>
<blockquote>
<p>注意:在一层内完成的全部功能并非都称为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务。</p>
</blockquote>
<p>( 3）有应答服务和无应答服务</p>
<p>有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。所发送的应答既可以是肯定应答，也可以是否定应答，通常在接收到的数据有错误时发送否定应答。例如，文件传输服务就是一种有应答服务。</p>
<p>无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件后不给出应答。</p>
<h4 id="ISO-OSI参考模型和TCP-IP模型"><a href="#ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="ISO/OSI参考模型和TCP/IP模型"></a>ISO/OSI参考模型和TCP/IP模型</h4><h5 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h5><p>国际标准化组织(ISO）提出的网络体系结构模型，称为开放系统互连参考模型（OSI/RM),通常简称为OSI参考模型。OSI参考模型有7层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。低三层统称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能;高三层统称为资源子网，它相当于计算机系统，完成数据的处理等功能。传输层承上启下。OSI参考模型的层次结构如图1.8所示。</p>
<details><summary>图1.8 OSI参考模型的层次结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164119.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164119.png';" /></details>

<p>下面详述OSI参考模型各层的功能。</p>
<p>(1）物理层（Physical Layer)</p>
<p>物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地传输原始比特流。</p>
<p>物理层主要定义数据终端设备（DTE）和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称物理层接口标准。由于在通信技术的早期阶段,通信规则称为规程(Procedure),因此物理层协议也称物理层规程。</p>
<p>物理层接口标准很多，如EIA-232C、EIA/TIA RS-449、CCITT的X.21等。在计算机网络的复习过程中，不要忽略对各层传输协议的记忆，到了后期，读者对数据链路层、网络层、传输层和应用层的协议会比较熟悉，但往往容易忽视物理层的协议。</p>
<p>图1.9表示的是两个通信结点及它们间的一段通信链路，物理层主要研究以下内容:</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164314.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164314.png';" /></details>

<p>${\textstyle\unicode{x2460}}$  通信链路与通信结点的连接需要一些电路接口，物理层规定了这些接口的一些参数，如机械形状和尺寸、交换电路的数量和排列等，例如，笔记本电脑上的网线接口，就是物理层规定的内容之一。</p>
<p>${\textstyle\unicode{x2461}}$  物理层也规定了通信链路上传输的信号的意义和电气特征。例如物理层规定信号A代表数字0，那么当结点要传输数字0时，就会发出信号A，当结点接收到信号A时，就知道自己接收到的实际上是数字0。</p>
<blockquote>
<p>注意，传输信息所利用的一些物理媒体，如双绞线、光缆、无线信道等，并不在物理层协议之内而在物理层协议下面。因此，有人把物理媒体当作第О层。</p>
</blockquote>
<p>(2）数据链路层(Data Link Layer)</p>
<p>数据链路层的传输单位是帧，任务是将网络层传来的P数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理等。</p>
<p>由于外界噪声的干扰，原始的物理连接在传输比特流时可能发生错误。如图1.8所示，左边结点想向右边结点传输数字0，于是发出了信号A;但传输过程中受到干扰，信号A变成了信号B，而信号B又刚好代表1，右边结点接收到信号B时，就会误以为左边结点传送了数字1，从而发生差错。两个结点之间如果规定了数据链路层协议，那么可以检测出这些差错，然后把收到的错误信息丢弃，这就是差错控制功能。</p>
<p>如图1.9所示，在两个相邻结点之间传送数据时，由于两个结点性能的不同，可能结点A发送数据的速率会比结点B接收数据的速率快，如果不加控制，那么结点B就会丢弃很多来不及接收的正确数据，造成传输线路效率的下降。流量控制可以协调两个结点的速率，使结点A发送数据的速率刚好是结点B可以接收的速率。</p>
<p>广播式网络在数据链路层还要处理新的问题，即如何控制对共享信道的访问。数据链路层的一个特殊的子层—介质访问子层，就是专门处理这个问题的。</p>
<p>典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。</p>
<p>(3）网络层(Network Layer)</p>
<p>网络层的传输单位是数据报，它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p>
<p>如图1.10所示，结点A向结点B传输一个分组时，既可经过边a、c、g，也可经过边b、h，有很多条可以选择的路由，而网络层的作用就是根据网络的情况，利用相应的路由算法计算出一条合适的路径，使这个分组可以顺利到达结点B。</p>
<details><summary>图1.10某网络结构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164514.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164514.png';" /></details>

<p>流量控制与数据链路层的流量控制含义一样,都是协调A的发送速率和B的接收速率。</p>
<p>差错控制是通信两结点之间约定的特定检错规则，如奇偶校验码，接收方根据这个规则检查接收到的分组是否出现差错，如果出现了差错，那么能纠错就纠错，不能纠错就丢弃，确保向上层提交的数据都是无误的。</p>
<p>如果图1.10中的结点都处于来不及接收分组而要丢弃大量分组的情况,那么网络就处于拥塞状态，拥塞状态使得网络中的两个结点无法正常通信。网络层要采取一定的措施来缓解这种拥塞，这就是拥塞控制。</p>
<p>因特网是一个很大的互联网，它由大量异构网络通过路由器（(Router）相互连接起来。因特网的主要网络层协议是无连接的网际协议（Internet Protocol，P)和许多路由选择协议，因此因特网的网络层也称网际层或IP层。</p>
<p>注意，网络层中的“网络”一词并不是我们通常谈及的具体网络，而是在计算机网络体系结构中使用的专有名词。</p>
<p>网络层的协议有IP、IPX、ICMP、IGMP、ARP、RARP和OSPF等。</p>
<p>(4)传输层（Transport Layer)</p>
<p>传输层也称运输层，传输单位是报文段(TCP）或用户数据报（UDP)，传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。</p>
<p>数据链路层提供的是点到点的通信，传输层提供的是端到端的通信，两者不同。通俗地说，点到点可以理解为主机到主机之间的通信，一个点是指一个硬件地址或P地址，网络中参与通信的主机是通过硬件地址或P地址标识的;端到端的通信是指运行在不同主机内的两个进程之间的通信，一个进程由一个端口来标识，所以称为端到端通信。</p>
<p>使用传输层的服务，高层用户可以直接进行端到端的数据传输，从而忽略通信子网的存在。通过传输层的屏蔽，高层用户看不到子网的交替和变化。由于一台主机可同时运行多个进程，因此传输层具有复用和分用的功能。复用是指多个应用层进程可同时使用下面传输层的服务，分用是指传输层把收到的信息分别交付给上面应用层中相应的进程。</p>
<p>传输层的协议有TCP、UDP。</p>
<p>(5）会话层(Session Layer)</p>
<p>会话层允许不同主机上的各个进程之间进行会话。会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称建立同步(SYN)。</p>
<p>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。</p>
<p>(6）表示层（Presentation Layer)</p>
<p>表示层主要处理在两个通信系统中交换信息的表示方式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交换，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示变换功能。</p>
<p>(7）应用层（Application Layer）</p>
<p>应用层是OSI参考模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI参考模型环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。典型的协议有用于文件传送的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。</p>
<h5 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h5><p>ARPA在研究ARPAnet时提出了TCP/IP模型，模型从低到高依次为网络接口层（对应OSI参考模型中的物理层和数据链路层)、网际层、传输层和应用层（对应OSI参考模型中的会话层、表示层和应用层)。TCP/P由于得到广泛应用而成为事实上的国际标准。TCP/P模型的层次结构及各层的主要协议如图1.11所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164734.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164734.png';" /></details>

<p>网络接口层的功能类似于OSI参考模型的物理层和数据链路层。它表示与物理网络的接口，但实际上TCP/IP本身并未真正描述这一部分，只是指出主机必须使用某种协议与网络连接，以便在其上传递IP分组。具体的物理网络既可以是各种类型的局域网，如以太网、令牌环网、令牌总线网等，也可以是诸如电话网、SDH、X.25、帧中继和 ATM等公共数据网络。网络接口层的作用是从主机或结点接收IP分组，并把它们发送到指定的物理网络上。</p>
<p>网际层（主机-主机）是TCP/IP体系结构的关键部分。它和OSI参考模型的网络层在功能上非常相似。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层负责。网际层定义了标准的分组格式和协议，即P。当前采用的P协议是第4版，即IPv4，它的下一版本是IPv6。</p>
<p>传输层（应用-应用或进程-进程）的功能同样和OSI参考模型中的传输层类似，即使得发送端和目的端主机上的对等实体进行会话。传输层主要使用以下两种协议:</p>
<p>1）传输控制协议（Transmission Control Protocol，TCP)。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。</p>
<p>2）用户数据报协议（User Datagram Protocol，UDP)。它是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。应用层(用户-用户)包含所有的高层协议，如虚拟终端协议(Telnet)、文件传输协议(FTP)、域名解析服务(DNS)、电子邮件协议(SMTP）和超文本传输协议（HTTP)。</p>
<p>由图1.10可以看出，IP 协议是因特网中的核心协议;TCP/IP可以为各式各样的应用提供服务(所谓的everything over IP)，同时TCP/P 也允许IP协议在由各种网络构成的互联网上运行(所谓的IP over everything)。正因为如此，因特网才会发展到今天的规模。</p>
<h5 id="TCP-IP模型与OSl参考模型的比较"><a href="#TCP-IP模型与OSl参考模型的比较" class="headerlink" title="TCP/IP模型与OSl参考模型的比较"></a>TCP/IP模型与OSl参考模型的比较</h5><p>TCP/IP模型与OSI参考模型有许多相似之处。</p>
<p>首先，二者都采取分层的体系结构，将庞大且复杂的问题划分为若干较容易处理的、范围较小的问题，而且分层的功能也大体相似。</p>
<p>其次，二者都是基于独立的协议栈的概念。</p>
<p>最后，二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信。它们之间的比较如图1.12所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164828.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164828.png';" /></details>

<p>两个模型除具有这些基本的相似之处外，也有很多差别。</p>
<p>第一，OSI参考模型的最大贡献就是精确地定义了三个主要概念:服务、协议和接口，这与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分，不符合软件工程的思想。</p>
<p>第二，OSI参考模型产生在协议发明之前，没有偏向于任何特定的协议，通用性良好。但设计者在协议方面没有太多经验，不知道把哪些功能放到哪一层更好。TCP/IP模型正好相反，首先出现的是协议，模型实际上是对已有协议的描述，因此不会出现协议不能匹配模型的情况，但该模型不适合于任何其他非TCP/IP的协议栈。</p>
<p>第三，TCP/IP模型在设计之初就考虑到了多种异构网的互联问题，并将网际协议(P）作为一个单独的重要层次。OSI参考模型最初只考虑到用一种标准的公用数据网将各种不同的系统互联。OSI参考模型认识到P的重要性后，只好在网络层中划分出一个子层来完成类似于TCP/IP模型中的IP的功能。</p>
<p>第四，OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。这个不同点常常作为考查点。</p>
<p>无论是OSI参考模型还是TCP/IP模型，都不是完美的，对二者的讨论和批评都很多。OSI参考模型的设计者从工作的开始，就试图建立一个全世界的计算机网络都要遵循的统一标准。从技术角度来看，他们希望追求一种完美的理想状态，这也导致基于OSI参考模型的软件效率极低。OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低，这是它未能达到预期目标的重要原因。</p>
<p>无论是OSI参考模型还是TCP/P模型，都不是完美的，对二者的讨论和批评都很多。OSI参考模型的设计者从工作的开始，就试图建立一个全世界的计算机网络都要遵循的统一标准。从技术角度来看，他们希望追求一种完美的理想状态，这也导致基于OSI参考模型的软件效率极低。OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低，这是它未能达到预期目标的重要原因。</p>
<p>学习计算机网络时，我们往往采取折中的办法，即综合OSI参考模型和TCP/IP模型的优点，采用一种如图1.13所示的只有5层协议的体系结构，即我们所熟知的物理层、数据链路层、网络层、传输层和应用层。本书也采用这种体系结构进行讨论。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724165119.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724165119.png';" /></details>

<p>最后简单介绍使用通信协议栈进行通信的结点的数据传输过程。每个协议栈的最顶端都是一个面向用户的接口，下面各层是为通信服务的协议。用户传输一个数据报时，通常给出用户能够理解的自然语言，然后通过应用层，将自然语言会转化为用于通信的通信数据。通信数据到达传输层，作为传输层的数据部分（传输层SDU)，加上传输层的控制信息（传输层PCI)，组成传输层的PDU，然后交到网络层，传输层的PDU下放到网络层后，就成为网络层的SDU，然后加上网络层的PCI，又组成了网络层的PDU，下放到数据链路层，就这样层层下放，层层包裹，最后形成的数据报通过通信线路传输，到达接收方结点协议栈，接收方再逆向地逐层把“包裹”拆开,然后把收到的数据提交给用户，如图1.14所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724165141.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724165141.png';" /></details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.techopedia.com/definition/9005/protocol-stack">协议栈和分层的区别</a>，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Protocol_stack">维基百科协议栈的定义</a><br>为什么我感觉协议栈和分层是同一概念？见谢书</p>
</blockquote>
<h5 id="计算机网络与分布式计算机系统的主要区别是什么"><a href="#计算机网络与分布式计算机系统的主要区别是什么" class="headerlink" title="计算机网络与分布式计算机系统的主要区别是什么?"></a>计算机网络与分布式计算机系统的主要区别是什么?</h5><p>分布式系统最主要的特点是，整个系统中的各个计算机对用户都是透明的。用户通过输入命令就可以运行程序，但用户并不知道哪台计算机在为它运行程序。操作系统为用户选择一台最合适的计算机来运行其程序，并将运行的结果传送到合适的地方。</p>
<p>计算机网络则与之不同，用户必须先登录欲运行程序的计算机，然后按照计算机的地址，将程序通过计算机网络传送到该计算机中运行，最后根据用户的命令将结果传送到指定的计算机中。二者的区别主要是软件的不同。</p>
<blockquote>
<p>不是应该是计算机网路是网络的网络吗？</p>
</blockquote>
<h5 id="为什么一个网络协议必须考虑到各种不利的情况"><a href="#为什么一个网络协议必须考虑到各种不利的情况" class="headerlink" title="为什么一个网络协议必须考虑到各种不利的情况?"></a>为什么一个网络协议必须考虑到各种不利的情况?</h5><p>因为网络协议如果不全面考虑不利的情况，那么当情况发生变化时,协议就会保持理想状况，一直等下去!就如同两位朋友在电话中约好下午3点在公园见面，并且约定不见不散。这一―协议很不科学，因为任何一方如果有耽搁而来不了，且无法通知对方，那么另一方就要一直等下去!所以判断一个计算机网络是否正确，不能只看在正常情况下是否正确，还必须非常仔细地检查协议能否应付各种异常情况。</p>
<h5 id="因特网使用的P协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么为什么当初不把因特网的传输设计为可靠的呢"><a href="#因特网使用的P协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么为什么当初不把因特网的传输设计为可靠的呢" class="headerlink" title="因特网使用的P协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么为什么当初不把因特网的传输设计为可靠的呢?"></a>因特网使用的P协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么为什么当初不把因特网的传输设计为可靠的呢?</h5><p>传统电信网的主要用途是电话通信，并且普通电话机不是智能的，因此电信公司必须花费巨大的代价把电信网设计得非常好，以保证用户的通信质量。</p>
<p>数据的传送显然必须非常可靠。当初在设计ARPAnet时，很重要的讨论内容之一是:“谁应当负责数据传输的可靠性?”一种意见是主张应当像电信网那样，由通信网络负责数据传输的可靠性（因为电信网的发展历史及其技术水平已经证明，人们可以将网络设计得相当可靠);另一种意见则坚决主张由用户的主机负责数据传输的可靠性，理由是这样可使计算机网络便宜、灵活。</p>
<p>计算机网络的先驱认为，计算机网络和电信网的一个重大区别是终端设备的性能差别很大。于是，他们采用了“端到端的可靠传输”策略，即在传输层使用面向连接的TCP协议，这样既能使网络部分价格便宜且灵活可靠，又能保证端到端的可靠传输。</p>
<blockquote>
<p>计算机网络和电信网的一个重大区别是终端设备的性能差别很大。按照这层意思不就更应该把可靠传输这种繁琐的工作交给计算机网络更好了吗</p>
</blockquote>
<h5 id="有人说，宽带信道相当于高速公路车道数目增多了，可以同时并行地跑更多数量的汽车。虽然汽车的时速并没有提高（相当于比特在信道上的传播速率未提高-，但整个高速公路的运输能力却增多了，相当于能够传送更多数量的比特。这种比喻合适否"><a href="#有人说，宽带信道相当于高速公路车道数目增多了，可以同时并行地跑更多数量的汽车。虽然汽车的时速并没有提高（相当于比特在信道上的传播速率未提高-，但整个高速公路的运输能力却增多了，相当于能够传送更多数量的比特。这种比喻合适否" class="headerlink" title="有人说，宽带信道相当于高速公路车道数目增多了，可以同时并行地跑更多数量的汽车。虽然汽车的时速并没有提高（相当于比特在信道上的传播速率未提高)，但整个高速公路的运输能力却增多了，相当于能够传送更多数量的比特。这种比喻合适否?"></a>有人说，宽带信道相当于高速公路车道数目增多了，可以同时并行地跑更多数量的汽车。虽然汽车的时速并没有提高（相当于比特在信道上的传播速率未提高)，但整个高速公路的运输能力却增多了，相当于能够传送更多数量的比特。这种比喻合适否?</h5><p>可以这样比喻。但一定不能误认为“提高信道的速率是设法使比特并行地传输”。</p>
<p>如果一定要用汽车在高速公路上行驶和比特在通信线路上传输相比较，那么可以这样来想象:低速信道相当于汽车进入高速公路的时间间隔较长。例如，每隔1分钟有一辆汽车进入高速公路;“信道速率提高”相当于进入高速公路的汽车的时间间隔缩短了，例如，现在每隔6秒就有一辆汽车进入高速公路。虽然汽车在高速公路上行驶的速率无变化，但在同样的时间内，进入高速公路的汽车总数却增多了(每隔1分钟进入高速公路的汽车现在增加到10辆)，因而吞吐量也就增大了。</p>
<p>也就是说，当带宽或发送速率提高后，比特在链路上向前传播的速率并未提高，只是每秒注入链路的比特数增加了。“速率提高”就体现在单位时间内发送到链路上的比特数增多了，而并不是比特在链路上跑得更快了。</p>
<h5 id="端到端通信和点到点通信有什么区别"><a href="#端到端通信和点到点通信有什么区别" class="headerlink" title="端到端通信和点到点通信有什么区别?"></a>端到端通信和点到点通信有什么区别?</h5><p>从本质上说，由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务，而传输层为网络中的主机提供端到端的通信。</p>
<p>直接相连的结点之间的通信称为点到点通信，它只提供一台机器到另一台机器之间的通信，不涉及程序或进程的概念。同时，点到点通信并不能保证数据传输的可靠性，也不能说明源主机与目的主机之间是哪两个进程在通信，这些工作都是由传输层来完成的。</p>
<p>端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是比点到点通信更高一级的通信方式，以完成应用程序（进程）之间的通信。“端”是指用户程序的端口，端口号标识了应用层中不同的进程。</p>
<h5 id="如何理解传输速率、带宽和传播速率"><a href="#如何理解传输速率、带宽和传播速率" class="headerlink" title="如何理解传输速率、带宽和传播速率?"></a>如何理解传输速率、带宽和传播速率?</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727094533.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727094533.png';" /></details>

<blockquote>
<p>这个理解似乎与期末考的定义恰好相反</p>
</blockquote>
<h5 id="如何理解传输时延、发送时延和传播时延"><a href="#如何理解传输时延、发送时延和传播时延" class="headerlink" title="如何理解传输时延、发送时延和传播时延?"></a>如何理解传输时延、发送时延和传播时延?</h5><p>传输时延又称发送时延，是主机或路由器发送数据帧所需的时间，即从数据帧的第1比特算起，到该数据帧的最后1比特发送完毕所需要的时间。计算公式是</p>
<p>发送时延=数据帧长度/信道带宽</p>
<p>传播时延是电磁波在信道中传播一定的距离所花费的时间。计算公式是</p>
<p>传播时延=信道长度/电磁波在信道上的传播速率</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">总结-官方系统架构设计师教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 13:02:27" itemprop="dateCreated datePublished" datetime="2021-07-19T13:02:27+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-25 17:00:44" itemprop="dateModified" datetime="2021-07-25T17:00:44+08:00">2021-07-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="官方系统架构设计师教程"><a href="#官方系统架构设计师教程" class="headerlink" title="官方系统架构设计师教程"></a>官方系统架构设计师教程</h1><h1 id="凑数"><a href="#凑数" class="headerlink" title="凑数"></a>凑数</h1><h2 id="凑数-1"><a href="#凑数-1" class="headerlink" title="凑数"></a>凑数</h2><h3 id="凑数-2"><a href="#凑数-2" class="headerlink" title="凑数"></a>凑数</h3><h4 id="凑数-3"><a href="#凑数-3" class="headerlink" title="凑数"></a>凑数</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E6%80%BB%E7%BB%93-%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E6%80%BB%E7%BB%93-%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">总结-官方系统架构设计师教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 13:02:27" itemprop="dateCreated datePublished" datetime="2021-07-19T13:02:27+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-26 16:33:26" itemprop="dateModified" datetime="2021-07-26T16:33:26+08:00">2021-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="官方系统架构设计师教程"><a href="#官方系统架构设计师教程" class="headerlink" title="官方系统架构设计师教程"></a>官方系统架构设计师教程</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>随着技术的进步，信息系统的规模越来越大，复杂程度越来越高，系统的结构显得越来越重要。对于大规模的复杂系统来说，对总体的系统结构设计比起对计算的算法和数据结构的选择已经变得更重要，在这种情况下，人们认识到系统架构的重要性，设计并确定系统整体结构的质量成为了重要的议题。系统架构对于系统开发时所涉及到的成熟产品与相关的组织整合问题具有非常重要的作用，而系统架构师正是解决这些问题的专家。系统架构作为集成技术框架规范了开发和实现系统所必需的技术层面的互动，作为开发内容框架影响了开发组织和个人的互动，因此，技术和组织因素也是系统架构要讨论的主要话题。在系统开发项目中，系统架构师是项目的总设计师，是生产企业新产品、新技术体系的构建者，是目前系统开发中急需的高层次技术人才。</p>
<p>系统架构师是近几年来在国内外迅速成长并发展良好的一个职业，它对系统开发和信息化建设的重要性及给IT业所带来的影响是不言而喻的。在我国，虽然系统架构师的职业在工作内容、工作职责以及工作边界等方面还存在一定的模糊性和不确定性，但它确实是时代发展的需要，并正在实践中不断完善和成熟。</p>
<h3 id="系统架构的概念及其发展历史"><a href="#系统架构的概念及其发展历史" class="headerlink" title="系统架构的概念及其发展历史"></a>系统架构的概念及其发展历史</h3><h4 id="系统架构的概念"><a href="#系统架构的概念" class="headerlink" title="系统架构的概念"></a>系统架构的概念</h4><p>架构是一个古老的研究领域。在现实中，很多人认为架构就是一个有关建造一个物理结构的学科。但是，在设计一个信息系统架构时，计划（规划）的概念把架构和建设分割开来。</p>
<p>古代的文明对架构的发展有三个主要的贡献。一是多个建筑结构的完美结合。例如在用于装饰和建筑元素中的横梁、拱扇和柱子间的结合。第二个是建筑装饰形式和模式的广泛普及，这当中许多已经成为东西方宝贵文化遗产的一部分，许多还在被用于今天的建筑当中。第三就是有序规划的概念，规划是架构的基石，也就是这三个贡献中最重要的。现代信息系统的“架构”要素亦继承了这三个要素，即$\color{red}{\text{构件、模式和规划}}$。</p>
<p>现代信息系统的“架构”本质上存在两个层次：一个是概念的层次，一个是物理的层次。而概念层次则包含了艺术、科学、方法和建设风格。物理的层次是指在一系列的架构工作之后而产生的物理结构及其相互作用的结果。</p>
<p>在实际工作中，为了有效地管理公司和运营业务，首先必须定义和建立一系列清晰的、实用的信息及其处理流程。这就是在一个企业中的企业总体业务架构观念，所谓软件架构必须支持这一观念。</p>
<p>目前，软件架构已经成为软件工程领域的研究热点。作为大型软件系统与软件产品线开发中的关键技术之一，已发展为软件工程领域的一个独立学科分支。由于所属的专业领域、学术研究和实践内容的不同，研究人员对软件架构有不同的理解和定义。这里，定义如下：</p>
<p>软件系统架构是关于软件系统的结构、行为和属性的高级抽象。在描述阶段，其对象是直接构成系统的抽象组件以及各个组件之间的连接规则，特别是相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体类或者对象。软件系统架构不仅指定了软件系统的组织结构和拓扑结构，而且显示了系统需求和构成组件之间的对应关系，包括设计决策的基本方法和基本原理。</p>
<h4 id="简要的发展历史"><a href="#简要的发展历史" class="headerlink" title="简要的发展历史"></a>简要的发展历史</h4><p>企业软件架构（Enterprise Software Architecture），也叫做企业架构，是应用全面的和严格的方法描述一个针对信息系统、流程处理、个人和组织当前和/或未来行为的抽象结构集合，所以它们与组织的核心目标和战略方向结合，尽管一般来说与信息技术高度相关，但也与商业流程优化密切相关，因此也涉及商业模式、功能管理和过程架构。</p>
<p>企业软件架构的雏形来自企业建模的理论和思想。在20世纪80年代早期，除了学术界，很少有人对企业流程再造或企业建模的思想感兴趣，而且使用的理论和模型通常被限于某个信息系统的设计和开发。</p>
<p>到20世纪80年代中期，还在IBM工作的John Zachman首先引入“信息系统架构框架”的概念。Zachman被公认为是企业架构领域的开拓者，他认为使用一个逻辑的企业构造蓝图（即一个架构）来定义和控制企业系统和其组件的集成是非常有用的。为此，Zachman提出从信息、流程、网络、人员、时间和基本原理等6个视角来分析企业，并提供了与这些视角相对应的6个模型，包括语义、概念、逻辑、物理、组件和功能模型。</p>
<p>当时，Zachman并没有使用“企业架构”的概念。1996年美国的Clinger-Cohen法案（以前被称作信息技术管理改革法案）导致了术语“IT架构”的产生。这部法案的主旨是，美国政府指导下属联邦政府机构通过建立综合方法来管理信息技术的引入、使用和处置等。Clinger-Cohen法案要求政府机构的（Chief Information Officer, CIO）要负责开发、维护和帮助一个合理的和集成的IT架构（IT Architecture, ITA）的实施，当时的术语ITA，现在被解释为IT企业架构。</p>
<p>因此，企业软件架构的最早应用是在一些美国的政府机构，美国政府对企业架构应用的推动也发挥了十分重要的作用。自从Zachman框架引入后，首先是美国国家技术标准研究所在1989年发布NIST框架，从此联邦政府内出现了许多框架，其他联邦实体也发布了企业架构框架，包括国防部和财政部等。</p>
<p>1999年9月，美国联邦CIO委员会出版了联邦企业架构框架，它的意图是为联邦机构提供一个架构的公共结构，以利于这些联邦机构间的公共业务流程、技术引入、信息流和系统投资的协调等。</p>
<p>联邦企业架构框架定义了一个IT企业架构作为战略信息资产库，它定义了业务、运营业务所必须的业务信息，支持业务运行的必要的IT技术，响应业务变革实施新技术所必须的变革流程等要素。</p>
<p>随后，美国的管理和预算办公室（OMB）发布的OMB Circular A-130，要求机构记录和提交他们的初始的企业架构到OMB，并对架构发生的重大变革进行更新。这给了OMB一个责任，即帮助推动政府机构内和政府机构间的企业架构的开发，并支持通过使用IT来改进政府运营能力。</p>
<p>2002年2月，OMB建立了一个联邦企业架构程序管理办公室来开发FEA，它的作用是，在联邦机构程序内和跨机构程序间，通过跨部门的分析来找到重复的投资，找到相互的差距，有助于在联邦政府范围内的协作、互操作和交互作用。</p>
<p>企业软件架构的理念很快就得到咨询公司和研究机构认可，被Gartner收购的META Group是最早对企业软件架构进行分析和研究的主要咨询公司。2000年，META Group发布《企业体系机构桌面参考》，提供了一个经验证的实施企业软件架构的方法论，意图成功地构建业务战略和技术实施之间的桥梁。在咨询和研究机构带动下，IBM、微软、HIP、EDS等IT厂商也纷纷把目光集聚到了企业软件架构，希望能够从企业这个视角来定位其产品和服务。</p>
<p>随后，政府、应用企业、咨询和研究机构、厂商广泛参与，企业架构标准化的工作越来越重要，也产生了一些研究团体和标准框架。目前，业界最有名的企业架构框架是TOGAF（The Open Group Architecture Framework, Open Group架构框架），TOGAF是一个行业标准的架构框架，它可以被任何希望开发一个信息系统架构的组织在组织内免费使用。</p>
<p>从20世纪90年代中期开始，TOGAF已经被一些世界领先的IT客户和厂商开发和持续演进。与TOGAF类似的架构包括联邦政府企业架构框架、联邦政府企业架构指南、财政部企业架构框架、Spewak的企业架构规划、Zachman框架、OMG的MOD等。</p>
<p>企业软件架构实施的主体是企业，企业的需求才是软件架构发展的引擎。而企业软件的需求来源广泛，企业信息化需要支持市场需求、环境要求、经营需要、技术发展、用户要求以及法律需求，涉及企业的各个业务领域，而几乎所有领域都能够和信息技术相结合构成企业信息化项目。</p>
<p>软件架构的研究已发展为软件工程领域的一个独立学科分支，研究主要包括软件架构描述语言、软件架构的描述与表示、软件架构的分析与验证、基于架构的软件维护与演化、软件架构的可靠性等方面。</p>
<h3 id="系统架构师的定义与职业素质"><a href="#系统架构师的定义与职业素质" class="headerlink" title="系统架构师的定义与职业素质"></a>系统架构师的定义与职业素质</h3><p>通常从组织上划分，架构师分为以下几大类：业务架构师（Business Architect）、主题领域架构师（Domain Architect）、技术架构师（Technology Architect）、项目架构师（J2EE架构师、.NET架构师等）以及我们本书所阐述的系统架构师（System Architecture）。</p>
<h4 id="系统架构师的定义"><a href="#系统架构师的定义" class="headerlink" title="系统架构师的定义"></a>系统架构师的定义</h4><p>系统架构师是系统或产品线的设计责任人，是一个负责理解和管理并最终确认和评估非功能性系统需求（如软件的可维护性、性能、复用性、可靠性、有效性和可测试性等），给出开发规范，搭建系统实现的核心构架，对整个软件架构、关键构件、接口进行总体设计并澄清关键技术细节的高级技术人员。</p>
<p>系统架构师主要着眼于系统的“技术实现”，同时还要考虑系统的“组织协调”。因此，系统架构师是特定的开发平台、语言、工具的大师，对常见应用场景能及时给出最恰当的解决方案，同时要对所属的开发团队有足够的了解，能够评估该开发团队实现特定的功能需求目标的资源代价。可以说，系统架构师是信息系统开发和演进的全方位技术与管理人才。</p>
<h4 id="系统架构师技术素质"><a href="#系统架构师技术素质" class="headerlink" title="系统架构师技术素质"></a>系统架构师技术素质</h4><p>系统架构师通常负责公司系统的架构设计与持续改进，承担从业务向技术系统转换的桥梁作用；协助项目经理制定项目计划和控制项目进度；需要承担技术管理工作，如负责组织技术研究和攻关，负责组织和管理技术培训工作，管理技术支撑团队并给项目、产品开发实施团队提供技术保障。因此一个好的系统架构师的技术素质十分重要，通常系统架构师需要具有系统思维的能力，还必须具备以下技术素质：</p>
<ul>
<li>具备丰富的一线大中型开方案设计及技术队伍管理经验。</li>
<li>具备软件行业工作经验，熟悉业务领域的技术应用和发展。</li>
<li>具有项目管理理论基础，并在应用系统开发平台和项目管理上有实践经验。</li>
<li>对相关的技术标准有深刻的认识，对软件工程标准规范有良好的把握。</li>
<li>具备C/S或B/S体系结构或特定领域软件产品开发及架构和设计的经验。</li>
<li>具有面向对象分析（object-Oriented Analysis, OOA）、设计（Object-Oriented Design, OOD）、开发（Object-Oriented Programming, OOP）能力，精通UML和XML等，熟练使用Rational Rose、PowerDesigner等CASE工具进行设计开发。</li>
<li>对相关编程技术（如PHP/.Net/JAVA）及整个解决方案有深刻的理解及熟练的应用，并且精通架构和设计模式（如WebService/J2EE），并在此基础上设计产品框架。</li>
<li>精通大型数据库如Oracle、Sql Server、MySQL等的开发。</li>
<li>对计算机系统、网络和安全、应用系统架构等有全面的认识。</li>
<li>良好的团队意识和协作精神，有较强的内外沟通能力。</li>
</ul>
<h4 id="系统架构师管理素质"><a href="#系统架构师管理素质" class="headerlink" title="系统架构师管理素质"></a>系统架构师管理素质</h4><p>系统架构师管理素质是必须强调的。它包括远见、诚信、果断的领导素质。系统架构师是一个高效工作团队的建造者。作为核心的高层技术管理人员，架构师必须尽可能使所有团队人员的想法保持一致，为一个项目制订一个清晰的、强制性的、有远见的目标作为整个团队的动力，从而为达到整体目标所作的权衡提供基础。作为技术的领导者，系统架构师必须提供特定的方法和模型作为理想的技术解决方案；并排除各种非系统相关因素的影响。作为一个技术管理者，系统架构师在需要做出决定时，必须避免犹豫，必须具备及时解决技术问题的紧迫感和自信心。</p>
<h4 id="系统架构师与其他团队角色的协调"><a href="#系统架构师与其他团队角色的协调" class="headerlink" title="系统架构师与其他团队角色的协调"></a>系统架构师与其他团队角色的协调</h4><p>关于系统架构师的定位，在很多资料中都没有明确的表述，这里可以参照系统开发中的主要角色的给出描述。</p>
<p>根据全国计算机技术与软件专业技术资格（水平）考试的安排，其中作为高级工程师级别的职位有项目管理师、系统分析师和系统架构师（这里的系统架构主要是指软件系统的架构）。考试大纲对这三个职位的要求和职责定义如下。</p>
<p>（1）项目管理师：掌握信息系统项目管理的知识体系，具备管理大型、复杂信息系统项目和多项目的经验和能力；能根据需求组织制定可行的项目管理计划；能够组织项目实施，对项目的人员、资金、设备、进度和质量等进行管理，并能根据实际情况及时做出调整，系统地监督项目实施过程的绩效，保证项目在一定的约束条件下到达既定的项目目标；能分析和评估项目管理计划和成果；能在项目管理进展的早期发现问题，并有预防问题的措施；能协调项目所涉及的相关人员。即项目管理师的主要职责是负责整个项目的实施和控制，协调各种资源（包括组织内部资源和客户资源）。</p>
<p>（2）系统分析师：熟悉应用领域的业务，能分析用户的需求和约束条件，写出信息系统需求规格说明书，制订项目开发计划，协调项目开发与运行所涉及的各类人员；能指导制订企业的战略数据规划，组织开发项目；能评估和选用适宜的开发方法和工具；能按照标准规范编写系统分析、设计文档；能对开发过程进行质量控制与进度控制；能具体指导项目开发。即系统分析师的主要职责是获取并分析用户的需求，形成规范化的文档，指导整个项目的开发，需要与客户不断的交流，熟悉应用领域的业务。</p>
<p>（3）系统架构师：能够根据用户需求，结合用户应用领域的实际情况，设计正确、合理的软件构架，维护系统构件及其接口，并确保系统构架具有良好的性能；能够对项目进行系统构架级的描述、分析、设计与评估；能够按照相关标准编写相应的设计文档；具有扎实的理论功底、广博的知识面，能够与系统分析师、项目管理师相互协作、配合工作。即系统架构师的职责更加强调整体的、宏观的系统设计，重点在架构级别上。重点要对架构进行描述、分析和评估。</p>
<details><summary>图1-1　系统架构师的定位</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210719131623.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210719131623.png';" /></details>

<p>图1-1的上图反映了传统的系统开发：通过对用户的需求分析，组织必要的资源和设施，选择设计合适的架构，然后由项目经理统筹安排组织实施（包括人、财和物），这是一个反复互动，逐步契合的过程。</p>
<p>由上面所述可以看出，在传统的系统开发中，系统开发进度及统筹的管理主要由项目经理来完成，需求分析及技术实现主要由系统分析员或设计员来完成。由于项目经理、系统分析员或者程序员从各自职位角度出发产生冲突的制约，不可能很好地给出开发规范，搭建系统实现的核心构架，并澄清技术细节、扫清主要难点的技术，或者说最终难以确认和评估技术对需求实现产生的影响。所以我们把系统架构设计师定位在图1-1的下图中两个椭圆相交的部分，他负责整个系统的战略策划和技术实现。图1-1的上图说明架构设计先行和系统架构师、系统分析师、项目管理师三者的相互关系与作用。</p>
<h5 id="系统构架师与项目经理的关系及区别"><a href="#系统构架师与项目经理的关系及区别" class="headerlink" title="系统构架师与项目经理的关系及区别"></a>系统构架师与项目经理的关系及区别</h5><p>软件项目经理是指对项目控制/管理，关注项目本身的进度、质量、分配、调动、协调，管理好人、财、物等资源的负责人。对于软件项目经理来讲，职责包括项目计划、进度跟踪/监控、质量保证、配置/发布/版本/变更管理、人员绩效评估等方面。优秀的项目经理需要的素质，并不仅在于会使用几种软件或是了解若干抽象的方法论原则，更重要的在于从大量项目实践中获得的宝贵经验，以及交流、协调、激励的能力，甚至还应具备某种个性魅力或领袖气质（charisma）。一般来讲，技术人员重技术而倾向于忽视“人”的因素，而这正是项目经理管理活动的一个主要方面。项目经理还必须能够应付开发过程中大量的偶发事件和杂务。</p>
<p>在一个项目中，推动项目技术发展的是系统构架师。在技术方面，项目经理（项目管理师）配合系统构架师并提供各个方面的支持，其主要职责是与内外部沟通和管理资源（包括人），系统构架师则要负责提出系统的总体构架，并给出开发指导。</p>
<h5 id="系统构架师与系统分析师的关系及区别"><a href="#系统构架师与系统分析师的关系及区别" class="headerlink" title="系统构架师与系统分析师的关系及区别"></a>系统构架师与系统分析师的关系及区别</h5><p>系统分析师（system analyst）是在系统开发中进行业务需求分析、系统需求分析、可行性分析、业务建模和指导项目开发的人。其工作特点是与行业专家、用户沟通，及时与项目经理（项目管理师）、软件架构师协商，分析项目具备的特点、成本、风险等，考虑实现的模型。系统分析师所面临的往往是有许多不确定性的事件，需要对这些不确定的事件进行分析、总结，使之得出一个相对可靠的确定性结论或实施方案模型。一般意义上讲，系统分析师的水平将影响系统开发的质量，甚至成败。在一个完善的系统开发队伍中，一般应有项目管理师、软件架构师、系统分析师、软件设计师、测试工程师、数据库工程师、程序员和质量保证人员等不同的职位，还需要有业务专家和其他辅助人员。对于大型企业或项目，如果一人承担多个角色，往往容易发生顾此失彼的现象。</p>
<p>系统分析师对业务系统进行分析、建模，他的任务、目标是明确的。系统架构师协同系统分析师的工作，建议系统分析师按什么标准，什么工具，什么模式，什么技术去思考系统。同时，系统架构师应该对系统分析师所提出的问题，碰到的难题及时地提出解决的方法。</p>
<h3 id="系统架构师知识结构"><a href="#系统架构师知识结构" class="headerlink" title="系统架构师知识结构"></a>系统架构师知识结构</h3><p>软件系统架构师综合的知识能力结构包括9个方面，即：</p>
<p>（1）战略规划能力。</p>
<p>（2）业务流程建模能力。</p>
<p>（3）信息数据架构能力。</p>
<p>（4）技术架构选择和实现能力。</p>
<p>（5）应用系统架构的解决和实现能力。</p>
<p>（6）基础IT知识及基础设施、资源调配的能力。</p>
<p>（7）信息安全技术支持与管理保障能力。</p>
<p>（8）IT审计、治理与基本需求分析、获取能力。</p>
<p>（9）面向软件系统可靠性与系统生命周期的质量保障服务能力。</p>
<p>作为系统架构师，必须成为所在开发团队的技术路线引导者；具有很强的系统思维的能力；需要从大量互相冲突的系统方法和工具中区分出哪些是有效的，哪些是无效的。架构师应当是一个成熟的、丰富的、有经验的、有良好教育的、学习快捷、善沟通和决策能力强的人。丰富是指他必须具有业务领域方面的工作知识，知识来源于经验或者教育。他必须广泛了解各种技术并精通一种特定技术，至少了解计算机通用技术以便确定哪种技术最优，或组织团队开展技术评估。优秀的架构师能考虑并评估所有可用来解决问题的总体技术方案。需要良好的书面和口头沟通技巧，一般通过可视化模型和小组讨论来沟通指导团队确保开发人员按照架构建造系统。</p>
<p>因此，系统架构师知识维度可以总结为“多层次＋多方面”。所谓多层次，意味着系统架构师必须在体系结构、计算机软硬件与网络基础知识、信息化基础知识、信息安全与可靠性基础知识等基本功的层面上受过良好的教育和快捷的学习能力；还须在系统架构设计方法、设计模式、设计流程以及各种模型等方面有丰富的经验，广泛了解各种构件产品和技术并精通一种特定领域的架构设计；进一步，还须在系统架构设计实践层面，有自己的认识和理解，同时具有很强的表述能力；所谓多方面，意味着系统架构师在每个知识层面上必须具有技术、管理、心理和艺术等多方面的知识和能力。这和系统架构师的多角色特点是相关的。本书也正是从这个角度来介绍系统架构的知识体系，即从系统构件、模式和规划三个方面的技术基础、原理和方法的角度编写而成的关于软件架构师的基本知识结构和水平的教材。</p>
<h3 id="从开发人员到架构师"><a href="#从开发人员到架构师" class="headerlink" title="从开发人员到架构师"></a>从开发人员到架构师</h3><p>软件架构师一般都是具备计算机科学或软件工程的知识，由程序员做起，然后再慢慢成长为架构师的。在国内，很多大学目前还没有设立软件架构的学位课程，随着IT业界对设计和架构的兴趣日渐高涨，在学校课程中增加部分相关内容已不能满足产业发展的需要。一方面，大学要加强软件架构学课程的建设，另一方面，软件架构师的成长还应该有一个实践的教育过程，并不是简单地通过学校的理论学习或者通过某软件公司的认证就能成为合格的软件架构师。除了在学校学习信息系统综合知识外，软件架构师的大部分知识和经验将来自实际开发工作。根据软件架构师的任职条件，一名合格的软件架构师的成长应该经历8年以上的软件项目开发实际工作经验。一般需要经历程序员、软件设计师等阶段，然后再逐步成长为软件架构师。</p>
<p>当然，并不是每一位程序员经过8年后都可以成长为软件架构师。一个软件工程师在充分掌握了软件架构师工作所必需的基本理论和技能后，如何得到和利用机会、如何利用所掌握的技能进行应用系统的合理架构、如何不断的抽象和总结自己的架构模式、如何深入行业总结规律，成为能够胜任分析、架构为一体的精英人才，这是机遇、努力和天赋的综合结果。</p>
<p>就目前来看，国内软件架构师的培养途径主要有两种方式：一种是大学（软件学院）教育方式，另一种是个人自我培养然后再进行相应的培训和认证。但是，不管哪种方式都有其不足之处。</p>
<p>软件学院的培养方式能够系统的学习软件架构师必需的知识体系，但是，软件架构师不是简单的通过理论学习就能够培养出来的，软件学院的学生可能缺乏必要的设计、开发经验和相关的领域知识。尽管软件学院也强调给予学生实践的机会，但毕竟这种机会是有限的。即使有充分的机会，也没有足够的时间在实践中获得广泛的检验和验证。也包含一些管理因素，如有关“三分之一的师资来自企业”的规定，在部分软件学院中也没有得到真正落实，导致传授给学生的还是一些纯理论知识。</p>
<p>自我培养方式的主要对象是具有一定年限的软件开发和设计人员，如Microsoft、IBM、Sun等公司的软件架构师认证对学员的基础并没有具体的要求，只要交纳规定的费用，然后进行几天的集中培训，通过考试就发给学员证书，甚至不需要考试就直接发放证书。这些开发人员在自我培养的过程中不一定能够系统的学习软件架构师的理论知识，他们只具有一定的开发和设计经验，仅仅经过几天的培训，是不太可能培养出合格的软件架构师的。而且，作为某个厂商的培训和认证，其最终目的是培育自己的市场，培养一批忠诚的用户或产品的代言人，而不是为中国培养软件架构师。</p>
<p>在国外，软件架构师的培养与认证具有严格的过程，明确规定了教育目标、认证的要求和学习课程等方面的内容。下面，介绍三个组织的软件架构师的认证情况。</p>
<h5 id="UC-Irvine"><a href="#UC-Irvine" class="headerlink" title="UC Irvine"></a>UC Irvine</h5><p>在UC Irvine的软件架构师认证计划中，为了拿到软件架构师C级认证，学员必须完成11个单元的必修课程和至少4个单元的选修课程。这些课程如下：</p>
<ul>
<li><p>必修课程：软件系统建模和分析概论（2个单元）、系统分析基础（3个单元）、用户需求的分析和文档化（3个单元）、软件架构项目（3个单元）。</p>
</li>
<li><p>选修课程：信息系统项目管理（2个单元）、系统性能建模（2.5个单元）、管理业务改进项目（2.5个单元）。</p>
</li>
</ul>
<p>UC Irvine的软件架构师认证要求学员具有业务系统建模，决定用户需求，评价业务过程的能力，掌握项目管理技术，能设计完善的、具有最佳可适应性和可扩展性的架构。该认证程序以一门实践课程结束，在实践课程中，学员从头开始，设计一个大规模软件解决方案的架构。</p>
<h5 id="CMU-SEI"><a href="#CMU-SEI" class="headerlink" title="CMU/SEI"></a>CMU/SEI</h5><p>SEI在软件架构师方面的认证包括三个职位，分别是软件架构师、ATAM评估师和ATAM主任评估师。这些认证都需要学习两年的课程。其中软件架构师需要学习的课程有：软件架构原理与实践、软件架构文档化、软件架构设计与分析和软件产品线。</p>
<h5 id="iCMG"><a href="#iCMG" class="headerlink" title="iCMG"></a>iCMG</h5><p>iCMG对软件架构师的认证强调7个层次的课程学习。</p>
<p>软件架构师作为软件的总设计师，其水平和能力直接决定了软件系统的总体性能，对软件架构师的认证是十分重要和紧迫的。全国计算机技术与软件专业技术资格（水平）考试设立系统架构设计师级别的认证考试，是解决软件架构师认证问题的重要途径。</p>
<h2 id="计算机与网络基础知识"><a href="#计算机与网络基础知识" class="headerlink" title="计算机与网络基础知识"></a>计算机与网络基础知识</h2><h2 id="信息系统基础知识"><a href="#信息系统基础知识" class="headerlink" title="信息系统基础知识"></a>信息系统基础知识</h2><h2 id="系统开发基础知识"><a href="#系统开发基础知识" class="headerlink" title="系统开发基础知识"></a>系统开发基础知识</h2><h2 id="软件架构设计"><a href="#软件架构设计" class="headerlink" title="软件架构设计"></a>软件架构设计</h2><h2 id="UML建模与架构文档化"><a href="#UML建模与架构文档化" class="headerlink" title="UML建模与架构文档化"></a>UML建模与架构文档化</h2><p>早在20世纪70年代就陆续出现了面向对象的建模方法，在80年代末到90年代中期，各种建模方法如雨后春笋般从不到10种增加到50多种。但方法种类的膨胀，同时极大地妨碍了用户的使用和交流。UML（统一建模语言）一出现，以融合了多种面向对象建模方法，简洁的图形与符号，直观的表示和强大的表示能力，得到工业界与学术界认可。它通过统一的表示法，使不同知识背景的领域专家、系统分析和开发人员以及用户可以方便地交流。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/3160571?fromtitle=UML&fromid=446747&fr=aladdin">全称</a>，Unified Modeling Language<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23569835">zhihu:UML 还有用吗？</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24840463">zhihu:敏捷开发</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23208040">UML 在业界的使用情况如何？</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/57620b762160">uml类图</a></p>
</blockquote>
<h3 id="UML现状与发展"><a href="#UML现状与发展" class="headerlink" title="UML现状与发展"></a>UML现状与发展</h3><h4 id="UML起源"><a href="#UML起源" class="headerlink" title="UML起源"></a>UML起源</h4><p>在1995年，Gray Booch和Janes Rumbaugh将他们的面向对象建模方法统一为Unified Method V0.8。一年之后Ivar Jacobson加入其中，共同将该方法统一为二义性较少的UML0.9。同时，这三位杰出的方法学家被称为“三友（Three <a target="_blank" rel="noopener" href="https://fanyi.baidu.com/?aldtype=85#en/zh/Amigos">Amigos</a>）”。</p>
<p>很快用户也认识到可对软件系统进行可视化、描述、构造和文档化的通用建模语言所带来的益处。他们充满激情地将这种语言的早期草案应用于不同的领域。受用户强烈需求的驱动，建模工具厂商也很快在它们的产品中加入了对UML的支持。</p>
<p>UML成了实际上的工业标准。1996年，一个由建模专家组成的国际性队伍“UML伙伴组织”开始同“三友”一起工作，计划将UML提议作为OMG（Object Management Group）的标准建模语言。</p>
<p>1997年1月，伙伴组织向OMG提交了最初的提案UML 1.0。经过了九个月的紧张修订，于1997年9月提出了最终提案UML 1.1，这个提案在1997年11月被OMG正式采纳为对象建模标准。</p>
<p>在一个规范被采纳后不久，将成立一个修订任务组，负责该规范的修订。1997年9月，OMG采纳UML1.1规范之后不久，特许成立了第一个UML修订任务组（Revision Task Forces, RTF），负责收集有关评论，并且提出修改建议。</p>
<p>该RTF提交的第一个主要产品是一个编辑版本UML 1.2，它改编了规范，使之与其他OMG规范更为一致。尽管这一版本纠正了印刷和语法错误，以及某些明显的逻辑上的不一致，但还是没有涉及对重要技术的改进。</p>
<p>该RTF的第二个主要的产品是其技术版本UML 1.3，它修正和改善了UML 1.1的遗留问题，并矫正了在此之后发现的许多小错误。该RTF一致推荐OMG批准其UML 1.3最终草案，并于1999年6月提交了一份最终报告。被推荐的规范随后被提交给组织委员会和平台技术委员会以获得批准。</p>
<h4 id="UML体系结构演变"><a href="#UML体系结构演变" class="headerlink" title="UML体系结构演变"></a>UML体系结构演变</h4><p>UML是用元模型来描述的，元模型是4层元模型体系结构模式中的一层。此模式的其他层次分别是元—元模型层、模型层和用户对象层。其中元模型层由元—元模型层导出，UML的元—元模型层在OMG MOF的元—元模型中定义，而UML元模型中的元类是MOF元—元类的实例。</p>
<p>元模型的体系结构模式已被证明可以用来定义复杂模型所要求的精确语义，这种复杂模型通常需要被可靠地保存、共享、操作以及在工具之间进行交换。它的特点如下：</p>
<p>（1）它在每一层都递归地定义语义结构，从而使语义更精确、更正规。</p>
<p>（2）它可用来定义重量级和轻量级扩展机制，如定义新的元类和构造型。</p>
<p>（3）它在体系结构上将UML元模型与其他基于4层元模型体系结构的标准（比如MOF和用于模型交换的XMI Facility）统一起来。</p>
<p>在元模型层，UML元模型又被分解为三个逻辑子包：基础包、行为元素包和模型管理包。其中基础包由核心、扩展机制和数据类型三个子包构成，它是描述模型静态结构的语言底层结构，支持类图、对象图和构件图和部署图等结构图。行为元素包是描述模型动态行为的语言上层结构，支持不同的行为图，包括Use Case（用况）图、顺序图、协作图、状态图和活动图。模型管理包则定义了对模型元素进行分组和管理的语义，它描述了几种分组结构，包括包、模型和子系统。行为元素包和模型管理包都依赖于基础包。</p>
<p>UML 1.3是建模语言规范第一个成熟的发布。它纠正或调整了从UML 1.1中继承下来的遗留问题，并且修正了最终提交后的一年来所发现的大多数错误。从建模者的角度看，从UML 1.1到UML 1.3并没有很大变化，对语言的大部分改进是在底层对UML元模型语义的调整，只有很少量的变化是针对表示法的细枝末节的修改。底层结构上的变化对大多数用户来说是看不到的，但这使得UML在将来更容易实现和扩展。</p>
<h5 id="解决UML-1-1的遗留问题"><a href="#解决UML-1-1的遗留问题" class="headerlink" title="解决UML 1.1的遗留问题"></a>解决UML 1.1的遗留问题</h5><p>1）完善活动图的语义和表示法增加了状态的动态激发语义，定义了执行条件线程的语义和表示法，而且增加了对象流功能。为了做这些修订，还需要对活动图所依赖的状态机语义做以下修改：为同步并发的活动加入“同步状态”、精化信号的语义、为合并状态转换定义附加的伪状态。</p>
<p>（2）清理关系的标准元素。引入关系元类来组织各种类型的关系，并且把依赖构造型改造为依赖和流。此外，精练了泛化，不再需要以前的许多构造型（如继承、私有、子类、子类型等）。依赖和其他关系名称的一致性也有所改进。</p>
<p>（3）体系结构的一致性。通过加入物理元模型和XMI （XML metadata Interchange）、DTD （Document Type Definition）定义，提高了UML 1.3元模型的体系结构跟MOF和XMI Facility的一致性。从UML语义逻辑元模型导出的物理元模型包含了一些支持产生IDL （Interface Definition Language）和XMI DTD的修改（例如将关联类转化为类）。尽管这样做与严格的元模型方法相左，但它为未来UML的修订达到这一目标提供了桥梁。</p>
<h5 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h5><p>（1）静态结构图。放宽了限制，使类和接口之间可以关联，并且在类中可以声明信号。信号被定义为一个类元，可以操作。另外，还重新定义了模板和强类型的语义。</p>
<p>（2）用例图。用例之间的关系被重新定义为三种主要类型：泛化、包含和延伸。</p>
<p>（3）交互图。放宽了限制，使用户可以描述角色或实例。而且协作也可以泛化。</p>
<p>（4）模型管理图。改进了模型和子系统的语义和表示法，将它们从包中分离出来，并使之更容易使用。澄清了对包的访问和引入权限的区别。</p>
<p>尽管UML规范的核心是语法和语义定义，但它还包括模型交换、语言扩展以及约束等方面的定义。UML 1.3对这些相关规范都进行了错误纠正，并使之与核心语言的改进保持一致。</p>
<h5 id="为UML-2-0确立路标"><a href="#为UML-2-0确立路标" class="headerlink" title="为UML 2.0确立路标"></a>为UML 2.0确立路标</h5><p>该RTF在最终报告中明确了因为超出其范围或时间不允许而不能做的各种改进。他们建议下一个RTF应特别注意扩展性和文档管理方面的问题。对目前的扩展机制，用户和工具开发商已经发现了一些重要问题，而涌入新UML外围的提案可能会加剧这些困难。在文档管理方面，物理元模型和XMI DTD规范的加入大幅度地增加了UML规范的长度，并使它变得笨拙难用（它现在已有800多页了）。下一次UML修订将会把物理建模规范拆分为单独的文档。</p>
<p>该RTF还进一步建议负责起草UML 2.0 RFP的工作组考虑以下问题。</p>
<ul>
<li>体系结构：使用严格的元模型方法定义一个与MOF元—元模型严格一致的物理元模型。给出改进的指导方针，以决定哪些部分应该定义在核心语言中，哪些部分应定义在UML的外围或标准模型库中。</li>
<li>扩展性：提供同4层元模型体系结构一致的扩展机制。提高外围规范的严密程度，使其支持用户对语言定制能力不断增加的要求。</li>
<li>构件：增强基于构件的软件开发的语义和表示法。</li>
<li>关系：提供“精化”和“追踪”依赖关系的基本语义。在多个抽象层次上定义关联的语义。</li>
<li>状态图和活动图：定义独立于状态图语义的活动图语义。在活动图和状态图中提供更随意的并发。详细说明状态机的泛化。</li>
<li>模型管理：重新定义模型和子系统的表示法和语义，以增强对企业体系结构视图的支持。</li>
<li>总体机制：定义一种模型版本管理的机制。详细说明图的互换机制。</li>
</ul>
<h4 id="UML的应用与未来"><a href="#UML的应用与未来" class="headerlink" title="UML的应用与未来"></a>UML的应用与未来</h4><p>UML是在多种面向对象建模方法的基础上发展起来的建模语言，主要用于软件密集型系统的建模。它的演化，可以按其性质划分为以下几个阶段：最初的阶段是专家的联合行动，由三位Object-Oriented（面向对象）方法学家将他们各自的方法结合在一起，形成UML 0.9。第二阶段是公司的联合行动，由十几家公司组成的“UML伙伴组织”将各自的意见加入UML，形成UML 1.0和1.1，并作为向OMG申请成为建模语言规范的提案。第三阶段是在OMG控制下的修订与改进，OMG于1997年11月正式采纳UML 1.1作为建模语言规范，然后成立任务组进行不断的修订，并产生了UML 1.2、1.3和1.4版本，其中UML 1.3是较为重要的修订版。目前正处于UML的重大修订阶段，目标是推出UML 2.0，作为向ISO提交的标准提案。</p>
<p>从UML的早期版本开始，便受到了计算机产业界的重视，OMG的采纳和大公司的支持把它推上了实际上的工业标准的地位，使它拥有越来越多的用户。它被广泛地用于应用领域和多种类型的系统建模，如管理信息系统、通信与控制系统、嵌入式实时系统、分布式系统和系统软件等。近几年还被运用于软件再工程、质量管理、过程管理和配置管理等方面。而且它的应用不仅仅限于计算机软件，还可用于非软件系统，例如硬件设计、业务处理流程、企业或事业单位的结构与行为建模。</p>
<p>对UML的讨论和评价，无论是Internet上的意见交流，或是每年一次的UML研讨会，还是学术期刊上发表的文章，都是既肯定其成绩，又指出其缺点和错误，并且以积极的态度提出建设性意见。总的来说：</p>
<ul>
<li>UML已经取得重要成功，它已成为在软件工业中占支配地位的建模语言，并在许多领域的软件开发中得到应用。</li>
<li>UML还存在许多问题，自它产生之日起就从未离开过批评：用户和教师抱怨它内容庞大、难学难教而且太过复杂；学者认为它缺少一个精练的核心和定义良好的外围，有些语义定义得不够精确而且带有二义性；建模实践者认为它缺少支持自己领域建模要求的机制；工具开发商则因为规范本身的不确定性而产生理解上的偏差，它们对UML的自行诠释有可能误导用户。</li>
<li>UML的关键问题是过于庞大和复杂，以及在语言体系结构、语义等方面存在理论缺陷。产生这些问题的一个重要原因是，在形成规范的过程中不得不照顾多种方法流派的观点和多家公司的利益。</li>
</ul>
<h3 id="UML基础"><a href="#UML基础" class="headerlink" title="UML基础"></a>UML基础</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>UML通过图形化的表示机制从多个侧面对系统的分析和设计模型进行刻画。它共定义了10种视图，并将其分为如下4类。</p>
<p>（1）用例图（use case diagram）。从外部用户的角度描述系统的功能，并指出功能的执行者。</p>
<p>（2）静态图。包括类图（class diagram）、对象图（object diagram）和包图（package diagram）。类图描述系统的静态结构，类图的节点表示系统中的类及其属性和操作，类图的边表示类之间的联系，包括继承、关联、依赖和聚合等。对象图是类图的一个实例，它描述在某种状态下或在某一时间段，系统中活跃的对象及其关系。包图描述系统的分解结构，它表示包（package）以及包之间的关系。包由子包及类组成。包之间的关系包括继承、构成与依赖关系。</p>
<p>（3）行为图。包括交互图（interactive diagram）、状态图（statechart diagram）与活动图（active diagram），它们从不同的侧面刻画系统的动态行为。交互图描述对象之间的消息传递，它又可分为顺序图（sequence diagram）与合作图（collaboration diagram）两种形式。顺序图强调对象之间消息发送的时间序。合作图更强调对象间的动态协作关系。合作图也可通过消息序号来表示消息传递的时间序，只不过这种表示不如顺序图那样直观。状态图描述类的对象的动态行为，它包含对象所有可能的状态、在每个状态下能够响应的事件以及事件发生时的状态迁移与响应动作。活动图描述系统为完成某项功能而执行的操作序列，这些操作序列可以并发和同步。活动图中包含控制流和信息流。</p>
<p>4）实现图（implementation diagram）。包括构件图（component diagram）与部署图（deployment diagram），它们描述软件实现系统的组成和分布状况。构件图描述软件实现系统中各组成部件以及它们之间的依赖关系。部署图描述作为软件系统运行环境的硬件及网络的物理体系结构，其节点表示实际的计算机和设备，边表示节点之间的物理连接关系，也可显示连接的类型及节点之间的依赖性。</p>
<h4 id="用例和用例图"><a href="#用例和用例图" class="headerlink" title="用例和用例图"></a>用例和用例图</h4><p>用例（use case）国内也翻译为用况、用案等，在UML中，用例用一个椭圆表示，用例名往往用动宾结构或主谓结构命名。它有两个比较有代表性的定义如下。</p>
<p>定义1：用例是对一个活动者（actor）使用系统的一项功能时所进行的交互过程的一个文字描述序列。</p>
<p>定义2：用例是系统、子系统或类和外部的参与者（actor）交互的动作序列的说明，包括可选的动作序列和会出现异常的动作序列。</p>
<p>用例是代表系统中各相关人员之间就系统的行为所达成的契约。软件的开发过程可以分为$\color{green}{\text{需求分析}}$、$\color{green}{\text{设计}}$、$\color{green}{\text{实现等阶段}}$，在需求阶段用例是分析人员与客户沟通的工具和项目规模估算的依据；设计阶段用例是系统功能设计的主要输入；在实现阶段用例是检测类行为正确性的文档。因此，面向对象的软件开发过程是用例驱动的。</p>
<p>用例分析可以支持领域建模（domain modeling），以确保定义正确的需求（right requirements），是保证OO软件开发成功的基础。但要在具体的项目中灵活使用用例来捕获用户的需求并不是一件容易的事情，往往需要用户的经验、沟通能力、丰富的领域知识等。</p>
<p>本质上，用例分析是一种功能分解（functional decomposition）的技术，并未使用到面向对象思想。但用例是UML的重要部分，确定一个系统的用例是开发OO系统的第一步，用例分析这步做得好，接着的交互图分析、类图分析等才有可能做得好，整个系统的开发才能顺利进行。</p>
<p>编写用例必须识别以下元素。</p>
<h5 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h5><p>角色（actor）是指系统以外的、需要使用系统或与系统交互的东西，包括人、设备、外部系统等。actor有很多不同的译名，包括参与者、活动者、执行者和行动者等。</p>
<p>一个参与者可以执行多个用例，一个用例也可以由多个参与者使用。但需要注意的是，参与者实际上并不是系统的一部分，尽管在模型中会使用参与者。</p>
<p>参与者实际上是一个版型化的类，其版型是〈〈Actor〉〉。图6-1是参与者的三种表示形式。</p>
<details><summary>图6-1　参与者的表示形式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725163741.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725163741.png';" /></details>

<blockquote>
<p>$\color{red}{\text{版型}}$化是什么意思。</p>
</blockquote>
<h5 id="用例间的关系"><a href="#用例间的关系" class="headerlink" title="用例间的关系"></a>用例间的关系</h5><p>用例除了与参与者有关联（association）关系外，用例之间也存在着一定的关系（relationship），如泛化（generalization）关系、包含（include）关系、扩展（extend）关系等。</p>
<p>包含（include）关系指的是两个用例之间的关系，其中一个用例（称作基本用例，base use case）的行为包含了另一个用例（称作包含用例，inclusion use case）的行为。包含关系是依赖关系的版型，也就是说包含关系是比较特殊的依赖关系，它们比一般的依赖关系多一些语义。如图6-2所示是包含关系的例子，其中用例取款机专用（ATM Session）是基本用例，用例识别客户（Identify Customer）和验证账号（Validate Account）是包含用例。</p>
<details><summary>图6-2　用例的包含关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725164243.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725164243.png';" /></details>


<p>扩展（extend）关系的基本含义与泛化关系类似。但在扩展关系中，对于扩展用例（extension use case）有更多的规则限制，即基本用例必须声明若干“扩展点”（extension point），而扩展用例只能在这些扩展点上增加新的行为和含义。图6-3所示是同时具有扩展关系和包含关系的例子，在这个例子中，可以看到基本用例、包含用例、扩展用例等概念间的联系和区别。</p>
<details><summary>图6-3　包含用例和扩展用例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725164701.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725164701.png';" /></details>

<p>对于“购货”这个用例，它扩展了“浏览网站”这个用例，同时也包含了“订单加入库存系统”这个用例。因此对于“浏览网站”这个用例来说是扩展用例，但对于“订单加入库存系统”这个用例来说是基本用例。</p>
<h5 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h5><p>用例图（use case diagram）是显示一组用例、参与者以及它们之间关系的图。在UML中，一个用例模型由若干个用例图描述。如图6-4显示了电话系统的使用用例图。</p>
<p>UML规范说明中并不使用颜色作为图形语义的区分标记，但建模人员可以在图中给某些图符加上填充颜色，以强调某一部分的模型，或希望引起使用者的特别注意。但在语义上，使用填充颜色和不使用填充颜色的模型是一样的。</p>
<h5 id="用例的描述"><a href="#用例的描述" class="headerlink" title="用例的描述"></a>用例的描述</h5><p>用例的描述才是用例的核心部分，用例采用自然语言描述参与者与系统进行交互时双方的行为，不追求形式化的语言表达。以下是一个典型描述多方式。</p>
<details><summary>图6-4　电话系统的使用用例图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725165901.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725165901.png';" /></details>


<p>用例：〈编号〉〈名称〉</p>
<p>用途及特征：</p>
<p>　　　　用例在系统中的目标（用例目标描述）</p>
<p>　　　　范围（当前考虑的是哪个系统）</p>
<p>　　　　级别（概要任务/首要任务/子功能）</p>
<p>　　　　当前条件（用例执行前系统应具有的状态）</p>
<p>　　　　成功后续条件（用例成功执行后应具有的状态）</p>
<p>　　　　失效后续条件（用例没有完成目标的状态）</p>
<p>　　　　触发（启动该用例执行的系列动作）</p>
<p>角色：首要角色（与该用例关联的首要角色）</p>
<p>主场景：动作序列</p>
<p>　　　　〈步骤编号〉〈动作描述〉〈系统响应〉</p>
<p>扩展场景：动作序列</p>
<p>　　　　〈步骤编号〉〈条件〉：〈动作或另一个用例〉</p>
<p>异常场景：</p>
<p>　　　　〈步骤编号〉〈条件〉：〈异常动作〉</p>
<p>相关信息（可选）：</p>
<p>　　　　优先级（该用例对于系统/组织的关键程度）</p>
<p>　　　　性能目标（该用例的执行时间耗费）</p>
<p>　　　　频度（该用例被执行的频度）</p>
<p>　　　　与首要角色的联系渠道（包括交互式、静态文件、数据库等）</p>
<p>存在问题：</p>
<p>　　　　列出关于该用例的未解决问题</p>
<h5 id="交互图"><a href="#交互图" class="headerlink" title="交互图"></a>交互图</h5><p>交互图（interaction diagram）是用来描述对象之间以及对象与参与者（actor）之间的动态协作关系以及协作过程中行为次序的图形文档。它通常用来描述一个用例的行为，显示该用例中所涉及的对象和这些对象之间的消息传递。交互图包括顺序图</p>
<p>（sequence diagram）和协作图（collaboration diagram）两种形式。顺序图着重描述对象按照时间顺序的消息交换，协作图着重描述系统成分如何协同工作。顺序图和协作图从不同的角度表达了系统中的交互和系统的行为，它们之间可以相互转化。一个用例需要多个顺序图或协作图，除非特别简单的用例。</p>
<p>交互图可以帮助分析人员对照检查每个用例中所描述的用户需求，如这些需求是否已经落实到能够完成这些功能的类中去实现，提醒分析人员去补充遗漏的类或方法。</p>
<h6 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h6><p>顺序图也称时序图。Rumbaugh对顺序图的定义是：顺序图是显示对象之间交互的图，这些对象是按时间顺序排列的。特别地，顺序图中显示的是参与交互的对象及对象之间消息交互的顺序。图6-5所示是一个简单的顺序图例子。</p>
<details><summary>图6-5　顺序图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725170635.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725170635.png';" /></details>

<p>顺序图是一个二维图形。在顺序图中水平方向为$\color{green}{\text{对象维}}$，沿水平方向排列的是参与交互的对象。其中对象间的排列顺序并不重要，但一般把表示参与者的对象放在图的两侧，主要参与者放在最左边，次要参与者放在最右边（或表示人的参与者放在最左边，表示系统的参与者放在最右边）。顺序图中的垂直方向为$\color{green}{\text{时间维}}$，沿垂直向下方向按时间递增顺序列出各对象所发出和接收的消息。</p>
<h6 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h6><p>协作图是用于描述系统的行为是如何由系统的成分协作实现的图，协作图中包括的建模元素有对象（包括参与者实例、多对象、主动对象等）、消息、链等。</p>
<h4 id="类图和对象图"><a href="#类图和对象图" class="headerlink" title="类图和对象图"></a>类图和对象图</h4><p>类是具有相似结构、行为和关系的一组对象的抽象。在UML中，类表示为划分成三个格子的长方形，如图6-6所示。</p>
<details><summary>图6-6　UML中类的表示图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725170953.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725170953.png';" /></details>

<p>在定义类的时候，类的命名应尽量用应用领域中的术语，应明确、无歧义，以利于开发人员与用户之间的相互理解和交流。一般而言，类的名字是名词。</p>
<p>一般说来，类之间的关系有关联、聚集、组合、泛化和依赖等，下面将对这些关系进行详细说明。</p>
<h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><p>关联（association）是模型元素间的一种语义联系，它是对具有共同的结构特性、行为特性、关系和语义的链（link）的描述。在上面的定义中，需要注意链这个概念，$\color{green}{\text{链}}$是一个实例，就像对象是类的实例一样，链是关联的实例，关联表示的是类与类之间的关系，而链表示的是对象与对象之间的关系。</p>
<p>在类图中，关联用一条把类连接在一起的实线表示。关联两端的类可以某种角色参与关联。例如在图6-7中，Company类以employer的角色、Person类以employee的角色参与关联，employer和employee称为角色名。如果在关联上没有标出角色名，则隐含地用类的名称作为角色名。角色还具有多重性（multiplicity），表示可以有多少个对象参与该关联。在图6-7中，employer可以雇佣多个employee，表示为0..n；employee只能被一家employer雇佣，表示为1。</p>
<details><summary>图6-7　关联的角色</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725171105.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725171105.png';" /></details>

<p>通过关联类（association class）可以进一步描述关联的属性、操作以及其他信息。关联类通过一条虚线与关联连接。图6-8中的Contract类是一个关联类，Contract类中有属性salary，这个属性描述的是Company类和Person类之间的关联的属性，而不是描述Company类或Person类的属性。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725183957.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725183957.png';" /></details>

<p>自返关联（reflexive association）又称递归关联（recursive association），是一个类与自身的关联，即同一个类的两个对象间的关系。自返关联虽然只有一个被关联的类，但有两个关联端，每个关联端的角色不同。自返关联的例子如图6-9所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725184016.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725184016.png';" /></details>

<h5 id="聚集和组合"><a href="#聚集和组合" class="headerlink" title="聚集和组合"></a>聚集和组合</h5><p>聚集（aggregation）是一种特殊形式的关联。聚集表示类之间整体与部分的关系。在对系统进行分析和设计时，需求描述中的“包含”、“组成”、“分为……部分”等词常常意味着存在聚集关系（见图6-10）。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725191648.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725191648.png';" /></details>

<p>组合（composition）表示的也是类之间的整体与部分的关系，但组合关系中的整体与部分具有同样的生存期。也就是说，组合是一种特殊形式的聚集。</p>
<h5 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h5><p>泛化（generalization）定义了一般和特殊元素之间关系，如果从面向对象程序设计语言的角度来说，类与类之间的泛化关系就是平常所说的类与类之间的继承关系。</p>
<p>UML中用一头为空心三角形的连线表示泛化关系。</p>
<h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>假设有两个元素X、Y，如果修改元素X的定义可能会导致对另一个元素Y的定义的修改，则称元素Y依赖于元素X。</p>
<h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p>6-11所示为学校内主要对象的类图。学校包含若干学生，是由多个系组成。每个系开设若干课程，学生参加不同课程学习（管联）关系；老师教一门或多门课程。在一个系中，有一个老师是领导，系包含若干老师。</p>
<p>类图以直观、抽象形式展示了不同对象之间关系。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725191917.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725191917.png';" /></details>

<h4 id="状态图和活动图"><a href="#状态图和活动图" class="headerlink" title="状态图和活动图"></a>状态图和活动图</h4><h5 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h5><p>UML中的状态图（state chart diagram）主要用于描述一个对象在其生存期间的动态行为，表现一个对象所经历的状态序列，引起状态转移的事件（event），以及因状态转移而伴随的动作（action）。状态图是UML中对系统的动态行为建模的5个图之一，状态图在检查、调试和描述类的动态行为时非常有用。一般可以用状态机对一个对象的生命周期建模，状态图是用于显示状态机的，重点在于描述状态之间的控制流。</p>
<p>图6-12所示是一个简单的状态图的例子。这个状态图中描述的对象除了初态和终态外，还有Idle和Running两个状态，而keyPress、finished、shut Down等是事件。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192052.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192052.png';" /></details>

<h5 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h5><p>活动图是对系统的动态行为建模的5个图之一。活动图可以用于描述系统的工作流程和并发行为。活动图其实可看作状态图的特殊形式，活动图中一个活动结束后将立即进入下一个活动（在状态图中状态的转移可能需要事件的触发）。</p>
<p>下面讨论活动图中的几个基本概念：活动、泳道、分支、分叉和汇合、对象流。</p>
<p>1）活动</p>
<p>活动（activity）表示的是某流程中的任务的执行，它可以表示某算法过程中语句的执行。在活动图中需要注意区分动作状态（action state）和活动状态（activity state）这两个概念。动作状态是原子的，不能被分解，没有内部转移，没有内部活动，动作状态的工作所占用的时间是可忽略的。动作状态的目的是执行进入动作（entry action），然后转向另一个状态。活动状态是可分解的，不是原子的，其工作的完成需要一定的时间。可以把动作状态看作活动状态的特例。</p>
<p>2）泳道</p>
<p>泳道（swimlane）是活动图中的区域划分，根据每个活动的职责对所有活动进行划分，每个泳道代表一个责任区。泳道和类并不是一一对应的关系，泳道关心的是其所代表的职责，一个泳道可能由一个类实现，也可能由多个类实现。</p>
<p>3）分支</p>
<p>在活动图中，对于同一个触发事件，可以根据不同的警戒条件转向不同的活动，每个可能的转移是一个分支（branch）。</p>
<p>4）分叉和汇合</p>
<p>分支表示的是从多种可能的活动转移中选择一个，如果要表示系统或对象中的并发行为，则可以使用分叉（fork）和汇合（join）这两种建模元素。分叉表示两个或多个控制流经过分叉后，这些控制流并发进行；汇合正好与分叉相反。</p>
<p>5）对象流</p>
<p>在活动图中可以出现对象。对象可以作为活动的输入或输出。活动图中的对象流表示活动和对象之间的关系，如一个活动创建对象（作为活动的输出）或使用对象（作为活动的输入）等。如图6-13所示。</p>
<details><summary>活动图案例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192219.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192219.png';" /></details>


<h4 id="构件图"><a href="#构件图" class="headerlink" title="构件图"></a>构件图</h4><p>构件（component）是系统中遵从一组接口且提供其实现的物理的、可替换的部分。构件图（componentdiagram）则显示一组构件以及它们之间的相互关系，包括编译、链接或执行时构件之间的依赖关系。图6-14所示是一个构件图的例子，表示.html文件、.exe文件、.dll文件这些构件之间的相互依赖关系。</p>
<details><summary>图6-14　构件图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192302.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192302.png';" /></details>

<p>构件就是一个实际文件，可以有以下几种类型：</p>
<p>1）部署构件（deploymentcomponent），如dll文件、exe文件、COM＋对象、CORBA对象、EJB、动态Web页和数据库表等。</p>
<p>（2）工作产品构件（work productcomponent），如源代码文件、数据文件等，这些构件可以用来产生部署构件。</p>
<p>（3）执行构件（execution component），也就是系统执行后得到的构件。</p>
<p>构件图可以对以下几个方面建模：</p>
<p>（1）对源代码文件之间的相互关系建模，如图6-15所示。</p>
<details><summary>图6-15　构件图用于对源代码建模</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192437.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192437.png';" /></details>

<p>2）对可执行文件之间的相互关系建模。图6-16所示是某可运行系统的部分文件之间的相互关系。</p>
<p>在图6-16中，IDriver是接口，构件path.dll和接口IDriver之间是依赖关系，而构件dirver.dll和接口IDriver之间是实现关系。</p>
<details><summary>图6-16　构件图用于对可运行系统建模</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192455.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192455.png';" /></details>


<h4 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h4><p>部署图也称配置图、实施图，它可以用来显示系统中计算结点的拓扑结构和通信路径与结点上运行的软构件等。一个系统模型只有一个部署图，部署图常用于帮助理解分布式系统。</p>
<p>部署图由体系结构设计师、网络工程师、系统工程师等描述。图6-17所示是一个部署图的例子。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192524.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192524.png';" /></details>

<h3 id="基于UML的软件开发过程"><a href="#基于UML的软件开发过程" class="headerlink" title="基于UML的软件开发过程"></a>基于UML的软件开发过程</h3><h4 id="开发过程概述"><a href="#开发过程概述" class="headerlink" title="开发过程概述"></a>开发过程概述</h4><p>UML是独立于软件开发过程的，即UML能够在几乎任何一种软件开发过程中使用。迭代的渐进式软件开发过程包含4个阶段，即初启、细化、构建和部署。</p>
<h5 id="初启"><a href="#初启" class="headerlink" title="初启"></a>初启</h5><p>在初启阶段，软件项目的发起人确定项目的主要目标和范围，并进行初步的可行性分析和经济效益分析。</p>
<h5 id="细化"><a href="#细化" class="headerlink" title="细化"></a>细化</h5><p>细化阶段的开始标志着项目的正式确立。软件项目组在此阶段需要完成以下工作：</p>
<p>（1）初步的需求分析。采用UML的用例描述目标软件系统所有比较重要、比较有风险的用例，利用用例图表示参与者与用例以及用例与用例之间的关系。采用UML的类图表示目标软件系统所基于的应用领域中的概念与概念之间的关系。这些相互关联的概念构成领域模型。领域模型一方面可以帮助软件项目组理解业务背景，与业务专家进行有效沟通；另一方面，随着软件开发阶段的不断推进，领域模型将成为软件结构的主要基础。如果领域中含有明显的流程处理成分，可以考虑利用UML的活动图来刻画领域中的工作流，并标识业务流程中的并发、同步等特征。</p>
<p>（2）初步的高层设计。如果目标软件系统的规模比较庞大，那么经初步需求分析获得的用例和类将会非常多。此时，可以考虑根据用例、类在业务领域中的关系，或者根据业务领域中某种有意义的分类方法将整个软件系统划分为若干个包，利用UML的包图刻画这些包及其间的关系。这样，用例、用例图、类、类图将依据包的划分方法分属于不同的包，从而得到整个目标软件系统的高层结构。</p>
<p>（3）部分的详细设计。对于系统中某些重要的或者风险比较高的用例，可以采用交互图进一步探讨其内部实现过程。同样，对于系统中的关键类，也可以详细研究其属性和操作，并在UML类图中加以表现。因此，这里倡导的软件开发过程是根据软件元素（用例、类等）的重要性和风险程度确立优先细化原则，建议软件项目组优先考虑重要的、比较有风险的用例和类，不能将风险的识别和解决延迟到细化阶段之后。</p>
<p>（4）部分的原型构造。在许多情形下，针对某些复杂的用例构造可实际运行的原型是降低技术风险、让用户帮助软件项目组确认用户需求的最有效的方法。为了构造原型，需要针对用例生成详尽的交互图，对所有相关类给出明确的属性和操作定义。</p>
<p>综上所述，在细化阶段可能需要使用的UML语言机制包括描述用户需求的用例及用例图、表示领域概念模型的类图、表示业务流程处理的活动图、表示系统高层结构的包图和表示用例内部实现过程的交互图。</p>
<h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><p>在构造阶段，开发人员通过一系列的迭代完成对所有用例的软件实现工作，在每次迭代中实现一部分用例。以迭代方式实现所有用例的好处在于，用户可以及早参与对已实现用例的实际评价，并提出改进意见。这样可有效降低大型软件系统的开发风险。在实际开始构造软件系统之前，有必要预先制定迭代计划。计划的制定需遵循如下两项原则：</p>
<p>（1）用户认为业务价值较大的用例应优先安排。</p>
<p>（2）开发人员评估后认为开发风险较高的用例应优先安排。</p>
<p>在迭代计划中，要确定迭代次数、每次迭代所需时间以及每次迭代中应完成（或部分完成）的用例。</p>
<p>每次迭代过程由针对用例的分析、设计、编码、测试和集成5个子阶段构成。在集成之后，用户可以对用例的实现效果进行评价，并提出修改意见。这些修改意见可以在本次迭代过程中立即实现，也可以在下次迭代中再予以考虑。</p>
<p>构建过程中，需要使用UML的交互图来设计用例的实现方法。为了与设计得出的交互图协调一致，需要修改或精化在细化阶段绘制的作为领域模型的类图，增加一些为软件实现所必需的类、类的属性或方法。</p>
<p>在构建阶段的每次迭代过程中，可以对细化阶段绘出的包图进行修改或精化，以便包图切实反映目标软件系统最顶层的结构划分状况。</p>
<p>综上所述，在构建阶段可能需要使用的UML语言机制包括：</p>
<p>（1）用例及用例图。它们是开发人员在构造阶段进行分析和设计的基础。</p>
<p>（2）类图。在领域概念模型的基础上引进为软件实现所必需的类、属性和方法。</p>
<p>（3）交互图。表示针对用例设计的软件实现方法。</p>
<p>（4）状态图。表示类的对象的状态—事件—响应行为。</p>
<p>（5）活动图。表示复杂的算法过程，尤其是过程中的并发和同步。</p>
<p>（6）包图。表示目标软件系统的顶层结构。</p>
<p>（7）构件图。</p>
<p>（8）部署图。</p>
<h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><p>在部署阶段，开发人员将构造阶段获得的软件系统在用户实际工作环境（或接近实际的模拟环境）中试运行，根据用户的修改意见进行少量调整。</p>
<h4 id="基于UML的需求分析"><a href="#基于UML的需求分析" class="headerlink" title="基于UML的需求分析"></a>基于UML的需求分析</h4><p>在初步的业务需求描述已经形成的前提下，基于UML的需求分析过程（见图6-18）大致可分为以下步骤。</p>
<ul>
<li>利用用例及用例图表示需求。从业务需求描述出发获取执行者和场景；对场景进行汇总、分类、抽象，形成用例；确定执行者与用例、用例与用例图之间的关系，生成用例图。</li>
</ul>
<details><summary>图6-18　需求分析过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725193042.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725193042.png';" /></details>

<ul>
<li>利用包图及类图表示目标软件系统的总体框架结构。根据领域知识、业务需求描述和既往经验设计目标软件系统的顶层架构；从业务需求描述中提取“关键概念”，形成领域概念模型；从概念模型和用例出发，研究系统中主要的类之间的关系，生成类图。</li>
</ul>
<p>上述两个步骤并没有时序关系，它们可以并行展开。</p>
<h5 id="生成用例"><a href="#生成用例" class="headerlink" title="生成用例"></a>生成用例</h5><p>从外部用户的视角看，一个用例是执行者（actor）与目标软件系统之间的一次典型的交互作用。从软件系统内部的视角出发，一个用例代表系统执行的一系列动作，动作执行的结果能够被外部的执行者所察觉。执行者是指外部用户或外部实体在系统中扮演的角色。如果多个用户在使用目标软件系统时扮演同一角色，这些用户将由单一执行者表示。反之，如果一个用户扮演多种角色，则需要用多个执行者来表示同一用户。</p>
<p>对用例的完整描述包括用例名称、参与执行者、前置条件、一个主事件流、零到多个辅事件流和后置条件。主事件流表示正常情况下执行者与系统之间的信息交互及动作序列，辅事件流则表示特殊情况或异常情况下的信息交互及动作序列。显式地分隔主、辅事件流是为了使分析人员首先聚焦于正常的业务处理流程，同时也便于用例的读者理解业务需求。</p>
<p>用例主要来源于分析人员对场景的分类和抽象，即将相似的场景进行归并，使一个用例可以通过实例化和参数调节而涵盖多个场景。</p>
<p>例如，在“家庭保安系统”中，执行者有“用户”、“传感器”、“警报器”、“报警电话”和“显示器”，用例有“系统配置”、“命令响应”和“传感器监测”。下面以“传感器监测”为例说明用例的一般描述格式。</p>
<p><u>用例名称</u>：传感器监测。</p>
<p>参与执行者：各类传感器、警报器、报警电话和显示器。</p>
<p><u>前置条件</u>：系统已开机。</p>
<p><u>主事件流</u>：</p>
<p>①传感器向目标软件系统上报其监测数据，系统判别监测数据是否正常。</p>
<p>②如果不正常，系统启动警报器，拨报警电话号码。</p>
<p>③报警电话接通后，软件系统播出语音，报告异常事件发生的时间、地点和事件的性质。</p>
<p>④系统在控制面板的显示器上显示报警时间及当前状态（报警）。</p>
<p><u>辅事件流</u>：</p>
<p>①如果报警电话无人接听，则按照重拨延迟反复拨号，直至电话接通，再转入主事件流的步骤③。</p>
<p>②如果重拨次数达到系统预设的最大次数，电话仍无人接听，则跳过主事件流的步骤③，转入步骤④。</p>
<p><u>后置条件</u>：如果已发现异常的监测数据，系统处于“报警”状态；否则，系统处于正常的“监测”状态。</p>
<h5 id="用活动图表示用例"><a href="#用活动图表示用例" class="headerlink" title="用活动图表示用例"></a>用活动图表示用例</h5><p>针对前面所述的“传感器监测”用例，其活动图表示如图6-19所示。</p>
<details><summary>活动图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725193731.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725193731.png';" /></details>


<h5 id="生成用例图"><a href="#生成用例图" class="headerlink" title="生成用例图"></a>生成用例图</h5><p>执行者与用例之间的关系有两种：触发执行与信息交换。执行者与用例之间可能兼具这两种关系，例如，在“家庭保安系统”中，执行者“用户”在触发用例“命令响应”的同时，还要向用例传送命令信息。</p>
<p>在UML用例图中，从执行者指向用例的边表示触发执行和/或信息交换，从用例指向执行者的边则表示用例将其生成的信息传递给执行者。例如图6-19中的“传感器监测”用例仅包含正常的处理流程，而“报警电话未接通”用例除正常流程外还增加了“重复拨号”以及“重拨次数达到最大次数仍无人接听”这两种异常处理动作。</p>
<h5 id="建立顶层架构"><a href="#建立顶层架构" class="headerlink" title="建立顶层架构"></a>建立顶层架构</h5><p>顶层架构的主要目的是为后续的分析和设计活动建立一种结构和分划，以便开发人员在不同的开发阶段，以及同一开发阶段的不同开发人员，能够聚焦于系统的不同部分。顶层架构是分析和设计的阶段成果的承载体。随着开发过程的推进，框架中的内容不断丰富、翔实，最终演进为完整的面向对象软件结构。</p>
<h6 id="UML包图"><a href="#UML包图" class="headerlink" title="UML包图"></a>UML包图</h6><p>包是UML对类进行分组的一种机制。可以从某种视角将具有比较密切的关联的一些类划分为一个包，分属于不同包的两个类之间的关联则比较松散。由此可见，对于大型软件系统而言，包的划分是实现“分而治之”的重要技术手段。</p>
<p>包之间存在两种依赖关系：依赖和构成。如果对类A的修改将导致类B的改变，则称B依赖于A。如果两个包中存在具有依赖关系的两个类，则认为这两个类分属的包之间存在依赖关系。</p>
<h6 id="顶层架构设计"><a href="#顶层架构设计" class="headerlink" title="顶层架构设计"></a>顶层架构设计</h6><p>软件系统顶层架构的基本方法是，结合实际需求，从既往的架构设计经验模式中选取适当者，再进行微调或局部改造。目前有如下几种主要的架构模式：</p>
<p>（1）流程处理模式。流程处理系统以算法和数据结构为中心，其系统功能由一系列的处理步骤构成，相邻的处理步骤之间以数据流通管道相互连接。</p>
<p>（2）客户/服务器模式。客户端负责用户输入和处理结果的呈现，服务器端则负责后台的业务逻辑处理。</p>
<ul>
<li>模型——视图——控制器（Model、View、Controller, MVC）模式。该模式将整个软件系统划分为模型、视图和控制器三个部分。模型负责维护并保存具有持久性的业务数据，实现业务处理功能，并将业务数据的变化情况及时通知视图；视图负责呈现模型中包含的业务数据，响应模型变化通知，更新呈现形式，并向控制器传递用户的界面动作；控制器负责将用户的界面动作映射为模型中的业务处理功能并实际调用之，然后根据模型返回的业务处理结果选择新的视图。MVC模式特别适合于分布式应用软件，尤其是Web应用系统。</li>
<li>分层模式。分层模式将整个软件系统分为若干层次，最顶层直接面向用户提供软件系统的操作界面，其余各层为紧邻其上的层次提供服务。分层模式可以有效地降低软件系统的耦合度，因此其应用十分普遍。</li>
</ul>
<p>事实上，大型软件的顶层架构往往需要复合使用多种架构样式。例如，整个目标软件系统采用分层结构，在系统的不同层次内再分别使用适宜的其他种类的架构模式。</p>
<p>在确立顶层架构的过程中需综合考虑以下因素：</p>
<ul>
<li>架构中包的数量。原则上，如果母个包中包含的软件元素（例如类）的数量过多，应考虑将其进一步细分；如果过少，则说明架构过早地陷入了细节，架构划分返工的可能性较大，同时也不合理地限制了后续分析和设计活动的自由空间。</li>
<li>架构中包之间的耦合度。包之间的依赖关系和连接关系应尽量简单、稀疏。</li>
<li>软件系统的稳定性。要尽量抽取不稳定的软件元素之中相对稳定的部分，将不稳引起的软件元素分类聚集于少数几个包中，以提高软件系统的可维护性。</li>
<li>软件系统的必然性。可以将可选功能和必须实现的功能分置于架构中不同的包或子包之中。</li>
<li>作为软件系统运行环境的物理网络拓扑。根据软件元素在分布环境中的部署情况。区分顶层架构中的包，可以使包之间的消息传递与物理节点之间的通信相吻合，使后续的分析和设计活动受益于顶层架构中明确定义的通信关系。</li>
<li>软件元素的安全、保密级别。根据安全访问的权限划分顶层架构中的包或者子包。</li>
<li>开发团队的技术专长。根据开发人员在问题领域和软件技术领域不同的专长划分顶层架构中的包，使每个包都能分配给最适合的开发人员进行后续的分析、设计、编码和测试等，从而有利于并行开发。</li>
</ul>
<h5 id="建立概念模型"><a href="#建立概念模型" class="headerlink" title="建立概念模型"></a>建立概念模型</h5><p>例如，“家庭保安系统”的领域概念模型如图6-20所示。</p>
<details><summary>图6-20　“家庭保安系统”的领域概念模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725194200.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725194200.png';" /></details>

<h4 id="面向对象的设计方法"><a href="#面向对象的设计方法" class="headerlink" title="面向对象的设计方法"></a>面向对象的设计方法</h4><p>面向对象的软件设计过程如图6-21所示。</p>
<details><summary>图6-21　面向对象的软件设计过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725194237.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725194237.png';" /></details>

<h5 id="设计用例实现方案"><a href="#设计用例实现方案" class="headerlink" title="设计用例实现方案"></a>设计用例实现方案</h5><p>UML的交互图（顺序图、协作图）适于用例实现方案的表示。该设计方法包含如下三个步骤：</p>
<h6 id="提取边界类、实体类和控制类"><a href="#提取边界类、实体类和控制类" class="headerlink" title="提取边界类、实体类和控制类"></a>提取边界类、实体类和控制类</h6><p>边界类用于描述目标软件系统与外部环境之间的交互，并负责实现如下功能：</p>
<ul>
<li>界面控制。包括输入数据的格式及内容转换、输出结果的呈现以及软件运行过程中界面的变化写切换等。</li>
<li>外部接口。实现目标软件系统与外部系统或外部设备之间的信息交流和互操作。主要关注跨越目标软件系统边界的通信协议。</li>
<li>环境隔离。将目标软件系统与操作系统、数据库管理系统、应用服务器中间件等境软件进行交互的功能与特性封装于边界类之中，使目标软件系统的其余部分尽可能地独立于环境软件。</li>
</ul>
<p>在UML类图中，边界类往往附加UML构造型〈〈boundary〉〉作为特别标识。</p>
<p>实体类表示目标软件系统中具有持久意义的信息项及其操作。实体类的操作具有“内向收敛”特征，它们仅向目标软件系统的其余部分提供读/写信息项内容的必要的操作接口，并不涉及业务逻辑处理。实体类的UML构造型为〈〈entity〉〉。</p>
<p>控制类作为完成用例任务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。对于比较复杂的用例，控制类通常并不处理具体的任务细节，但是它应知道如何分解任务，如何将子任务分派给适当的辅助类，以及如何在辅助类之间进行消息传递和协调。控制类的UML构造型为〈〈control〉〉。</p>
<p>通常情况下，执行者与用例之间的一种通信连接对应一个边界类。但是，如果两个以上的用例与同一执行者交互，并且这些交互具有共同的行为、完成相同或类似的任务，就可以考虑用同一边界类实现用例与执行者之间的交互。这就意味着边界类的作用范围可以超越单个用例。</p>
<h6 id="构造交互图"><a href="#构造交互图" class="headerlink" title="构造交互图"></a>构造交互图</h6><p>UML交互图，以交互图作为用例的精确实现方案。</p>
<p>如前所述，用例描述中已包含事件流说明。事件流中的事件应直接对应于交互图中的消息，而事件间的先后关系体现为交互图中的时序，对消息的响应则构成消息接收者的职责。这种职责在后续的设计活动中将被确立为类的方法。</p>
<p>对于比较复杂的用例而言，仅仅依靠控制类、边界类和实体类并不能很好地解决问题，因为我们不能使单个控制类过于庞大和复杂，让它既承担控制、协调的任务，又承担复杂的计算任务。因此，在设计复杂用例的实施方案时，应考虑为控制类设置一些独立的辅助类，让控制类将一些任务委托给辅助类完成。例如，在图6-20所示的“家庭保安系统”类图中，“系统配置管理器”和“日志管理器”就是这种意义上的辅助类。</p>
<p>在UML顺序图中，用例的主动执行者应位于最左侧，紧邻其右的类是作为用户界面的边界类，再往右是控制类。控制类的右侧应放置辅助类和实体类，它们的右侧是作为外部接口和环境隔离层的边界类，最右侧是位于目标软件系统边界之外的被动执行者。如此布局之后，在顺序图中不应该出现穿越控制类生命线的消息，即主动执行者向边界类发出命令，边界类将命令进行适当转换后传送至控制类，控制类通过消息请求辅助类、实体类的帮助，协调、控制它们共同完成来自主动执行者的命令。在此过程中，控制类或辅助类可以向右侧的边界类发送消息，将信息或外部处理请求由边界类传向外部系统（被动执行者）。按照上述布局规则绘制的典型的顺序图如图6-22所示。</p>
<details><summary>图6-22　典型布局规则下顺序图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725194500.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725194500.png';" /></details>

<p>在用例描述中，许多用例除主事件流外，往往还包含备选事件流，以说明在某些特殊或异常情况下的事件和响应动作序列。为易于理解，在设计模型中应该用分离的UML交互图分别表示事件流和每个备选事件流。</p>
<p>（3）根据交互图精化类图。</p>
<p>在UML交互图中，对每个类的对象都规定了它必须响应的消息以及类的对象之间的消息传递通道。前者对应于类的操作，后者则对应于类之间的连接关系。因此，可以利用交互图精化分析模型中的类图，将交互图中出现的新类添加到原有类图中，并且对相关的类进行精化，定义其属性和操作。</p>
<p>原则上，每个类都应该有一个操作来响应交互图中指向其对象的那条消息。但是，这并不意味着消息与操作一定会一一对应，因为类的一个操作可能具有响应多条消息的能力。同理，两个类之间的一条连接关系也可以为多条消息提供传递通道。为了简化设计模型，也为了提高重用程度，设计人员应该尽量使用已有的操作来响应新消息，并尽量使用已存在的连接路径作为消息传递的通道。如果两个类之间存在明确、自然的聚合或组合关系，则可以在类图中直接用相应的UML图元符号表示类间的聚合或组成关系，这两个关系均可提供消息传递通道。</p>
<p>接下来讨论如何根据交互图确立类的属性。类的操作完成消息响应责任的能力来源于两方面的知识，一是类本身具有的信息，即类的属性；二是类能够找到的其他类，通过其他类协助其完成消息响应。在综合考虑这两个因素之后，类的操作应该明确哪些子任务可通过消息传递路径委托给其他类完成，哪些子任务必须由自身完成。根据后一种子任务的需要，结合领域和业务知识即可推导出类应具有的属性。</p>
<h5 id="设计技术支撑方案"><a href="#设计技术支撑方案" class="headerlink" title="设计技术支撑方案"></a>设计技术支撑方案</h5><p>在许多软件项目中，应用功能往往都需要一组技术支撑机制为其提供服务。例如，对分布式应用软件（包括电子商务应用、企业ERP系统等）而言，需要数据持久存储服务、安全控制服务、分布式事务管理服务、并发与同步控制服务和可靠消息服务等。这些技术支撑设施并非业务需求的直接组成部分，但形态各异的业务处理功能全都依赖于它们提供的公共技术服务。让每个业务功能的设计者直接面对裸机、基本操作系统或基本网络环境来完成软件实现方案是不可思议的。</p>
<p>技术支撑方案应该为多个用例的软件实现提供技术服务，所以，它应该成为整个目标软件系统中全局性的公共技术平台。当用户需求发生变化时，技术支撑方案应具有良好的稳定性。这就要求软件设计者选用开放性和可扩充性较好的技术支撑方案。如果目标软件系统的顶层架构采用分层方式，那么技术支撑方案应该位于层次结构中的较低层次。</p>
<p>技术支撑方案的设计一方面取决于目标软件系统对公共技术服务的需求，另一方面取决于设计人员对软件技术手段的把握和选取。</p>
<h5 id="设计用户界面"><a href="#设计用户界面" class="headerlink" title="设计用户界面"></a>设计用户界面</h5><p>用户界面设计的策略与步骤如下：</p>
<p>（1）熟悉用户并对用户分类。设计人员应深入用户环境，考虑用户需要完成的任务、完成这些任务需要什么工具支持以及这些工具对用户是否适用。事实上，不同类型的用户要求也不同，一般可按技术熟练程度、工作性质和访问权限对用户进行分类，以便尽量照顾到所有用户的合理要求，并优先满足某些特权用户。</p>
<p>2）按用户类别分析用户的工作流程与习惯。在用户分类的基础上，从每类中选取一个用户代表，建立包括下列内容的调查表，并通过对调查结果的分析判断用户对操作界面的需求和喜好。</p>
<ul>
<li>姓名。</li>
<li>期望软件用途。</li>
<li>特征（如年龄、文化程度、限制等）。</li>
<li>主要要求与喜好。</li>
<li>技术熟练程度。</li>
<li>任务客观场景描述。</li>
</ul>
<p>（3）设计命令系统并进行优化。在设计一个新命令系统时，应尽量遵循用户界面的一般原则和规范，必要时可参考一些优秀的商品软件。根据用户分析结果确定初步的命令系统，然后再优化。命令系统既可为若干菜单、菜单栏，也可为一组按钮。优化命令系统时首先应考虑命令的顺序，一般常用命令居先，命令的顺序与用户工作习惯保持一致；其次，根据外部服务之间的聚合关系组织相应的命令，总体功能对应父命令，部分功能对应子命令；然后，充分考虑人类记忆的局限性（即所谓“7 12”原则或“3×3”原则），命令系统最好组织为一棵两层的多叉树；最后，应尽可能减少用户完成一个操作所需的动作（如单击鼠标、拖曳鼠标和敲击键盘等），并为熟练用户提供操作的快捷方式。</p>
<p>（4）设计用户界面的各种细节。此步骤包括设计一致的用户界面风格、耗时操作的状态反馈、undo机制、帮助用户记忆的操作序列和自封闭的集成环境等。</p>
<p>（5）增加用户界面专用的类与对象。用户界面专用类的设计与所选用的图形用户界面（GUI）工具或者支持环境有关。一般而言，需要为窗口、菜单、对话框等界面元素定义相应的类，这些类往往继承自GUI工具或者支持环境提供的类库中的父类。最后，还需要针对每个与用户命令处理相关的界面类，定义控制设计模型中的其他类的方法。</p>
<p>利用快速原型演示，改进界面设计。为人机交互部分构造原型，是界面设计的基本技术之一。为用户演示界面原型，让他们直观感受目标软件系统的使用方法，并评判系统是否功能齐全、方便好用。</p>
<h5 id="精化设计模型"><a href="#精化设计模型" class="headerlink" title="精化设计模型"></a>精化设计模型</h5><p>对模型进行改进的活动可以分为$\color{green}{\text{精化}}$和$\color{green}{\text{合并}}$两种，一般先从精化开始。首先，由于初始架构模型已经包括了总原则和层结构两部分的内容。现在要做的工作是根据需求和架构原则来划分不同的粗粒度组件。粗粒度组件来源于分析活动中的业务实体。把具有很强相关性业务实体组合起来，形成一个集合。集合内部存在错综复杂的关系，同时集合向外部提供服务接口。这样的集合就称为粗粒度组件。粗粒度组件对外的接口和内部的实现是相区分的。粗粒度组件的形式有很多，Java平台上的Jar文件、Windows平台上的dll文件，甚至古老的。或a文件都可以是粗粒度组件的表现形式。设计优秀的粗粒度组件应该只是完成一项功能，这一点是它与子系统的主要区分。一个系统中可能包括会计子系统、库存管理子系统。但是提供会计粗粒度组件或是库存管理粗粒度组件是没有什么意义的。因为这样的粗粒度组件的范围过于广泛，难以发挥重用的价值。粗粒度组件是可以（可能也是必须）跨越层次的。粗粒度组件拥有持久化的行为，拥有业务逻辑，需要表示层的支持。这样看起来，它所属的轴向和层次的轴向是相互垂直的。粗粒度组件来源于需求。需求阶段产生的需求说明书或是用例模型将是粗粒度组件开发的基础。在拥有了需求工件之后，我们需要对需求进行功能性的划分，将需求分为几个功能组，这样我们基本上就可以得到相应的粗粒度组件了。如果系统比较庞大，可以对功能组再做细分。这取决于粗粒度组件的范围。过小的范围，将会造成粗粒度组件不容易使用，用户需要理解不同的粗粒度组件之间的复杂关系，最后的结果也将包含大量的组件和复杂的逻辑。过大的范围，则会造成粗粒度组件难以重用，导致粗粒度组件称为一个子系统。</p>
<p>假设需要开发一个人力资源管理系统。经过整理，它的需求大致分为如下几个部分。</p>
<ul>
<li>组织结构的设计和管理：包括员工职务管理和员工所属部门的管理。</li>
<li>员工资料的管理：包括员工的基本资料和简单的考评资料。</li>
<li>日常事务的管理：包括了对员工的考勤管理和工资发放管理。</li>
</ul>
<p>对于前两项的功能组，建立粗粒度组件是比较合适的。但是对于第三项功能组，由于范围过大，将之分为考勤管理和工资管理。现在我们得到了4个粗粒度组件。分别是组织结构组件、员工资料组件、员工考勤组件和员工工资组件。</p>
<p>在得到了粗粒度组件之后，下面的工作分为两个部分：第一个部分是定义不同的粗粒度组件之间的关系。第二个部分是在粗粒度组件的基础上定义业务实体或是定义细粒度组件。</p>
<p>不同的粗粒度组件之间的关系其实就是前文提到的粗粒度组件的外部接口。如果可能，在粗粒度组件之间定义单向的关联（如上图所示）可以有效的减少组件之间的耦合。如果必须要定义双向的关联，请确保关联双方组件之间的一致性。在图6-23中，我们可以清晰的看出，组织结构处于最底层，员工资料依赖于组织结构，包括从组织结构中获得员工的所属部门，以及员工职务等信息。而对于考勤、工资组件来说，需要从员工资料中获取必要的信息，也包括了部门和职务两方面的信息。这里有两种关联定义的方法，一种是让考勤组件从组织结构组件中获得部门和职务信息，从员工资料中获得另外的信息，另一种是如图6-23一样，考勤组件只从员工资料组件中获得信息，而员工资料组件再使用委托，从组织结构中获得部门和职务的信息。第二种做法的好处是向考勤、工资组件屏蔽了组织结构组件的存在，并保持了信息获取的一致性。这里演示的只是组件之间的简单关系，现实中的关系不可能如此的简单，但是处理的基本思路是一样的，就是尽可能简化组件之间的关系，从而减少它们之间的耦合度。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725195410.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725195410.png';" /></details>

<p>在得到了粗粒度组件模型之后，我们需要对其进行进一步的分析，以得到细粒度的组件。细粒度的组件具有更好的重用性，并使得架构设计的精化工作更进一步。按Jacobson推荐的面向对象软件工程（Object Oriented Software Enginerring, OOSE）的做法，我们需要从软件的目标领域中识别出关键性的实体，或者说是领域中的名词。例如上例中的员工、部门、工资等。然后决定它们应该归属于哪些粗粒度组件。先识别细粒度组件还是先识别粗粒度组件并没有固定的顺序。</p>
<p>最初得到的组件模型可能并不完善，需要对其进行修改。可能某个组件中的类太多了，过于复杂，就需要对其进一步精化、分为更细的组件，也许某个组件中的类太少了，需要和其他的组件进行合并。也许你会发现某两个组件之间存在重复的要素，可以从中抽取出共性的部分，形成新的组件。组件分析的过程并没有一种标准的做法，你只能够根据具体的案例来进行分析。</p>
<p>最后的模型将会明确的包含几个经过精化之后的粗粒度组件。粗粒度组件之间的关系也会进行一次重新定义。</p>
<h3 id="系统架构文档化"><a href="#系统架构文档化" class="headerlink" title="系统架构文档化"></a>系统架构文档化</h3><h4 id="模型概述"><a href="#模型概述" class="headerlink" title="模型概述"></a>模型概述</h4><p>软件架构用来处理软件高层次结构的设计和实施。它以精心选择的形式将若干结构元素进行装配，从而满足系统主要功能和性能需求，并满足其他非功能性需求，如可靠性、可伸缩性、可移植性和可用性。Perry和Wolfe使用一个精确的公式来表达，该公式由Boehm做了进一步修改。</p>
<p>$\color{green}{\text{软件架构}}$＝｛元素，形式，关系/约束｝</p>
<p>软件架构涉及到抽象、分解和组合、风格和美学。我们用由多个视图或视角组成的模型来描述它。为了最终处理大型的、富有挑战性的架构，该模型包含5个主要的视图如图6-24所示。</p>
<ul>
<li>逻辑视图（logical view），设计的对象模型（使用面向对象的设计方法时）。</li>
<li>过程视图（process view），捕捉设计的并发和同步特征。</li>
<li>物理视图（physical view），描述了软件到硬件的映射，反映了分布式特性。</li>
<li>开发视图（development view），描述了在开发环境中软件的静态组织结构。</li>
</ul>
<p>架构的描述，即所做的各种决定，可以围绕着这4个视图来组织，然后由一些用例（use cases）或场景（scenarios）来说明，从而形成了第5个视图。正如将看到的，实际上软件架构部分从这些场景演进而来。</p>
<details><summary>图6-24　Rational“4＋1”视图模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725202552.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725202552.png';" /></details>




<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>近年来，在面向对象领域中的一个重要突破就是提出了设计模式的概念。软件的设计模式是人们在长期的开发实践中良好经验的结晶，它提供了一个简单、统一的描述方法，使人们可以复用这些软件设计方法、过程管理经验。由于设计模式在表达上既经济又清楚，从而越来越受到重视。本章将介绍软件设计模式的概念、组成要素和分类，并介绍了façade、Adapter、Abstract Factory等常用设计模式。</p>
<p>补充材料</p>
<h3 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h3><p>在任何设计活动中都存在着某些重复遇到的典型问题，不同开发人员对这些问题设计出不同的解决方案，随着设计经验在实践者之间日益广泛地被利用，描述这些共同问题和解决这些问题的方案就形成了所谓的模式。</p>
<h4 id="设计模式的历史"><a href="#设计模式的历史" class="headerlink" title="设计模式的历史"></a>设计模式的历史</h4><p>模式概念是建筑师Christopher Alexander提出的，他提出可以把现实中一些已经实现的较好的建筑和房屋的设计经验作为模式，在以后的设计中直接加以运用。他还定义了一种“模式语言”来描述建筑和城市中的成功的架构。</p>
<p>Christopher Alexander将模式分为几个部分：首先是特定的情景（Context），指模式在何种状况下发生作用；其二是动机（System of Force），指问题或预期的目标；其三是解决方案（Solution），指平衡各动机或解决所阐述问题的一个构造或配置。他提出模式是表示特定的情景、动机、解决方案三个方面关系的一个规则，每个模式描述了一个在某种特定情景下不断重复发生的问题，以及该问题解决方案的核心所在。模式既是一个事物又是一个过程，不仅描述该事物本身，而且提出了通过怎样的过程来产生该事物。设计模式的核心是问题描述和解决方案，问题描述说明模式的最佳使用场合及它将如何解决问题，解决方案是用一组类和对象及其结构和动态协作来描述的。</p>
<p>20世纪80年代中期由Ward Cunningham和Kent Beck将其思想引入到软件领域。1995年，E. Gamma，R. Helm，R. Johnson和J. Vlissides4人合著了Design Patterns; Elements of Object-Oriented Software，这是软件设计模式领域中的一本经典书籍，从此设计模式成为软件工程领域内的一个重要研究领域，这四人也因此被称为Gang of Four（GoF），成为设计模式中的大师级人物。</p>
<h4 id="为什么要使用设计模式"><a href="#为什么要使用设计模式" class="headerlink" title="为什么要使用设计模式"></a>为什么要使用设计模式</h4><p>面向对象设计时需要考虑许多因素，例如封装性、粒度大小、依赖关系、灵活性和可重用性等。如何确定系统中类及类之间的关系？如何保证在系统内部的一个类始终只有一个实例被创建？如何动态地将追加的功能增加到一个对象？哪些是设计时要努力达到的目标？这些都是软件设计中不容易掌握的问题。要真正掌握软件设计，必须研究其他软件设计大师的设计，这些设计中包含了许多设计模式。软件模式的应用对软件开发产生了重大的作用，主要表现在以下几个方面。</p>
<h5 id="简化并加快设计"><a href="#简化并加快设计" class="headerlink" title="简化并加快设计"></a>简化并加快设计</h5><p>开发人员面对的问题来自不同的层次。在最底层，涉及的是单个类的接口或实现的细节问题；在最高层，涉及的是系统的整体架构的创建问题。设计模式关注的是中间层，在这一层必须保证局部化的特定的设计性质。设计模式使得软件开发人员无须从底层做起，开发人员可以重用成功的设计，可节省开发时间，同时有助于提高软件质量。</p>
<h5 id="方便开发人员之间的通信"><a href="#方便开发人员之间的通信" class="headerlink" title="方便开发人员之间的通信"></a>方便开发人员之间的通信</h5><p>利用设计模式可以更准确地描述问题及问题的解决方案，使解决方案具有一致性；也有利于开发人员可以在更高层次上思考问题和讨论方案。例如，如果所有人都理解Factory设计模式的意思，则开发人员可以用“建议采用Factory设计模式来解决这个问题”这样的话来表达。</p>
<h5 id="降低风险"><a href="#降低风险" class="headerlink" title="降低风险"></a>降低风险</h5><p>由于设计模式经过很多人的使用，已被证明是有效的解决方法，所以采用设计模式可以降低失败的可能性，也有利于在复杂的系统中产生简洁、精巧的设计。</p>
<h5 id="有助于转到面向对象技术"><a href="#有助于转到面向对象技术" class="headerlink" title="有助于转到面向对象技术"></a>有助于转到面向对象技术</h5><p>新技术要在一个开发机构中得到应用，一般要经历两个阶段，即技术获取阶段和技术迁移阶段。技术获取阶段较容易，但在技术迁移阶段，由于开发人员对新技术往往会有抵触或排斥心理，对新技术可能带来的效果持怀疑态度，同时由于对新技术还是一知半解，所以要在一个开发机构中进行技术迁移并不是一件容易的事。设计模式一般都是基于面向对象技术而提出的，也可应用于接口定义良好的结构化方法中。另外，设计模式是可重用的设计经验的总结，已在实际的系统中多次得到成功应用，因此通过对设计模式的研究，能够深入理解良好设计的最基本的性质，从而有助于说服开发人员采用新技术。</p>
<p>成熟的软件设计模式具有以下特性。</p>
<p>（1）巧妙：设计模式是一些优雅的解决方案，是在大量实践经验的基础上提炼出来的。</p>
<p>（2）通用：设计模式通常不依赖于某个特定的系统类型、程序设计语言或应用领域，它们是通用的。</p>
<p>（3）得到很好的证明：设计模式在实际系统和面向对象系统中得到广泛应用，它们并不仅仅停留在理论上。</p>
<p>（4）简单：设计模式通常都非常简单，只涉及很少的一些类。为了构建更多更复杂的解决方案，可以把不同的设计模式与应用代码结合或混合使用。</p>
<p>（5）可重用：设计模式的建档方式使它们非常易于使用，因而可方便用于任何适宜的系统。</p>
<p>（6）面向对象：设计模式是用最基本的面向对象机制如类、对象、多态等构造的。许多模式特别强调了某些面向对象设计擅长的领域，例如，区分接口和实现、降低各部分之间的依赖性、隔离硬件和软件等。</p>
<h4 id="设计模式的组成元素"><a href="#设计模式的组成元素" class="headerlink" title="设计模式的组成元素"></a>设计模式的组成元素</h4><p>模式是一个高度抽象的概念。设计模式的基本组成元素如下。</p>
<h5 id="模式名"><a href="#模式名" class="headerlink" title="模式名"></a>模式名</h5><p>模式必须具有一个有意义的名称，这样就可以用一个词或短语来指代该模式，以及它所描述的知识和结构。模式名称简洁地描述了模式的本质。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果，找到恰当的模式名也是设计模式编目工作的难点之一。</p>
<h5 id="问题或意图"><a href="#问题或意图" class="headerlink" title="问题或意图"></a>问题或意图</h5><p>陈述问题并描述它的意图，以及它在特定的情景和动机下要达到的目标，它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等，也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。通常情况下这些动机和目标是相互矛盾、相互影响的。</p>
<h5 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h5><p>情景是问题及其解决方案产生时的前提条件。情景告诉我们该模式的适用性，可以将情景视为应用该模式之前的系统初始配置。</p>
<h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><p>它描述相关的动机和约束，它们之间或与期望达到的目标之间的相互作用（或冲突），通常需要对各期望的目标进行优先级排序。动机阐明了问题的复杂性，定义了在相互冲突时所采取的各种权衡手段。一个好的模式应尽可能将所有产生影响的动机考虑在内。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>解决方案是描述一些静态的关系和动态的规则，用以描述如何得到所需的结果。通常是给出一组指令来说明如何构造所需的工作制品。该说明可包括图表、文字，用以标示模式的结构、参与者及其之间的协作，从而表明问题是如何解决的。因为模式就像一个模板，可应用于多种不同的场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>示例指一个或多个该模式的应用例子，示例说明了模式在怎样的初始情景下如何发生作用，如何改变情景而导致结果情景的出现。示例帮助读者理解模式的具体使用方法。</p>
<h5 id="结果情景"><a href="#结果情景" class="headerlink" title="结果情景"></a>结果情景</h5><p>结果情景指在应用该模式后系统的状态或配置，包括模式发生作用后带来的后果，以及在新的情景下产生的问题、可应用的模式等。它阐述了模式的后续状态和副作用。通常通过对结果情景的描述，使该模式与其他模式联系起来（该模式的结果情景成为其他模式的初始情景）。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>基本原理指对该模式中的解决步骤或采用的规则的解释、证明，解释该模式如何、为何能解决当前问题，它采用的方法为何能得到与期望相一致的结果。</p>
<h5 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h5><p>该模式与其他模式的关系，包括静态的和动态的。例如，该模式的前导模式（前导模式应用后产生的结果情景与该模式的初始情景一致）、后续模式（该模式应用后产生的结果情景与后续模式的初始情景一致）、替代模式（使用该模式的替代模式产生同样的效果）等。</p>
<h5 id="已知应用"><a href="#已知应用" class="headerlink" title="已知应用"></a>已知应用</h5><p>阐述该模式在已有应用系统中的实际应用情况，有助于验证该模式的有效性。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。模式效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</p>
<p>通常好的模式前面都有一个摘要，提供简短的总结和概述，为模式描绘出一个清晰的图画，提供有关该模式能够解决问题的快速信息。有时这种描述称为模式的缩略概要，或一个缩略图。模式应该说明它的目标读者，以及对读者有哪些知识要求。</p>
<h4 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h4><p>软件模式主要可分为设计模式、分析模式、组织和过程模式等，每一类又可细分为若干个子类。在此着重介绍设计模式，目前它的使用最为广泛。设计模式主要用于得到简洁灵活的系统设计，GoF的书中共有23个设计模式，这些模式可以按两个准则来分类：一是按设计模式的目的划分，可分为创建型、结构型和行为型三种模式；二是按设计模式的范围划分，即根据设计模式是作用于类还是作用于对象来划分，可以把设计模式分为类设计模式和对象设计模式。</p>
<h5 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h5><p>该类型模式是对对象实例化过程的抽象，它通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息。</p>
<h5 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h5><p>该类模式主要用于如何组合已有的类和对象以获得更大的结构，一般借鉴封装、代理、继承等概念将一个或多个类或对象进行组合、封装，以提供统一的外部视图或新的功能。</p>
<h5 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h5><p>该类模式主要用于对象之间的职责及其提供的服务的分配，它不仅描述对象或类的模式，还描述它们之间的通信模式，特别是描述一组对等的对象怎样相互协作以完成其中任一对象都无法单独完成的任务。</p>
<h3 id="设计模式实例"><a href="#设计模式实例" class="headerlink" title="设计模式实例"></a>设计模式实例</h3><h4 id="创建性模式"><a href="#创建性模式" class="headerlink" title="创建性模式"></a>创建性模式</h4><p>在系统中，创建性模式支持对象的创建。该模式允许在系统中创建对象，而不需要在代码中标识特定类的类型，这样用户就不需要编写大量、复杂的代码来初始化对象。它是通过该类的子类来创建对象的。但是，这可能会限制在系统内创建对象的类型或数目。本节将介绍如下的创建性模式：</p>
<ul>
<li>Abstract Factory（抽象工厂）。</li>
<li>Builder（构建器）。</li>
<li>Factory Method（工厂方法）。</li>
<li>Prototype（原型）。</li>
<li>Singleton（单独）。</li>
</ul>
<h5 id="Abstract-Factory模式"><a href="#Abstract-Factory模式" class="headerlink" title="Abstract Factory模式"></a>Abstract Factory模式</h5><p>在不指定具体类的情况下，这种模式为创建一系列相关或相互依赖的对象提供了一个接口。根据给定的相关抽象类，Abstract Factory模式提供了从一个相匹配的具体子类集创建这些抽象类的实例的方法，如图7-1所示。</p>
<p>Abstract Factory模式提供了一个可以确定合适的具体类的抽象类，这个抽象类可以用来创建实现标准接口的具体产品的集合。客户端只与产品接口和Abstract Factory类进行交互。使用这种模式，客户端不用知道具体的构造类。Abstract Factory模式类似于Factory Method模式，但是Abstract Factory模式可以创建一系列的相关对象。</p>
<p>其优点如下。</p>
<ul>
<li>可以与具体类分开。</li>
<li>更容易在产品系列中进行转换。</li>
<li>提高了产品间的一致性。</li>
</ul>
<details><summary>图7-1　Abstract Factory模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210719133628.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210719133628.png';" /></details>

<p>在以下情况中，应该使用Abstract Factory模式：</p>
<ul>
<li>系统独立于产品的创建、组成以及表示。</li>
<li>系统配置成具有多个产品的系列，例如Microsoft Windows或Apple McIntosh类。</li>
<li>相关产品对象系列是共同使用的，而且必须确保这一点。这是该模式的关键，否则可以使用Factory Method模式。</li>
<li>你希望提供产品的类库，只开放其接口，而不是其实现。</li>
</ul>
<h5 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h5><p>Builder模式将复杂对象的构建与其表示相分离，这样相同的构造过程可以创建不同的对象。通过只指定对象的类型和内容，Builder模式允许客户端对象构建一个复杂对象。客户端可以不受该对象构造的细节的影响。这样通过定义一个能够构建其他类实例的类，就可以简化复杂对象的创建过程。Builder模式生产一个主要产品，而该产品中可能有多个类，但是通常只有一个主类。图7-2所示的就是Builder模式，当使用该模式时，可以一次就创建所有的复杂对象。而其他模式一次就只能创建一个对象。</p>
<p>其优点如下。</p>
<ul>
<li>可以对产品的内部表示进行改变。</li>
<li>将构造代码与表示代码相分离。</li>
</ul>
<p>在以下情况中，应该使用Builder模式：</p>
<ul>
<li>创建复杂对象的算法独立于组成对象的部分以及这些部分的集合方式。</li>
<li>构造过程必须允许已构建对象有不同表示。</li>
</ul>
<details><summary>图7-2　Builder模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210719134540.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210719134540.png';" /></details>

<h5 id="Factory-Method模式"><a href="#Factory-Method模式" class="headerlink" title="Factory Method模式"></a>Factory Method模式</h5><p>Factory Method模式定义了创建对象的接口，它允许子类决定实例化哪个类。它允许类将实例化工作交给其子类，这对于在特定目的下构建单个对象是非常有帮助的，而且它不需要请求者知道要被实例化的特定类，这就可以在不修改代码的情况下引入新类，因为新类只实现了接口，这样它就可以被客户端使用。可以创建一个新的Factory类来创建新类，而由这个Factory类来实现Factory接口。图7-3所示的是Factory Method模式。</p>
<h2 id="XML技术"><a href="#XML技术" class="headerlink" title="XML技术"></a>XML技术</h2><h2 id="面向构建的软件设计"><a href="#面向构建的软件设计" class="headerlink" title="面向构建的软件设计"></a>面向构建的软件设计</h2><h2 id="构建平台与典型架构"><a href="#构建平台与典型架构" class="headerlink" title="构建平台与典型架构"></a>构建平台与典型架构</h2><h2 id="信息安全技术"><a href="#信息安全技术" class="headerlink" title="信息安全技术"></a>信息安全技术</h2><h2 id="系统安全架构设计"><a href="#系统安全架构设计" class="headerlink" title="系统安全架构设计"></a>系统安全架构设计</h2><h2 id="系统的可靠性设计"><a href="#系统的可靠性设计" class="headerlink" title="系统的可靠性设计"></a>系统的可靠性设计</h2><h2 id="基于ODP的架构师设计"><a href="#基于ODP的架构师设计" class="headerlink" title="基于ODP的架构师设计"></a>基于ODP的架构师设计</h2><h2 id="架构师的管理实践"><a href="#架构师的管理实践" class="headerlink" title="架构师的管理实践"></a>架构师的管理实践</h2><h2 id="层次式架构设计"><a href="#层次式架构设计" class="headerlink" title="层次式架构设计"></a>层次式架构设计</h2><h2 id="企业集成架构设计"><a href="#企业集成架构设计" class="headerlink" title="企业集成架构设计"></a>企业集成架构设计</h2><h2 id="面向方面的编程"><a href="#面向方面的编程" class="headerlink" title="面向方面的编程"></a>面向方面的编程</h2><h2 id="嵌入式系统设计"><a href="#嵌入式系统设计" class="headerlink" title="嵌入式系统设计"></a>嵌入式系统设计</h2><h2 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h2><h2 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">总结-计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 13:02:27" itemprop="dateCreated datePublished" datetime="2021-07-19T13:02:27+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 16:32:21" itemprop="dateModified" datetime="2021-07-30T16:32:21+08:00">2021-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h1 id="凑数"><a href="#凑数" class="headerlink" title="凑数"></a>凑数</h1><h2 id="凑数-1"><a href="#凑数-1" class="headerlink" title="凑数"></a>凑数</h2><h3 id="凑数-2"><a href="#凑数-2" class="headerlink" title="凑数"></a>凑数</h3><h4 id="凑数-3"><a href="#凑数-3" class="headerlink" title="凑数"></a>凑数</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E6%80%BB%E7%BB%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E6%80%BB%E7%BB%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">总结-计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 13:02:27" itemprop="dateCreated datePublished" datetime="2021-07-19T13:02:27+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 16:32:21" itemprop="dateModified" datetime="2021-07-30T16:32:21+08:00">2021-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>【考纲内容】</p>
<p>(一）计算机网络概述</p>
<p>计算机网络的概念、组成与功能;</p>
<p>计算机网络的分类</p>
<p>计算机网络的性能指标</p>
<p>(二）计算机网络体系结构与参考模型</p>
<p>计算机网络分层结构;计算机网络协议、接口、服务的概念</p>
<p>ISO/OSI参考模型和 TCP/IP模型</p>
<p>【复习提示】</p>
<p>本章主要介绍计算机网络体系结构的基本概念，读者可以在理解的基础上适当地记忆。重点掌握网络的分层结构（包括5层和7层结构)，尤其是ISO/OSI参考模型各层的功能及相关协议、接口和服务等概念。掌握有关网络的各种性能指标，特别是时延、带宽、速率和吞吐量等的计算。</p>
<p>OSI参考模型的功能</p>
<table>
<thead>
<tr>
<th>层</th>
<th>物理寻址</th>
<th>流量控制</th>
<th>差错校验</th>
<th>拥塞控制</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>处理信号通过介质的传输</td>
</tr>
<tr>
<td>数据链路层</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{green}{\checkmark}$</td>
<td>$\color{red}{\times}$(王道)</td>
<td>保证数据正确的顺序和完整性;链路连接的建立、拆除、分离;帧界定和帧同步;差错检测;物理寻址;数据重发</td>
</tr>
<tr>
<td>网络层</td>
<td></td>
<td></td>
<td></td>
<td>$\color{green}{\checkmark}$</td>
<td>控制报文通过网络的路由选择；提供面向连接和无连接的服务</td>
</tr>
<tr>
<td>传输层</td>
<td></td>
<td>$\color{green}{\checkmark}$</td>
<td></td>
<td>$\color{green}{\checkmark}$</td>
<td>仅提供面向连接的服务</td>
</tr>
<tr>
<td>会话层</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>应用层</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>提供用户和网络的接</td>
</tr>
</tbody></table>
<p>(raw page:课本的页码，pp:pdf page, pdf书籍阅读器的index)</p>
<blockquote>
<p>(王相林.rp.159)$\color{red}{\text{流量控制}}$是对一条通信路径上的流量进行控制，其目的是保证发送者的发送速度不超过接收者的接收速度。流量控制只设计一个发送者和一个接收者，涉及两个节点，可以是相邻节点之间，也可以是端节点之间，分别对应$\color{green}{\text{数据链路层}}$的相邻节点之间的流量控制，以及$\color{green}{\text{运输层}}$的端节点之间的流量控制。流量控制只涉及两个网络节点，属于是局部控制。<br>(王相林.rp.159)$\color{red}{\text{拥塞控制}}$是对整个通信子网的流量进行控制，其目的是保证通信子网的流量与网络可提供资源相匹配，不出现网络系统性能恶化、甚至崩溃的局面。拥塞控制涉及网络中多个节点（主机、路由器、交换机），属于是全局控制。拥塞控制的最终目标是，防止由于网络中PDU过载而使网络的吞吐量下降，合理分配网络资源；避免死锁；匹配速度传输速度。拥塞控制涉及的网络层次有：$\color{green}{\text{数据链路层}}$、$\color{green}{\text{网络层}}$和$\color{green}{\text{运输层}}$，而这些层次上对拥塞控制产生影响的策略，见表5-3。<br>流量控制涉及的层次有数据链路层和运输层。流量控制一般是由接收方根据自己缓冲区的大小和接收数据的情况，给发送方反馈流量控制信息，也就是说，是由接收方控制发送方发送数据的速率。流量控制与拥寒控制是相关的，若局部的流量控制做得很好，可以对全局的拥塞控制起到缓解的作用。</p>
</blockquote>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725152627.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725152627.png';" /></details>


<p>五层协议栈（Five-layer Internet protocol stack）</p>
<table>
<thead>
<tr>
<th>名称(name)</th>
<th>协议（protocols)</th>
<th>分组名称（packet name）</th>
</tr>
</thead>
<tbody><tr>
<td>应用层（Application Layer）</td>
<td>HTTP（WEB文档的请求和传送）<br /> SMTP（电子邮件）<br /> FTP（端系统间文件传送）</td>
<td>报文（message）</td>
</tr>
<tr>
<td>传输层（Transport Layer）</td>
<td>TCP<br />   UDP</td>
<td>报文段(segment);报文段(TCP);用户数据报(UDP)</td>
</tr>
<tr>
<td>网络层（Network Layer）</td>
<td>IP层</td>
<td>数据报(datagram)</td>
</tr>
<tr>
<td>链路层（Link Layer）</td>
<td>以太网<br />    WiFi<br />               电缆接入网的DOCSIS协议</td>
<td>帧(frame)</td>
</tr>
<tr>
<td>物理层（physical Layer）</td>
<td></td>
<td>比特(bit)</td>
</tr>
</tbody></table>
<p>物理设备</p>
<table>
<thead>
<tr>
<th>设备名</th>
<th>工作层</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>集线器(HUB)</td>
<td>物理层</td>
<td>多端口中继器</td>
</tr>
<tr>
<td>交换机(Switch)</td>
<td>数据链路层</td>
<td>多端口网桥</td>
</tr>
<tr>
<td>路由器(Router)</td>
<td>网络层</td>
<td>实现了网络模型的下三层，即物理层、数据链路层和网络层</td>
</tr>
</tbody></table>
<h3 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h3><h4 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h4><p>一般认为，计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。简而言之，计算机网络就是一些$\color{green}{\text{互联的}}$、$\color{green}{\text{自治}}$的$\color{green}{\text{计算机系统}}$的$\color{green}{\text{集合}}$。</p>
<p>在计算机网络发展的不同阶段，人们对计算机网络给出了不同的定义，这些定义反映了当时网络技术发展的水平。这些定义可分为以下三类。</p>
<h5 id="广义观点"><a href="#广义观点" class="headerlink" title="广义观点"></a>广义观点</h5><p>这种观点认为，只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，都是计算机网络。广义的观点定义了一个计算机通信网络，它在物理结构上具有计算机网络的雏形，但资源共享能力弱，是计算机网络发展的低级阶段。</p>
<h5 id="资源共享观点"><a href="#资源共享观点" class="headerlink" title="资源共享观点"></a>资源共享观点</h5><p>这种观点认为，计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。该定义包含三层含义:①目的——资源共享;②组成单元——分布在不同地理位置的多台独立的“自治计算机”;③网络中的计算机必须遵循的统一规则——网络协议。该定义符合目前计算机网络的基本特征。</p>
<h5 id="用户透明性观点"><a href="#用户透明性观点" class="headerlink" title="用户透明性观点"></a>用户透明性观点</h5><p>这种观点认为，存在一个能为用户自动管理资源的网络操作系统，它能够调用用户所需要的资源，而整个网络就像一个大的计算机系统一样对用户是透明的。用户使用网络就像使用一台单一的超级计算机，无须了解网络的存在、资源的位置信息。用户透明性观点的定义描述了一个分布式系统，它是网络未来发展追求的目标。</p>
<h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><p>从不同的角度，可以将计算机网络的组成分为如下几类。</p>
<p>1)从组成部分上看，一个完整的计算机网络主要由$\color{green}{\text{硬件}}$、$\color{green}{\text{软件}}$、$\color{green}{\text{协议}}$三大部分组成，缺一不可。硬件主要由主机（也称端系统)、通信链路（如双绞线、光纤)、交换设备（如路由器、交换机等）和通信处理机（如网卡）等组成。软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件（如网络操作系统、邮件收发程序、FTP程序、聊天程序等)。软件部分多属于应用层。协议是计算机网络的核心，如同交通规则制约汽车驾驶一样，协议规定了网络传输数据时所遵循的规范。</p>
<p>2）从工作方式上看，计算机网络（这里主要指Internet，即因特网）可分为$\color{green}{\text{边缘部分}}$和$\color{green}{\text{核心部分}}$。边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信(如传输数据、音频或视频）和资源共享;核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。图1.1给出了这两部分的示意图。</p>
<p>3）从功能组成上看，计算机网络由$\color{green}{\text{通信子网}}$和$\color{green}{\text{资源子网}}$组成。通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。资源子网是实现资源共享功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724094736.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724094736.png';" /></details>

<h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><p>计算机网络的功能很多，现今的很多应用都与网络有关。主要有以下五大功能。</p>
<h5 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h5><p>它是计算机网络最基本和最重要的功能，用来实现联网计算机之间各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。例如，文件传输、电子邮件等应用，离开了计算机网络将无法实现。</p>
<h5 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h5><p>资源共享可以是软件共享、数据共享，也可以是硬件共享。它使计算机网络中的资源互通有无、分工协作，从而极大地提高硬件资源、软件资源和数据资源的利用率。</p>
<h5 id="分布式处理"><a href="#分布式处理" class="headerlink" title="分布式处理"></a>分布式处理</h5><p>当计算机网络中的某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源以提高整个系统的利用率。</p>
<h5 id="提高可靠性"><a href="#提高可靠性" class="headerlink" title="提高可靠性"></a>提高可靠性</h5><p>计算机网络中的各台计算机可以通过网络互为替代机。</p>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>将工作任务均衡地分配给计算机网络中的各台计算机。</p>
<p>除以上几大主要功能外，计算机网络还可以实现电子化办公与服务、远程教育、娱乐等功能，满足了社会的需求，方便了人们学习、工作和生活，具有巨大的经济效益。</p>
<h4 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h4><h5 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h5><p>1)广域网（WAN)。广域网的任务是提供长距离通信，运送主机所发送的数据，其覆盖范围通常是直径为几十千米到几千千米的区域，因而有时也称远程网。广域网是因特网的核心部分。连接广域网的各结点交换机的链路一般都是高速链路，具有较大的通信容量。</p>
<p>2）城域网(MAN)。城域网的覆盖范围可以跨越几个街区甚至整个城市，覆盖区域的直径范围是5~50km。城域网大多采用以太网技术，因此有时也常并入局域网的范围讨论。</p>
<p>3）局域网（LAN)。局域网一般用微机或工.作站通过高速线路相连，覆盖范围较小，通常是直径为几十米到几千米的区域。局域网在计算机配置的数量上没有太多的限制，少的可以只有两台，多的可达几百台。传统上，局域网使用广播技术，而广域网使用交换技术。</p>
<p>4）个人区域网(PAN)。个人区域网是指在个人工作的地方将消费电子设备（如平板电脑、智能手机等）用无线技术连接起来的网络，也常称为无线个人区域网（WPAN)，覆盖区域的直径约为10m。</p>
<blockquote>
<p>注意:若中央处理器之间的距离非常近(如仅1m的数量级或甚至更小)，则一般称为多处理器系统，而不称为计算机网络。</p>
</blockquote>
<h5 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h5><p>1)广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组。局域网基本上都采用广播式通信技术，广域网中的无线、卫星通信网络也采用广播式通信技术。</p>
<p>2）点对点网络。每条物理线路连接一对计算机。若通信的两台主机之间没有直接连接的线路，则它们之间的分组传输就要通过中间结点进行接收、存储和转发，直至目的结点。是否采用分组存储转发与路由选择机制是点对点式网络与广播式网络的重要区别，广域网基本都属于点对点网络。</p>
<h5 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h5><p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系（如总线形、环形)表示的网络结构，主要指通信子网的拓扑结构。</p>
<p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系（如总线形、环形)表示的网络结构，主要指通信子网的拓扑结构。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724095447.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724095447.png';" /></details>

<p>1）总线形网络。用单根传输线把计算机连接起来。总线形网络的优点是建网容易、增/减结点方便、节省线路。缺点是重负载时通信效率不高、总线任意一处对故障敏感。</p>
<p>2）星形网络。每个终端或计算机都以单独的线路与中央设备相连。中央设备早期是计算机，现在一般是交换机或路由器。星形网络便于集中控制和管理，因为端用户之间的通信必须经过中央设备。缺点是成本高、中心设备对故障敏感。</p>
<p>3）环形网络。所有计算机接口设备连接成一个环。环形网络最典型的例子是$\color{green}{\text{令牌环局域网}}$。环可以是单环，也可以是双环，环中信号是单向传输的。</p>
<p>4）网状网络。一般情况下，每个结点至少有两条路径与其他结点相连，多用在广域网中。其有规则型和非规则型两种。其优点是可靠性高，缺点是控制复杂、线路成本高。以上4种基本的网络拓扑结构可以互联为更复杂的网络。</p>
<p>以上4种基本的网络拓扑结构可以互联为更复杂的网络。</p>
<h5 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h5><p>1）公用网（Public Network)。指电信公司出资建造的大型网络。“公用”的意思是指所有愿意按电信公司的规定交纳费用的人都可以使用这种网络，因此也称公众网。</p>
<p>2）专用网（Private Network)。指某个部门为满足本单位特殊业务的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如铁路、电力、军队等部门的专用网。</p>
<h5 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h5><p>交换技术是指各台主机之间、各通信设备之间或主机与通信设备之间为交换信息所采用的数据格式和交换装置的方式。按交换技术可将网络分为如下几种。</p>
<p>1)电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网是传统电话网络。该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送、时延小。缺点是线路利用率低、不能充分利用线路容量、不便于进行差错控制。</p>
<p>2)报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点，全部存储后，再转发给下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。报文交换网络也称存储-转发网络，主要特点是整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一个结点。优点是可以较为充分地利用线路容量，可以实现不同链路之间不同数据传输速率的转换，可以实现格式转换，可以实现一对多、多对一的访问，可以实现差错控制。缺点是增大了资源开销（如辅助信息导致处理时间和存储资源的开销)，增加了缓冲时延，需要额外的控制机制来保证多个报文的顺序不乱序，缓冲区难以管理（因为报文的大小不确定，接收方在接收到报文之前不能预知报文的大小)。</p>
<p>3）分组交换网络，也称包交换网络。其原理是，将数据分成较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包)，以存储-转发方式传输。其主要特点是单个分组（它只是整个报文的一部分）传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点:缓冲易于管理;包的平均时延更小，网络占用的平均缓冲区更少;更易于标准化;更适合应用。现在的主流网络基本上都可视为分组交换网络。</p>
<blockquote>
<p>报文交换和分组交换的区别：整个报文在网络中传递，分组交换报文被分割了</p>
</blockquote>
<h5 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h5><p>传输介质可分为有线和无线两大类，因此网络可以分为有线网络和无线网络。有线网络又分为双绞线网络、同轴电缆网络等。无线网络又可分为蓝牙、微波、无线电等类型。</p>
<h4 id="计算机网络的标准化工作及相关组织"><a href="#计算机网络的标准化工作及相关组织" class="headerlink" title="*计算机网络的标准化工作及相关组织"></a>*计算机网络的标准化工作及相关组织</h4><p>计算机网络的标准化对计算机网络的发展和推广起到了极为重要的作用。</p>
<p>因特网的所有标准都以RFC (Request For Comments）的形式在因特网上发布，但并非每个RFC都是因特网标准，RFC要上升为因特网的正式标准需经过以下4个阶段。</p>
<p>1)）因特网草案（ Internet Draft)。这个阶段还不是RFC文档。</p>
<p>2）建议标准（Proposed Standard)。从这个阶段开始就成为RFC文档。3）草案标准（Draft Standard)。</p>
<p>4）因特网标准(Internet Standard)。</p>
<p>此外，还有试验的RFC和提供信息的RFC。各种RFC之间的关系如图1.3所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724095943.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724095943.png';" /></details>

<p>在国际上，负责制定、实施相关网络标准的标准化组织众多，主要有如下几个:</p>
<ul>
<li>国际标准化组织(ISO)。其制定的主要网络标准或规范有OSI参考模型、HDLC等。</li>
<li>国际电信联盟(ITU)。其前身为国际电话电报咨询委员会(CCITT)，其下属机构ITU-T制定了大量有关远程通信的标准。</li>
<li>国际电气电子工程师协会（IEEE)。世界上最大的专业技术团体，由计算机和工程学专业人士组成。IEEE在通信领域最著名的研究成果是802标准。</li>
</ul>
<h4 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h4><p>性能指标从不同方面度量计算机网络的性能。常用的性能指标如下。</p>
<p>1）带宽（Bandwidth)。本来表示通信线路允许通过的信号频带范围，单位是赫兹（Hz)。而在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“最高数据传输速率”的同义语，单位是比特/秒( b/s）。</p>
<p>2）时延(Delay)。指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成:发送时延、传播时延、处理时延和排队时延。</p>
<ul>
<li>发送时延。结点将分组的所有比特推向（传输）链路所需的时间，即从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间，因此也称传输时延。计算公式为：发送时延=分组长度/信道宽度</li>
<li>传播时延。电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的一端传播到另一端所需的时间。计算公式为：传播时延=信道长度/电磁波在信道上的传播速率</li>
<li>处理时延。数据在交换结点为存储转发而进行的一些必要的处理所花费的时间。例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等。</li>
<li>排队时延。分组在进入路由器后要先在输入队列中排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</li>
</ul>
<p>因此，数据在网络中经历的总时延就是以上4部分时延之和:</p>
<p>总时延一发送时延＋传播时延＋处理时延＋排队时延</p>
<blockquote>
<p>注意:做题时，排队时延和处理时延一般可忽略不计（除非题目另有说明)。另外，对于高速链路，提高的仅是数据发送速率而非比特在链路上的传播速率。提高数据的发送速率只是为了减少数据的发送时延。</p>
</blockquote>
<p>3）时延带宽积。指发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特，因此又称以比特为单位的链路长度，即时延带宽积=传播时延×信道带宽。</p>
<p>如图1.4所示，考虑一个代表链路的圆柱形管道，其长度表示链路的传播时延，横截面积表示链路带宽，则时延带宽积表示该管道可以容纳的比特数量。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724100452.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724100452.png';" /></details>

<p>4)）往返时延(Round-Trip Time，RTT)。指从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认)，总共经历的时延。在互联网中，往返时延还包括各中间结点的处理时延、排队时延及转发数据时的发送时延。</p>
<p>5）吞吐量(Throughput)。指单位时间内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络额定速率的限制。</p>
<p>6）速率(Speed)。网络中的速率是指连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据传输速率、数据率或比特率，单位为 bl/s （比特/秒)(或bit/s，有时也写为bps)。数据率较高时，可用kb/s (k = 103)、Mb/s (M = 10°）或Gb/s (G = 10’)表示。在计算机网络中，通常把最高数据传输速率称为带宽。</p>
<p>7)信道利用率。指出某一信道有百分之多少的时间是有数据通过的，即信道利用率=有数据通过时间/(有+无)数据通过时间。</p>
<blockquote>
<p>结合计网期末考的概念：传输时延，重点在<code>输送</code>，传播实验，重点在<code>广播</code>（$\color{red}{\text{Q}}$：好像王道的传播和自顶向下的传播不是指一个东西）<br>注意带宽的单位是$\text{比特}/s=b/s$,不可以是$\text{字节}/s=B/s$！！</p>
</blockquote>
<p>网络的<a target="_blank" rel="noopener" href="https://blog.csdn.net/wanghaobo920/article/details/11877589">报文流和字节流</a>，程序中的<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/89316568.html">字符流和字节流</a></p>
<p><a target="_blank" rel="noopener" href="https://www.javapedia.net/JMS/1106">字节流和报文流</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/100037179">jms和socket</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hzq3554055/p/12004633.html">jms和amqp和rabbitmq的区别</a></p>
<h3 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h3><h4 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h4><p>两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对计算机网络的体系结构以分层的方式进行建模。</p>
<p>我们把计算机网络的各层及其协议的集合称为网络的体系结构（Architecture)。换言之，计算机网络的体系结构就是这个计算机网络及其所应完成的功能的精确定义，它是计算机网络中的层次、各层的协议及层间接口的集合。需要强调的是，这些功能究竟是用何种硬件或软件完成的,则是一个遵循这种体系结构的实现(Implementation)问题。体系结构是抽象的，而实现是具体的，是真正在运行的计算机硬件和软件。</p>
<p>计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分成若干较容易实现的层次。分层的基本原则如下:</p>
<p>1）每层都实现一种相对独立的功能，降低大系统的复杂度。</p>
<p>2）各层之间界面自然清晰，易于理解，相互交流尽可能少。</p>
<p>3）各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现。</p>
<p>4）保持下层对上层的独立性，上层单向使用下层提供的服务。</p>
<p>5）整个分层结构应能促进标准化工作。</p>
<p>由于分层后各层之间相对独立，灵活性好，因而分层的体系结构易于更新（替换单个模块)易于调试，易于交流，易于抽象，易于标准化。但层次越多，有些功能在不同层中难免重复出现，产生额外的开销，导致整体运行效率越低。层次越少，就会使每层的协议太复杂。因此，在分层时应考虑层次的清晰程度与运行效率间的折中、层次数量的折中。</p>
<p>依据一定的规则，将分层后的网络从低层到高层依次称为第1层、第2层……第n层，通常还为每层取一个特定的名称，如第1层的名称为$\color{green}{\text{物理层}}$。</p>
<p>在计算机网络的分层结构中，第n层中的活动元素通常称为第n层实体。具体来说，实体指任何可发送或接收信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为$\color{green}{\text{对等层}}$，同一层的实体称为$\color{green}{\text{对等实体}}$。第n层实体实现的服务为第n +1层所利用。在这种情况下，第n层称为$\color{green}{\text{服务提供者}}$，第n+1层则服务于$\color{green}{\text{用户}}$。</p>
<p>每一层还有自己传送的数据单位，其名称、大小、含义也各有不同。</p>
<p>在计算机网络体系结构的各个层次中，每个报文都分为两部分:一是数据部分，即SDU;二是控制信息部分，即 PCI，它们共同组成PDU。</p>
<p>服务数据单元(SDU):为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。</p>
<p>协议控制信息(PCI):控制协议操作的信息。第n层的协议控制信息记为n-PCI。</p>
<p>协议数据单元(PDU):对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据单元记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为$\color{green}{\text{比特}}$，数据链路层的PDU称为$\color{green}{\text{帧}}$，网络层的PDU称为$\color{green}{\text{分组}}$，传输层的PDU称为$\color{green}{\text{报文段}}$。</p>
<p>在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI,就变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反的处理，因此可知三者的关系为n-SDU + n-PCI = n-PDU=(n- 1)-SDU，其变换过程如图1.5所示。</p>
<details><summary>图1.5网络各层数据单元的联系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724162854.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724162854.png';" /></details>

<p>1)第n层的实体不仅要使用第n-1层的服务来实现自身定义的功能，还要向第n+1层提供本层的服务，该服务是第n层及其下面各层提供的服务总和。</p>
<p>2）最低层只提供服务，是整个层次结构的基础;中间各层既是下一层的服务使用者，又是上一层的服务提供者;最高层面向用户提供服务。</p>
<p>3)上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务;下一层所提供服务的实现细节对上一层透明。</p>
<p>4）两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方。</p>
<blockquote>
<p>也就是在物理上还是经过了下一层</p>
</blockquote>
<h4 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h4><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><p>协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则。这些规则明确规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议(Network Protocol)，它是控制两个(或多个）对等实体进行通信的规则的集合，是水平的。不对等实体之间是没有协议的，比如用TCP/IP 协议栈通信的两个结点，结点A的传输层和结点B的传输层之间存在协议，但结点A的传输层和结点B的网络层之间不存在协议。网络协议也简称为协议。</p>
<p>协议由语法、语义和同步三部分组成。语法规定了传输数据的格式;语义规定了所要完成的功能，即需要发出何种控制信息、完成何种动作及做出何种应答;同步规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。一个完整的协议通常应具有线路管理（建立、释放连接)、差错控制、数据转换等功能。</p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口是同一结点内相邻两层间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点(Service Access Point，SAP）进行交互。服务是通过SAP提供给上层使用的，第n层的SAP就是第n+1层可以访问第n层服务的地方。每个SAP都有一个能够标识它的地址。SAP是一个抽象的概念，它实际上是一个逻辑接口（类似于邮政信箱)，但和通常所说的两个设备之间的硬件接口是很不一样的。</p>
<h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>服务是指下层为紧邻的上层提供的功能调用，它是垂直的。对等实体在协议的控制下，使得本层能为上一层提供服务，但要实现本层协议还需要使用下一层所提供的服务。</p>
<p>上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI参考模型中称为服务原语。OSI参考模型将原语划分为4类:(原语的主语用绿色高亮)</p>
<p>1）请求(Request)。由$\color{green}{\text{服务用户}}$发往服务提供者，请求完成某项工作。</p>
<p>2）指示(Indication)。由$\color{green}{\text{服务提供者}}$发往服务用户，指示用户做某件事情。</p>
<p>3）响应(Response)。由$\color{green}{\text{服务用户}}$发往服务提供者，作为对指示的响应。</p>
<p>4）证实(Confirmation)。由$\color{green}{\text{服务提供者}}$发往服务用户，作为对请求的证实。</p>
<p>这4类原语用于不同的功能，如建立连接、传输数据和断开连接等。有应答服务包括全部4类原语，而无应答服务则只有请求和指示两类原语。<br>4类原语的关系如图1.6所示。</p>
<details><summary>4类原语的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724163436.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724163436.png';" /></details>

<p>一定要注意，协议和服务在概念上是不一样的。首先，只有本层协议的实现才能保证向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议，即下面的协议对上层的服务用户是透明的。其次，协议是“$\color{green}{\text{水平的}}$”，即协议是控制对等实体之间通信的规则。但服务是“$\color{green}{\text{垂直的}}$”，即服务是由下层通过层间接口向上层提供的。另外，并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才称为服务。</p>
<p>协议、接口、服务三者之间的关系如图1.7所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724163750.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724163750.png';" /></details>

<p>计算机网络提供的服务可按以下三种方式分类。</p>
<p>( 1)面向连接服务与无连接服务</p>
<p>在面向连接服务中，通信前双方必须先建立连接，分配相应的资源（如缓冲区)，以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可以分为连接建立、数据传输和连接释放三个阶段。例如TCP就是一种面向连接服务的协议。</p>
<p>在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包（报文分组）传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务。这种服务常被描述为“尽最大努力交付”(Best-Effort-Delivery)，它并不保证通信的可靠性。例如$\color{green}{\text{IP}}$、$\color{green}{\text{UDP}}$就是一种无连接服务的协议。</p>
<p>(2)可靠服务和不可靠服务</p>
<p>可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。</p>
<p>不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。</p>
<p>对于提供不可靠服务的网络，其网络的正确性、可靠性要由应用或用户来保障。例如，用户收到信息后要判断信息的正确性，如果不正确，那么用户要把出错信息报告给信息的发送者，以便发送者采取纠正措施。通过用户的这些措施，可以把不可靠的服务变成可靠的服务。</p>
<blockquote>
<p>注意:在一层内完成的全部功能并非都称为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务。</p>
</blockquote>
<p>( 3）有应答服务和无应答服务</p>
<p>有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统内部自动实现，而不由用户实现。所发送的应答既可以是肯定应答，也可以是否定应答，通常在接收到的数据有错误时发送否定应答。例如，文件传输服务就是一种有应答服务。</p>
<p>无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件后不给出应答。</p>
<h4 id="ISO-OSI参考模型和TCP-IP模型"><a href="#ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="ISO/OSI参考模型和TCP/IP模型"></a>ISO/OSI参考模型和TCP/IP模型</h4><h5 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h5><p>国际标准化组织(ISO）提出的网络体系结构模型，称为开放系统互连参考模型（OSI/RM),通常简称为OSI参考模型。OSI参考模型有7层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。低三层统称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能;高三层统称为资源子网，它相当于计算机系统，完成数据的处理等功能。传输层承上启下。OSI参考模型的层次结构如图1.8所示。</p>
<details><summary>图1.8 OSI参考模型的层次结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164119.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164119.png';" /></details>

<p>下面详述OSI参考模型各层的功能。</p>
<p>(1）物理层（Physical Layer)</p>
<p>物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地传输原始比特流。</p>
<p>物理层主要定义数据终端设备（DTE）和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称物理层接口标准。由于在通信技术的早期阶段,通信规则称为规程(Procedure),因此物理层协议也称物理层规程。</p>
<p>物理层接口标准很多，如EIA-232C、EIA/TIA RS-449、CCITT的X.21等。在计算机网络的复习过程中，不要忽略对各层传输协议的记忆，到了后期，读者对数据链路层、网络层、传输层和应用层的协议会比较熟悉，但往往容易忽视物理层的协议。</p>
<p>图1.9表示的是两个通信结点及它们间的一段通信链路，物理层主要研究以下内容:</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164314.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164314.png';" /></details>

<p>${\textstyle\unicode{x2460}}$  通信链路与通信结点的连接需要一些电路接口，物理层规定了这些接口的一些参数，如机械形状和尺寸、交换电路的数量和排列等，例如，笔记本电脑上的网线接口，就是物理层规定的内容之一。</p>
<p>${\textstyle\unicode{x2461}}$  物理层也规定了通信链路上传输的信号的意义和电气特征。例如物理层规定信号A代表数字0，那么当结点要传输数字0时，就会发出信号A，当结点接收到信号A时，就知道自己接收到的实际上是数字0。</p>
<blockquote>
<p>注意，传输信息所利用的一些物理媒体，如双绞线、光缆、无线信道等，并不在物理层协议之内而在物理层协议下面。因此，有人把物理媒体当作第О层。</p>
</blockquote>
<p>(2）数据链路层(Data Link Layer)</p>
<p>数据链路层的传输单位是帧，任务是将网络层传来的P数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理等。</p>
<p>由于外界噪声的干扰，原始的物理连接在传输比特流时可能发生错误。如图1.8所示，左边结点想向右边结点传输数字0，于是发出了信号A;但传输过程中受到干扰，信号A变成了信号B，而信号B又刚好代表1，右边结点接收到信号B时，就会误以为左边结点传送了数字1，从而发生差错。两个结点之间如果规定了数据链路层协议，那么可以检测出这些差错，然后把收到的错误信息丢弃，这就是差错控制功能。</p>
<p>如图1.9所示，在两个相邻结点之间传送数据时，由于两个结点性能的不同，可能结点A发送数据的速率会比结点B接收数据的速率快，如果不加控制，那么结点B就会丢弃很多来不及接收的正确数据，造成传输线路效率的下降。流量控制可以协调两个结点的速率，使结点A发送数据的速率刚好是结点B可以接收的速率。</p>
<p>广播式网络在数据链路层还要处理新的问题，即如何控制对共享信道的访问。数据链路层的一个特殊的子层—介质访问子层，就是专门处理这个问题的。</p>
<p>典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。</p>
<p>(3）网络层(Network Layer)</p>
<p>网络层的传输单位是数据报，它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p>
<p>如图1.10所示，结点A向结点B传输一个分组时，既可经过边a、c、g，也可经过边b、h，有很多条可以选择的路由，而网络层的作用就是根据网络的情况，利用相应的路由算法计算出一条合适的路径，使这个分组可以顺利到达结点B。</p>
<details><summary>图1.10某网络结构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164514.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164514.png';" /></details>

<p>流量控制与数据链路层的流量控制含义一样,都是协调A的发送速率和B的接收速率。</p>
<p>差错控制是通信两结点之间约定的特定检错规则，如奇偶校验码，接收方根据这个规则检查接收到的分组是否出现差错，如果出现了差错，那么能纠错就纠错，不能纠错就丢弃，确保向上层提交的数据都是无误的。</p>
<p>如果图1.10中的结点都处于来不及接收分组而要丢弃大量分组的情况,那么网络就处于拥塞状态，拥塞状态使得网络中的两个结点无法正常通信。网络层要采取一定的措施来缓解这种拥塞，这就是拥塞控制。</p>
<p>因特网是一个很大的互联网，它由大量异构网络通过路由器（(Router）相互连接起来。因特网的主要网络层协议是无连接的网际协议（Internet Protocol，P)和许多路由选择协议，因此因特网的网络层也称网际层或IP层。</p>
<p>注意，网络层中的“网络”一词并不是我们通常谈及的具体网络，而是在计算机网络体系结构中使用的专有名词。</p>
<p>网络层的协议有IP、IPX、ICMP、IGMP、ARP、RARP和OSPF等。</p>
<p>(4)传输层（Transport Layer)</p>
<p>传输层也称运输层，传输单位是报文段(TCP）或用户数据报（UDP)，传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。</p>
<p>数据链路层提供的是点到点的通信，传输层提供的是端到端的通信，两者不同。通俗地说，点到点可以理解为主机到主机之间的通信，一个点是指一个硬件地址或P地址，网络中参与通信的主机是通过硬件地址或P地址标识的;端到端的通信是指运行在不同主机内的两个进程之间的通信，一个进程由一个端口来标识，所以称为端到端通信。</p>
<p>使用传输层的服务，高层用户可以直接进行端到端的数据传输，从而忽略通信子网的存在。通过传输层的屏蔽，高层用户看不到子网的交替和变化。由于一台主机可同时运行多个进程，因此传输层具有复用和分用的功能。复用是指多个应用层进程可同时使用下面传输层的服务，分用是指传输层把收到的信息分别交付给上面应用层中相应的进程。</p>
<p>传输层的协议有TCP、UDP。</p>
<p>(5）会话层(Session Layer)</p>
<p>会话层允许不同主机上的各个进程之间进行会话。会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称建立同步(SYN)。</p>
<p>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。</p>
<p>(6）表示层（Presentation Layer)</p>
<p>表示层主要处理在两个通信系统中交换信息的表示方式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交换，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示变换功能。</p>
<p>(7）应用层（Application Layer）</p>
<p>应用层是OSI参考模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI参考模型环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。典型的协议有用于文件传送的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。</p>
<h5 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h5><p>ARPA在研究ARPAnet时提出了TCP/IP模型，模型从低到高依次为网络接口层（对应OSI参考模型中的物理层和数据链路层)、网际层、传输层和应用层（对应OSI参考模型中的会话层、表示层和应用层)。TCP/P由于得到广泛应用而成为事实上的国际标准。TCP/P模型的层次结构及各层的主要协议如图1.11所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164734.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164734.png';" /></details>

<p>网络接口层的功能类似于OSI参考模型的物理层和数据链路层。它表示与物理网络的接口，但实际上TCP/IP本身并未真正描述这一部分，只是指出主机必须使用某种协议与网络连接，以便在其上传递IP分组。具体的物理网络既可以是各种类型的局域网，如以太网、令牌环网、令牌总线网等，也可以是诸如电话网、SDH、X.25、帧中继和 ATM等公共数据网络。网络接口层的作用是从主机或结点接收IP分组，并把它们发送到指定的物理网络上。</p>
<p>网际层（主机-主机）是TCP/IP体系结构的关键部分。它和OSI参考模型的网络层在功能上非常相似。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层负责。网际层定义了标准的分组格式和协议，即P。当前采用的P协议是第4版，即IPv4，它的下一版本是IPv6。</p>
<p>传输层（应用-应用或进程-进程）的功能同样和OSI参考模型中的传输层类似，即使得发送端和目的端主机上的对等实体进行会话。传输层主要使用以下两种协议:</p>
<p>1）传输控制协议（Transmission Control Protocol，TCP)。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。</p>
<p>2）用户数据报协议（User Datagram Protocol，UDP)。它是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。应用层(用户-用户)包含所有的高层协议，如虚拟终端协议(Telnet)、文件传输协议(FTP)、域名解析服务(DNS)、电子邮件协议(SMTP）和超文本传输协议（HTTP)。</p>
<p>由图1.10可以看出，IP 协议是因特网中的核心协议;TCP/IP可以为各式各样的应用提供服务(所谓的everything over IP)，同时TCP/P 也允许IP协议在由各种网络构成的互联网上运行(所谓的IP over everything)。正因为如此，因特网才会发展到今天的规模。</p>
<h5 id="TCP-IP模型与OSl参考模型的比较"><a href="#TCP-IP模型与OSl参考模型的比较" class="headerlink" title="TCP/IP模型与OSl参考模型的比较"></a>TCP/IP模型与OSl参考模型的比较</h5><p>TCP/IP模型与OSI参考模型有许多相似之处。</p>
<p>首先，二者都采取分层的体系结构，将庞大且复杂的问题划分为若干较容易处理的、范围较小的问题，而且分层的功能也大体相似。</p>
<p>其次，二者都是基于独立的协议栈的概念。</p>
<p>最后，二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信。它们之间的比较如图1.12所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724164828.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724164828.png';" /></details>

<p>两个模型除具有这些基本的相似之处外，也有很多差别。</p>
<p>第一，OSI参考模型的最大贡献就是精确地定义了三个主要概念:服务、协议和接口，这与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分，不符合软件工程的思想。</p>
<p>第二，OSI参考模型产生在协议发明之前，没有偏向于任何特定的协议，通用性良好。但设计者在协议方面没有太多经验，不知道把哪些功能放到哪一层更好。TCP/IP模型正好相反，首先出现的是协议，模型实际上是对已有协议的描述，因此不会出现协议不能匹配模型的情况，但该模型不适合于任何其他非TCP/IP的协议栈。</p>
<p>第三，TCP/IP模型在设计之初就考虑到了多种异构网的互联问题，并将网际协议(P）作为一个单独的重要层次。OSI参考模型最初只考虑到用一种标准的公用数据网将各种不同的系统互联。OSI参考模型认识到P的重要性后，只好在网络层中划分出一个子层来完成类似于TCP/IP模型中的IP的功能。</p>
<p>第四，OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。这个不同点常常作为考查点。</p>
<p>无论是OSI参考模型还是TCP/IP模型，都不是完美的，对二者的讨论和批评都很多。OSI参考模型的设计者从工作的开始，就试图建立一个全世界的计算机网络都要遵循的统一标准。从技术角度来看，他们希望追求一种完美的理想状态，这也导致基于OSI参考模型的软件效率极低。OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低，这是它未能达到预期目标的重要原因。</p>
<p>无论是OSI参考模型还是TCP/P模型，都不是完美的，对二者的讨论和批评都很多。OSI参考模型的设计者从工作的开始，就试图建立一个全世界的计算机网络都要遵循的统一标准。从技术角度来看，他们希望追求一种完美的理想状态，这也导致基于OSI参考模型的软件效率极低。OSI参考模型缺乏市场与商业动力，结构复杂，实现周期长，运行效率低，这是它未能达到预期目标的重要原因。</p>
<p>学习计算机网络时，我们往往采取折中的办法，即综合OSI参考模型和TCP/IP模型的优点，采用一种如图1.13所示的只有5层协议的体系结构，即我们所熟知的物理层、数据链路层、网络层、传输层和应用层。本书也采用这种体系结构进行讨论。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724165119.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724165119.png';" /></details>

<p>最后简单介绍使用通信协议栈进行通信的结点的数据传输过程。每个协议栈的最顶端都是一个面向用户的接口，下面各层是为通信服务的协议。用户传输一个数据报时，通常给出用户能够理解的自然语言，然后通过应用层，将自然语言会转化为用于通信的通信数据。通信数据到达传输层，作为传输层的数据部分（传输层SDU)，加上传输层的控制信息（传输层PCI)，组成传输层的PDU，然后交到网络层，传输层的PDU下放到网络层后，就成为网络层的SDU，然后加上网络层的PCI，又组成了网络层的PDU，下放到数据链路层，就这样层层下放，层层包裹，最后形成的数据报通过通信线路传输，到达接收方结点协议栈，接收方再逆向地逐层把“包裹”拆开,然后把收到的数据提交给用户，如图1.14所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210724165141.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210724165141.png';" /></details>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.techopedia.com/definition/9005/protocol-stack">协议栈和分层的区别</a>，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Protocol_stack">维基百科协议栈的定义</a><br>为什么我感觉协议栈和分层是同一概念？见谢书</p>
</blockquote>
<h5 id="计算机网络与分布式计算机系统的主要区别是什么"><a href="#计算机网络与分布式计算机系统的主要区别是什么" class="headerlink" title="计算机网络与分布式计算机系统的主要区别是什么?"></a>计算机网络与分布式计算机系统的主要区别是什么?</h5><p>分布式系统最主要的特点是，整个系统中的各个计算机对用户都是透明的。用户通过输入命令就可以运行程序，但用户并不知道哪台计算机在为它运行程序。操作系统为用户选择一台最合适的计算机来运行其程序，并将运行的结果传送到合适的地方。</p>
<p>计算机网络则与之不同，用户必须先登录欲运行程序的计算机，然后按照计算机的地址，将程序通过计算机网络传送到该计算机中运行，最后根据用户的命令将结果传送到指定的计算机中。二者的区别主要是软件的不同。</p>
<blockquote>
<p>不是应该是计算机网路是网络的网络吗？</p>
</blockquote>
<h5 id="为什么一个网络协议必须考虑到各种不利的情况"><a href="#为什么一个网络协议必须考虑到各种不利的情况" class="headerlink" title="为什么一个网络协议必须考虑到各种不利的情况?"></a>为什么一个网络协议必须考虑到各种不利的情况?</h5><p>因为网络协议如果不全面考虑不利的情况，那么当情况发生变化时,协议就会保持理想状况，一直等下去!就如同两位朋友在电话中约好下午3点在公园见面，并且约定不见不散。这一―协议很不科学，因为任何一方如果有耽搁而来不了，且无法通知对方，那么另一方就要一直等下去!所以判断一个计算机网络是否正确，不能只看在正常情况下是否正确，还必须非常仔细地检查协议能否应付各种异常情况。</p>
<h5 id="因特网使用的P协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么为什么当初不把因特网的传输设计为可靠的呢"><a href="#因特网使用的P协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么为什么当初不把因特网的传输设计为可靠的呢" class="headerlink" title="因特网使用的P协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么为什么当初不把因特网的传输设计为可靠的呢?"></a>因特网使用的P协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么为什么当初不把因特网的传输设计为可靠的呢?</h5><p>传统电信网的主要用途是电话通信，并且普通电话机不是智能的，因此电信公司必须花费巨大的代价把电信网设计得非常好，以保证用户的通信质量。</p>
<p>数据的传送显然必须非常可靠。当初在设计ARPAnet时，很重要的讨论内容之一是:“谁应当负责数据传输的可靠性?”一种意见是主张应当像电信网那样，由通信网络负责数据传输的可靠性（因为电信网的发展历史及其技术水平已经证明，人们可以将网络设计得相当可靠);另一种意见则坚决主张由用户的主机负责数据传输的可靠性，理由是这样可使计算机网络便宜、灵活。</p>
<p>计算机网络的先驱认为，计算机网络和电信网的一个重大区别是终端设备的性能差别很大。于是，他们采用了“端到端的可靠传输”策略，即在传输层使用面向连接的TCP协议，这样既能使网络部分价格便宜且灵活可靠，又能保证端到端的可靠传输。</p>
<blockquote>
<p>计算机网络和电信网的一个重大区别是终端设备的性能差别很大。按照这层意思不就更应该把可靠传输这种繁琐的工作交给计算机网络更好了吗</p>
</blockquote>
<h5 id="有人说，宽带信道相当于高速公路车道数目增多了，可以同时并行地跑更多数量的汽车。虽然汽车的时速并没有提高（相当于比特在信道上的传播速率未提高-，但整个高速公路的运输能力却增多了，相当于能够传送更多数量的比特。这种比喻合适否"><a href="#有人说，宽带信道相当于高速公路车道数目增多了，可以同时并行地跑更多数量的汽车。虽然汽车的时速并没有提高（相当于比特在信道上的传播速率未提高-，但整个高速公路的运输能力却增多了，相当于能够传送更多数量的比特。这种比喻合适否" class="headerlink" title="有人说，宽带信道相当于高速公路车道数目增多了，可以同时并行地跑更多数量的汽车。虽然汽车的时速并没有提高（相当于比特在信道上的传播速率未提高)，但整个高速公路的运输能力却增多了，相当于能够传送更多数量的比特。这种比喻合适否?"></a>有人说，宽带信道相当于高速公路车道数目增多了，可以同时并行地跑更多数量的汽车。虽然汽车的时速并没有提高（相当于比特在信道上的传播速率未提高)，但整个高速公路的运输能力却增多了，相当于能够传送更多数量的比特。这种比喻合适否?</h5><p>可以这样比喻。但一定不能误认为“提高信道的速率是设法使比特并行地传输”。</p>
<p>如果一定要用汽车在高速公路上行驶和比特在通信线路上传输相比较，那么可以这样来想象:低速信道相当于汽车进入高速公路的时间间隔较长。例如，每隔1分钟有一辆汽车进入高速公路;“信道速率提高”相当于进入高速公路的汽车的时间间隔缩短了，例如，现在每隔6秒就有一辆汽车进入高速公路。虽然汽车在高速公路上行驶的速率无变化，但在同样的时间内，进入高速公路的汽车总数却增多了(每隔1分钟进入高速公路的汽车现在增加到10辆)，因而吞吐量也就增大了。</p>
<p>也就是说，当带宽或发送速率提高后，比特在链路上向前传播的速率并未提高，只是每秒注入链路的比特数增加了。“速率提高”就体现在单位时间内发送到链路上的比特数增多了，而并不是比特在链路上跑得更快了。</p>
<h5 id="端到端通信和点到点通信有什么区别"><a href="#端到端通信和点到点通信有什么区别" class="headerlink" title="端到端通信和点到点通信有什么区别?"></a>端到端通信和点到点通信有什么区别?</h5><p>从本质上说，由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务，而传输层为网络中的主机提供端到端的通信。</p>
<p>直接相连的结点之间的通信称为点到点通信，它只提供一台机器到另一台机器之间的通信，不涉及程序或进程的概念。同时，点到点通信并不能保证数据传输的可靠性，也不能说明源主机与目的主机之间是哪两个进程在通信，这些工作都是由传输层来完成的。</p>
<p>端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是比点到点通信更高一级的通信方式，以完成应用程序（进程）之间的通信。“端”是指用户程序的端口，端口号标识了应用层中不同的进程。</p>
<h5 id="如何理解传输速率、带宽和传播速率"><a href="#如何理解传输速率、带宽和传播速率" class="headerlink" title="如何理解传输速率、带宽和传播速率?"></a>如何理解传输速率、带宽和传播速率?</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727094533.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727094533.png';" /></details>

<blockquote>
<p>这个理解似乎与期末考的定义恰好相反</p>
</blockquote>
<h5 id="如何理解传输时延、发送时延和传播时延"><a href="#如何理解传输时延、发送时延和传播时延" class="headerlink" title="如何理解传输时延、发送时延和传播时延?"></a>如何理解传输时延、发送时延和传播时延?</h5><p>传输时延又称发送时延，是主机或路由器发送数据帧所需的时间，即从数据帧的第1比特算起，到该数据帧的最后1比特发送完毕所需要的时间。计算公式是</p>
<p>发送时延=数据帧长度/信道带宽</p>
<p>传播时延是电磁波在信道中传播一定的距离所花费的时间。计算公式是</p>
<p>传播时延=信道长度/电磁波在信道上的传播速率</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>【考纲内容】</p>
<p>(一）通信基础</p>
<p>信道、信号、带宽、码元、波特、速率、信源与信宿等基本概念</p>
<p>奈奎斯特定理与香农定理;编码与调制</p>
<p>电路交换、报文交换与分组交换;数据报与虚电路</p>
<p>(二）传输介质</p>
<p>双绞线、同轴电缆、光纤与无线传输介质;物理层接口的特性</p>
<p>(三）物理层设备</p>
<p>中继器;集线器</p>
<p>【复习提示】</p>
<p>物理层考虑的是怎样才能在连接各台计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。本章概念较多，易出选择题，且涉及一些通信原理，读者不太明白的地方可以参考一些相关书籍，通信部分的内容也并非考研重点。复习时应抓住重点，如奈奎斯特定理和香农定理的应用、编码与调制技术、数据交换方式，以及电路交换、报文交换与分组交换技术等。</p>
<h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="数据、信号与码元"><a href="#数据、信号与码元" class="headerlink" title="数据、信号与码元"></a>数据、信号与码元</h5><p>通信的目的是传送信息，如文字、图像和视频等。数据是指传送信息的实体。信号则是数据的电气或电磁表现，是数据在传输过程中的存在形式。数据和信号都可用“模拟的”或“数字的”来修饰:①连续变化的数据（或信号）称为模拟数据（或$\color{green}{\text{模拟信号}}$);②取值仅允许为有限的几个离散数值的数据（或信号）称为数字数据（或$\color{green}{\text{数字信号}}$)。<br>数据传输方式可分为串行传输和并行传输。串行传输是指1比特1比特地按照时间顺序传输(远距离通信通常采用串行传输)，并行传输是指若干比特通过多条通信信道同时传输。</p>
<p>码元是指用一个固定时长的信号波形（数字脉冲）表示一位k进制数字，代表不同$\color{green}{\text{离散数值}}$的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。1码元可以携带若干比特的信息量。例如，在使用二进制编码时，只有两种不同的码元:一种代表О状态，另一种代表1状态。</p>
<h5 id="信源、信道与信宿"><a href="#信源、信道与信宿" class="headerlink" title="信源、信道与信宿"></a>信源、信道与信宿</h5><p>数据通信是指数字计算机或其他数字终端之间的通信。一个数据通信系统主要划分为信源、信道和信宿三部分。信源是产生和发送数据的源头。信宿是接收数据的终点，它们通常都是计算机或其他数字终端装置。发送端信源发出的信息需要通过变换器转换成适合于在信道上传输的信号，而通过信道传输到接收端的信号先由反变换器转换成原始信息，再发送给信宿。</p>
<p>信道与电路并不等同，信道是信号的传输媒介。一个信道可视为一条线路的逻辑部件，一般用来表示向某个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。噪声源是信道上的噪声（即对信号的干扰）及分散在通信系统其他各处的噪声的集中表示。</p>
<p>图2.1所示为一个单向通信系统的模型。实际的通信系统大多为双向的，即往往包含一条发送信道和一条接收信道，信道可以进行双向通信。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727094849.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727094849.png';" /></details>

<p>信道按传输信号形式的不同，可分为传送模拟信号的模拟信道和传送数字信号的数字信道两大类;信道按传输介质的不同可分为无线信道和有线信道。</p>
<p>信道上传送的信号有$\color{green}{\text{基带信号}}$和$\color{green}{\text{宽带信号}}$之分。基带信号将数字信号1和0直接用两种不同的电压表示，然后送到数字信道上传输（称为基带传输);宽带信号将基带信号进行调制后形成频分复用模拟信号，然后送到模拟信道上传输（称为宽带传输)。</p>
<p>从通信双方信息的交互方式看，可分为三种基本方式:</p>
<p>1)单向通信。只有一个方向的通信而没有反方向的交互，仅需要一条信道。例如，无线电广播、电视广播就属于这种类型。</p>
<p>2）半双工通信。通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收信息，此时需要两条信道。</p>
<p>3）全双工通信。通信双方可以同时发送和接收信息，也需要两条信道。</p>
<p>信道的极限容量是指信道的最高码元传输速率或信道的极限信息传输速率。</p>
<h5 id="速率、波特与带宽"><a href="#速率、波特与带宽" class="headerlink" title="速率、波特与带宽"></a>速率、波特与带宽</h5><p>速率也称数据率，指的是数据传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示。</p>
<p>1）码元传输速率。又称波特率，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数)，单位是波特（$\color{green}{\text{Baud}}$)。1波特表示数字通信系统每秒传输一个码元。码元可以是多进制的，也可以是二进制的，码元速率与进制数无关。</p>
<p>2）信息传输速率。又称信息速率、比特率等，它表示单位时间内数字通信系统传输的二进制码元个数（即比特数)，单位是比特/秒(b/s)。</p>
<blockquote>
<p>注意:波特和比特是两个不同的概念，码元传输速率也称调制速率、波形速率或符号速率。但码元传输速率与信息传输速率在数量上却又有一定的关系。若一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为Mn比特/秒。</p>
</blockquote>
<p>带宽原指信号具有的频带宽度，单位是赫兹（Hz)。在实际网络中，由于数据率是信道最重要的指标之一，而带宽与数据率存在数值上的互换关系，因此常用来表示网络的通信线路所能传输数据的能力。因此,带宽表示单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。显然，此时带宽的单位不再是Hz，而是b/s。</p>
<h4 id="奈奎斯特定理与香农定理"><a href="#奈奎斯特定理与香农定理" class="headerlink" title="奈奎斯特定理与香农定理"></a>奈奎斯特定理与香农定理</h4><p>$\color{red}{\text{Q}}$ 奈奎斯特定理和香农定理的关系？</p>
<h5 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h5><p>具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道，否则在传输中会衰减，导致接收端收到的信号波形失去码元之间的清晰界限，这种现象称为码间串扰。奈奎斯特（Nyquist）定理又称奈氏准则，它规定:在理想低通（没有噪声、带宽有限)的信道中，为了避免码间串扰，极限码元传输速率为2W波特，其中W是理想低通信道的带宽。若用V表示每个码元离散电平的数目（码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要4个二进制位，因此数据传输速率是码元传输速率的4倍)，则极限数据率为</p>
<p>理想低通信道下的极限数据传输速率=$2W log_2V$(单位为 b/s)</p>
<p>对于奈氏准则，可以得出以下结论:</p>
<p>1）在任何信道中，码元传输速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使得接收端不可能完全正确识别码元。</p>
<p>2）信道的频带越宽（即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。</p>
<p>3）奈氏准则给出了码元传输速率的限制，但并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。</p>
<p>由于码元传输速率受奈氏准则的制约，所以要提高数据传输速率，就必须设法使每个码元携带更多比特的信息量，此时就需要采用多元制的调制方法。</p>
<blockquote>
<p>这个地方配合谢书看，来龙去脉讲的比较清楚</p>
</blockquote>
<details><summary>谢书：奈奎斯特定理</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210730143427.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210730143427.png';" /></details>

<h5 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h5><p>香农（Shannon）定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输速率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为</p>
<p>信道的极限数据传输速率= W$log_2$( 1 +S/N)(单位为b/s)</p>
<p>式中，W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率。S/N为信噪比，即信号的平均功率与噪声的平均功率之比，信噪比 = 10$log_{10}$(S/N)(单位为dB)，例如当S/N= 10时，信噪比为10dB，而当S/N = 1000时，信噪比为30dB。</p>
<p>对于香农定理，可以得出以下结论:</p>
<p>1）信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。</p>
<p>2）对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。</p>
<p>3）只要信息传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。</p>
<p>4）香农定理得出的是极限信息传输速率，实际信道能达到的传输速率要比它低不少。</p>
<p>奈氏准则只考虑了带宽与极限码元传输速率的关系，而香农定理不仅考虑到了带宽，也考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。</p>
<blockquote>
<p>怎么表明的？？？啥叫对应的二进制位数</p>
</blockquote>
<h4 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h4><p>数据无论是数字的还是模拟的，为了传输的目的都必须转变成信号。把数据变换为模拟信号的过程称为$\color{green}{\text{调制}}$，把数据变换为数字信号的过程称为$\color{green}{\text{编码}}$。</p>
<p>信号是数据的具体表示形式，它和数据有一定的关系，但又和数据不同。数字数据可以通过数字发送器转换为数字信号传输，也可以通过调制器转换成模拟信号传输;同样，模拟数据可以通过 PCM编码器转换成数字信号传输，也可以通过放大器调制器转换成模拟信号传输。这样，就形成了下列4种编码方式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210730143939.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210730143939.png';" /></details>


<h5 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h5><p>数字数据编码用于基带传输中，即在基本不改变数字数据信号频率的情况下，直接传输数字信号。具体用什么样的数字信号表示0及用什么样的数字信号表示1就是所谓的编码。编码的规则有多种，只要能有效地把1和0区分开即可，常用的数据数据编码有以下几种，如图2.2所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727100211.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727100211.png';" /></details>

<blockquote>
<p>时钟周期的作用<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30652105/article/details/112576297">参考文献</a><br>为什么归零编码可以传递时钟周期,波形应该画成参考文献那样理解，传递时钟周期可以立即为我要分辨出来连续1的话到底是几个1</p>
</blockquote>
<p>(1）归零编码</p>
<p>在归零编码(RZ）中用高电平代表1、低电平代表0(或者相反)，每个时钟周期的中间均跳变到低电平（归零)，接收方根据该跳变调整本方的时钟基准，这就为传输双方提供了自同步机制。由于归零需要占用一部分带宽，因此传输效率受到了一定的影响。</p>
<p>(2）非归零编码</p>
<p>非归零编码(NRZ)与RZ编码的区别是不用归零，一个周期可以全部用来传输数据。但NRZ编码无法传递时钟信号，双方难以同步，因此若想传输高速同步数据，则需要都带有时钟线。</p>
<p>(3）反向非归零编码</p>
<p>反向非归零编码(NRZI)与NRZ编码的区别是用信号的翻转代表0、信号保持不变代表1。翻转的信号本身可以作为一种通知机制。这种编码方式集成了前两种编码的优点，既能传输时钟信号，又能尽量不损失系统带宽。$\color{green}{\text{USB 2.0}}$通信的编码方式就是NRZI编码。</p>
<blockquote>
<p>$\color{red}{\text{Q}}$:感觉反向非归零编码并不能传递时钟周期啊？？<br>$\color{red}{\text{A}}$:<a target="_blank" rel="noopener" href="http://www.360doc.com/content/19/0428/20/6828497_832142706.shtml">参考文献</a></p>
</blockquote>
<p>(4）曼彻斯特编码</p>
<p>曼彻斯特编码（Manchester Encoding)将一个码元分成两个相等的间隔，前一个间隔为高电平而后一个间隔为低电平表示码元1;码元0的表示方法则正好相反。当然，也可采用相反的规定。该编码的特点是，在每个码元的中间出现电平跳变，位中间的跳变既作为时钟信号(可用于同步)，又作为数据信号，但它所占的频带宽度是原始基带宽度的两倍。</p>
<blockquote>
<p>注意:$\color{green}{\text{以太网}}$使用的编码方式就是曼彻斯特编码。</p>
</blockquote>
<p>(5）差分曼彻斯特编码</p>
<p>差分曼彻斯特编码常用于$\color{green}{\text{局域网}}$传输，其规则是:若码元为1，则前半个码元的电平与上一码元的后半个码元的电平相同;若码元为0，则情形相反。该编码的特点是，在每个码元的中间都有一次电平的跳转，可以实现自同步，且抗干扰性较好。</p>
<blockquote>
<p>局域网, 以太网的区别，<a target="_blank" rel="noopener" href="https://blog.csdn.net/digitalkee/article/details/105054541">参考文献</a></p>
</blockquote>
<blockquote>
<p>在每个时钟周期的起始处：跳变则说明该比特是0，不跳变则说明该比特是1。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B7%AE%E5%88%86%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81/7486879?fr=aladdin">百度百科</a></p>
</blockquote>
<p>(6）4B/5B编码</p>
<p>将欲发送数据流的每4位作为一组，然后按照4B/5B编码规则将其转换成相应的5位码。5位码共32种组合，但只采用其中的16种对应16种不同的4位码，其他16种作为控制码（帧的开始和结束、线路的状态信息等）或保留。</p>
<h5 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h5><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。基本的数字调制方法有如下几种:</p>
<p>1）幅移键控（ASK)。通过改变载波信号的振幅来表示数字信号1和0，而载波的频率和相位都不改变。比较容易实现，但抗干扰能力差。</p>
<p>2）频移键控(FSK)。通过改变载波信号的频率来表示数字信号1和0，而载波的振幅和相位都不改变。容易实现，抗干扰能力强，目前应用较为广泛。</p>
<p>3）相移键控（PSK)。通过改变载波信号的相位来表示数字信号1和0，而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。</p>
<p>4）正交振幅调制(QAM)。在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。设波特率为B，采用m个相位，每个相位有n种振幅，则该QAM技术的数据传输速率R为</p>
<p>R= B$log_2$(mn)(单位为b/s)</p>
<p>图2.3所示是二进制幅移键控、频移键控和相移键控的例子。2ASK中用载波有幅度和无幅度分别表示数字数据的1和0;2FSK中用两种不同的频率分别表示数字数据1和0;2PSK中用相位0和相位T分别表示数字数据的1和0，是一种绝对调相方式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727100922.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727100922.png';" /></details>


<h5 id="模拟数据编码为数字信号"><a href="#模拟数据编码为数字信号" class="headerlink" title="模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h5><p>这种编码方式最典型的例子是常用于对音频信号进行编码的脉码调制(PCM, Pulse Code Modulation,<p style='color:green'>脉冲编码调制</p>)。它主要包括三个步骤，即采样、量化和编码。</p>
<p>先来介绍采样定理:在通信领域，带宽是指信号最高频率与最低频率之差，单位为Hz。因此，将模拟信号转换成数字信号时，假设原始信号中的最大频率为f，那么采样频率$f_{\text{采样}}$必须大于等于最大频率f的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息（(只需记住结论)。另外，$\color{green}{\text{采样定理}}$又称奈奎斯特定理。</p>
<p>1）采样是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。根据采样定理，当采样的频率大于等于模拟数据的频带带宽（最高变化频率）的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据。</p>
<p>2）量化是把采样取得的电平幅值按照一定的分级标度转化为对应的数字值并取整数,这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。</p>
<p>3）编码是把量化的结果转换为与之对应的二进制编码。</p>
<h5 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h5><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用（FDM,Frequency Division Multiplexing)技术，充分利用带宽资源。电话机和本地局交换机采用模拟信号传输模拟数据的编码方式,模拟的声音数据是加载到模拟的载波信号中传输的。</p>
<h4 id="电路交换、报文交换与分组交换"><a href="#电路交换、报文交换与分组交换" class="headerlink" title="电路交换、报文交换与分组交换"></a>电路交换、报文交换与分组交换</h4><p>$\color{red}{\text{Q}}$：数据报交换和分组交换的区别</p>
<p>$\color{red}{\text{A}}$：数据报交换是分组交换的一种</p>
<h5 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h5><p>在进行数据传输前，两个结点之间必须先建立一条专用（双方独占）的物理通信路径（由通信双方之间的交换设备和链路逐段连接而成)，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束后才被释放。因此，电路交换技术分为三个阶段<br>连接建立、数据传输和连接释放。</p>
<p>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源电路交换的关键点是，在数据传输的过程中，用户始终占用端到端的固定传输带宽。</p>
<p>电路交换技术的优点如下:</p>
<p>1）通信时延小。由于通信线路为通信双方用户专用，数据直达，因此传输数据的时延非常小。当传输的数据量较大时，这一优点非常明显。</p>
<p>2）有序传输。双方通信时按发送顺序传送数据，不存在失序问题。</p>
<p>3）没有冲突。不同的通信双方拥有不同的信道，不会出现争用物理信道的问题。</p>
<p>4）适用范围广。电路交换既适用于传输模拟信号，又适用于传输数字信号。</p>
<p>5）实时性强。通信双方之间的物理通路一旦建立，双方就可以随时通信。</p>
<p>6）控制简单。电路交换的交换设备（交换机等）及控制均较简单。</p>
<p>电路交换技术的缺点如下:</p>
<p>1）建立连接时间长。电路交换的平均连接建立时间对计算机通信来说太长。</p>
<p>2）线路独占，使用效率低。电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用率低。</p>
<p>3）灵活性差。只要在通信双方建立的通路中的任何一点出了故障，就必须重新拨号建立新的连接，这对十分紧急和重要的通信是很不利的。</p>
<p>4）难以规格化。电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。</p>
<blockquote>
<p>注意，电路建立后，除源结点和目的结点外，电路上的任何结点都采取“直通方式”接收数据和发送数据，即不会存在存储转发所耗费的时间。</p>
</blockquote>
<h5 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h5><p>数据交换的单位是报文，报文携带有目标地址、源地址等信息。报文交换在交换结点采用的是存储转发的传输方式。</p>
<p>报文交换技术的优点如下:</p>
<p>1）无须建立连接。报文交换不需要为通信双方预先建立一条专用的通信线路，不存在建立连接时延，用户可以随时发送报文。</p>
<p>2）动态分配线路。当发送方把报文交给交换设备时，交换设备先存储整个报文，然后选择一条合适的空闲线路，将报文发送出去。</p>
<p>3）提高线路可靠性。如果某条传输路径发生故障，那么可重新选择另一条路径传输数据，因此提高了传输的可靠性。</p>
<p>4）提高线路利用率。通信双方不是固定占有一条通信线路，而是在不同的时间一段段地部分占有这条物理通道，因而大大提高了通信线路的利用率。</p>
<p>5)提供多目标服务。一个报文可以同时发送给多个目的地址，这在电路交换中是很难实现的。</p>
<p>报文交换技术的缺点如下:</p>
<p>1）由于数据进入交换结点后要经历存储、转发这一过程，因此会引起转发时延（包括接收报文、检验正确性、排队、发送时间等)。</p>
<p>2）报文交换对报文的大小没有限制，这就要求网络结点需要有较大的缓存空间。</p>
<blockquote>
<p>注意:报文交换主要使用在早期的电报通信网中，现在较少使用，通常被较先进的分组交换方式所取代。</p>
</blockquote>
<h5 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h5><p>同报文交换一样，分组交换也采用存储转发方式，但解决了报文交换中大报文传输的问题。</p>
<p>分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小数据块，再加上一些必要的控制信息（如源地址、目的地址和编号信息等)，构成分组(Packet)。网络绐点恨掂控制信息把分组送到下一个结点，下一个结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一个结点，直到到达目的结点。</p>
<p>分组交换的优点如下:</p>
<p>1）无建立时延。不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延,用户可随时发送分组。</p>
<p>2）线路利用率高。通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。</p>
<p>3)简化了存储管理（相对于报文交换)。因为分组的长度固定，相应的缓冲区的大小也固定在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。</p>
<p>4)加速传输。分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线方式减少了报文的传输时间。此外，传输一个分组所需的缓冲区比传输次报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的概率及时间也必然少得多.</p>
<p>5）减少了出错概率和重发数据量。因为分组较短，其出错概率必然减小，所以每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。</p>
<p>分组交换的缺点如下:</p>
<p>1)存在传输时延。尽管分组交换比报文交换的传输时延少，但相对于电路交换仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。</p>
<p>2）需要传输额外的信息量。每个小数据块都要加上源地址、目的地址和分组编号等信息从而构成分组，因此使得传送的信息量增大了5%～10%，一定程度上降低了通信效率增加了处理的时间，使控制复杂，时延增加。</p>
<p>3）当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</p>
<p>图2.4给出了三种数据交换方式的比较。要传送的数据量很大且其传送时间远大于呼叫时间时，采用电路交换较为合适。端到端的通路由多段链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式数据通信。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727103336.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727103336.png';" /></details>

<h4 id="数据报与虚电路"><a href="#数据报与虚电路" class="headerlink" title="数据报与虚电路"></a>数据报与虚电路</h4><p>分组交换根据其通信子网向端点系统提供的服务，还可进一步分为面向连接的虚电路方式和无连接的数据报方式。这两种服务方式都由网络层提供。要注意$\color{green}{\text{数据报方式}}$和$\color{green}{\text{虚电路方式}}$是$\color{green}{\text{分组交换}}$的两种方式。</p>
<p>ATM网中存在虚电路：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/434759624/answer/1631222452">参考文献</a></p>
<h5 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h5><p>作为通信子网用户的端系统发送一个报文时，在端系统中实现的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据报分组（即网络层的 PDU)。中间结点存储分组很短一段时间，找到最佳的路由后，尽快转发每个分组。不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。</p>
<p>我们用图2.5的例子来说明数据报服务的原理。假定主机A要向主机B发送分组。</p>
<p>1）主机A先将分组逐个发往与它直接相连的交换结点A，交换结点A缓存收到的分组。</p>
<p>2）然后查找自己的转发表。由于不同时刻的网络状态不同，因此转发表的内容可能不完全相同，所以有的分组转发给交换结点C，有的分组转发给交换结点D。</p>
<p>3）网络中的其他结点收到分组后，类似地转发分组，直到分组最终到达主机B。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727103443.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727103443.png';" /></details>

<p>当分组正在某-链路上传送时，分组并不占用网络的其他部分资源。因为采用存储转发技术，资源是共享的，所以主机A在发送分组时，主机B也可同时向其他主机发送分组。</p>
<p>通过上面的例子，我们可以总结出数据报服务具有如下特点:</p>
<p>1)发送分组前不需要建立连接。发送方可随时发送分组，网络中的结点可随时接收分组。</p>
<p>2)网络尽最大努力交付，传输不保证可靠性，所以可能丢失;为每个分组独立地选择路由，转发的路径可能不同，因而分组不一定按序到达目的结点。</p>
<p>3)发送的分组中要包括发送端和接收端的完整地址，以便可以独立传输。</p>
<p>4)分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。</p>
<p>5)网络具有冗余路径，当某个交换结点或一条链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强。</p>
<p>6)存储转发的延时一般较小， 提高了网络的吞吐量。</p>
<p>7)收发双方不独占某条链路，资源利用率较高。</p>
<h5 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h5><p>虚电路方式试图将数据报方式与电路交换方式结合起来，充分发挥两种方法的优点，以达到最佳的数据交换效果。在分组发送之前，要求在发送方和接收方建立一条逻辑上相连的虚电路，并且连接一旦建立，就固定了虚电路所对应的物理路径。与电路交换类似，整个通信过程分为三个阶段:虚电路建立、数据传输与虚电路释放。</p>
<p>在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的虚电路号分配给该虚电路，以区别于本系统中的其他虚电路。在传送数据时，每个数据分组不仅要有分组号、校验和等控制信息，还要有它要通过的虚电路号，以区别于其他虚电路上的分组。在虚电路网络中的每个结点上都维持一张虚电路表，表中的每项记录了一个打开的虚电路的信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。数据的传输是双向进行的，上述信息是在虚电路的建立过程中确定的。</p>
<p>虚电路方式的工作原理如图2.6所示。</p>
<p>1）为进行数据传输，主机A与主机B之间先建立一条逻辑通路，主机A发出一个特殊的“呼叫请求”分组，该分组通过中间结点送往主机B，若主机B同意连接，则发送“呼叫应答”分组予以确认。</p>
<p>2）虚电路建立后，主机A就可向主机B发送数据分组。当然，主机B也可在该虚电路上向主机A发送数据。</p>
<p>3）传送结束后主机A通过发送“释放请求”分组来拆除虚电路，逐段断开整个连接。</p>
<p>通过上面的例子，可以总结出虚电路服务具有如下特点:</p>
<p>1）虚电路通信链路的建立和拆除需要时间开销，对交互式应用和小量的短分组情况显得很浪费，但对长时间、频繁的数据交换效率较高。</p>
<p>2）虚电路的路由选择体现在连接建立阶段，连接建立后，就确定了传输路径。</p>
<p>3）虚电路提供了可靠的通信功能，能保证每个分组正确且有序到达。此外，还可以对两个数据端点的流量进行控制，当接收方来不及接收数据时，可以通知发送方暂缓发送。</p>
<p>4）虚电路有一个致命的弱点，即当网络中的某个结点或某条链路出现故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727103748.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727103748.png';" /></details>

<p>5）分组首部不包含目的地址，包含的是虚电路标识符，相对于数据报方式，其开销小。</p>
<p>虚电路之所以是“虚”的，是因为这条电路不是专用的，每个结点到其他结点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每条虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同。</p>
<blockquote>
<p>注意，图2.6所示的数据传输过程是有确认的传输（由高层实现)，主机B收到分组后要发回相应分组的确认。网络中的传输是否有确认与网络层提供的两种服务没有任何关系。</p>
</blockquote>
<p>数据报服务和虚电路服务的比较见表2.1。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727103909.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727103909.png';" /></details>

<h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><h4 id="双绞线、同轴电缆、光纤与无线传输介质"><a href="#双绞线、同轴电缆、光纤与无线传输介质" class="headerlink" title="双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h4><p>传输介质也称传输媒体，它是数据传输系统中发送设备和接收设备之间的物理通路。传输介质可分为导向传输介质和非导向传输介质。在导向传输介质中，电磁波被导向沿着固体媒介（铜线或光纤）传播，而非导向传输介质可以是空气、真空或海水等。</p>
<h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><p>双绞线是最常用的古老传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。绞合可以减少对相邻导线的电磁干扰。为了进一步提高抗电磁干扰的能力，可在双绞线的外面再加上一层，即用金属丝编织成的屏蔽层，这就是屏蔽双绞线(STP)。无屏蔽层的双绞线称为非屏蔽双绞线（UTP)。它们的结构如图2.7所示。</p>
<p>双绞线的价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。双绞线的带宽取决于铜线的粗细和传输的距离。模拟传输和数字传输都可使用双绞线，其通信距离一般为几千米到数十千米。距离太远时，对于模拟传输，要用放大器放大衰减的信号;对于数字传输,要用中继器将失真的信号整形。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727104043.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727104043.png';" /></details>


<h5 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h5><p>同轴电缆由内导体、绝缘层、网状编织屏蔽层和塑料外层构成，如图2.8所示。按特性阻抗数值的不同，通常将同轴电缆分为两类:50$\Omega$同轴电缆和75$\Omega$同轴电缆。其中，50$\Omega$同轴电缆主要用于传送基带数字信号，又称基带同轴电缆，它在局域网中应用广泛;75$\Omega$同轴电缆主要用于传送宽带信号，又称宽带同轴电缆，主要用于有线电视系统。</p>
<p>由于外导体屏蔽层的作用，同轴电缆具有良好的抗干扰特性，被广泛用于传输较高速率的数据，其传输距离更远，但价格较双绞线贵。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727104152.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727104152.png';" /></details>

<h5 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h5><p>光纤通信就是利用光导纤维（简称光纤）传递光脉冲来进行通信。有光脉冲表示1，无光脉冲表示0。可见光的频率约为$10^8$MHz，因此光纤通信系统的带宽范围极大。</p>
<p>光纤主要由纤芯和包层构成(见图2.9)，纤芯很细，其直径只有8至100$\mu$m，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，只要入射角大于某个临界角度，就会出现全反射，即光线碰到包层时就会折射回纤芯，这个过程不断重复，光也就沿着光纤传输下去。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727104315.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727104315.png';" /></details>

<p>利用光的全反射特性，可以将从不同角度入射的多条光线在一根光纤中传输，这种光纤称为多模光纤（见图2.10)，多模光纤的光源为发光二极管。光脉冲在多模光纤中传输时会逐渐展宽，造成失真，因此多模光纤只适合于近距离传输。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727104338.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727104338.png';" /></details>

<p>光纤的直径减小到只有一个光的波长时，光纤就像一根波导那样，可使光线一直向前传播，而不会产生多次反射，这样的光纤就是单模光纤（见图2.11)。单模光纤的纤芯很细，直径只有几微米，制造成本较高。同时，单模光纤的光源为定向性很好的半导体激光器，因此单模光纤的衰减较小，可传输数公里甚至数十千米而不必采用中继器，适合远距离传输。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210727104506.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210727104506.png';" /></details>

<p>光纤不仅具有通信容量非常大的优点，还具有如下特点:</p>
<p>1）传输损耗小，中继距离长，对远距离传输特别经济。</p>
<p>2）抗雷电和电磁干扰性能好。这在有大电流脉冲干扰的环境下尤为重要。</p>
<p>3）无串音干扰，保密性好，也不易被窃听或截取数据。</p>
<p>4）体积小，重量轻。这在现有电缆管道已拥塞不堪的情况下特别有利。</p>
<h5 id="无线传输介质"><a href="#无线传输介质" class="headerlink" title="无线传输介质"></a>无线传输介质</h5><p>无线通信已广泛应用于移动电话领域，构成蜂窝式无线电话网。随着便携式计算机的出现，以及在军事、野外等特殊场合下移动通信联网的需要，促进了数字化移动通信的发展，现在无线局域网产品的应用已非常普遍。</p>
<p>(1）无线电波</p>
<p>无线电波具有较强的穿透能力，可以传输很长的距离，所以它被广泛应用于通信领域,如无线手机通信、计算机网络中的无线局域网（WLAN)等。因为无线电波使信号向所有方向散播，大大简化了通信连接，因此有效距离范围内的接收设备无须对准某个方向，就可与无线电波发射者进行通信连接,简化了通信连接。这也是无线电传输的最重要优点之一。</p>
<p>(2）微波、红外线和激光</p>
<p>目前高带宽的无线通信主要使用三种技术:微波、红外线和激光。它们都需要发送方和接收方之间存在一条视线(Line-of-sight)通路，有很强的万同性，都沾宜线传擂，有的统然这二有内视线介质。不同的是，红外通信和激光通信把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。</p>
<blockquote>
<p>$\color{red}{\text{Q}}$:视线介质是什么？</p>
</blockquote>
<p>微波通信的频率较高，频段范围也很宽，载波频率通常为2～40GHz，因而通信信道的容量大。例如，一个带宽为2MHz的频段可容纳500条语音线路，若用来传输数字信号，数据率可达数兆比特/秒。与通常的无线电波不同，微波通信的信号是沿直线传播的，因此在地面的传播距离有限，超过一定距离后就要用中继站来接力。</p>
<p>卫星通信利用地球同步卫星作为中继来转发微波信号，可以克服地面微波通信距离的限制。三颗相隔120°的同步卫星几乎能覆盖整个地球表面，因而基本能实现全球通信。卫星通信的优点是通信容量大、距离远、覆盖广，缺点是保密性差、端到端传播时延长。</p>
<h4 id="物理层接口的特性"><a href="#物理层接口的特性" class="headerlink" title="物理层接口的特性"></a>物理层接口的特性</h4><p>物理层考虑的是如何在连接到各种计算机的传输媒体上传输数据比特流，而不指具体的传输媒体。网络中的硬件设备和传输介质的种类繁多，通信方式也各不相同。物理层应尽可能屏蔽这些差异，让数据链路层感觉不到这些差异，使数据链路层只需考虑如何完成本层的协议和服务。<br>物理层的主要任务可以描述为确定与传输媒体的接口有关的一些特性:</p>
<p>1)）机械特性。指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</p>
<p>2）电气特性。指明在接口电缆的各条线上出现的电压的范围。</p>
<p>3）功能特性。指明某条线上出现的某一电平的电压表示何种意义。</p>
<p>4）过程特性。或称规程特性。指明对于不同功能的各种可能事件的出现顺序。常用的物理层接口标准有EIARS-232-C、ADSL和 SONET/SDH等。</p>
<h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h3><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>中继器的主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后而产生的失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。其原理是信号再生（而非简单地将衰减的信号放大)。中继器有两个端口，数据从一个端口输入，再从另一个端口发出。端口仅作用于信号的电气部分，而不管是否有错误数据或不适于网段的数据。</p>
<p>中继器是用来扩大网络规模的最简单廉价的互联设备。中继器两端的网络部分是网段而不是子网，使用中继器连接的几个网段仍然是一个局域网。中继器若出现故障，对相邻两个网段的工作都将产生影响。由于中继器工作在物理层，因此它不能连接两个具有不同速率的局域网。</p>
<blockquote>
<p>注意:如果某个网络设备具有存储转发的功能，那么可以认为它能连接两个不同的协议;如果该网络设备没有存储转发功能，那么认为它不能连接两个不同的协议。中继器没有存储转发功能，因此它不能连接两个速率不同的网段，中继器两端的网段一定要使用同一个协议。</p>
</blockquote>
<p>从理论上讲，中继器的使用数目是无限的，网络因而也可以无限延长。但事实上这不可能，因为网络标准中对信号的延迟范围做了具体的规定，中继器只能在此规定范围内进行有效的工作，否则会引起网络故障。例如，在采用粗同轴电缆的10BASE5 以太网规范中，互相串联的中继器的个数不能超过4个，而且用4个中继器串联的5段通信介质中只有3段可以挂接计算机，其余两段只能用作扩展通信范围的链路段，不能挂接计算机。这就是所谓的“5-4-3规则”。</p>
<blockquote>
<p>注意:放大器和中继器都起放大作用，只不过放大器放大的是模拟信号，原理是将衰减的信号放大，而中继器放大的是数字信号，原理是将衰减的信号整形再生。</p>
</blockquote>
<h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>集线器（Hub）实质上是一个多端口的中继器。当Hub 工作时，一个端口接收到数据信号后，由于信号在从端口到Hub 的传输过程中已有衰减，所以Hub便将该信号进行整形放大，使之再生（恢复）到发送时的状态，紧接着转发到其他所有（除输入端口外）处于工作状态的端口。如果同时有两个或多个端口输入，那么输出时会发生冲突，致使这些数据都无效。从 Hub的工作方式可以看出，它在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，而不具备信号的定向传送能力，即信号传输的方向是固定的，是一个标准的共享式设备。</p>
<p>Hub主要使用双绞线组建共享网络，是从服务器连接到桌面的最经济方案。在交换式网络中，Hub直接与交换机相连，将交换机端口的数据送到桌面上。使用Hub组网灵活，它把所有结点的通信集中在以其为中心的结点上，对结点相连的工作站进行集中管理，不让出问题的工h作站影响整个网络的正常运行，并且用户的加入和退出也很自由。由Hub组成的网络是共享式网络，但逻辑上仍是一个总线网。Hub的每个端口连接的网络部分是同一个网络的不同网段，同时Hub也只能在半双工状态下工作，网络的吞吐率因而受到限制。</p>
<blockquote>
<p>注意:多台计算机必然会发生同时通信的情形，因此集线器不能分割冲突域，所有集线器的端口都属于同一个冲突域。集线器在一个时钟周期中只能传输一组信息，如果一台集线器连接的机器数目较多，且多台机器经常需要同时通信，那么将导致信息碰撞，使得集线器的工作效率很差。比如，一个带宽为10Mb/s的集线器上连接了8台计算机，当这8台计算机同时工作时，每台计算机真正所拥有的带宽为10/8Mb/s = 1.25Mb/s。</p>
</blockquote>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h3><h4 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h4><h4 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h4><h4 id="帧定界、帧同步与透明传输"><a href="#帧定界、帧同步与透明传输" class="headerlink" title="帧定界、帧同步与透明传输"></a>帧定界、帧同步与透明传输</h4><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><h4 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h4><h4 id="字符填充的首尾定界符法"><a href="#字符填充的首尾定界符法" class="headerlink" title="字符填充的首尾定界符法"></a>字符填充的首尾定界符法</h4><h4 id="零比特填充的首尾标志法"><a href="#零比特填充的首尾标志法" class="headerlink" title="零比特填充的首尾标志法"></a>零比特填充的首尾标志法</h4><h4 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h4><h3 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h3><h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h3><h4 id="流量控制、可靠传输与滑动窗口机制"><a href="#流量控制、可靠传输与滑动窗口机制" class="headerlink" title="流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h4><h4 id="单帧滑动窗口与停止-等待协议"><a href="#单帧滑动窗口与停止-等待协议" class="headerlink" title="单帧滑动窗口与停止-等待协议"></a>单帧滑动窗口与停止-等待协议</h4><h4 id="多帧滑动窗口与后退N帧协议（GBN"><a href="#多帧滑动窗口与后退N帧协议（GBN" class="headerlink" title="多帧滑动窗口与后退N帧协议（GBN)"></a>多帧滑动窗口与后退N帧协议（GBN)</h4><h4 id="多帧滑动窗口与选择重传协议-SR"><a href="#多帧滑动窗口与选择重传协议-SR" class="headerlink" title="多帧滑动窗口与选择重传协议(SR)"></a>多帧滑动窗口与选择重传协议(SR)</h4><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><h4 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h4><h4 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h4><h4 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h4><h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><h4 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h4><h4 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h4><h4 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h4><h4 id="令牌环网的基本原理"><a href="#令牌环网的基本原理" class="headerlink" title="令牌环网的基本原理"></a>令牌环网的基本原理</h4><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><h4 id="广域网的基本概念"><a href="#广域网的基本概念" class="headerlink" title="广域网的基本概念"></a>广域网的基本概念</h4><h4 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h4><h4 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h4><h3 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h3><h4 id="网桥的概念及其基本原理"><a href="#网桥的概念及其基本原理" class="headerlink" title="网桥的概念及其基本原理"></a>网桥的概念及其基本原理</h4><h4 id="局域网交换机及其工作原理"><a href="#局域网交换机及其工作原理" class="headerlink" title="局域网交换机及其工作原理"></a>局域网交换机及其工作原理</h4><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h3><h4 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h4><h4 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h4><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><h4 id="静态路由与动态路由"><a href="#静态路由与动态路由" class="headerlink" title="静态路由与动态路由"></a>静态路由与动态路由</h4><h4 id="距离-向量路由算法"><a href="#距离-向量路由算法" class="headerlink" title="距离-向量路由算法"></a>距离-向量路由算法</h4><h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h4><h4 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h4><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><h4 id="IPv4分组"><a href="#IPv4分组" class="headerlink" title="IPv4分组"></a>IPv4分组</h4><h4 id="IPv4地址与NAT"><a href="#IPv4地址与NAT" class="headerlink" title="IPv4地址与NAT"></a>IPv4地址与NAT</h4><h4 id="子网划分与子网掩码、CIDR"><a href="#子网划分与子网掩码、CIDR" class="headerlink" title="子网划分与子网掩码、CIDR"></a>子网划分与子网掩码、CIDR</h4><h4 id="ARP、DHCP-与ICMP"><a href="#ARP、DHCP-与ICMP" class="headerlink" title="ARP、DHCP 与ICMP"></a>ARP、DHCP 与ICMP</h4><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6的主要特点"><a href="#IPv6的主要特点" class="headerlink" title="IPv6的主要特点"></a>IPv6的主要特点</h4><h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><h4 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h4><h4 id="域内路由与域间路由"><a href="#域内路由与域间路由" class="headerlink" title="域内路由与域间路由"></a>域内路由与域间路由</h4><h4 id="路由信息协议（RIP"><a href="#路由信息协议（RIP" class="headerlink" title="路由信息协议（RIP)"></a>路由信息协议（RIP)</h4><h4 id="开放最短路径优先（OSPF-协议"><a href="#开放最短路径优先（OSPF-协议" class="headerlink" title="开放最短路径优先（OSPF)协议"></a>开放最短路径优先（OSPF)协议</h4><h4 id="边界网关协议（BGP"><a href="#边界网关协议（BGP" class="headerlink" title="边界网关协议（BGP)"></a>边界网关协议（BGP)</h4><h3 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h3><h4 id="组播的概念"><a href="#组播的概念" class="headerlink" title="组播的概念"></a>组播的概念</h4><h4 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h4><h4 id="IGMP与组播路由算法"><a href="#IGMP与组播路由算法" class="headerlink" title="IGMP与组播路由算法"></a>IGMP与组播路由算法</h4><h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h3><h4 id="移动P的概念"><a href="#移动P的概念" class="headerlink" title="移动P的概念"></a>移动P的概念</h4><h4 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h4><h3 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h3><h4 id="路由器的组成和功能"><a href="#路由器的组成和功能" class="headerlink" title="路由器的组成和功能"></a>路由器的组成和功能</h4><h4 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h4><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h3><h4 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h4><h4 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h4><h4 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h4><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h4><h4 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h4><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><h4 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h4><h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><h4 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h4><h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><h4 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户/服务器模型"></a>客户/服务器模型</h4><h4 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h4><h3 id="域名系统（DNS"><a href="#域名系统（DNS" class="headerlink" title="域名系统（DNS)"></a>域名系统（DNS)</h3><h4 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h4><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><h3 id="文件传输协议（-FTP"><a href="#文件传输协议（-FTP" class="headerlink" title="文件传输协议（(FTP)"></a>文件传输协议（(FTP)</h3><h4 id="FTP的工作原理"><a href="#FTP的工作原理" class="headerlink" title="FTP的工作原理"></a>FTP的工作原理</h4><h4 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h4><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><h4 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h4><h4 id="电子邮件格式与-MIME"><a href="#电子邮件格式与-MIME" class="headerlink" title="电子邮件格式与 MIME"></a>电子邮件格式与 MIME</h4><h4 id="SMTP-和-POP3"><a href="#SMTP-和-POP3" class="headerlink" title="SMTP 和 POP3"></a>SMTP 和 POP3</h4><h3 id="万维网-WWW"><a href="#万维网-WWW" class="headerlink" title="万维网(WWW)"></a>万维网(WWW)</h3><h4 id="WWW的概念与组成结构"><a href="#WWW的概念与组成结构" class="headerlink" title="WWW的概念与组成结构"></a>WWW的概念与组成结构</h4><h4 id="超文本传输协议（HTTP"><a href="#超文本传输协议（HTTP" class="headerlink" title="超文本传输协议（HTTP)"></a>超文本传输协议（HTTP)</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">总结-计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 13:02:27" itemprop="dateCreated datePublished" datetime="2021-07-19T13:02:27+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-26 16:33:26" itemprop="dateModified" datetime="2021-07-26T16:33:26+08:00">2021-07-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="凑数"><a href="#凑数" class="headerlink" title="凑数"></a>凑数</h1><h2 id="凑数-1"><a href="#凑数-1" class="headerlink" title="凑数"></a>凑数</h2><h3 id="凑数-2"><a href="#凑数-2" class="headerlink" title="凑数"></a>凑数</h3><h4 id="凑数-3"><a href="#凑数-3" class="headerlink" title="凑数"></a>凑数</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E6%80%BB%E7%BB%93-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E6%80%BB%E7%BB%93-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">总结-计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 13:02:27" itemprop="dateCreated datePublished" datetime="2021-07-19T13:02:27+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-30 16:32:21" itemprop="dateModified" datetime="2021-07-30T16:32:21+08:00">2021-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h2><p>【考纲内容】</p>
<p>(一）操作系统的概念、特征、功能和提供的服务</p>
<p>(二）操作系统的发展与分类</p>
<p>(三）操作系统的运行环境</p>
<p>内核态与用户态;中断、异常;系统调用</p>
<p>(四）操作系统体系结构</p>
<p>【知识框架】</p>
<p>概论</p>
<ul>
<li>特征<ul>
<li>并发(最基本)</li>
<li>共享(最基本)</li>
<li>虚拟</li>
<li>同步</li>
</ul>
</li>
<li>目标和功能<ul>
<li>计算机系统资源的管理者</li>
<li>用户与计算机系统之间的接口<ul>
<li>命令接口</li>
<li>程序接口</li>
<li>GUI</li>
</ul>
</li>
<li>扩充机器</li>
</ul>
</li>
<li>发展——批处理操作系统——分时操作系统——实时操作系统——网络和分布式操作系统</li>
<li>运行机制<ul>
<li>中断和异常</li>
<li>系统调用</li>
</ul>
</li>
<li>体系结构<ul>
<li>大内核</li>
<li>微内核</li>
</ul>
</li>
</ul>
<p>【复习提示】</p>
<p>本章内容通常以选择题的形式考查，重点考查操作系统的功能、运行环境和提供的服务。要求读者能在宏观上把握操作系统各个部分的功能，微观上掌握细微的知识点。因此，在复习操作系统时，首先要在形成大体框架后，通过反复做题巩固、完善知识体系，然后把操作系统的所有内容串成一个整体。本章的内容有助于读者整体上初步认识操作系统，为后面展开各章节的知识点奠定基础，进而整体把握课程。不要因为本章内容在历年考题中出现的比例不高而忽视。</p>
<h3 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h3><h4 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h4><p>在信息化时代，软件是计算机系统的灵魂，而作为软件核心的操作系统，已与现代计算机系统密不可分、融为一体。计算机系统自下而上可大致分为4部分:$\color{green}{\text{硬件}}$、$\color{green}{\text{操作系统}}$、$\color{green}{\text{应用程序}}$和$\color{green}{\text{用户}}$(这里的划分与计算机组成原理中的分层不同)。操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介。</p>
<p>硬件如中央处理器、内存、输入/输出设备等，提供基本的计算资源。应用程序如字处理程序、电子制表软件、编译器、网络浏览器等，规定按何种方式使用这些资源来解决用户的计算问题。操作系统控制和协调各用户的应用程序对硬件的分配与使用。</p>
<p>在计算机系统的运行过程中，操作系统提供了正确使用这些资源的方法。</p>
<p>综上所述，操作系统(Operating System，OS）是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。</p>
<h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><p>操作系统是一种系统软件，但与其他系统软件和应用软件有很大的不同，它有自己的特殊性即基本特征。操作系统的基本特征包括并发、共享、虚拟和异步。这些概念对理解和掌握操作系统的核心至关重要，将一直贯穿于各个章节中。</p>
<h5 id="并发-Concurrence"><a href="#并发-Concurrence" class="headerlink" title="并发(Concurrence)"></a>并发(Concurrence)</h5><p>并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的是使程序能并发执行。</p>
<p>注意同一时间间隔（$\color{red}{\text{并发}}$）和同一时刻（$\color{red}{\text{并行}}$）的区别。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此微观上这些程序仍是分时交替执行的。操作系统的并发性是通过分时得以实现的。</p>
<p>注意，并行性是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。</p>
<p>我们以现实生活中的直观例子来认识并发和并行的区别。例如，如果你在9:00～9:10仅吃面包，在9:10～9:20仅写字，在9:20～9:30仅吃面包，在9:30～10:00仅写字，那么在9:00～10:00吃面包和写字这两种行为就是并发执行的;再如，如果你在9:00～10:00右手写字，左手同时拿着面包吃，那么这两个动作就是并行执行的。</p>
<h5 id="共享-Sharing"><a href="#共享-Sharing" class="headerlink" title="共享(Sharing)"></a>共享(Sharing)</h5><p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为以下两种资源共享方式。</p>
<p>(1）互斥共享方式</p>
<p>系统中的某些资源，如打印机、磁带机，虽然可供多个进程使用，但为使得所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源。</p>
<p>为此，当进程A访问某个资源时，必须先提出请求，若此时该资源空闲，则系统便将之分配给进程A使用，此后有其他进程也要访问该资源时（只要A未用完）就必须等待。仅当进程A访问完并释放该资源后，才允许另一个进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。</p>
<p>(2）同时访问方式</p>
<p>系统中还有另一类资源，这类资源允许在一段时间内由多个进程“同时”访问。这里所说的“同时”通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。可供多个进程“同时”访问的典型资源是磁盘设备，一些用重入码编写的文件也可被“同时”共享，即允许若干个用户同时访问该文件。</p>
<p>注意，互斥共享要求一种资源在一段时间内（哪怕是一段很小的时间）只能满足一个请求，否则就会出现严重的问题，(你能想象打印机第一行打印A文档的内容、第二行打印B文档的内容的效果吗?）而同时访问共享通常要求一个请求分几个时间片段间隔地完成，其效果与连续完成的效果相同。</p>
<p>$\color{green}{\text{并发}}$和$\color{green}{\text{共享}}$是操作系统两个最基本的特征，两者之间互为存在的条件:①资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题;②若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</p>
<h5 id="虚拟-Virtual"><a href="#虚拟-Virtual" class="headerlink" title="虚拟(Virtual)"></a>虚拟(Virtual)</h5><p>虚拟是指把一个物理上的$\color{green}{\text{实体}}$变为若干$\color{green}{\text{逻辑}}$上的对应物。物理实体（前者）是实的，即实际存在的;而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。操作系统中利用了多种虚拟技术来实现虚拟处理器、虚拟内存和虚拟外部设备等。</p>
<p>虚拟处理器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器(CPU)在专门为它服务。利用多道程序设计技术把一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器。</p>
<p>类似地，可以采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。我们把用户感觉到（但实际不存在)的存储器称为虚拟存储器。</p>
<p>还可采用虚拟设备技术将一台物理IO设备虚拟为多台逻辑上的I/O 设备，并允许每个用户占用一台逻辑上的IO设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源)变为在一段时间内允许多个用户同时访问的共享设备。</p>
<p>因此，操作系统的虚拟技术可归纳为:时分复用技术，如处理器的分时共享;空分复用技术，如虚拟存储器。</p>
<h5 id="异步-Asynchronism"><a href="#异步-Asynchronism" class="headerlink" title="异步(Asynchronism)"></a>异步(Asynchronism)</h5><p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误（就像对全局变量的访问顺序不当会导致程序出错一样)。然而，只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。</p>
<h4 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h4><p>为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能:处理机管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时，操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p>
<p>我们用一个直观的例子来理解这种情况。例如，用户是雇主，操作系统是工人（用来操作机器)，计算机是机器（由处理机、存储器、设备、文件几个部件构成)，工人有熟练的技能，能够控制和协调各个部件的工作，这就是操作系统对资源的管理;同时，工人必须接收雇主的命令，这就是“接口”;有了工人，机器就能发挥更大的作用，因此工人就成了“扩充机器”。</p>
<h5 id="操作系统作为计算机系统资源的管理者"><a href="#操作系统作为计算机系统资源的管理者" class="headerlink" title="操作系统作为计算机系统资源的管理者"></a>操作系统作为计算机系统资源的管理者</h5><h6 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h6><p>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h6 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h6><p>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</p>
<h6 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h6><p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p>
<h6 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h6><p>设备管理的主要任务是完成用户的IO请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</p>
<p>这些工作都由“工人”负责，“雇主”无须关注。</p>
<h5 id="操作系统作为用户与计算机硬件系统之间的接口"><a href="#操作系统作为用户与计算机硬件系统之间的接口" class="headerlink" title="操作系统作为用户与计算机硬件系统之间的接口"></a>操作系统作为用户与计算机硬件系统之间的接口</h5><p>为了让用户方便、快捷、可靠地操纵计算机硬件并运行自己的程序，操作系统还提供了用户接口。操作系统提供的接口主要分为两类:一类是命令接口，用户利用这些操作命令来组织和控制作业的执行;另一类是程序接口，编程人员可以使用它们来请求操作系统服务。</p>
<h6 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h6><p>使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可将命令接口分为联机命令接口和脱机命令接口。</p>
<p>$\color{green}{\text{联机命令接口}}$又称$\color{green}{\text{交互式命令接口}}$，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能。之后，控制权转回控制台或终端，此时用户又可输入下一条命令。联机命令接口可以这样理解:“雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。</p>
<p>$\color{green}{\text{脱机命令接口}}$又称$\color{green}{\text{批处理命令接口}}$，适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。脱机命令接口可以这样理解:“雇主”把要“工人”做的事写在清单上，“工人”按照清单命令逐条完成这些事，这就是批处理。</p>
<blockquote>
<p>$\color{green}{\text{联}}$机和脱机可以理解为「$\color{green}{\text{联}}$接机器」的「$\color{green}{\text{联}}$」不是「$\color{red}{\text{联}}$网」的「$\color{red}{\text{联}}$」;交互的状态不就是连接着机器的吗</p>
</blockquote>
<h6 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h6><p>程序接口由一组$\color{green}{\text{系统调用}}$（也称$\color{green}{\text{广义指令}}$）组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。</p>
<p>当前最为流行的是图形用户界面(GUI),即图形接口。GUI最终是通过调用程序接口实现的，用户通过鼠标和键盘在图形界面上单击或使用快捷键，就能很方便地使用操作系统。严格来说，图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。</p>
<h5 id="操作系统用作扩充机器"><a href="#操作系统用作扩充机器" class="headerlink" title="操作系统用作扩充机器"></a>操作系统用作扩充机器</h5><p>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器;因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</p>
<p>“工人”操作机器，机器就有更大的作用，于是“工人”便成了“扩充机器”。</p>
<p>注意，本课程所关注的内容是操作系统如何控制和协调处理机、存储器、设备和文件，而不关注接口和扩充机器，后两者读者只需要有个印象，能理解即可。</p>
<h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3><h4 id="手工操作阶段（此阶段无操作系统"><a href="#手工操作阶段（此阶段无操作系统" class="headerlink" title="手工操作阶段（此阶段无操作系统)"></a>手工操作阶段（此阶段无操作系统)</h4><p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大，必须寻求新的解决办法。</p>
<p>手工操作阶段有两个突出的缺点:①用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。②CPU等待手工操作，CPU的利用不充分。</p>
<p>唯一的解决办法就是用高速的机器代替相对较慢的手工操作来对作业进行控制。</p>
<h4 id="批处理阶段-操作系统开始出现）"><a href="#批处理阶段-操作系统开始出现）" class="headerlink" title="批处理阶段(操作系统开始出现）"></a>批处理阶段(操作系统开始出现）</h4><p>为了解决人机矛盾及CPU和IO设备之间速度不匹配的矛盾，出现了批处理系统。按发展历程又分为单道批处理系统、多道批处理系统（多道程序设计技术出现以后)。·</p>
<h5 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h5><p>系统对作业的处理是成批进行的，但内存中始终保持一道作业。单道批处理系统是在解决人机矛盾及CPU和IO设备速率不匹配的矛盾中形成的。单道批处理系统的主要特征如下:</p>
<p>1）自动性。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预</p>
<p>2）顺序性。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。</p>
<p>3）单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</p>
<p>此时面临的问题是:每次主机内存中仅存放一道作业，每当它在运行期间（注意这里是“运行时”而不是“完成后”)发出输入/输出请求后，高速的CPU便处于等待低速的IO完成的状态。为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。</p>
<h5 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h5><p>多道程序设计技术允许多个程序同时进入内存并允许它们在CPU中交替地运行，这些程序共享系统中的各种硬/软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。它不采用某些机制来提高某一技术方面的瓶颈问题，而让系统的各个组成部分都尽量去“忙”，因此切换任务所花费的时间很少，可实现系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。</p>
<p>当然，多道批处理系统的设计和实现要比单道系统复杂很多，因为要充分利用各种资源，就要涉及各种资源的调度问题。</p>
<p>多道程序设计的特点是多道、宏观上并行、微观上串行。</p>
<p>1）多道。计算机内存中同时存放多道相互独立的程序。</p>
<p>2）宏观上并行。同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</p>
<p>3）微观上串行。内存中的多道程序轮流占有CPU，交替执行。</p>
<p>多道程序设计技术的实现需要解决下列问题:</p>
<p>1）如何分配处理器。</p>
<p>2）多道程序的内存分配问题。</p>
<p>3）IO设备如何分配。</p>
<p>4）如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。</p>
<p>在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行。</p>
<p>优点:资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用;系统吞吐量大，CPU和其他资源保持“忙碌”状态。缺点:用户响应的时间较长;不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。</p>
<h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><p>所谓分时技术，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己独占一台计算机。</p>
<p>分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。因此，实现分时系统最关键的问题是如何使用户能与自己的作业进行交互，即当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令，再将结果返回用户。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征。分时系统的主要特征如下:</p>
<p>1）同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</p>
<p>2）交互性。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</p>
<p>3）独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</p>
<p>4）及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</p>
<p>虽然分时操作系统较好地解决了人机交互问题，但在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内做出处理（比如飞机订票系统或导弹制导系统)，因此，实时操作系统应运而生。</p>
<h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况:若某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统，如飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。若能够接受偶尔违反时间规定且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统。</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。实时操作系统的主要特点是及时性和可靠性。</p>
<h4 id="网络操作系统和分布式计算机系统"><a href="#网络操作系统和分布式计算机系统" class="headerlink" title="网络操作系统和分布式计算机系统"></a>网络操作系统和分布式计算机系统</h4><p>网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。</p>
<p>分布式计算机系统是由多台计算机组成并满足下列条件的系统:系统中任意两台计算机通过通信方式交换信息;系统中的每台计算机都具有同等的地位，即没有主机也没有从机;每台计算机上的资源为所有用户共享;系统中的任意台计算机都可以构成一个子系统，并且还能重构;任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是:分布性和并行性。分布式操作系统与网络操作系统的本质不同是，分布式操作系统中的若干计算机相互协同完成同一任务。</p>
<h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有 Windows、Linux和 Macintosh等。操作系统的发展历程如图1.1所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210726161521.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210726161521.png';" /></details>

<p>此外，还有嵌入式操作系统、服务器操作系统、智能手机操作系统等。</p>
<h3 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h3><h4 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h4><blockquote>
<p>初学者需要弄清楚一个问题，即计算机“指令”和高级语言的“代码”是不同的。我们一般所说的“编写代码”指的是用高级语言〈如C、Java等）来编写程序。但CPU看不懂这些高级语言程序的含义，为了让这些程序能够顺利执行，就需要把它们“翻译”成CPU能懂的机器语言，即一条条“指令”(这个“翻译”的过程称为“编译”)。所谓执行程序，其实就是CPU根据一条条指令的指示来执行一个个具体的操作。</p>
</blockquote>
<p>计算机系统中，通常CPU执行两种不同性质的程序:一种是操作系统内核程序;另一种是用户自编程序（即系统外层的应用程序，或简称“应用程序”)。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”(即内核程序）要执行一些特权指令，而“被管理程序”(即用户自编程序）出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如IO指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。在具体实现上，将CPU的状态划分为用户态(目态）和核心态（又称管态、内核态)。可以理解为CPU内部有一个小开关，当小开关为1时，CPU处于核心态，此时CPU可以执行特权指令;当小开关为0时，CPU处于用户态，此时CPU只能执行非特权指令。用户自编程序运行在用户态，操作系统内核程序运行在核心态。</p>
<p>在软件工程思想和结构化程序设计方法影响下诞生的现代操作系统，几乎都是层次式的结构。操作系统的各项功能分别被设置在不同的层次上。一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p>
<p>内核是计算机上配置的底层软件，是计算机功能的延伸。不同系统对内核的定义稍有区别，大多数操作系统的内核包括4方面的内容。</p>
<h5 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h5><p>在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于时钟。</p>
<h5 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h5><p>引入中断技术的初衷是提高多道程序运行环境中CPU 的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。</p>
<p>中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</p>
<h5 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h5><p>按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。它们的特点如下:</p>
<p>1）处于操作系统的最低层，是最接近硬件的部分。</p>
<p>2)这些程序的运行具有原子性，其操作只能一气呵成(主要从系统安全性和便于管理考虑)。</p>
<p>3）这些程序的运行时间都较短，而且调用频繁。</p>
<p>通常把具有这些特点的程序称为原语(Atomic Operation)。定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。</p>
<p>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。</p>
<h5 id="系统控制的数据结构及处理"><a href="#系统控制的数据结构及处理" class="headerlink" title="系统控制的数据结构及处理"></a>系统控制的数据结构及处理</h5><p>系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理,系统需要一些基本的操作，常见的操作有以下3种:</p>
<p>1)进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。</p>
<p>2）存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</p>
<p>3）设备管理。缓冲区管理、设备分配和回收等。</p>
<p>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。</p>
<h4 id="中断和异常的概念"><a href="#中断和异常的概念" class="headerlink" title="中断和异常的概念"></a>中断和异常的概念</h4><blockquote>
<p>建议结合《计算机组成原理考研复习指导》第7章学习，那里的讲解更详细。</p>
</blockquote>
<p>在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换。操作系统内核工作在核心态，而用户程序工作在用户态。系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。因此，需要在核心态建立一些“门”，以便实现从用户态进入核心态。在实际操作系统中，CPU运行上层程序时唯一能进入这些“门”的途径就是通过中断或异常。发生中断或异常时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的(例如,用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，则只需将该位置0即可)。中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。原因是，操作系统的发展过程大体上就是一个想方设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源的占有权释放，而这一行为就需要通过中断实现。</p>
<h5 id="中断和异常的定义"><a href="#中断和异常的定义" class="headerlink" title="中断和异常的定义"></a>中断和异常的定义</h5><p>中断(Interruption)也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的IO结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入/输出请求，同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前指令执行无关的事件，即它们与当前处理机运行的程序无关。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210726162307.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210726162307.png';" /></details>

<p>异常（Exception）也称内中断、例外或陷入(trap)，指源自CPU执行指令内部的事件,如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。关于内中断和外中断的联系与区别如图1.2所示。</p>
<blockquote>
<p>异常不能被屏蔽，一旦出现应立即处理???</p>
</blockquote>
<h5 id="中断处理的过程"><a href="#中断处理的过程" class="headerlink" title="中断处理的过程"></a>中断处理的过程</h5><p>不同计算机的中断(指外中断)处理过程各具特色，就其多数而论，中断处理流程如图1.3所示。各阶段处理流程的描述如下:</p>
<details><summary>图1.3 中断处理流程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210729154445.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210729154445.png';" /></details>

<p>1）关中断。CPU响应中断后，首先要保护程序的现场状态，在保护现场的过程中，CPU不应响应更高级中断源的中断请求。否则，若现场保存不完整，在中断服务程序结束后，也就不能正确地恢复并继续执行现行程序。</p>
<p>2）保存断点。为保证中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来的程序的断点（即程序计数器PC）保存起来。</p>
<p>3）中断服务程序寻址。其实质是取出中断服务程序的入口地址送入程序计数器PC。</p>
<p>4)保存现场和屏蔽字。进入中断服务程序后，首先要保存现场，现场信息一般是指程序状态字寄存器PSWR和某些通用寄存器的内容。</p>
<p>5）开中断。允许更高级中断请求得到响应。</p>
<p>6）执行中断服务程序。这是中断请求的目的。</p>
<p>7）关中断。保证在恢复现场和屏蔽字时不被中断。</p>
<p>8）恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。</p>
<p>9)开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p>
<p>其中，1 ~ 3步是在CPU进入中断周期后，由硬件自动（中断隐指令）完成的;4 ~ 9步由中断服务程序完成。恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作由中断服务程序完成。中断返回由中断服务程序的最后一条中断返回指令完成。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>所谓系统调用，是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行IO传输及管理文件等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十条乃至上百条之多。这些系统调用按功能大致可分为如下几类。</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li>
</ul>
<p>显然，系统调用相关功能涉及系统资源管理、进程管理之类的操作，对整个系统的影响非常大，因此必定需要使用某些特权指令才能完成，所以系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。用户程序可以执行陷入指令(又称$\color{green}{\text{访管指令}}$或$\color{green}{\text{trap指令}}$）来发起系统调用，请求操作系统提供服务。可以这么理解，用户程序执行“陷入指令”，相当于把CPU成低用权主动交给操作系统内核程序（CPU 状态会从用户态进入核心态)，之后操作系统内核程序再对系统调用请求做出相应处理。处理完成后，操作系统内核程序又会把CPU的使用权还给用户程序(即CPU状态会从核心态回到用户态)。这么设计的目的是:用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用的方式请求操作系统代为执行，以便保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行。</p>
<p>这样，操作系统的运行环境就可以理解为:用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序;也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行，如图1.4所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210726162621.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210726162621.png';" /></details>


<p>在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现与切换，对于硬件层面的具体理解，可以结合“计算机组成原理”课程中有关中断的内容进行学习。</p>
<p>下面列举一些由用户态转向核心态的例子:</p>
<p>1）用户程序要求操作系统的服务，即系统调用。</p>
<p>2）发生一次中断。</p>
<p>3）用户程序中产生了一个错误状态。</p>
<p>4）用户程序中企图执行一条特权指令。</p>
<p>5）从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。</p>
<blockquote>
<p>注意:由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p>
</blockquote>
<p>若程序的运行由用户态转到核心态，则会用到访管指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p>
<h3 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h3><h4 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h4><p>操作系统的体系结构是一个开放的问题。如上文所述，操作系统在核心态为应用程序提供公共的服务，那么操作系统在核心态应该提供什么服务、怎样提供服务﹖有关这一问题的回答形成了两种主要的体系结构:大内核和微内核。</p>
<p>大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性.所以具有无可比拟的性能优势。</p>
<p>但随着体系结构和应用需求的不断发展，需要操作系统提供的服务越来越多，而且接口形式越来越复杂，操作系统的设计规模急剧增长，操作系统也面临着“软件危机”困境。为此，操作系统设计人员试图按照复杂性、时间常数、抽象级别等因素，将操作系统内核分成基本进程管理、虚存、IO与设备管理、IPC、文件系统等几个层次，继而定义层次之间的服务结构，提高操作系统内核设计上的模块化。但是，由于层次之间的交互关系错综复杂，定义清晰的层次间接口非常困难，复杂的交互关系也使得层次之间的界限极其模糊。</p>
<p>为解决操作系统的内核代码难以维护的问题，提出了微内核的体系结构。它将内核中最基本的功能（如进程管理等）保留在内核，而将那些不需要在核心态执行的功能移到用户态执行,从而降低了内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。</p>
<p>微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进，从而保证了操作系统的可靠性。</p>
<p>微内核结构的最大问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。因此有的操作系统将那些频繁使用的系统服务又移回内核，从而保证系统性能。但相当多的实验数据表明，体系结构不是引起性能下降的主要因素，体系结构带来的性能提升足以弥补切换开销带来的缺陷。为减少切换开销，也有人提出将系统服务作为运行库链接到用户程序的一种解决方案，这样的体系结构称为库操作系统。</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h4><h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><h4 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h4><h4 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h4><h4 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h4><h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><h4 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h4><h4 id="调度的时机、切换与过程"><a href="#调度的时机、切换与过程" class="headerlink" title="调度的时机、切换与过程"></a>调度的时机、切换与过程</h4><h4 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h4><h4 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h4><h4 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h4><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h4><h4 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h4><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><h4 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h4><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h3><h4 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h4><h4 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h4><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><h4 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h4><h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><h4 id="页面置换算法（决定应该换入哪页、换出哪页"><a href="#页面置换算法（决定应该换入哪页、换出哪页" class="headerlink" title="页面置换算法（决定应该换入哪页、换出哪页)"></a>页面置换算法（决定应该换入哪页、换出哪页)</h4><h4 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h4><h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><h4 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h4><h2 id="文件管理-1"><a href="#文件管理-1" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h3><h4 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h4><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><h3 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h3><h4 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h4><h4 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h4><h4 id="文件实现—文件分配方式"><a href="#文件实现—文件分配方式" class="headerlink" title="文件实现—文件分配方式"></a>文件实现—文件分配方式</h4><h4 id="文件实现——文件存储空间管理"><a href="#文件实现——文件存储空间管理" class="headerlink" title="文件实现——文件存储空间管理"></a>文件实现——文件存储空间管理</h4><h3 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h3><h4 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h4><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><h4 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h4><h2 id="输入-输出-I-O-管理"><a href="#输入-输出-I-O-管理" class="headerlink" title="输入/输出(I/O)管理"></a>输入/输出(I/O)管理</h2><h3 id="I-O管理概述"><a href="#I-O管理概述" class="headerlink" title="I/O管理概述"></a>I/O管理概述</h3><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h4><h4 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h4><h4 id="1-O子系统的层次结构"><a href="#1-O子系统的层次结构" class="headerlink" title="1/O子系统的层次结构"></a>1/O子系统的层次结构</h4><h3 id="1-O核心子系统"><a href="#1-O核心子系统" class="headerlink" title="1/O核心子系统"></a>1/O核心子系统</h3><h4 id="I-O子系统概述"><a href="#I-O子系统概述" class="headerlink" title="I/O子系统概述"></a>I/O子系统概述</h4><h4 id="IO调度概念"><a href="#IO调度概念" class="headerlink" title="IO调度概念"></a>IO调度概念</h4><h4 id="高速缓存与缓冲区"><a href="#高速缓存与缓冲区" class="headerlink" title="高速缓存与缓冲区"></a>高速缓存与缓冲区</h4><h4 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h4><h4 id="SPOOLing技术（假脱机技术）"><a href="#SPOOLing技术（假脱机技术）" class="headerlink" title="SPOOLing技术（假脱机技术）"></a>SPOOLing技术（假脱机技术）</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch21-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch21-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch21-案例研究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-19 12:58:47 / 修改时间：13:01:15" itemprop="dateCreated datePublished" datetime="2021-07-19T12:58:47+08:00">2021-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch20-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch20-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch20-面向服务的架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-19 12:58:29 / 修改时间：13:01:10" itemprop="dateCreated datePublished" datetime="2021-07-19T12:58:29+08:00">2021-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch19-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch19-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch19-嵌入式系统设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-19 12:58:13 / 修改时间：13:01:06" itemprop="dateCreated datePublished" datetime="2021-07-19T12:58:13+08:00">2021-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="嵌入式系统设计"><a href="#嵌入式系统设计" class="headerlink" title="嵌入式系统设计"></a>嵌入式系统设计</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/index/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/index/">1</a><span class="page-number current">2</span><a class="page-number" href="/index/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/29/">29</a><a class="extend next" rel="next" href="/index/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">287</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
