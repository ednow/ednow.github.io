<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ednow">
<meta property="og:url" content="http://ednow.github.io/index/page/3/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ednow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ednow.github.io/index/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">总结-计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 13:02:27" itemprop="dateCreated datePublished" datetime="2021-07-19T13:02:27+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-21 22:34:26" itemprop="dateModified" datetime="2021-08-21T22:34:26+08:00">2021-08-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="凑数"><a href="#凑数" class="headerlink" title="凑数"></a>凑数</h1><h2 id="凑数-1"><a href="#凑数-1" class="headerlink" title="凑数"></a>凑数</h2><h3 id="凑数-2"><a href="#凑数-2" class="headerlink" title="凑数"></a>凑数</h3><h4 id="凑数-3"><a href="#凑数-3" class="headerlink" title="凑数"></a>凑数</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/19/%E6%80%BB%E7%BB%93-%E4%B9%A0%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E6%80%BB%E7%BB%93-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E6%80%BB%E7%BB%93-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">总结-计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 13:02:27" itemprop="dateCreated datePublished" datetime="2021-07-19T13:02:27+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-17 18:56:45" itemprop="dateModified" datetime="2021-09-17T18:56:45+08:00">2021-09-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h2><details><summary>计算机操作系统总考纲</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210917185554.jpg" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210917185554.png';" /></details>

<p>【考纲内容】</p>
<p>(一）操作系统的概念、特征、功能和提供的服务</p>
<p>(二）操作系统的发展与分类</p>
<p>(三）操作系统的运行环境</p>
<p>内核态与用户态;中断、异常;系统调用</p>
<p>(四）操作系统体系结构</p>
<p>【知识框架】</p>
<p>概论</p>
<ul>
<li>特征<ul>
<li>并发(最基本)</li>
<li>共享(最基本)</li>
<li>虚拟</li>
<li>同步</li>
</ul>
</li>
<li>目标和功能<ul>
<li>计算机系统资源的管理者</li>
<li>用户与计算机系统之间的接口<ul>
<li>命令接口</li>
<li>程序接口</li>
<li>GUI</li>
</ul>
</li>
<li>扩充机器</li>
</ul>
</li>
<li>发展——批处理操作系统——分时操作系统——实时操作系统——网络和分布式操作系统</li>
<li>运行机制<ul>
<li>中断和异常</li>
<li>系统调用</li>
</ul>
</li>
<li>体系结构<ul>
<li>大内核</li>
<li>微内核</li>
</ul>
</li>
</ul>
<p>【复习提示】</p>
<p>本章内容通常以选择题的形式考查，重点考查操作系统的功能、运行环境和提供的服务。要求读者能在宏观上把握操作系统各个部分的功能，微观上掌握细微的知识点。因此，在复习操作系统时，首先要在形成大体框架后，通过反复做题巩固、完善知识体系，然后把操作系统的所有内容串成一个整体。本章的内容有助于读者整体上初步认识操作系统，为后面展开各章节的知识点奠定基础，进而整体把握课程。不要因为本章内容在历年考题中出现的比例不高而忽视。</p>
<h3 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h3><h4 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h4><p>在信息化时代，软件是计算机系统的灵魂，而作为软件核心的操作系统，已与现代计算机系统密不可分、融为一体。计算机系统自下而上可大致分为4部分:$\color{green}{\text{硬件}}$、$\color{green}{\text{操作系统}}$、$\color{green}{\text{应用程序}}$和$\color{green}{\text{用户}}$(这里的划分与计算机组成原理中的分层不同)。操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介。</p>
<p>硬件如中央处理器、内存、输入/输出设备等，提供基本的计算资源。应用程序如字处理程序、电子制表软件、编译器、网络浏览器等，规定按何种方式使用这些资源来解决用户的计算问题。操作系统控制和协调各用户的应用程序对硬件的分配与使用。</p>
<p>在计算机系统的运行过程中，操作系统提供了正确使用这些资源的方法。</p>
<p>综上所述，操作系统(Operating System，OS）是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。</p>
<h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><p>操作系统是一种系统软件，但与其他系统软件和应用软件有很大的不同，它有自己的特殊性即基本特征。操作系统的基本特征包括并发、共享、虚拟和异步。这些概念对理解和掌握操作系统的核心至关重要，将一直贯穿于各个章节中。</p>
<h5 id="并发-Concurrence"><a href="#并发-Concurrence" class="headerlink" title="并发(Concurrence)"></a>并发(Concurrence)</h5><p>并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的是使程序能并发执行。</p>
<p>注意同一时间间隔（$\color{red}{\text{并发}}$）和同一时刻（$\color{red}{\text{并行}}$）的区别。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此微观上这些程序仍是分时交替执行的。操作系统的并发性是通过分时得以实现的。</p>
<p>注意，并行性是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。</p>
<p>我们以现实生活中的直观例子来认识并发和并行的区别。例如，如果你在9:00～9:10仅吃面包，在9:10～9:20仅写字，在9:20～9:30仅吃面包，在9:30～10:00仅写字，那么在9:00～10:00吃面包和写字这两种行为就是并发执行的;再如，如果你在9:00～10:00右手写字，左手同时拿着面包吃，那么这两个动作就是并行执行的。</p>
<h5 id="共享-Sharing"><a href="#共享-Sharing" class="headerlink" title="共享(Sharing)"></a>共享(Sharing)</h5><p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为以下两种资源共享方式。</p>
<p>(1）互斥共享方式</p>
<p>系统中的某些资源，如打印机、磁带机，虽然可供多个进程使用，但为使得所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源。</p>
<p>为此，当进程A访问某个资源时，必须先提出请求，若此时该资源空闲，则系统便将之分配给进程A使用，此后有其他进程也要访问该资源时（只要A未用完）就必须等待。仅当进程A访问完并释放该资源后，才允许另一个进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。</p>
<p>(2）同时访问方式</p>
<p>系统中还有另一类资源，这类资源允许在一段时间内由多个进程“同时”访问。这里所说的“同时”通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。可供多个进程“同时”访问的典型资源是磁盘设备，一些用重入码编写的文件也可被“同时”共享，即允许若干个用户同时访问该文件。</p>
<p>注意，互斥共享要求一种资源在一段时间内（哪怕是一段很小的时间）只能满足一个请求，否则就会出现严重的问题，(你能想象打印机第一行打印A文档的内容、第二行打印B文档的内容的效果吗?）而同时访问共享通常要求一个请求分几个时间片段间隔地完成，其效果与连续完成的效果相同。</p>
<p>$\color{green}{\text{并发}}$和$\color{green}{\text{共享}}$是操作系统两个最基本的特征，两者之间互为存在的条件:①资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题;②若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</p>
<h5 id="虚拟-Virtual"><a href="#虚拟-Virtual" class="headerlink" title="虚拟(Virtual)"></a>虚拟(Virtual)</h5><p>虚拟是指把一个物理上的$\color{green}{\text{实体}}$变为若干$\color{green}{\text{逻辑}}$上的对应物。物理实体（前者）是实的，即实际存在的;而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。操作系统中利用了多种虚拟技术来实现虚拟处理器、虚拟内存和虚拟外部设备等。</p>
<p>虚拟处理器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器(CPU)在专门为它服务。利用多道程序设计技术把一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器。</p>
<p>类似地，可以采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。我们把用户感觉到（但实际不存在)的存储器称为虚拟存储器。</p>
<p>还可采用虚拟设备技术将一台物理IO设备虚拟为多台逻辑上的I/O 设备，并允许每个用户占用一台逻辑上的IO设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源)变为在一段时间内允许多个用户同时访问的共享设备。</p>
<p>因此，操作系统的虚拟技术可归纳为:时分复用技术，如处理器的分时共享;空分复用技术，如虚拟存储器。</p>
<h5 id="异步-Asynchronism"><a href="#异步-Asynchronism" class="headerlink" title="异步(Asynchronism)"></a>异步(Asynchronism)</h5><p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误（就像对全局变量的访问顺序不当会导致程序出错一样)。然而，只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。</p>
<h4 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h4><p>为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能:处理机管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时，操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p>
<p>我们用一个直观的例子来理解这种情况。例如，用户是雇主，操作系统是工人（用来操作机器)，计算机是机器（由处理机、存储器、设备、文件几个部件构成)，工人有熟练的技能，能够控制和协调各个部件的工作，这就是操作系统对资源的管理;同时，工人必须接收雇主的命令，这就是“接口”;有了工人，机器就能发挥更大的作用，因此工人就成了“扩充机器”。</p>
<h5 id="操作系统作为计算机系统资源的管理者"><a href="#操作系统作为计算机系统资源的管理者" class="headerlink" title="操作系统作为计算机系统资源的管理者"></a>操作系统作为计算机系统资源的管理者</h5><h6 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h6><p>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h6 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h6><p>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</p>
<h6 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h6><p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p>
<h6 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h6><p>设备管理的主要任务是完成用户的IO请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</p>
<p>这些工作都由“工人”负责，“雇主”无须关注。</p>
<h5 id="操作系统作为用户与计算机硬件系统之间的接口"><a href="#操作系统作为用户与计算机硬件系统之间的接口" class="headerlink" title="操作系统作为用户与计算机硬件系统之间的接口"></a>操作系统作为用户与计算机硬件系统之间的接口</h5><p>为了让用户方便、快捷、可靠地操纵计算机硬件并运行自己的程序，操作系统还提供了用户接口。操作系统提供的接口主要分为两类:一类是命令接口，用户利用这些操作命令来组织和控制作业的执行;另一类是程序接口，编程人员可以使用它们来请求操作系统服务。</p>
<h6 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h6><p>使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可将命令接口分为联机命令接口和脱机命令接口。</p>
<p>$\color{green}{\text{联机命令接口}}$又称$\color{green}{\text{交互式命令接口}}$，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能。之后，控制权转回控制台或终端，此时用户又可输入下一条命令。联机命令接口可以这样理解:“雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。</p>
<p>$\color{green}{\text{脱机命令接口}}$又称$\color{green}{\text{批处理命令接口}}$，适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。脱机命令接口可以这样理解:“雇主”把要“工人”做的事写在清单上，“工人”按照清单命令逐条完成这些事，这就是批处理。</p>
<blockquote>
<p>$\color{green}{\text{联}}$机和脱机可以理解为「$\color{green}{\text{联}}$接机器」的「$\color{green}{\text{联}}$」不是「$\color{red}{\text{联}}$网」的「$\color{red}{\text{联}}$」;交互的状态不就是连接着机器的吗</p>
</blockquote>
<h6 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h6><p>程序接口由一组$\color{green}{\text{系统调用}}$（也称$\color{green}{\text{广义指令}}$）组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。</p>
<p>当前最为流行的是图形用户界面(GUI),即图形接口。GUI最终是通过调用程序接口实现的，用户通过鼠标和键盘在图形界面上单击或使用快捷键，就能很方便地使用操作系统。严格来说，图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。</p>
<h5 id="操作系统用作扩充机器"><a href="#操作系统用作扩充机器" class="headerlink" title="操作系统用作扩充机器"></a>操作系统用作扩充机器</h5><p>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器;因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</p>
<p>“工人”操作机器，机器就有更大的作用，于是“工人”便成了“扩充机器”。</p>
<p>注意，本课程所关注的内容是操作系统如何控制和协调处理机、存储器、设备和文件，而不关注接口和扩充机器，后两者读者只需要有个印象，能理解即可。</p>
<h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3><h4 id="手工操作阶段（此阶段无操作系统"><a href="#手工操作阶段（此阶段无操作系统" class="headerlink" title="手工操作阶段（此阶段无操作系统)"></a>手工操作阶段（此阶段无操作系统)</h4><p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大，必须寻求新的解决办法。</p>
<p>手工操作阶段有两个突出的缺点:①用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。②CPU等待手工操作，CPU的利用不充分。</p>
<p>唯一的解决办法就是用高速的机器代替相对较慢的手工操作来对作业进行控制。</p>
<h4 id="批处理阶段-操作系统开始出现）"><a href="#批处理阶段-操作系统开始出现）" class="headerlink" title="批处理阶段(操作系统开始出现）"></a>批处理阶段(操作系统开始出现）</h4><p>为了解决人机矛盾及CPU和IO设备之间速度不匹配的矛盾，出现了批处理系统。按发展历程又分为单道批处理系统、多道批处理系统（多道程序设计技术出现以后)。·</p>
<h5 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h5><p>系统对作业的处理是成批进行的，但内存中始终保持一道作业。单道批处理系统是在解决人机矛盾及CPU和IO设备速率不匹配的矛盾中形成的。单道批处理系统的主要特征如下:</p>
<p>1）自动性。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预</p>
<p>2）顺序性。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。</p>
<p>3）单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</p>
<p>此时面临的问题是:每次主机内存中仅存放一道作业，每当它在运行期间（注意这里是“运行时”而不是“完成后”)发出输入/输出请求后，高速的CPU便处于等待低速的IO完成的状态。为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。</p>
<h5 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h5><p>多道程序设计技术允许多个程序同时进入内存并允许它们在CPU中交替地运行，这些程序共享系统中的各种硬/软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。它不采用某些机制来提高某一技术方面的瓶颈问题，而让系统的各个组成部分都尽量去“忙”，因此切换任务所花费的时间很少，可实现系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。</p>
<p>当然，多道批处理系统的设计和实现要比单道系统复杂很多，因为要充分利用各种资源，就要涉及各种资源的调度问题。</p>
<p>多道程序设计的特点是多道、宏观上并行、微观上串行。</p>
<p>1）多道。计算机内存中同时存放多道相互独立的程序。</p>
<p>2）宏观上并行。同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</p>
<p>3）微观上串行。内存中的多道程序轮流占有CPU，交替执行。</p>
<p>多道程序设计技术的实现需要解决下列问题:</p>
<p>1）如何分配处理器。</p>
<p>2）多道程序的内存分配问题。</p>
<p>3）IO设备如何分配。</p>
<p>4）如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。</p>
<p>在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行。</p>
<p>优点:资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用;系统吞吐量大，CPU和其他资源保持“忙碌”状态。缺点:用户响应的时间较长;不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。</p>
<h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><p>所谓分时技术，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己独占一台计算机。</p>
<p>分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。因此，实现分时系统最关键的问题是如何使用户能与自己的作业进行交互，即当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令，再将结果返回用户。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征。分时系统的主要特征如下:</p>
<p>1）同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</p>
<p>2）交互性。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</p>
<p>3）独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</p>
<p>4）及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</p>
<p>虽然分时操作系统较好地解决了人机交互问题，但在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内做出处理（比如飞机订票系统或导弹制导系统)，因此，实时操作系统应运而生。</p>
<h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况:若某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统，如飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。若能够接受偶尔违反时间规定且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统。</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。实时操作系统的主要特点是及时性和可靠性。</p>
<h4 id="网络操作系统和分布式计算机系统"><a href="#网络操作系统和分布式计算机系统" class="headerlink" title="网络操作系统和分布式计算机系统"></a>网络操作系统和分布式计算机系统</h4><p>网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。</p>
<p>分布式计算机系统是由多台计算机组成并满足下列条件的系统:系统中任意两台计算机通过通信方式交换信息;系统中的每台计算机都具有同等的地位，即没有主机也没有从机;每台计算机上的资源为所有用户共享;系统中的任意台计算机都可以构成一个子系统，并且还能重构;任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是:分布性和并行性。分布式操作系统与网络操作系统的本质不同是，分布式操作系统中的若干计算机相互协同完成同一任务。</p>
<h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有 Windows、Linux和 Macintosh等。操作系统的发展历程如图1.1所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210726161521.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210726161521.png';" /></details>

<p>此外，还有嵌入式操作系统、服务器操作系统、智能手机操作系统等。</p>
<h3 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h3><h4 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h4><blockquote>
<p>初学者需要弄清楚一个问题，即计算机“指令”和高级语言的“代码”是不同的。我们一般所说的“编写代码”指的是用高级语言〈如C、Java等）来编写程序。但CPU看不懂这些高级语言程序的含义，为了让这些程序能够顺利执行，就需要把它们“翻译”成CPU能懂的机器语言，即一条条“指令”(这个“翻译”的过程称为“编译”)。所谓执行程序，其实就是CPU根据一条条指令的指示来执行一个个具体的操作。</p>
</blockquote>
<p>计算机系统中，通常CPU执行两种不同性质的程序:一种是操作系统内核程序;另一种是用户自编程序（即系统外层的应用程序，或简称“应用程序”)。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”(即内核程序）要执行一些特权指令，而“被管理程序”(即用户自编程序）出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如IO指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。在具体实现上，将CPU的状态划分为用户态(目态）和核心态（又称管态、内核态)。可以理解为CPU内部有一个小开关，当小开关为1时，CPU处于核心态，此时CPU可以执行特权指令;当小开关为0时，CPU处于用户态，此时CPU只能执行非特权指令。用户自编程序运行在用户态，操作系统内核程序运行在核心态。</p>
<p>在软件工程思想和结构化程序设计方法影响下诞生的现代操作系统，几乎都是层次式的结构。操作系统的各项功能分别被设置在不同的层次上。一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p>
<p>内核是计算机上配置的底层软件，是计算机功能的延伸。不同系统对内核的定义稍有区别，大多数操作系统的内核包括4方面的内容。</p>
<h5 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h5><p>在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于时钟。</p>
<h5 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h5><p>引入中断技术的初衷是提高多道程序运行环境中CPU 的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。</p>
<p>中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</p>
<h5 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h5><p>按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。它们的特点如下:</p>
<p>1）处于操作系统的最低层，是最接近硬件的部分。</p>
<p>2)这些程序的运行具有原子性，其操作只能一气呵成(主要从系统安全性和便于管理考虑)。</p>
<p>3）这些程序的运行时间都较短，而且调用频繁。</p>
<p>通常把具有这些特点的程序称为原语(Atomic Operation)。定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。</p>
<p>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。</p>
<h5 id="系统控制的数据结构及处理"><a href="#系统控制的数据结构及处理" class="headerlink" title="系统控制的数据结构及处理"></a>系统控制的数据结构及处理</h5><p>系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理,系统需要一些基本的操作，常见的操作有以下3种:</p>
<p>1)进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。</p>
<p>2）存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</p>
<p>3）设备管理。缓冲区管理、设备分配和回收等。</p>
<p>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。</p>
<h4 id="中断和异常的概念"><a href="#中断和异常的概念" class="headerlink" title="中断和异常的概念"></a>中断和异常的概念</h4><blockquote>
<p>建议结合《计算机组成原理考研复习指导》第7章学习，那里的讲解更详细。</p>
</blockquote>
<p>在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换。操作系统内核工作在核心态，而用户程序工作在用户态。系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。因此，需要在核心态建立一些“门”，以便实现从用户态进入核心态。在实际操作系统中，CPU运行上层程序时唯一能进入这些“门”的途径就是通过中断或异常。发生中断或异常时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的(例如,用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，则只需将该位置0即可)。中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。原因是，操作系统的发展过程大体上就是一个想方设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源的占有权释放，而这一行为就需要通过中断实现。</p>
<h5 id="中断和异常的定义"><a href="#中断和异常的定义" class="headerlink" title="中断和异常的定义"></a>中断和异常的定义</h5><p>中断(Interruption)也称外中断，指来自CPU执行指令以外的事件的发生，如设备发出的IO结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入/输出请求，同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前指令执行无关的事件，即它们与当前处理机运行的程序无关。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210726162307.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210726162307.png';" /></details>

<p>异常（Exception）也称内中断、例外或陷入(trap)，指源自CPU执行指令内部的事件,如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。关于内中断和外中断的联系与区别如图1.2所示。</p>
<blockquote>
<p>异常不能被屏蔽，一旦出现应立即处理???</p>
</blockquote>
<h5 id="中断处理的过程"><a href="#中断处理的过程" class="headerlink" title="中断处理的过程"></a>中断处理的过程</h5><p>不同计算机的中断(指外中断)处理过程各具特色，就其多数而论，中断处理流程如图1.3所示。各阶段处理流程的描述如下:</p>
<details><summary>图1.3 中断处理流程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210729154445.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210729154445.png';" /></details>

<p>1）关中断。CPU响应中断后，首先要保护程序的现场状态，在保护现场的过程中，CPU不应响应更高级中断源的中断请求。否则，若现场保存不完整，在中断服务程序结束后，也就不能正确地恢复并继续执行现行程序。</p>
<p>2）保存断点。为保证中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来的程序的断点（即程序计数器PC）保存起来。</p>
<p>3）中断服务程序寻址。其实质是取出中断服务程序的入口地址送入程序计数器PC。</p>
<p>4)保存现场和屏蔽字。进入中断服务程序后，首先要保存现场，现场信息一般是指程序状态字寄存器PSWR和某些通用寄存器的内容。</p>
<p>5）开中断。允许更高级中断请求得到响应。</p>
<p>6）执行中断服务程序。这是中断请求的目的。</p>
<p>7）关中断。保证在恢复现场和屏蔽字时不被中断。</p>
<p>8）恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。</p>
<p>9)开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p>
<p>其中，1 ~ 3步是在CPU进入中断周期后，由硬件自动（中断隐指令）完成的;4 ~ 9步由中断服务程序完成。恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作由中断服务程序完成。中断返回由中断服务程序的最后一条中断返回指令完成。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>所谓系统调用，是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行IO传输及管理文件等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十条乃至上百条之多。这些系统调用按功能大致可分为如下几类。</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li>
</ul>
<p>显然，系统调用相关功能涉及系统资源管理、进程管理之类的操作，对整个系统的影响非常大，因此必定需要使用某些特权指令才能完成，所以系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。用户程序可以执行陷入指令(又称$\color{green}{\text{访管指令}}$或$\color{green}{\text{trap指令}}$）来发起系统调用，请求操作系统提供服务。可以这么理解，用户程序执行“陷入指令”，相当于把CPU成低用权主动交给操作系统内核程序（CPU 状态会从用户态进入核心态)，之后操作系统内核程序再对系统调用请求做出相应处理。处理完成后，操作系统内核程序又会把CPU的使用权还给用户程序(即CPU状态会从核心态回到用户态)。这么设计的目的是:用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用的方式请求操作系统代为执行，以便保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行。</p>
<p>这样，操作系统的运行环境就可以理解为:用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序;也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行，如图1.4所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210726162621.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210726162621.png';" /></details>


<p>在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现与切换，对于硬件层面的具体理解，可以结合“计算机组成原理”课程中有关中断的内容进行学习。</p>
<p>下面列举一些由用户态转向核心态的例子:</p>
<p>1）用户程序要求操作系统的服务，即系统调用。</p>
<p>2）发生一次中断。</p>
<p>3）用户程序中产生了一个错误状态。</p>
<p>4）用户程序中企图执行一条特权指令。</p>
<p>5）从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。</p>
<blockquote>
<p>注意:由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p>
</blockquote>
<p>若程序的运行由用户态转到核心态，则会用到访管指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p>
<h3 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h3><h4 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h4><p>操作系统的体系结构是一个开放的问题。如上文所述，操作系统在核心态为应用程序提供公共的服务，那么操作系统在核心态应该提供什么服务、怎样提供服务﹖有关这一问题的回答形成了两种主要的体系结构:大内核和微内核。</p>
<p>大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性.所以具有无可比拟的性能优势。</p>
<p>但随着体系结构和应用需求的不断发展，需要操作系统提供的服务越来越多，而且接口形式越来越复杂，操作系统的设计规模急剧增长，操作系统也面临着“软件危机”困境。为此，操作系统设计人员试图按照复杂性、时间常数、抽象级别等因素，将操作系统内核分成基本进程管理、虚存、IO与设备管理、IPC、文件系统等几个层次，继而定义层次之间的服务结构，提高操作系统内核设计上的模块化。但是，由于层次之间的交互关系错综复杂，定义清晰的层次间接口非常困难，复杂的交互关系也使得层次之间的界限极其模糊。</p>
<p>为解决操作系统的内核代码难以维护的问题，提出了微内核的体系结构。它将内核中最基本的功能（如进程管理等）保留在内核，而将那些不需要在核心态执行的功能移到用户态执行,从而降低了内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。</p>
<p>微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进，从而保证了操作系统的可靠性。</p>
<p>微内核结构的最大问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。因此有的操作系统将那些频繁使用的系统服务又移回内核，从而保证系统性能。但相当多的实验数据表明，体系结构不是引起性能下降的主要因素，体系结构带来的性能提升足以弥补切换开销带来的缺陷。为减少切换开销，也有人提出将系统服务作为运行库链接到用户程序的一种解决方案，这样的体系结构称为$\color{green}{\text{库操作系统}}$。</p>
<blockquote>
<p><code>体系结构带来的性能提升足以弥补切换开销带来的缺陷</code>在说啥?</p>
</blockquote>
<h3 id="本章疑难点"><a href="#本章疑难点" class="headerlink" title="本章疑难点"></a>本章疑难点</h3><h4 id="并行性与并发性的区别和联系"><a href="#并行性与并发性的区别和联系" class="headerlink" title="并行性与并发性的区别和联系"></a>并行性与并发性的区别和联系</h4><p>并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生，并发性是指两个或多个事件在同一时间间隔内发生。</p>
<p>在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序同时运行，但在单处理器系统中每个时刻却仅能有一道程序执行，因此微观上这些程序只能分时地交替执行。若在计算机系统中有多个处理器，则这些可以并发执行的程序便被分配到多个处理器上，实现并行执行，即利用每个处理器来处理一个可并发执行的程序。</p>
<blockquote>
<p>咬文嚼字一下，并行依靠多处理器支持，如果两个任务挂在到两个不同的处理器那么就能并行执行<br>考虑java的线程机制，一个继承了thread的线程，在调用start的时候$\color{green}{\text{启动}}$一个线程，那么就实现了并$\color{green}{\text{发}}$(发车，启动)<br>java <a target="_blank" rel="noopener" href="https://www.cnblogs.com/agilestyle/p/11421515.html">run和start的区别</a></p>
</blockquote>
<h4 id="特权指令与非特权指令"><a href="#特权指令与非特权指令" class="headerlink" title="特权指令与非特权指令"></a>特权指令与非特权指令</h4><p>所谓特权指令，是指有特殊权限的指令，由于这类指令的权限最大，使用不当将导致整个系统崩溃，如清内存、置时钟、分配系统资源、修改虚存的段表或页表、修改用户的访问权限等。若所有程序都能使用这些指令，则系统一天死机n次就不足为奇。为保证系统安全，这类指令只能用于操作系统或其他系统软件，不直接提供给用户使用。因此，特权指令必须在核心态执行。实际上，CPU在核心态下可以执行指令系统的全集。形象地说，特权指令是那些儿童不宜的东西，而非特权指令是老少皆宜的东西。</p>
<p>为了防止用户程序中使用特权指令，用户态下只能使用非特权指令，核心态下可以使用全部指令。在用户态下使用特权指令时，将产生中断以阻止用户使用特权指令。所以把用户程序放在用户态下运行，而操作系统中必须使用特权指令的那部分程序在核心态下运行，保证了计算机系<br>统的安全可靠。从用户态转换为核心态的唯一途径是中断或异常。</p>
<h4 id="访管指令与访管中断"><a href="#访管指令与访管中断" class="headerlink" title="访管指令与访管中断"></a>访管指令与访管中断</h4><p>访管指令是一条可以在用户态下执行的指令。在用户程序中，因要求操作系统提供服务而有意识地使用访管指令，从而产生一个中断事件（自愿中断)，将操作系统转换为核心态，称为访管中断。访管中断由访管指令产生，程序员使用访管指令向操作系统请求服务。</p>
<p>为什么要在程序中引入访管指令呢?这是因为用户程序只能在用户态下运行。若用户程序想要完成在用户态下无法完成的工作，该怎么办﹖解决这个问题要靠访管指令。访管指令本身不是特权指令，其基本功能是让程序拥有“自愿进管”的手段，从而引起访管中断。</p>
<p>处于用户态的用户程序使用访管指令时，系统根据访管指令的操作数执行访管中断处理程序，访管中断处理程序将按系统调用的操作数和参数转到相应的例行子程序。完成服务功能后，退出中断，返回到用户程序断点继续执行。</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>【考纲内容】</p>
<p>(一）进程与线程</p>
<p>进程的概念;进程的状态与转换</p>
<p>进程控制;进程组织</p>
<p>进程通信;线程概念与多线程模型</p>
<p>(二）处理机调度</p>
<p>调度的基本概念;调度时机、切换与过程</p>
<p>调度的基本准则;调度方式;典型调度算法</p>
<p>(三）进程同步</p>
<p>进程同步的基本概念</p>
<p>实现临界区互斥的基本方法</p>
<p>信号量;管程;经典同步问题</p>
<p>(四）死锁</p>
<p>死锁的概念;死锁处理策略</p>
<p>死锁预防;死锁避免;死锁的检测和解除</p>
<p>【知识框架】</p>
<ul>
<li>进程<ul>
<li>概念:与程序的区别</li>
<li>特征:动态性、并发性、独立性、异步性、结构性</li>
<li>状态:运行、就绪、阻塞、创建、结束</li>
<li>控制:创建、终止、阻塞和唤醒、切换</li>
<li>组织:进程控制块PCB、程序段、数据段</li>
<li>通信:共享存储、消息传递、管道通信</li>
</ul>
</li>
<li>线程<ul>
<li>概念、与进程的比较、属性</li>
<li>线程的实现方式</li>
</ul>
</li>
<li>处理机调度<ul>
<li>概念、三级调度:作业调度、中级调度、进程调度调度方式:剥夺式、非剥夺式</li>
<li>调度准则:CPU利用率、吞吐量、周转时间、等待时间、响应时间</li>
<li>算法:先来先服务、短作业(SJF）优先、优先级、高响应比优先、时间片轮转、多级反馈队列</li>
</ul>
</li>
<li>进程同步<ul>
<li>概念:临界资源、同步、互斥</li>
<li>实现方法:软件实现的几种算法、硬件实现</li>
<li>信号量:整型、记录型</li>
<li>经典问题:生产者-消费者问题、读者-写者问题、哲学家进餐问题、吸烟者问题</li>
</ul>
</li>
<li>死锁<ul>
<li>定义</li>
<li>原因:系统资源竞争、进程推进顺序非法</li>
<li>条件:互斥、不剥夺、请求和保持、循环等待</li>
<li>策略:预防死锁、避免死锁、死锁的检测与解除</li>
</ul>
</li>
</ul>
<p>【复习提示】</p>
<p>进程管理是操作系统的核心，也是每年必考的重点。其中，进程的概念、进程调度、信号量机制实现同步和互斥、进程死锁等更是重中之重，必须深入掌握。需要注意的是，除选择题外，本章还容易出综合题，其中信号量机制实现同步和互斥、进程调度算法和银行家算法都是可能出现的综合题考点，如利用信号量进行进程同步就在往年的统考中频繁出现。</p>
<p>进程:process</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>在学习本节时，请读者思考以下问题:</p>
<p>1）为什么要引入进程?</p>
<p>2）什么是进程?进程由什么组成?</p>
<p>3）进程是如何解决问题的?</p>
<p>希望读者带着上述问题去学习本节内容，并在学习的过程中多思考，从而更深入地理解本节内容。进程本身是一个比较抽象的概念，它不是实物，看不见、摸不着，初学者在理解进程概念时存在一定困难，在介绍完进程的相关知识后，我们会用比较直观的例子帮助大家理解。</p>
<h4 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h4><h5 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h5><p>在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性)。</p>
<p>为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块（Process Control Block，PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和PCB三部分构成了进程映像（进程实体)。所谓创建进程，实质上是创建进程映像中的PCB;而撤销进程,实质上是撤销进程的PCB。值得注意的是，进程映像是静态的，进程则是动态的。</p>
<p>注意:PCB是进程存在的唯一标志!</p>
<p>从不同的角度，进程可以有不同的定义，比较典型的定义有:</p>
<p>1）进程是程序的一次执行过程。</p>
<p>2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p>
<p>3）进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
<p>引入进程实体的概念后，我们可以把传统操作系统中的进程定义为:“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。”</p>
<p>读者要准确理解这里说的系统资源。它指处理机、存储器和其他设备服务于某个进程的“时间”，例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，即“时间片”分配的独立单位，这就决定了进程一定是一个动态的、过程性的概念。</p>
<h5 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h5><p>进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。</p>
<p>1）动态性。进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</p>
<p>2）并发性。指多个进程实体同时存于内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是使程序能与其他进程的程序并发执行，以提高资源利用率。</p>
<p>3）独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序，都不能作为一个独立的单位参与运行。</p>
<p>4）异步性。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。</p>
<p>5）结构性。每个进程都配置一个PCB对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制块三部分组成的。</p>
<p>通常不会直接考查进程有什么特性，所以读者对上面的5个特性不求记忆，只求理解。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/67644873/answer/829627104">并发和异步的区别</a></p>
</blockquote>
<h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><p>进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化(一个进程会经历若干不同状态)。通常进程有以下5种状态，前3种是进程的基本状态。</p>
<p>1）运行态。进程正在处理机上运行。在单处理机环境下，每个时刻最多只有一个进程处于运行态。</p>
<p>2）就绪态。进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p>
<p>3）阻塞态，又称等待态。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。</p>
<p>4）创建态。进程正在被创建，尚未转到就绪态。创建进程通常需要多个步骤:首先申请一个空白的 PCB，并向PCB中填写一些控制和管理进程的信息;然后由系统为该进程分配运行时所必需的资源;最后把该进程转入就绪态。</p>
<p>5）结束态。进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。进程需要结束运行时，系统首先必须将该进程置为结束态，然后进一步处理资源释放和回收等工作。</p>
<p>注意区别就绪态和等待态:就绪态是指进程仅缺少处理机，只要获得处理机资源就立即运行;而等待态是指进程需要其他资源（除了处理机）或等待某一事件。之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪态的;而其他资源（如外设）的使用和分配或某一事件的发生（如IO操作的完成）对应的时间相对来说很长，进程转换到等待态的次数也相对较少。这样来看，就绪态和等待态是进程生命周期中两个完全不同的状态，显然需要加以区分。</p>
<p>图2.1说明了5种进程状态的转换，而3种基本状态之间的转换如下:</p>
<ul>
<li>就绪态→运行态:处于就绪态的进程被调度后，获得处理机资源（分派处理机时间片)，于是进程由就绪态转换为运行态。 </li>
<li>运行态→就绪态:处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态，让更高优先级的进程执行。</li>
<li>运行态→阻塞态:进程请求某一资源（如外设）的使用和分配或等待某一事件的发生(如I/O操作的完成）时，它就从运行态转换为阻塞态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</li>
<li>阻塞态→就绪态:进程等待的事件到来时，如IO操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。</li>
</ul>
<details><summary>图2.1 5种进程状态的转换</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210808131002.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210808131002.png';" /></details>

<p>需要注意的是，一个进程从运行态变成阻塞态是主动的行为，而从阻塞态变成就绪态是被动的行为，需要其他相关进程的协助。</p>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</p>
<h5 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h5><p>允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给程。此外，在撤销父进程时，必须同时撤销其所有的子进程。</p>
<p>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语):<br>1）为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB (PCB是有限的)。若申请失败，则创建失败。</p>
<p>2）为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间（在PCB中体现)。注意，若资源不足（如内存空间)，则并不是创建失败，而是处于阻塞态，等待内存资源。</p>
<p>3）初始化 PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</p>
<p>4）若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</p>
<h5 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h5><p>引起进程终止的事件主要有:①正常结束，表示进程的任务已完成并准备退出运行。②异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O故障等。③外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</p>
<p>操作系统终止进程的过程如下（撤销原语):</p>
<p>1）根据被终止进程的标识符，检索PCB，从中读出该进程的状态。</p>
<p>2）若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</p>
<p>3）若该进程还有子孙进程，则应将其所有子孙进程终止。</p>
<p>4）将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。</p>
<p>5）将该PCB从所在队列（链表）中删除。</p>
<h5 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h5><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作可做等，由系统自动执行阻塞原语（Block)，使自己由运行态变为阻塞态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程(获得CPU才可能将其转为阻塞态。阻塞原语的执行过程如下:</p>
<p>1）找到将要被阻塞进程的标识号对应的PCB。</p>
<p>2）若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。3）把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。</p>
<p>当被阻塞进程所期待的事件出现时,如它所启动的IO操作已完成或其所期待的数据已到达，由有关进程（比如，释放该IO 设备的进程，或提供数据的进程）调用唤醒原语（Wakeup)，将等待该事件的进程唤醒。唤醒原语的执行过程如下:</p>
<p>1）在该事件的等待队列中找到相应进程的PCB。</p>
<p>2）将其从等待队列中移出，并置其状态为就绪态。</p>
<p>3）把该PCB插入就绪队列，等待调度程序调度。</p>
<p>需要注意的是，Block原语和 Wakeup原语是一对作用刚好相反的原语，必须成对使用。Block原语是由被阻塞进程自我调用实现的，而 Wakeup原语则是由一个与被唤醒进程合作或被其他相关的进程调用实现的。</p>
<h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><p>对于通常的进程而言，其创建、撤销及要求由系统设备完成的I/O操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>进程切换是指处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生了实质性的变化。进程切换的过程如下:</p>
<p>1)）保存处理机上下文，包括程序计数器和其他寄存器。</p>
<p>2）更新PCB信息。</p>
<p>3）把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</p>
<p>4）选择另一个进程执行，并更新其PCB。</p>
<p>5）更新内存管理的数据结构。</p>
<p>6）恢复处理机上下文。</p>
<blockquote>
<p>注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的CPU现场，而无须改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p>
</blockquote>
<h4 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h4><p>进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。它由以下三部分组成，其中最核心的是进程控制块（PCB)。</p>
<h5 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h5><p>进程创建时，操作系统为它新建一个PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。</p>
<p>进程执行时，系统通过其 PCB 了解进程的现行状态信息，以便对其进行控制和管理;进程结束时，系统收回其PCB，该进程随之消亡。操作系统通过PCB表来管理和控制进程。</p>
<p>当操作系统欲调度某进程运行时，要从该进程的PCB中查出其现行状态及优先级;在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据;进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB;当进程由于某种原因而暂停运行时，又需将其断点的处理机环境保存在PCB中。可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即系统唯有通过进程的PCB才能感知到该进程的存在。</p>
<p>表2.1是一个PCB 的实例。PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。各部分的主要说明如下:</p>
<details><summary>表2.1 PCB通常包含的内容</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210808131744.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210808131744.png';" /></details>

<p>1）进程描述信息。进程标识符:标志各个进程，每个进程都有一个唯一的标识号。用户标识符:进程归属的用户，用户标识符主要为共享和保护服务。</p>
<p>2）进程控制和管理信息。进程当前状态:描述进程的状态信息，作为处理机分配调度的依据。进程优先级:描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机。</p>
<p>3）资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息。</p>
<p>4）处理机相关信息，主要指处理机中各寄存器的值，当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。</p>
<p>在一个系统中，通常存在着许多进程的PCB，有的处于就绪态，有的处于阻塞态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。目前，常用的组织方式有链接方式和索引方式两种。链接方式将同一状态的PCB链接成一个队列,不同状态对应不同的队列，也可把处于阻塞态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。索引方式将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</p>
<h5 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h5><p>程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可被多个进程共享，即多个进程可以运行同一个程序。</p>
<h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h5><p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p>
<h4 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h4><p>进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类。</p>
<h5 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h5><p>在通信的进程之间存在一块可直接访问的共享空间,通过对这片共享空间进行写/读操作实现进程之间的信息交换，如图2.2所示。在对共享空间进行写/读操作时，需要使用同步互斥工具(如Р操作、V操作)，对共享空间的写/读进行控制。共享存储又分为两种:低级方式的共享是基于数据结构的共享;高级方式的共享则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。</p>
<p>注意，用户进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，要想让两个用户进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。</p>
<p>简单理解就是，甲和乙中间有一个大布袋，甲和乙交换物品是通过大布袋进行的，甲把物品放在大布袋里，乙拿走。但乙不能直接到甲的手中拿东西，甲也不能直接到乙的手中拿东西。</p>
<h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h5><p>在消息传递系统中，进程间的数据交换是以格式化的消息（Message）为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p>
<p>1）直接通信方式。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息，如图2.3所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210808132052.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210808132052.png';" /></details>

<p>2）间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。</p>
<p>这种中间实体一般称为信箱，这种通信方式又称信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。<br>简单理解就是，甲要告诉乙某些事情，就要写信，然后通过邮差送给乙。直接通信就是邮差把信直接送到乙的手上;间接通信就是乙家门口有一个邮箱，邮差把信放到邮箱里。</p>
<h5 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h5><p>管道通信是消息传递的一种特殊方式（见图2.4)。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名pipe文件。向管道(共享文件)提供输入的发送进程（即写进程)，以字符流形式将大量的数据送入(写）管道;而接收管道输出的接收进程（即读进程）则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力:互斥、同步和确定对方的存在。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210808132250.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210808132250.png';" /></details>

<p>下面以Linux中的管道为例进行说明。在Linux 中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下:</p>
<p>1）限制管道的大小。实际上，管道是一个固定大小的缓冲区。在 Linux中，该缓冲区的大小为4KB，这使得它的大小不像文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的 write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供 write()调用写。</p>
<p>2）读进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞,等待某些数据被写入,这解决了read()调用返回文件结束的问题。</p>
<blockquote>
<p>注意:从管道读数据是一次性操作，数据一旦被读取，它就从管道中被抛弃，释放空间以便写更多的数据。管道只能采用半双工通信，即某一时刻只能单向传输。要实现父子进程双方互动通信，需要定义两个管道。</p>
</blockquote>
<p>管道可以理解为共享存储的优化和发展,因为在共享存储中，若某进程要访问共享存储空间则必须没有其他进程在该共享存储空间中进行写操作，否则访问行为就会被阻塞。而管道通信中存储空间进化成了缓冲区，缓冲区只允许一边写入、另一边读出，因此只要缓冲区中有数据，进程就能从缓冲区中读出，而不必担心会因为其他进程在其中进行写操作而遭到阻塞，因为写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写数据。当然，这也决定了管道通信必然是半双工通信。</p>
<h4 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h4><h5 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h5><p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量;而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>
<p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p>
<p>引入线程后，进程的内涵发生了改变，进程只作为除CPU外的系统资源的分配单元，而线程则作为处理机的分配单元。由于一个进程内部有多个线程，若线程的切换发生在同一个进程内部，则只需要很少的时空开销。</p>
<h5 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h5><p>1）调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中,线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p>
<p>2）拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点儿必不可少的资源)，但线程可以访问其隶属进程的系统资源。要知道，若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。</p>
<p>3）并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。</p>
<p>4）系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU 环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。</p>
<p>5）地址空间和其他资源（如打开的文件)。进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</p>
<p>6）通信方面。进程间通信（IPC）需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p>
<h5 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h5><p>多线程操作系统把线程作为独立运行（或调度）的基本单位，此时的进程已不再是一个基本的可执行实体，但它仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。线程的主要属性如下:</p>
<p>1）线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。</p>
<p>2）不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。</p>
<p>3)同一进程中的各个线程共享该进程所拥有的资源。</p>
<p>4)线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU;在多CPU的计算机系统中，各线程可同时占用不同的CPU,若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。</p>
<p>5）一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</p>
<p>为什么线程的提出有利于提高系统并发性?可以这样来理解:由于有了线程，线程切换时，有可能会发生进程切换，也有可能不发生进程切换，平均而言每次切换所需的开销就变小了，因此能够让更多的线程参与并发，而不会影响到响应时间等问题。</p>
<h5 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h5><p>线程的实现可以分为两类:用户级线程(User-Level Thread，ULT)和内核级线程(Kernel-LevelThread，KLT)。内核级线程又称内核支持的线程。</p>
<p>在用户级线程中，有关线程管理（线程的创建、撤销和切换等）的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程开始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。图2.5(a)说明了用户级线程的实现方式。</p>
<p>在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。图2.5(b)说明了内核级线程的实现方式。</p>
<p>有些系统中使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些(小于等于用户级线程的数目）内核级线程上。图2.5(c)说明了用户级与内核级的组合实现方式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210808155557.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210808155557.png';" /></details>


<h5 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h5><p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p>
<p>1）多对一模型。将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（即透明)。</p>
<p>优点:线程管理是在用户空间进行的，因而效率比较高。</p>
<p>缺点:一个线程在使用内核服务时被阻塞，整个进程都会被阻塞;多个线程不能并行地运行在多处理机上。</p>
<p>2）一对一模型。将每个用户级线程映射到一个内核级线程。</p>
<p>优点:当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</p>
<p>缺点:每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</p>
<p>3）多对多模型。将n个用户级线程映射到m个内核级线程上，要求m≤n。</p>
<p>特点:多对多模型是多对一模型和一对一模型的折中，既克服了多对一模型并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。</p>
<p>此外，还拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。</p>
<h4 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h4><h5 id="为什么要引入进程"><a href="#为什么要引入进程" class="headerlink" title="为什么要引入进程?"></a>为什么要引入进程?</h5><p>在多道程序同时运行的背景下，进程之间需要共享系统资源，因此会导致各程序在执行过程中出现相互制约的关系，程序的执行会表现出间断性的特征。这些特征都是在程序的执行过程中发生的，是动态的过程，而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程序在内存中的执行情况，即我们无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其他执行程序的关系，因此，程序这个静态概念已不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。</p>
<h5 id="什么是进程-进程由什么组成"><a href="#什么是进程-进程由什么组成" class="headerlink" title="什么是进程?进程由什么组成?"></a>什么是进程?进程由什么组成?</h5><p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码本身，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</p>
<p>一个进程实体由程序段、相关数据段和 PCB三部分构成，其中 PCB是标志一个进程存在的唯一标识，程序段是进程运行的程序的代码，数据段则存储程序运行过程中相关的一些数据。</p>
<h5 id="进程是如何解决问题的"><a href="#进程是如何解决问题的" class="headerlink" title="进程是如何解决问题的?"></a>进程是如何解决问题的?</h5><p>进程把能够识别程序运行态的一些变量存放在 PCB中，通过这些变量系统能够更好地了解进程的状况，并在适当时进行进程的切换，以避免一些资源的浪费，甚至划分为更小的调度单位一线程来提高系统的并发度。</p>
<p>本节主要介绍什么是进程，并围绕这个问题进行一些阐述和讨论，为下一节讨论的内容做铺垫，但之前未学过相关课程的读者可能会比较费解，到现在为止对进程这个概念还未形成比较清晰的认识。接下来，我们再用一个比较熟悉的概念来类比进程，以便大家能彻底理解本节的内容到底在讲什么，到底解决了什么问题。</p>
<p>我们用“人的生命历程”来类比进程。首先，人的生命历程一定是一个动态的、过程性的概念，要研究人的生命历程，先要介绍经历这个历程的主体是什么。主体当然是人，相当于经历进程的主体是进程映像，人有自己的身份，相当于进程映像里有PCB;人生历程会经历好几种状态:出生的时候、弥留的时候、充满斗志的时候、发奋图强的时候及失落的时候，相当于进程有创建、撤销、就绪、运行、阻塞等状态，这几种状态会发生改变，人会充满斗志而转向发奋图强，发奋图强获得进步之后又会充满斗志预备下一次发奋图强，或者发奋图强后遇到阻碍会进入失落状态，然后在别人的开导之下又重新充满斗志。类比进程，会由就绪态转向运行态，运行态转向就绪态，或者运行态转向阻塞态，然后在别的进程帮助下返回就绪态。</p>
<p>若我们用“人生历程”这个过程的概念去类比进程，则对进程的理解就会更深一层。前面生活化的例子可以帮我们理解进程的实质，但它毕竟有不严谨的地方。一种较好的方式是，在类比进程和“人生历程”后，再看一遍前面较为严谨的书面阐述和讨论，这样对知识的掌握会更加准确而全面。</p>
<p>这里再给出一些学习计算机科学知识的建议。学习科学知识时，很多同学会陷入一个误区，即只注重对定理、公式的应用，而忽视对基础概念的理解。这是我们从小到大为了应付考试而培养出的一个毛病，因为熟练应用公式和定理对考试有立竿见影的效果。公式、定理的应用固然重要，但基础概念的理解能让我们透彻地理解一门学科，更利于我们产生兴趣，培养创造性思维。</p>
<h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><h4 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h4><h4 id="调度的时机、切换与过程"><a href="#调度的时机、切换与过程" class="headerlink" title="调度的时机、切换与过程"></a>调度的时机、切换与过程</h4><h4 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h4><h4 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h4><h4 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h4><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h4><h4 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h4><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><h4 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h4><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h3><h4 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h4><h4 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h4><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><h4 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h4><h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><h4 id="页面置换算法（决定应该换入哪页、换出哪页"><a href="#页面置换算法（决定应该换入哪页、换出哪页" class="headerlink" title="页面置换算法（决定应该换入哪页、换出哪页)"></a>页面置换算法（决定应该换入哪页、换出哪页)</h4><h4 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h4><h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><h4 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h4><h2 id="文件管理-1"><a href="#文件管理-1" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h3><h4 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h4><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><h3 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h3><h4 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h4><h4 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h4><h4 id="文件实现—文件分配方式"><a href="#文件实现—文件分配方式" class="headerlink" title="文件实现—文件分配方式"></a>文件实现—文件分配方式</h4><h4 id="文件实现——文件存储空间管理"><a href="#文件实现——文件存储空间管理" class="headerlink" title="文件实现——文件存储空间管理"></a>文件实现——文件存储空间管理</h4><h3 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h3><h4 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h4><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><h4 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h4><h2 id="输入-输出-I-O-管理"><a href="#输入-输出-I-O-管理" class="headerlink" title="输入/输出(I/O)管理"></a>输入/输出(I/O)管理</h2><h3 id="I-O管理概述"><a href="#I-O管理概述" class="headerlink" title="I/O管理概述"></a>I/O管理概述</h3><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h4><h4 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h4><h4 id="1-O子系统的层次结构"><a href="#1-O子系统的层次结构" class="headerlink" title="1/O子系统的层次结构"></a>1/O子系统的层次结构</h4><h3 id="1-O核心子系统"><a href="#1-O核心子系统" class="headerlink" title="1/O核心子系统"></a>1/O核心子系统</h3><h4 id="I-O子系统概述"><a href="#I-O子系统概述" class="headerlink" title="I/O子系统概述"></a>I/O子系统概述</h4><h4 id="IO调度概念"><a href="#IO调度概念" class="headerlink" title="IO调度概念"></a>IO调度概念</h4><h4 id="高速缓存与缓冲区"><a href="#高速缓存与缓冲区" class="headerlink" title="高速缓存与缓冲区"></a>高速缓存与缓冲区</h4><h4 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h4><h4 id="SPOOLing技术（假脱机技术）"><a href="#SPOOLing技术（假脱机技术）" class="headerlink" title="SPOOLing技术（假脱机技术）"></a>SPOOLing技术（假脱机技术）</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch21-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch21-%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch21-案例研究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:58:47" itemprop="dateCreated datePublished" datetime="2021-07-19T12:58:47+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-07 15:58:54" itemprop="dateModified" datetime="2021-09-07T15:58:54+08:00">2021-09-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h2><p>目前，软件体系架构技术依然是工业界和学术界探讨并不断发展的学科，属于起步阶段。工业界和学术界都用自己的方式表达对体系结构的概念与思维和探索。本章选择了一些案例或文章，以便于读者分析、研究体系结构。</p>
<h3 id="价值驱动的体系结构：连接产品策略与体系结构"><a href="#价值驱动的体系结构：连接产品策略与体系结构" class="headerlink" title="价值驱动的体系结构：连接产品策略与体系结构"></a>价值驱动的体系结构：连接产品策略与体系结构</h3><p>原文参见URL（<a target="_blank" rel="noopener" href="http://msdn2.microsoft.com/zh-cn/library/aa480060.aspx%EF%BC%89%E3%80%82">http://msdn2.microsoft.com/zh-cn/library/aa480060.aspx）。</a></p>
<p>系统的存在是为了为利益相关方创造价值。然而，这种理想往往无法完全实现。当前的开发方法给利益相关方、架构师和开发人员提供的信息是不完全和不充分的。这里介绍两个概念：价值模型和体系结构策略。它们似乎在许多开发过程中被遗忘，但创造定义完善的价值模型可以为提高折衷方案的质量提供指导，特别是那些部署到不同环境中的用户众多的系统。</p>
<h4 id="价值模型概述"><a href="#价值模型概述" class="headerlink" title="价值模型概述"></a>价值模型概述</h4><p>开发有目的的系统，其目的是为其利益相关者创造价值。在大多数情况下，这种价值被认为是有利的，因为这些利益相关者在其他系统中扮演着重要角色。同样，这些其他系统也是为了为其利益相关者创造价值。系统的这种递归特性是分析和了解价值流的一个关键。下一部分（发现价值模型）将对此进行更深入的讨论。</p>
<p>价值模型核心的特征可以简化为三种基本形式。</p>
<p>（1）价值期望值：表示对某一特定功能的需求，包括内容（功能）、满意度（质量）和不同级别质量的实用性。例如，汽车驾驶员对汽车从60英里每小时的速度进行急刹车的快慢和安全性有一种价值期望值。</p>
<p>（2）反作用力：系统部署实际环境中，实现某种价值期望值的难度，通常期望越高难度越大，即反作用力。例如，汽车从60英里每小时的速度进行紧急刹车的结果如何取决于路面类型、路面坡度和汽车重量等。</p>
<p>（3）变革催化剂：表示环境中导致价值期望值发生变化的某种事件，或者是导致不同结果的限制因素。</p>
<p>反作用力和变革催化剂称为限制因素，把这三个统称为价值驱动因素。如果系统旨在有效满足其利益相关者的价值模型要求，那么它就需要能够识别和分析价值模型。</p>
<p>传统方法，如用例方案和业务/营销需求，都是通过聚焦于与系统进行交互的参与者的类型开始的。这种方法有如下几个突出的局限性。</p>
<p>（1）对参与者的行为模型关注较多，而对其中目标关注较少。</p>
<p>（2）往往将参与者固定化分成几种角色，其中每个角色所在的个体在本质上都是相同的（例如商人、投资经理或系统管理员）。</p>
<p>（3）往往忽略限制因素之间的差别（例如，纽约的证券交易员和伦敦的证券交易员是否相同？市场开放交易与每天交易是否相同？）。</p>
<p>（4）结果简单。要求得到满足或未得到满足，用例成功完成或未成功完成。</p>
<p>这种方法有一个非常合乎逻辑的实际原因。它使用顺序推理和分类逻辑，因此易于教授和讲解，并能生成一组易于验证的结果。</p>
<p>在《竞争优势》一书中，Michael Porter以公司战略规划为背景讨论了价值链概念：</p>
<p>“虽然价值活动是竞争优势的构造块，但价值链并不是独立活动的一个集合，而是一系列相互依赖的活动的一个系统。联系是指一个价值活动的执行方式与另一个价值活动的性价比之间的关系”，“联系不仅存在于公司的价值链中（横向联系），还存在于公司价值链与供应商和渠道商价值链之间（纵向联系）。供应商供货渠道活动会影响公司活动的性价比（反之亦然）”。</p>
<p>效用曲线就是一个从一种度量标准到另外一种度量标准的映射。第一种度量标准表示一个可量化的结果变量，第二种度量标准是生成的值（满意度、效用）的级别。使用Kepner和Tregoe所描述的决策分析方法，各个可选方案会与各个期望值进行对照评估。效用曲线用于将每一个可选方案所得出的定量测量值映射到其对应值。然后，值级别用期望优先级加权，并进行叠加。叠加值越高，方案越可取。在某些情况下，该方法可能比较主观。</p>
<h4 id="体系结构挑战"><a href="#体系结构挑战" class="headerlink" title="体系结构挑战"></a>体系结构挑战</h4><p>体系结构挑战是因为一个或多个限制因素使得满足一个或多个期望值变得更困难。在任何环境中，识别体系结构挑战都涉及评估。</p>
<p>（1）哪些限制因素影响一个或多个期望值？</p>
<p>（2）如果知道了影响，它们满足期望值更容易（积极影响）还是更难（消极影响）？</p>
<p>（3）各种影响的影响程度如何？在这种情况下，简单的低、中和高三个等级通常就已经够用了。</p>
<p>必须在体系结构挑战自己的背景中对其加以考虑。虽然跨背景平均效用曲线是可能的，但对于限制因素对期望值的影响不能采用同样的处理方法。例如，假设Web服务器在两种情况下提供页面。一种情况是访问静态信息，如参考文献。它们要求相应时间为1～3s。另一种情况是访问动态信息，如正在进行的体育项目的个人得分表。其响应时间为3～6s。</p>
<p>两种情况都有CPU、内存、磁盘和网络局限性。不过，当请求量增加10或100倍时，这两种情况可能遇到大不相同的可伸缩性障碍。对于动态内容，更新和访问的同步成为重负载下的一个限制因素。对于静态内容，重负载可以通过频繁缓存读页来克服。</p>
<p>制定系统的体系结构策略始于：</p>
<p>（1）识别合适的价值背景并对其进行优先化。</p>
<p>（2）在每一背景中定义效用曲线和优先化期望值。</p>
<p>（3）识别和分析每一背景中的反作用力和变革催化剂。</p>
<p>（4）检测限制因素使满足期望值变难的领域。</p>
<p>最早的体系结构决策产生最大价值才有意义。有几个标准可用于优先化体系结构。建议对以下几点进行权衡。</p>
<p>●　重要性：受挑战影响的期望值的优先级有多高？如果这些期望值是特定于不多的几个背景，那么这些背景的相对优先级如何？</p>
<p>●　程度：限制因素对期望值产生了多大影响？</p>
<p>●　后果：大概多少种方案可供选择？这些方案的难度或有效性是否有很大差异？</p>
<p>●　隔离：对最现实的方案的隔离情况如何？影响越广，该因素的重要性越高。</p>
<p>一旦体系结构挑战的优先级确定之后，就要确定处理最高优先级挑战的方法。尽管体系结构样式和模式技术非常有用，不过在该领域，在问题和解决方案领域的身后经验仍具有无法估量的价值。应对的有效方法源于技能、洞察力、奋斗和辛勤的工作。这个论断千真万确，不管问题是关于外科学、行政管理还是软件体系结构。</p>
<p>当制定了应对高优先级的方法之后，体系结构策略就可以表达出来了。架构是会分析这组方法，并给出一组关于以下领域的指导原则。</p>
<p>●　组织：如何将系统组织入子系统和组件？它们的组成和职责是什么？系统如何部署在网络上？都有哪些类型的用户和外部系统？它们位于何处？是如何连接的？</p>
<p>●　操作：组件如何交互？在哪些情况下通信是同步的？在哪些情况下是异步的？组件的各种操作是如何协调的？何时可以配置组件或在其上运行诊断？如何检测、诊断和纠正错误条件？</p>
<p>●　可变性：系统的哪些重要功能可以随部署环境的变化而变化？对于每一功能，哪些方案得到支持？何时可以做出选择（例如，编译、链接、安装、启动或在运行时）？各个分歧点之间有什么相关性？</p>
<p>●　演变：为了支持变更同时保持其稳定性，系统是如何设计的？哪些特定类型的重大变革已在预料之中，应对这些变更有哪些可取的方法？</p>
<p>总之，体系结构策略就是帆船的舵和龙骨，可以确定方向和稳定性。它应该是简短的高标准方向的陈述，必须能够被所有利益相关者所理解，并应在系统的整个生存期内保持相对稳定。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>价值模型有助于了解和传达关于价值来源的重要信息。它解决一些重要问题，如价值如何流动，期望值和外部因素中存在的相似性和区别，系统要实现这些价值有哪些子集。架构师分解系统产生一般影响的力，特定于某些背景的力和预计随着时间的推移而变化的力，以实现这些期望值。价值模型和软件体系结构的联系是明确而又合乎逻辑的，可以用以下9点来表述。</p>
<p>（1）软件密集型产品和系统的存在是为了提供价值。</p>
<p>（2）价值是一个标量，它融合了对边际效用理解和诸多不同目标之间的相对重要性。目标折衷是一个极其重要的问题。</p>
<p>（3）价值存在于多个层面，其中某些层面包含了目标系统，并将其作为一个价值提供者。用于这些领域的价值模型包含了软件体系结构的主要驱动因素。</p>
<p>（4）该层次结构中高于上述层面的价值模型可以导致其下层价值模型发生变化。这是制定系统演化原则的一个重要依据。</p>
<p>（5）对于每一个价值群，价值模型都是同类的。暴露于不同环境条件的价值背景具有不同的期望值。</p>
<p>（6）对于满足不同价值背景需要，系统的开发赞助商有着不同的优先级。</p>
<p>（7）体系结构挑战是由环境因素自某一背景中对期望的影响引起的。</p>
<p>（8）体系结构方法试图通过首先克服最高优先级体系结构挑战来实现价值的最大化。</p>
<p>（9）体系结构策略是通过总结共同规则、政策和组织原则、操作、变化和演变从最高优先级体系结构方法综合得出的。</p>
<h3 id="使用RUP和UML开发联邦企业体系结构框架"><a href="#使用RUP和UML开发联邦企业体系结构框架" class="headerlink" title="使用RUP和UML开发联邦企业体系结构框架"></a>使用RUP和UML开发联邦企业体系结构框架</h3><p>原文参见URL（<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/rational/r-feaf/%EF%BC%89%E3%80%82">http://www.ibm.com/developerworks/cn/rational/r-feaf/）。</a></p>
<p>对于贯彻联邦企业体系结构框架（Federal Enterprise Architecture Framework，FEAF）方针的团体和机构而言，IBM Rational Unified Process（RUP）是足以支持其企业体系结构（Enterprise Architecture，EA）计划的一种选择。本文探讨如何使用RUP和UML构建和管理企业体系结构。具体而言，将分析FEAF的4层矩阵结构（level IV matrix），并讨论如何用RUP促进捕获各种FEAF模型。</p>
<p>1996年的克林格—科恩法案（Clinger-Cohen Act）授权联邦机构开发和维护一种企业IT体系结构，以便促进联邦机构间的信息共享和组织。1999年，联邦首席信息官负责根据这一授权建立FEAF，具体内容参阅<a target="_blank" rel="noopener" href="http://www.cio.gov/documents/fedarch1.pdf%E3%80%82FEAF%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E5%BB%BA%E7%AB%8B%E6%9C%BA%E6%9E%84%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E8%B7%AF%E7%BA%BF%E5%9B%BE%EF%BC%8C%E9%80%9A%E8%BF%87%E5%9C%A8%E6%9C%89%E6%95%88%E7%9A%84%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BC%98%E5%8C%96%E5%85%B6%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E8%BF%87%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%9D%A5%E5%B1%A5%E8%A1%8C%E6%9C%BA%E6%9E%84%E7%9A%84%E4%BD%BF%E5%91%BD%E3%80%82%E4%BC%81%E4%B8%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%8A%A9%E6%9C%BA%E6%9E%84%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%80%E7%9B%AE%E6%A0%87%EF%BC%8C%E7%AE%80%E5%8D%95%E5%9C%B0%E8%AE%B2%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%B3%BB%E7%BB%9F%E8%80%8C%E5%AE%8C%E6%95%B4%E5%9C%B0%E5%AE%9A%E4%B9%89%E4%BA%86%E7%BB%84%E7%BB%87%E7%9A%84%E5%BD%93%E5%89%8D%EF%BC%88%E5%9F%BA%E5%87%86%EF%BC%89%E7%8E%AF%E5%A2%83%E5%92%8C%E6%9C%9F%E6%9C%9B%EF%BC%88%E7%9B%AE%E6%A0%87%EF%BC%89%E7%8E%AF%E5%A2%83%E7%9A%84%E8%93%9D%E5%9B%BE%E3%80%82%E5%AF%B9%E4%BA%8E%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%8F%91%E4%BC%98%E5%8C%96%E5%85%B6%E8%81%8C%E8%83%BD%E4%BB%B7%E5%80%BC%E7%9A%84%E6%96%B0%E7%B3%BB%E7%BB%9F%E8%80%8C%E8%A8%80%EF%BC%8CEA%E6%98%AF%E5%BF%85%E4%B8%8D%E5%8F%AF%E5%B0%91%E7%9A%84%E3%80%82%E4%BC%81%E4%B8%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%8E%E9%80%BB%E8%BE%91%E6%88%96%E4%B8%9A%E5%8A%A1%EF%BC%88%E5%A6%82%E8%81%8C%E8%83%BD%E3%80%81%E4%B8%9A%E5%8A%A1%E8%81%8C%E8%B4%A3%E3%80%81%E4%BF%A1%E6%81%AF%E6%B5%81%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%EF%BC%88%E5%A6%82%E8%BD%AF%E4%BB%B6%E3%80%81%E7%A1%AC%E4%BB%B6%E3%80%81%E9%80%9A%E4%BF%A1%EF%BC%89%E4%B8%A4%E6%96%B9%E9%9D%A2%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8C%85%E6%8B%AC%E4%BB%8E%E5%9F%BA%E5%87%86%E7%8E%AF%E5%A2%83%E8%BD%AC%E6%8D%A2%E5%88%B0%E7%9B%AE%E6%A0%87%E7%8E%AF%E5%A2%83%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A7%84%E5%88%92%EF%BC%88Sequencing">http://www.cio.gov/documents/fedarch1.pdf。FEAF的目的是建立机构范围内的路线图，通过在有效的信息技术环境中优化其核心业务过程的性能来履行机构的使命。企业体系结构可以帮助机构实现这一目标，简单地讲，它们系统而完整地定义了组织的当前（基准）环境和期望（目标）环境的蓝图。对于信息系统的演进以及开发优化其职能价值的新系统而言，EA是必不可少的。企业体系结构是从逻辑或业务（如职能、业务职责、信息流和系统环境）以及技术（如软件、硬件、通信）两方面来定义的，并且包括从基准环境转换到目标环境的顺序规划（Sequencing</a> Plan）。</p>
<h4 id="联邦企业体系结构框架概述"><a href="#联邦企业体系结构框架概述" class="headerlink" title="联邦企业体系结构框架概述"></a>联邦企业体系结构框架概述</h4><p>联邦企业体系结构框架作为一种组织机制，用于管理体系结构描述的开发和维护。FEAF也提供了组织联邦资源、描述和管理联邦企业体系结构活动的结构。框架是通过把企业信息组织到不同的层次或参考结构中来实现这一目标的。最上面的第一层是企业的最高层视图，最下面的第4层包含最详细的企业信息。它把企业体系结构划分为4部分：业务、数据、应用程序和技术。FEAF还考虑了Zachman Framework的元素以及Spewak EA规划方法学的应用。</p>
<p>FEAF确定了开发和维护联邦企业体系结构所需的8种构件。这8种构件的分解进一步细化了FEAF的4个层次。前三层阐述了这8种构件逐步细化的过程，最终在第四层形成了分类和组织联邦企业描述性表示的结构。</p>
<p>第一层是联邦企业体系结构框架的最高层，它引入了开发和维护联邦企业体系结构所需要的8种构件。</p>
<p>●　体系结构推动者（Architecture Drivers）：代表推动联邦企业体系结构变更的外部激励因素。</p>
<p>●　战略方向（Strategic Direction）：确保变更和政府的总体方向一致。</p>
<p>●　当前体系结构（Current Architecture）：表示企业或机构的当前状态。完整描述可能非常重要，应该小心维护。</p>
<p>●　目标体系结构（Target Architecture）：表示战略方向环境中企业的目标状态。</p>
<p>●　转换过程（Transitional Processes）：这些过程按照体系结构标准施行从当前体系结构到目标体系结构的变更，如不同的决策或管理过程、迁移规划、预算、配置管理和变更控制。</p>
<p>●　体系结构片段（Architectural Segments）：关注整个企业中的某个子集或较小的企业。</p>
<p>●　体系结构模型（Architectural Models）：提供在企业中管理和实现变更的文档和基础。</p>
<p>●　标准（Standards）：机构所采用的标准（无论是强制采用还是自愿采用的），包括最佳实践和各种开放标准，所有标准都是为了提高互操作性。</p>
<p>第二层在更详细的层次上说明了联邦企业体系结构的业务和设计方面以及两者之间的关联。业务体系结构和设计体系结构之间的关系是推/拉关系——业务推动设计以满足自身的需要，设计（即新开发的数据、应用程序和技术）通过支持业务运作来拉动业务到新的服务交付水平。</p>
<p>第一层所描述的8种元素在第二层中进一步细化，在更小的粒度上描述业务和设计。例如，在第二层中观察当前体系结构（Current Architecture）构件时，将关注当前业务体系结构（Current Business Architecture），它确定了当前设计所支持的当前业务需求。以及当前设计体系结构（Current Design Architectures），它定义了用于支持当前业务需求的当前实现的数据、应用程序和技术。对于第二层中的其他构件也可从类似的视角来观察。</p>
<p>第三层展开了框架的设计部分，显示三种设计体系结构：数据、应用程序和技术。设计体系结构进一步细化了第二层中列出的设计细节。下面是第三层中进一步细化的6种构件中的三种。</p>
<p>●　当前设计体系结构（Current Design Architectures）：用于支持当前业务需求已实现的设计。当前设计体系结构由数据体系结构、应用程序体系结构和技术体系结构组成。</p>
<p>●　目标设计体系结构（Target Design Architectures）：用于支持未来业务需求的未来设计。目标设计体系结构由目标数据体系结构、目标应用程序体系结构和目标技术体系结构组成。</p>
<p>●　设计模型（Design Models）：用于定义企业的模型。有数据模型、应用程序模型和技术模型三种类型。</p>
<p>第三层还提供了体系结构片段（Architectural Segment）、转换过程（Transitional Processes）和标准（Standards）这三种构件的更多细节。</p>
<p>第四层（最详细的视图）确定了描述业务体系结构和三种设计体系结构（数据、应用程序和技术）的模型种类。它还定义了企业体系结构规划。在第四层上，三种设计体系结构如何支持业务体系结构开始逐渐明确起来。在这一层上，FEAF确定了两种机制：FEAF矩阵和企业体系结构规划（Enterprise Architecture Planning，EAP）方法学。FEAF矩阵用于组织体系结构信息，EAP帮助定义什么样的体系结构适合特定的企业。</p>
<h4 id="FEAF矩阵概述"><a href="#FEAF矩阵概述" class="headerlink" title="FEAF矩阵概述"></a>FEAF矩阵概述</h4><p>FEAF提供了开发、维护和实现高层操作环境并支持IT系统实现的结构。这种结构根据Zachman框架来分类和组织企业的重要模型。Zachman Framework是1987年由John Zachman提出的，是企业根据总体信息需求评估软件开发过程模型完整性的一种方法。该框架为完整的体系结构提供了多种视角，并对体系结构产品进行了分类。Zachman Framework实际上是一个包括36个单元的矩阵，涵盖了企业中的谁（who）、什么（what）、何处（where）、何时（when）、为何（why）以及如何（how）。该框架把企业分解成6个视角（perspective），从最高层的业务抽象开始直到实现。该框架可以包含全局规划，也可以包含技术细节、列表和图表。任何适当的步骤、标准、角色、方法或技术都可以放进去。</p>
<p>FEAF关注Zachman Framework中的三个方面：数据（什么）、过程或应用程序（如何）和位置或技术（何处）。如图所示，把FEAF图形化表示为一个3×5的矩阵，体系结构类型（数据、应用程序和技术）是矩阵的一个轴，视角（规划者（Planner）、所有者（Owner）、设计者（Designer）、构建者（Builder）和转包者（Subcontractor））在另一个轴上。相应的EA产品列在矩阵的单元中。</p>
<p>图21-1提供了FEAF矩阵的综览，在第四层上描述了FEAF。该矩阵结合了5个视角行（即视图）：规划者、所有者、设计者、构建者和转包者，以及Zachman Framework中的前三个体系结构工件或产品抽象列（即什么、如何和何处）。FEAF矩阵也把视角或行称为视图，表示不同的抽象层次。此外，视角和焦点（列）的相交称为FEAF的“模型”。IBM Rational Unified Process也结合最佳实践为不同的项目干系人和需求提供不同的抽象层次。在RUP中，体系结构通过不同的视图来定义，每个视图都依赖于特定项目干系人所需要的详细程度。关键体系结构决策在每个视图中表示。RUP中的模型记录了所有做出的决策，包括体系结构上的重要决策。例如，用例模型可能包括25个用例，其中只有10个对体系结构非常重要。用例视图就仅仅表示对体系结构至关重要的那些用例。对于本文而言，FEAF模型和RUP体系结构视图是等价的。此外，RUP提供了一组一致的模型，把不同视图中的体系结构元素关联在一起。</p>
<details><summary>图21-1　HL7消息发展体系（引自HL7 V3 Ballot7）</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171428.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171428.png';" /></details>

<p>规划者和所有者这两行关注的是业务体系结构的定义和编档。这两行一旦完成，就明确了企业的业务是什么，以及用什么样的信息来控制它（即业务模型）。这两行被认为是基础，要开发能够共同理解并跨联邦企业集成的体系结构描述必须要完成这两行。</p>
<p>第三、四、五行（即设计者、构建者和转包者）定义了支持业务体系结构的设计体系结构（即数据、应用程序和技术）。根据特定体系结构的用途和目标开发这几行的适当模型。</p>
<p>每个视角和设计体系结构的相交（Intersection）所定义的模型，是及时管理和实现企业变更的基础。对于那些支持系统管理和开发至关重要的企业模型，该框架提供了分类和组织这种企业模型的逻辑结构。</p>
<h4 id="使用RUP支持FEAF"><a href="#使用RUP支持FEAF" class="headerlink" title="使用RUP支持FEAF"></a>使用RUP支持FEAF</h4><p>Rational Unified Process主要强调的是软件系统。企业体系结构包括软件，但是还涉及到硬件、人员和信息。从FEAF强调数据、应用程序和技术设计体系结构可以看出这一点。本质上，企业组织可以看作一个包含其他系统的系统。虽然RUP确实讨论了如何表示软件应用程序的硬件、人员和信息，但是在解决系统问题时还有待于改进。为满足这种需要，RUP for System Engineering出现了，它是一个RUP插件，提供了新的和改进的活动和工件，增强了RUP的功能。它还提供了一组技术用于减少功能分解的必要性，从而使系统和子系统规格说明满足整个开发团队的需要。本文不再深入探讨如何在EA开发中使用RUP SE技术，但是讨论了构建EA时使用的RUP和RUP for System Engineering工作流的详细情况。</p>
<p>表21-1说明了构造FEAF矩阵中各种模型（或者RUP体系结构视图）时应该使用RUP和RUP for System Engineering的哪一部分。下面的矩阵简要定义了要捕获的体系结构视图，如何使用RUP和UML捕获这些视图，以及有关使用RUP的更多信息的RUP工作流和活动参考。体系结构视图不是互相独立的，而是一组一致且可实现的模型视图。</p>
<details><summary>表21-1　FEAF矩阵中的各种模型描述</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171457.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171457.png';" /></details>

<details><summary>表21-1　FEAF矩阵中的各种模型描述-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171506.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171506.png';" /></details>

<details><summary>表21-1　FEAF矩阵中的各种模型描述-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171527.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171527.png';" /></details>

<details><summary>表21-1　FEAF矩阵中的各种模型描述-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171539.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171539.png';" /></details>


<details><summary>表21-1　FEAF矩阵中的各种模型描述-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171602.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171602.png';" /></details>


<details><summary>表21-1　FEAF矩阵中的各种模型描述-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171613.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171613.png';" /></details>

<details><summary>表21-1　FEAF矩阵中的各种模型描述-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171626.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171626.png';" /></details>

<details><summary>表21-1　FEAF矩阵中的各种模型描述-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171647.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171647.png';" /></details>

<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>建立和管理企业体系结构所需要的业务模型和设计模型可以使用不同的技术和方法来完成。IBM Rational Unified Process提供了建立和维护企业体系结构的一组关联的最佳实践和方法。Rational Unified Process把不同的视角和一组实践活动，以及创建一组一致的模型所得到的工件结合在一起。模型的体系结构视图可以组织成FEAF矩阵。总之，使用RUP作为开发企业体系结构的过程框架，组织可以有效地捕获、审查、管理变更，并可在不同视角和组织之间沟通企业体系结构。</p>
<h3 id="Web服务在HL7上的应用——Web服务基础实现框架"><a href="#Web服务在HL7上的应用——Web服务基础实现框架" class="headerlink" title="Web服务在HL7上的应用——Web服务基础实现框架"></a>Web服务在HL7上的应用——Web服务基础实现框架</h3><p>原文参见URL（<a target="_blank" rel="noopener" href="http://msdn2.microsoft.com/zh-cn/library/ms954603.aspx%EF%BC%89%E3%80%82">http://msdn2.microsoft.com/zh-cn/library/ms954603.aspx）。</a></p>
<p>今天，由于商业与法律的需要，例如美国的健康保险便利和义务法案（Health Insurance Portability and Accountability Act，HIPAA）——卫生保健组织机构很清楚要与它们的商业结合起来。遗憾的是，大多数的健康信息系统一直是私人所有，而且在一个卫生保健行业它们只为一个部门服务。</p>
<p>Health Level Seven（HL7）是美国国家标准化协会（ANSI）认可的标准化开发组织中的一个，它正在全世界保健行业里运行着（Level Seven引用了开放系统互连模型OSI的最高层——应用层）。传统上，它从事临床建模与数据的管理工作，最近的一个版本——HL73.0版本扩展到了各种卫生保健行业，如制药业、医疗设备及成像设备。</p>
<p>HL7标准也指定了一些适当的信息基层组织，如Web Services，它就适合传送HL7信息，并且在应用软件之间对于如何确保这个信息的传送的交互性，提供了一个说明性的向导。将HL7应用软件应用在Web Services上，意味着首先设计一个正确的体系结构，其次是提供一个可执行的满足Web Services的环境。本文只是涉及HL7 Web Services Basic profile（HL7WSP）。</p>
<h4 id="HL7模型概念"><a href="#HL7模型概念" class="headerlink" title="HL7模型概念"></a>HL7模型概念</h4><p>通过对HL7标准规格说明书以及本文以外的一些工具的描述，这部分将介绍一些主要的HL7模型概念和人工制品，这些都与我们的讨论相关。</p>
<h5 id="参考信息模型"><a href="#参考信息模型" class="headerlink" title="参考信息模型"></a>参考信息模型</h5><p>对于一个给定的卫生保健领域，HL73.0版本说明书是基于参考信息模型的（RIM）。这是一种公共的模型框架，包括病例模型、信息模型、交互模型、消息模型和实现信息说明书。</p>
<p>HL7的参考信息模型是一个静态的卫生保健信息模型，它代表了至今为止负责HL7标准发展行为的卫生保健领域的各个方面。HL73.0版本标准开发过程定义了一些规则，这些规则用于从参考信息模型中获取一些具体领域信息模型，从而在HL7规格说明书中使这些模型更精确，最后产生XML表单定义（XSD）与一个具体的消息类型联合起来。</p>
<h5 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h5><p>HL7应用软件之间的交互行为是通过消息的交换来完成的。这样，在提供envelopes支持应用程序之间的消息交换期间，这个标准就提供了一个真实的功能水准。HL7消息的封装被称为wrappers，最初是通过RIM中类的定义和关联模型化的。然后，这些说明书被用来为消息wrappers创建XML表单。接下来，在HL7消息开发框架中所列的过程在图21-2中有所描述。</p>
<details><summary>图21-2　HL7消息发展体系——引自HL7 V3 Ballot7</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171802.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171802.png';" /></details>

<p>所有的HL7消息都被放在Transmission Wrapper，Wrapper的目的是支持应用软件之间消息的传输（和确认）。Wrapper的重要部分是一些元素，如消息标志符、消息的创建时间、交互标志符、发送者和接收者标志符、确认编码和消息序列号（可选）。认为HL7消息是在合理的HL7应用软件之间进行交换这一点是很重要的。也就是说，特殊的软件应用或是组成成分（像“顺序实体”）都代表着有组织的或是可管理的实体（像西部医院登记一样）。所以，在传输层，发送者和接收者概念不会被看成是一个规格说明书的一部分。</p>
<h5 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h5><p>一次HL7交互就是信息特殊转移过程中的一次联合，一个触发事件就开始了消息的转移，应用软件进行接收和发送消息。在HL7里，一个触发事件是引起信息在应用软件之间进行转移的一系列精确条件，它也代表着一个真实的事件。例如，实验室顺序的安排或是一个病人的登记。</p>
<h5 id="应用程序角色"><a href="#应用程序角色" class="headerlink" title="应用程序角色"></a>应用程序角色</h5><p>HL7里的每一个应用属于一个具体的应用程序角色。根据一个应用程序提供给其他应用程序的服务或是一个应用程序为了获得特定的服务而发送给其他应用程序的消息，这样一个角色就体现了应用程序的职责。</p>
<h5 id="Storyboard"><a href="#Storyboard" class="headerlink" title="Storyboard"></a>Storyboard</h5><p>像消息类型、交互作用和应用程序角色这些概念都集合在了一个HL7 Storyboard里，它是用来指定在HL7标准化行为范围内与任意卫生保健领域相关联的用例。</p>
<p>一个Storyboard是由一小段记叙了它本身的目的及交互作用图表的描述所组成的（在应用层）应用程序角色间相互作用的级数。就像图21-1中的那样，交互作用的图表指明了相应交互作用的职责（就是应用程序角色）、交换信息的类型以及期望的信息交换的顺序。</p>
<h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>基于刚刚介绍的HL7概念模型，现在我们能更精确地定义出HL7应用。这些都是在支持应用程序角色软件组成中的设计与实现，这些角色是作为交互行为中的一部分来实现发送者/接收者的职责，通过使用Web服务通信基层结构来满足HL7 Web服务的（如图21-3所示）。</p>
<details><summary>图21-3　参考体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904171904.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904171904.png';" /></details>


<p>在图21-3所示的结构里，能够抽象出HL7发送者/接收者内部的这两组功能：商业逻辑和Web服务适配器（需要强调的是，这里商业逻辑的范围是在HL7应用进行它们的发送者的角色和/或信息的接收者内部。也就是说，它支持一种具体的通信模式。应用层商业逻辑、消息的产生，或是为了响应需求而提供的具体服务这些都是在范围之外的）。</p>
<p>至于HL7消息的扩展，我们需要关注一下。商业逻辑的任务如下。</p>
<p>（1）发送端：创建一种具体HL7消息类型的XML描述，消息类型包含消息体、Transmission and Control Wrappers。将消息传送到Web服务适配器，适配器负责传送到接收应用端。</p>
<p>（2）接收端：“找回”由Web服务适配器接收的HL7消息，同时从接收到的XML消息那里打开Transmission Wrapper、Control Wrapper和消息体；验证HL7消息是否满足用来交互的商业规则和约束；核实发送应用端是否需要一个应用层的确认信息（HL7消息类型MCI）——如果是那样的话，发送那个消息。</p>
<p>Web服务适配器的功能主要是用来处理消息的分发和确认信息。因此，主要包括如下内容。</p>
<p>1）发送端</p>
<p>（1）读取接收到的HL7消息的Transmission Wrapper，以便决定如何到达Web服务基层结构上的发送容器（例如接收应用软件），从而配置SOAP。</p>
<p>（2）基于HL7消息类型、应用配置和规则（如安全性）来准备一个SOAP消息，包括作为一个SOAP消息体部分的HL7 XML消息，这个消息被发送到Web服务基层组织。</p>
<p>（3）把SOAP消息传递到Web服务代理，通过网络进行传输。</p>
<p>（4）无论发送端什么时候请求，都准备接收并存储来自接收端的相应信息或是应用层的确认消息。</p>
<p>2）接收端</p>
<p>（1）从Web服务站处接收SOAP消息。</p>
<p>（2）验证接收到的SOAP消息满足应用配置和一些约束条件（如安全性）。</p>
<p>（3）或者将这些接收到的消息在内存中以永久的形式保留。</p>
<p>（4）有选择性地从SOAP消息里打开HL7 XML消息，同时核对接收到的HL7消息是否与期望的HL7消息类型相符合。</p>
<p>（5）验证是否任意通信层的确认信息都需要被执行，在哪种情况下资金积累一个合适的消息发送到源消息发送端。</p>
<p>（6）传递HL7消息给接收应用端。</p>
<p>在适配器这层，这些情况都能够当作多个单行道方式或是请求/就答消息扩展模式来实现。在一个真正的实施过程中，适配器的结构也需要处理综合性应用和互操作能力。例如，如果一个应用业务逻辑不能直接与一个Web服务环境进行交互或是它被搭建在一个与以前实现时不同的平台上。</p>
<h4 id="开发HL7-Web服务适配器"><a href="#开发HL7-Web服务适配器" class="headerlink" title="开发HL7 Web服务适配器"></a>开发HL7 Web服务适配器</h4><p>原则上，尤其是当范围被限制在只是支持HL7 Web服务时，开发HL7 Web服务就与开发普通的Web服务相类似了。事实上，RIM的标准化模型的有效性，消息类型的说明书，通信模式及Web服务都在一定程序上影响着开发过程。为了高效地开发HL7 Web服务适配器，需要按如下步骤来做。</p>
<p>（1）消息和数据类型的设计。在一个像HL7这样面向消息的环境里开发一个Web服务，必须首先设计可交换的消息、已用的数据类型以及XSD表单里它们的说明书。这项活动完全受益于HL7（使XSD表单自动化产生）所构造的消息和数据类型工具。</p>
<p>（2）适配器模式的选择。创建Web服务适配器的下一步是选择哪一个适配器结构模式能够最好地适合HL7通信模式，这个通信模式是由步骤（1）中所获得的消息类型来指定的。这一步要定义，比如说，一个（仅仅一个）代理/Stub组成成分是必要的。</p>
<p>（3）HL7 Web服务契约开发。从一个普通的角度考虑，在创建一个面向消息的Web服务的下一步就能够定义它的契约了，用一种标准化的可用计算机处理的语言称作Web服务描述语言，或者在支持Web服务标准的编程语言里实现它的开发。</p>
<p>（4）产生Web服务Stub和代理的实现。一旦WSDL契约完成，它就可能创建使用一些工具的Web服务Stub和代理服务器，这些工具是由像WSDL.exe这样的开发平台所提供的。</p>
<p>（5）开发适配器业务逻辑。这一步是建立在前一步代码生成的基础上的，添加了必要的逻辑来支持适配器的功能，这些功能在Architecture一节里已描述过了。</p>
<p>一个普通的WSDL契约都详细说明了一个Web服务的名字和端口，通过这些端口，Web服务器可以和客户端应用程序进行通信。一个端口指定了网络中服务生效的位置。每个端口也指定了端口上的一群有用的操作（portTypes），和客户与服务器在那个端口上进行通信的协议间的一个绑定。端口类型代表了暴露在Web服务上的各种接口。操作是接口的方法，它们定义了客户端请求服务端的输入信息，以及定义了服务器用于应答客户的输出信息。消息的格式也是基于WSDL契约中所定义的类型的格式（XML表单）。</p>
<h4 id="案例研究-1"><a href="#案例研究-1" class="headerlink" title="案例研究"></a>案例研究</h4><p>一个参考实现案例已经构建了，包括两个系统之间的交互：医疗信息系统（Hospital Information System，HIS）和实验室信息系统（Laboratory Information System，LIS）。</p>
<p>（1）HIS是由两个Sub-systems排序和报告组成的，为此应用程序和Web服务已经被开发。</p>
<p>（2）类似地，LIS是由Web服务和业务逻辑组成的，Web服务从HIS排序系统接收命令，业务逻辑是将确认信息返回到HIS排序或报告系统。</p>
<p>（3）这里，设想中用到的通信模式交换与前面所描述的“发送消息负载——附有确认信息——立即”是相符的。</p>
<p>（4）为了保持业务逻辑的简单实施，当允许一些用户与样品应用程序进行交互时，两个Windows客户应用程序必须被开发。</p>
<p>HIS客户应用程序发送命令请求给HIS Web服务器，并且显示发送命令的接收确认信息。它的用户界面允许用户发送一个命令（发送按钮），因为全球唯一的标识符（GUID）是由客户应用程序自动产生的。当HIS系统接收确认、信息确认和通信结果时，HIS客户用户界面也会通过LIS系统（用三个验证框：OrderAck、ActiveConf和Result）显示出来。</p>
<p>下面是用来交换HL7信息的逐步流程，这些信息存在于提前设想的模板的上下文里。</p>
<p>（1）当用户接口从HIS客户机那里收到信号时，HIS业务逻辑就会产生一个序号标识符，同时通过创建一个XML文件以及在HL7负载里加入一个序号ID来构造POLB 1N2120信息。</p>
<p>（2）业务逻辑发送一个POLB IN2120信息（Send Order）给适配器，通过它的代理服务（POLB AR002942服务代理）来调用LIS服务。</p>
<p>（3）在Laboratory端，POLB_AR002942 Service Stub接收到SOAP信息，同时使它对于LIS Web服务适配器是可用的。</p>
<p>（4）LIS适配器从SOAP信息里得到HL7信息（Order），同时依据HL7信息类型表单来验证从SOAP那得到的被封装的HL7负载。</p>
<p>（5）LIS适配器从SOAP信息里得到HL7信息（Order），同时依据HL7信息类型表单来验证从SOAP那得到的被封装的HL7负载。</p>
<p>（6）如果需要，它会准备确认序列，这个确认序列是通过构造一个XML文件同时在文件里附上一个预先定义的应答确认来实现的。</p>
<p>（7）当一个新的信息到达时，LIS业务逻辑重新从顺序队列里得到HL7信息，并且将信息发送给LIS客户端。</p>
<p>事实上，对于给定的应用程序角色和交互活动，可以构造一个能自动产生代码的工具，用这个工具来创建需求信息队列和存储引入的信息。这是一种用来构建Web服务适配器代码的方法（代码案例见原文）。</p>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><p>在卫生保健领域，HL7是用来为协同工作而创建的基层结构。HL7使用参考信息模型（RIM）来获得具体领域的信息模型，同时把它们精炼到HL7说明书中，结合具体的消息类型自动产生XML表单定义（XSD）。因为能够被设计所公用，因此这些概念就对它们进行建模，而不是只集中在关于互操作能力的一些技术问题上。我们能够考虑说明书，同时知道如何构建一个应用程序软件，包括角色、协作模式和消息。</p>
<p>从理论到实践，HL7并没有告诉我们怎么构建和设计一些方案，而是当Web服务被用时，本文提到的参考体系结构就是一个相应的出发点。</p>
<h3 id="以服务为中心的企业整合——案例分析"><a href="#以服务为中心的企业整合——案例分析" class="headerlink" title="以服务为中心的企业整合——案例分析"></a>以服务为中心的企业整合——案例分析</h3><p>原文参见URL（<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/webservices/ws-soi2/%EF%BC%89%E3%80%82">http://www.ibm.com/developerworks/cn/webservices/ws-soi2/）。</a></p>
<p>以一个经过简化的实际案例为例，介绍了以服务为中心的企业集成的基本步骤，从业务分析到服务建模，到架构设计，到系统开发的整个生命周期。以服务为中心的企业集成涉及到的主要技术被穿插在各个步骤中进行了详细的讲解。</p>
<h4 id="案例背景"><a href="#案例背景" class="headerlink" title="案例背景"></a>案例背景</h4><p>某航空公司的IT系统已有好几十年的历史。该航空公司的主要业务系统构建于20世纪七八十年代，以IBM的主机系统为主——包括运行于TPF上的订票系统和运行在IMS上的航班调度系统等。在这些核心系统周围也不乏基于UNIX的非核心作业系统，和基于Net的简单应用。这些形形色色的应用，有的用汇编或COBOL编写，运行于主机和IMS之上；有的以PRO*C编写，运行在UNIX和Oracle上。这些应用虽然以基于主机终端的界面，但是基于Web和GUI的应用也为数众多。</p>
<p>近年来，该公司在企业集成方面也是煞费苦心——已经在几个主要的核心系统之间构建了用于信息集成的信息Hub（Information Hub），其他应用间也有不少点到点的集成。尽管这些企业集成技术在一定程度上增进了系统间的信息共享，但是面对如此异构的系统，技术人员依然觉得企业集成困难重重。</p>
<p>（1）因为大部分核心应用构建在主机之上，所以Information Hub是基于主机技术开发，很难被开放系统使用。</p>
<p>（2）Information Hub对Event支持不强，被集成的系统间的事件以点到点流转为主，被集成系统间耦合性强。</p>
<p>（3）牵扯到多个系统间的业务协作以硬编码为主，将业务活动自动化的成本高，周期长，被开发的业务活动模块重用性差。</p>
<p>为了解决这些企业集成中的问题，该公司决定以Ramp Control系统为例探索一条以服务为中心的企业集成道路。本文将以Ramp Control系统中的Ramp Coordination流程为例，说明如何用以服务为中心的企业集成技术一步步解决该公司IT技术人员面临的企业集成问题。</p>
<h4 id="业务环境分析"><a href="#业务环境分析" class="headerlink" title="业务环境分析"></a>业务环境分析</h4><p>在航空业中，Ramp Coordination是指飞机从降落到起飞过程中所需要进行的各种业务活动的协调过程，其流程图如图21-4所示。通常，每个航班都有一个人负责Ramp Coordination，这人通常称为Ramp Coordinator。由Ramp Coordinator协调的业务活动有：检查机位环境是否安全、卸货、装货和补充燃料等。</p>
<details><summary>图21-4　设想的体系结构的模板</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904172113.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904172113.png';" /></details>

<p>实际上，Ramp Coordination的流程因航班类型的不同，机型的不同有很大差异。图21-5所示的流程主要针对降落后不久就起飞的航班，这种类型的航班称为short turn around航班。除了short turn around航班外，还有其他两种类型的航班，如图所示。Arrival Only航班指降落后需要隔夜才起飞的，Departure Only航班是指每天一早第一班飞机。这些航班的Ramp Coordination的流程和Short Turn Around类型的流程大部分的业务活动是相似的。这三种类型的航班根据长途/短途，国内/国外等因素还可以进一步细分。每种细分的航班类型的Ramp Coordination的流程都是略有不同。</p>
<details><summary>图21-5　Ramp Coordination流程图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904172137.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904172137.png';" /></details>

<p>很明显，如此多的流程之间共享着一个业务活动的集合，如此多种类型的流程都是这些业务活动的不同组装方式。以服务为中心的企业集成中流程服务就是通过将这些流程间共享的业务活动抽象为可重用的服务，并通过流程服务提供的流程编排的能力将它们组成各种大同小异的流程类型，来降低流程集成成本，加快流程集成开发效率的。以服务为中心的企业集成，通过服务建模过程发现这些可重用的服务，并通过流程模型将这些服务组装在一起。</p>
<p>服务建模</p>
<p>IBM推荐使用组件业务建模（Component Business Model）和面向服务的建模和架构（Service-Oriented Model and Architecture）两种方法学建立业务的组件模型、服务模型和流程模型。</p>
<p>服务模型是服务建模的主要结果。Ramp Coordination相关的服务模型及和Ramp Coordination流程相关的有两个业务组件，内容如下。</p>
<p>●　Ramp Control：负责Ramp Control相关各种业务活动的组件。</p>
<p>●　Flight Management：负责航班相关信息的管理，包括航班日程，乘客信息等。</p>
<p>这两个业务组件分别输出如下服务。</p>
<p>（1）Retrieve Flight BO：由Flight Management输出，主要用于提取和航班相关的数据信息。</p>
<p>（2）Ramp Coordination：由Ramp Control输出，主要用于Ramp Coordination流程的编排。</p>
<p>（3）Check Spot：由Ramp Control输出，用于检测机位安全信息。</p>
<p>（4）Check Unloading：由Ramp Control输出，用于检查卸货状况。</p>
<p>（5）Check Loading：由Ramp Control输出，用于检查装货状况。</p>
<p>（6）Check Push Back：由Ramp Control输出，用于检查关门动作。</p>
<p>在服务建模确定系统相关的服务输出后，还需要确定服务在当前环境下的实现方式。在我们的案例中，Retrieve Flight BO被实现为信息服务，Ramp Coordination被实现为流程服务，通过BPEL4WS方式实现。其他4个服务都是Staff Service。需要注意的是，因为环境的不同和随着系统的演化，我们可能会改变服务的实现方式，如Check Push Back现在通过Staff Service即人工服务实现。将来随着自动化程度的增强，Check Push Back完全可能通过自动化的系统实现。到那时，只需重新实现这个服务，而无需改变整个流程。这是服务的可替换性的一个典型实例。</p>
<h4 id="IT环境分析"><a href="#IT环境分析" class="headerlink" title="IT环境分析"></a>IT环境分析</h4><p>在构建Ramp Control系统之前，该航空公司已经有大量的IT系统。作为架构设计的重要步骤的现有IT环境调研，描绘了和Ramp Control相关的IT系统的状况，包括周围应用和应用提供的接口，这些应用和Ramp Control交互的类型和数据格式。简化的IT环境视图，描绘了Ramp Coordination流程和周围系统交互状况。目前，Ramp Coordination流程需要4种类型的外围应用交互。</p>
<p>（1）从乘务人员管理系统提取航班乘务员的信息。</p>
<p>（2）从订票系统中提取乘客信息。</p>
<p>（3）从机务人员管理系统中提取机务人员信息。</p>
<p>（4）接收来自航班调度系统的航班到达事件。</p>
<p>通过将主机应用中的信息集中为粗粒度的业务对象，并通过信息服务输出，为该公司的核心系统提供了更加通用的连接能力，同时为IT系统的平滑演进提供了必需的条件。</p>
<h4 id="高层架构设计"><a href="#高层架构设计" class="headerlink" title="高层架构设计"></a>高层架构设计</h4><p>据需求和设计阶段的业务模型和现有IT环境调研结果，再结合传统的IT应用开发方法，Ramp Coordination系统的高层架构被设计了出来，如图21-6所示。</p>
<details><summary>图21-6　Ramp Coordination系统架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904172225.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904172225.png';" /></details>

<p>如下4点简要介绍了本案例中的主要架构元素以及它们之间的工作关系。</p>
<p>（1）信息服务。Federation Service：Ramp Coordination流程中需要从已有系统中提取4类信息，在Service建模阶段这4类信息被聚合为Flight BO（Business Object）。如上文所述，Retrieve Flight BO服务用于从已有系统中提取Flight BO。它实际上是一个Federation Service，将来自乘务人员管理系统、机务人员管理系统和订票系统中的信息聚合在一起。从这三个已有系统来的Crew Info、Cockpit Info和Passage Info是在已有系统中已经存在的业务逻辑或业务数据，它们属于可接入服务（on-ramp service），接入的协议分别为JDBC、IMS J2C Connector和socket。乘务人员管理系统基于Oracle数据库，Crew Info可以直接通过JDBC获得。机务人员管理系统基于S/390上的IMS，IBM已经提供了IMS的J2C Connector，所以Cockpit Info可以通过J2C connector获得。订票系统构建在IBM TPF之上，由于实时性的要求，socket是比较好的接入方法。Retrieve Flight BO被实现为一个EJB，外部访问通过RMI/IIOP绑定访问这个服务。在Retrieve Flight BO内部，Flight BO以SDO来表示。</p>
<p>（2）企业服务总线中的事件服务。Event Service：在检查机务环境安全（Check Spot）前，Ramp Coordiator需要被通知航班已经到达。这个业务事件由航班调度系统激发，Flight Arrival是典型事件发现服务（Event Detect Service），它通过MQ将事件传递给Message Broker，通过JMS的Pub/Sub，这个事件被分发给Check Spot。这里的Event Service是本例中ESB的重要组成部分。通过ESB上的通用事件服务，现有Information Hub的缺陷得到了克服。应用程序间的事件集成不再需要点到点的方式，而是通过ESB的事件服务完成订阅发布，应用程序间的耦合性得到了极大的缓解。</p>
<p>（3）流程服务。Process Service：Ramp Coordination被实现为一个Process Service，它被WBI SF的BPEL4WS容器执行，BPEL4WS容器提供Choreograph Service、Transaction Service和Staff Service支持。Ramp Coordination通过RMI/IIOP协议调用，在BPEL4WS容器中WSIF被用于通过各种协议调用服务，它成为ESB中Transport Service的一部分。Ramp Coordination中的人工动作被实现为Staff Service而集成到流程中。这里，Staff Service通过Portlet实现，运行在Websphere Portal Server上。Portal Service 实现部分Delivery Service支持PDA设备，Ramp Coordinator通过PDA设备访问系统。</p>
<p>（4）企业服务总线中的传输服务。RCMS是即将新建系统，用于提供包括Ramp Coordination在内的Ramp Control的功能。RCMS通过由WSIF实现的Transport Service以SOAP/HTTP调用Ramp Coordination服务。</p>
<h4 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h4><p>通过一个简单的案例，讲解了以服务为中心的企业集成的主要步骤和涉及的技术。这些集成的技术，无论是方法学，体系结构，还是编程模型都在不断的发展中。随着这些技术的不断完善，以服务为中心的企业集成方案的实施将更加简单高效。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><ul>
<li>考点分析</li>
<li>做好准备工作</li>
<li>论文写作格式</li>
<li>如何解答试题</li>
<li>如何写好摘要</li>
<li>如何写好正文</li>
<li>常见问题及解决办法</li>
<li>论文评分标准</li>
<li>论文写作实战</li>
</ul>
<h4 id="论文写作注意事项"><a href="#论文写作注意事项" class="headerlink" title="论文写作注意事项"></a>论文写作注意事项</h4><ul>
<li><p>会出现的问题</p>
<ul>
<li>方法</li>
<li>技巧</li>
<li>实践</li>
<li>缺乏理论和组织</li>
<li>偏题</li>
<li>缺乏实践</li>
</ul>
</li>
<li><p>不要猜题</p>
</li>
</ul>
<h4 id="考试大纲"><a href="#考试大纲" class="headerlink" title="考试大纲"></a>考试大纲</h4><ul>
<li>系统建模</li>
<li>软件架构设计</li>
<li>系统设计</li>
<li>分布式系统设计</li>
<li>系统可靠性分析与设计</li>
<li>系统安全性和保密性设计</li>
</ul>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907151923.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907151923.png';" /></details>

<h4 id="做好准备工作"><a href="#做好准备工作" class="headerlink" title="做好准备工作"></a>做好准备工作</h4><ul>
<li>检查考生是否具有参加系统架构设计工作的实践经验</li>
<li>检查考生分析问题与解决问题的能力，特别是考生的独立工作能力<ul>
<li>讲清楚为什么这样做</li>
</ul>
</li>
<li>检查考生的表达能力</li>
</ul>
<ul>
<li>加强学习</li>
<li>平时积累</li>
<li>共同提高</li>
<li>参加希赛教育的辅导</li>
<li>提高写作速度</li>
<li>以不变应万变</li>
</ul>
<p>最好只写一个项目</p>
<p>训练七八篇，最后一篇是电子版也没关系</p>
<h4 id="论文写作格式"><a href="#论文写作格式" class="headerlink" title="论文写作格式"></a>论文写作格式</h4><p>主题描述+三个问题(决定问题如何组织)</p>
<p>可以画图,画图占格子(但图不能可有可无)</p>
<p>摘要330个格子，正文2750个格子</p>
<h4 id="如何解答试题"><a href="#如何解答试题" class="headerlink" title="如何解答试题"></a>如何解答试题</h4><ul>
<li>选试题（ 3分钟)</li>
<li>论文构思(12分钟)</li>
<li>写摘要(15分钟)</li>
<li>正文撰写(80分钟)</li>
<li>检查修正( 10分钟)</li>
</ul>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907153445.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907153445.png';" /></details>


<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907153458.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907153458.png';" /></details>

<h4 id="如何写好摘要"><a href="#如何写好摘要" class="headerlink" title="如何写好摘要"></a>如何写好摘要</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907153628.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907153628.png';" /></details>

<p>摘要写得好</p>
<p>模板+个性化的风格</p>
<h4 id="如何写好正文"><a href="#如何写好正文" class="headerlink" title="如何写好正文"></a>如何写好正文</h4><ul>
<li>以“我”为中心</li>
<li>站在高级工程师的高度</li>
<li>忠实于论点</li>
<li>条理清晰，开门见山</li>
<li>标新立异，要有主见<ul>
<li>死马当活马医才用</li>
</ul>
</li>
<li>图文并茂，能收奇效</li>
<li>首尾一致</li>
</ul>
<p>我们，定位角色比较高，架构师是上层次的设计（不要讲程序级的东西）</p>
<p>构思主要的主题，再定小主题</p>
<h4 id="常见问题及解决办法"><a href="#常见问题及解决办法" class="headerlink" title="常见问题及解决办法"></a>常见问题及解决办法</h4><ul>
<li>走题</li>
<li>字数不够，字数偏多(320,2200-2500)</li>
<li>摘要归纳欠妥</li>
<li>文章深度不够，缺少特色，泛泛而谈</li>
<li>文章口语化太重，文字表达能力太差</li>
<li>文章缺乏主题项目，项目年代久远</li>
<li>整篇文章从大一二三到小123，给人以压抑感<ul>
<li>可以只用大一二三</li>
</ul>
</li>
<li>文章结构不够清晰，段落太长</li>
</ul>
<h4 id="论文评分标准"><a href="#论文评分标准" class="headerlink" title="论文评分标准"></a>论文评分标准</h4><ul>
<li>切合题意( 30% )</li>
<li>应用深度与水平( 20% )</li>
<li>实践性(20% )</li>
<li>表达能力( 15%)</li>
<li>综合能力与分析能力( 15%)</li>
</ul>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907155013.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907155013.png';" /></details>


<h5 id="雷区"><a href="#雷区" class="headerlink" title="雷区"></a>雷区</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907155313.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907155313.png';" /></details>

<p>报喜报忧(上天再给机会)</p>
<p>写完总结还不够字数</p>
<ul>
<li>加图</li>
<li>展望</li>
<li>一定要收尾</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch20-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch20-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch20-面向服务的架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:58:29" itemprop="dateCreated datePublished" datetime="2021-07-19T12:58:29+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 17:11:35" itemprop="dateModified" datetime="2021-09-04T17:11:35+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="面向服务的架构"><a href="#面向服务的架构" class="headerlink" title="面向服务的架构"></a>面向服务的架构</h2><p>Massimo Pezzini，Gartner Group说过，“当有一天，所有的应用都写成Web服务，集成也许可以变得更容易”</p>
<p>服务是一个由服务提供者提供的，用于满足使用者请求的业务单元。服务的提供者和使用者都是软件代理为了各自的利益而产生的角色。</p>
<p>在SOA中，服务的概念有了延伸，泛指系统对外提供的功能集。例如，在一个大型企业内部，可能存在进销存、人事档案和财务等多个系统，在实施SOA后，每个系统用于提供相应的服务，财务系统作为资金运作的重要环节，也向整个企业信息化系统提供财务处理的服务，那么财务系统的开放接口可以看成是一个服务。</p>
<h3 id="SOA的相关概念"><a href="#SOA的相关概念" class="headerlink" title="SOA的相关概念"></a>SOA的相关概念</h3><h4 id="SOA的定义"><a href="#SOA的定义" class="headerlink" title="SOA的定义"></a>SOA的定义</h4><p>面向服务的体系结构（Service-Oriented Architecture，SOA），从应用和原理的角度看，目前有两种业界公认的标准定义。</p>
<p>从应用的角度定义，可以认为SOA是一种应用框架，它着眼于日常的业务应用，并将它们划分为单独的业务功能和流程，即所谓的服务。SOA使用户可以构建、部署和整合这些服务，且无需依赖应用程序及其运行平台，从而提高业务流程的灵活性。这种业务灵活性可使企业加快发展速度，降低总体拥有成本，改善对及时、准确信息的访问。SOA有助于实现更多的资产重用、更轻松的管理和更快的开发与部署。</p>
<p>从软件的基本原理定义，可以认为SOA是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以一种统一和通用的方式进行交互。</p>
<p>作为软件架构师，后一种从软件原理方面的定义，对日常工作更具指导性。</p>
<h4 id="业务流程与BPEL"><a href="#业务流程与BPEL" class="headerlink" title="业务流程与BPEL"></a>业务流程与BPEL</h4><p>业务流程是指为了实现某种业务目的行为所进行的流程或一系列动作。在计算机领域，业务流程代表的是某一个问题在计算机系统内部得到解决的全部流程。</p>
<p>由于业务流程来源于现实世界，传统上是通过复杂的语言进行描述。在计算机业务系统建模中，需要用到一种特定的、简洁的语言来专门描述计算机系统的业务流程，这便促使了BPEL的诞生。</p>
<p>BPEL（Business Process Execution Language For Web Services）翻译成中文的意思是面向Web服务的业务流程执行语言，也有的文献简写成BPEL4WS，它是一种使用Web服务定义和执行业务流程的语言。使用BPEL，用户可以通过组合、编排和协调Web服务自上而下地实现面向服务的体系结构。BPEL提供了一种相对简单易懂的方法，可将多个Web服务组合到一个新的复合服务（称作业务流程）中。</p>
<p>BPEL目前用于整合现有的Web Services，将现有的Web Services按照要求的业务流程整理成为一个新的Web Services，在这个基础上，形成一个从外界看来和单个Service一样的Service。</p>
<h3 id="SOA的发展历史"><a href="#SOA的发展历史" class="headerlink" title="SOA的发展历史"></a>SOA的发展历史</h3><h4 id="SOA的发展历史-1"><a href="#SOA的发展历史-1" class="headerlink" title="SOA的发展历史"></a>SOA的发展历史</h4><p>SOA的概念最初由Gartner公司提出，由于当时的技术水平和市场环境尚不具备真正实施SOA的条件，因此当时SOA并未引起人们的广泛关注，SOA在当时沉寂了一段时间。伴随着因特网的浪潮，越来越多的企业将业务转移到因特网领域，带动了电子商务的蓬勃发展。为了能够将公司的业务打包成独立的、具有很强伸缩性的基于因特网的服务，人们提出了Web服务的概念，这可以说是SOA的起源。</p>
<p>Web服务开始流行以后，因特网迅速出现了大量的基于不同平台和语言开发的Web服务组件。为了能够有效地对这些为数众多的组件进行管理，人们迫切需要找到一种新的面向服务的分布式Web计算架构，该架构要能够使这些由不同组织开发的Web服务相互学习和交互，保障安全以及兼顾复用性和可管理性。由此，人们重新找回面向服务的架构，并赋予其时代的特征。需求推动技术进步，正是这种强烈的市场需求，使得SOA再次成为人们关注的焦点。回顾SOA发展历程，我们把其大致分为了三个阶段，下面将分别介绍每个阶段的重要标准和规范。</p>
<p>SOA的发展最初始于国外，其经历了如下三个阶段。</p>
<h5 id="萌芽阶段"><a href="#萌芽阶段" class="headerlink" title="萌芽阶段"></a>萌芽阶段</h5><p>这一阶段以XML技术为标志，时间大致从20世纪90年代末到21世纪初。虽然这段时期很少提到SOA，但XML的出现无疑为SOA的兴起奠定了稳固的基石。</p>
<p>XML系W3C所创建，源自流行的标准通用标记语言（Standard Generalised Markup Language，SGML），它在20世纪60年代后期就已存在。这种广泛使用的元语言，允许组织定义文档的元数据，实现企业内部和企业之间的电子数据交换。由于SGML比较复杂，实施成本很高，因此很长时间里只用于大公司之间，限制了它的推广和普及。</p>
<p>通过XML，开发人员摆脱了HTML语言的限制，可以将任何文档转换成XML格式，然后跨越因特网协议传输。借助XML转换语言（eXtensible Stylesheet Language Transformation，XSLT），接受方可以很容易地解析和抽取XML的数据。这使得企业既能够将数据以一种统一的格式描述和交换，同时又不必负担SGML那样高的成本。事实上，XML实施成本几乎和HTML一样。</p>
<p>XML是SOA的基石。XML规定了服务之间以及服务内部数据交换的格式和结构。XSD Schemas保障了消息数据的完整性和有效性，而XSLT使得不同的数据表达能通过Schema映射而互相通信。</p>
<h5 id="标准化阶段"><a href="#标准化阶段" class="headerlink" title="标准化阶段"></a>标准化阶段</h5><p>2000年以后，人们普遍认识到基于公共——专有因特网之上的电子商务具有极大的发展潜力，因此需要创建一套全新的基于因特网的开放通信框架，以满足企业对电子商务中各分立系统之间通信的要求。于是，人们提出了Web服务的概念，希望通过将企业对外服务封装为基于统一标准的Web服务，实现异构系统之间的简单交互。这一时期，出现了三个著名的Web服务标准和规范：简单对象访问协议（Simple Object Access Protocal，SOAP）、Web服务描述语言（Web Services Description Language，WSDL）及通用服务发现和集成协议（Universal Discovery Description and Integration，UDDI）。</p>
<p>这三个标准可谓Web服务三剑客，极大地推动了Web服务的普及和发展。短短几年之间，因特网上出现了大量的Web服务，越来越多的网站和公司将其对外服务或业务接口封装成Web服务，有力地推动了电子商务和因特网的发展。Web服务也是因特网Web 2.0时代的一项重要特征。</p>
<h5 id="成熟应用阶段"><a href="#成熟应用阶段" class="headerlink" title="成熟应用阶段"></a>成熟应用阶段</h5><p>从2005年开始，SOA推广和普及工作开始加速。不仅专家学者，几乎所有关心软件行业发展的人士都开始把目光投向SOA。一时间，SOA频频出现在各种技术媒体、新产品发布会和技术交流会上。</p>
<p>各大厂商也逐渐放弃成见，通过建立厂商间的协作组织共同努力制定中立的SOA标准。这一努力最重要的成果体现在三个重量级规范上：SCA/SDO/WS-Policy。SCA和SDO构成了SOA编程模型的基础，而WS-Policy建立了SOA组件之间安全交互的规范。这三个规范的发布，标志着SOA进入了实施阶段。</p>
<p>从整体架构角度看，人们已经把关注点从简单的Web服务拓展到面向服务体系架构的各个方面，包括安全、业务流程和事务处理等。</p>
<h4 id="国内SOA的发展现状与国外对比"><a href="#国内SOA的发展现状与国外对比" class="headerlink" title="国内SOA的发展现状与国外对比"></a>国内SOA的发展现状与国外对比</h4><p>在SOA概念深入普及的同时，国内也兴起了对SOA的研究和初步实践。2007年，IDC发布了《SOA中国路线图》。有观点认为，这是“国际研究机构首次基于中国IT背景，针对中国企业实施SOA路线所做的特定解读”，这也是目前关于SOA这一新兴技术在中国实施的第一份比较权威的报告。</p>
<p>报告中，重点指出了中国和美国在SOA领域的差距。</p>
<p>在美国，过去的半个多世纪，美国从主机时代、PC时代，到了现在的网络时代，积累了大量的应用系统。美国实现SOA架构的关键任务是：对已有系统中的功能进行提取和包装，形成标准的“服务”。</p>
<p>在中国，过去近30年的IT建设多为生产型系统，服务型系统普遍未开始建设，大量“服务”需要全新构造才是中国SOA的主要任务。</p>
<p>这份报告的可取之处如下。</p>
<p>（1）指出了中美IT系统所面临的根本性问题不同。现阶段，国内主要是以“构建支撑某一业务的应用系统”为主，其中伴随着一部分企业内部应用系统之间的整合。如果用前面的“三个阶段”来做以下匹配，可能更多还处于第一阶段，即使第二阶段的应用也处于起步状态。</p>
<p>（2）为国内大型集团化企业指明了如何解决系统集成和系统构建的融合性问题，基于SOA方式下的解决方案。</p>
<p>关于国内实施SOA的现状，报告用表20-1进行了阐述。</p>
<details><summary>表20-1　国内商用领域和政府领域的SOA应用</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170115.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170115.png';" /></details>

<h3 id="SOA的参考架构"><a href="#SOA的参考架构" class="headerlink" title="SOA的参考架构"></a>SOA的参考架构</h3><p>IBM的Websphere业务集成参考架构（如图20-1所示，以下称参考架构）是典型的以服务为中心的企业集成架构，接下来的讨论都将以此参考架构为背景进行。</p>
<p>以服务为中心的企业集成采用“关注点分离（Separation of Concern）”的方法规划企业集成中的各种架构元素，同时从服务视角规划每种架构元素提供的服务，以及服务如何被组合在一起完成某种类型的集成。这里架构元素提供的服务既包括狭义的服务（WSDL描述），也包括广义的服务（某种能力）。从服务为中心的视角来看，企业集成的架构按图20-1所示的方式划分为6大类。</p>
<p>（1）业务逻辑服务（Business Logic Service）：包括用于实现业务逻辑的服务和执行业务逻辑的能力，其中包括业务应用服务（Business Application Service）、业务伙伴服务（Partner Service）以及应用和信息资产（Application and Information asset）。</p>
<details><summary>图20-1　IBM WebSphere业务集成参考架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170138.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170138.png';" /></details>


<p>2）控制服务（Control Service）：包括实现人（people）、流程（process）和信息（infor-mation）集成的服务，以及执行这些集成逻辑的能力。</p>
<p>（3）连接服务（Connectivity Service）：通过提供企业服务总线提供分布在各种架构元素中服务间的连接性。</p>
<p>（4）业务创新和优化服务（Business Innovation and Optimization Service）：用于监控业务系统运行时服务的业务性能，并通过及时了解到的业务性能和变化，采取措施适应变化的市场。</p>
<p>（5）开发服务（Development Service）：贯彻整个软件开发生命周期的开发平台，从需求分析，到建模、设计、开发、测试和维护等全面的工具支持。</p>
<p>（6）IT服务管理（IT Service Management）：支持业务系统运行的各种基础设施管理能力或服务，如安全服务、目录服务、系统管理和资源虚拟化。</p>
<h4 id="连接服务——企业服务总线"><a href="#连接服务——企业服务总线" class="headerlink" title="连接服务——企业服务总线"></a>连接服务——企业服务总线</h4><p>企业服务总线（Enterprise Service Bus，ESB）是过去消息中间件的发展，采用了“总线”这样一种模式来管理和简化应用之间的集成拓扑结构，以广为接受的开放标准为基础来支持应用之间在消息、事件和服务的级别上动态地互联互通。</p>
<p>ESB的基本特征和能力包括：描述服务的元数据和服务注册管理；在服务请求者和提供者之间传递数据，以及对这些数据进行转换的能力，并支持由实践中总结出来的一些模式如同步模式、异步模式等；发现、路由、匹配和选择的能力，以支持服务之间的动态交互，解耦服务请求者和服务提供者。高级一些的能力，包括对安全的支持、服务质量保证、可管理性和负载平衡等。</p>
<p>ESB所提供的基于标准的连接服务，将应用中实现的功能或者数据资源转化为服务请求者能以标准的方式来访问的服务；当请求者来请求一个服务时，ESB中这种中介转化过程可能简单到什么也没有，也可能需要很复杂的中介服务支持，包括动态地查找、选择一个服务，消息的传递、路由和转换、协议的转换。这种中介过程，是ESB借助于服务注册管理以及问题域相关的知识（如业务方面的一些规则等）自动进行的，不需要服务请求者和提供者介入，从而实现了解耦服务请求者和提供者的技术基础，使得服务请求者不需要关心服务提供者的位置和具体实现技术，双方在保持接口不变的情况下，各自可以独立地演变。</p>
<p>所以，ESB采用总线结构模式简化了应用之间的集成拓扑，通过源自实践的模式，提供了基于标准的通用连接服务，使得服务请求者和服务提供者之间可以以松散耦合、动态的方式交互，从而在不同层次上使得SOI解决方案是一个松散耦合、灵活的架构。</p>
<p>一个典型的企业服务总线如图20-2所示。需要注意的是，ESB是一种架构模式，不能简单地等同于特定的技术或者产品，但实现ESB确实需要各种产品在运行时和工具方面的支持。IBM有很好的产品支持，运行时支持包括WebSphere ESB和WebSphere Message Broker；而工具方面IBM则有WebSphere Integration Developer，支持用户以图形界面的方式来完成相关的开发任务，如发布服务，使用各种模式、转换消息和定义路由等。</p>
<details><summary>图20-2　一个典型的企业服务总线</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170228.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170228.png';" /></details>

<h4 id="业务逻辑服务"><a href="#业务逻辑服务" class="headerlink" title="业务逻辑服务"></a>业务逻辑服务</h4><p>1）整合已有应用——应用和信息访问服务</p>
<p>已有应用和信息是实现业务逻辑和业务数据的重要资产。通过集成已有的应用和信息将可以在已有企业系统上实现更多增值服务，所以集成已有应用和信息是企业集成中重要的一环。</p>
<p>以服务为中心的企业集成通过应用和信息访问服务（Application and Information Access Service）来实现对已有应用和信息的集成。它通过各种适配器技术将已有系统中的业务逻辑和业务数据包装成企业服务总线支持的协议和数据格式。通过企业服务总线，这些被包装起来的业务逻辑和数据就可以方便地参与上层的业务流程，从而已有应用系统的能力可以得以继续发挥。这里的已有应用包括遗留应用、预包装的应用和各种企业数据存储。在参考架构中，主要有两类访问服务。</p>
<p>（1）可接入服务（On-Ramp Service）：通过各种消息通信模式（单向、请求/应答和轮询）将业务逻辑和业务数据包装成企业服务总线可以访问的功能。</p>
<p>（2）事件发现服务（Event Detect Service）：提供事件通知服务将已有应用和数据中的变化通过事件框架发布到企业服务总线上。</p>
<p>2）整合新开发的应用——业务应用服务</p>
<p>同已有应用和数据类似，新开发的应用也作为重要的业务逻辑成为企业集成的目标。以服务为中心的企业集成通过业务应用服务（Business Application Service）实现新应用集成。一方面，业务应用服务帮助程序员开发可重用、可维护和灵活的业务逻辑组件；另一方面，它也提供运行时的集成对业务逻辑组件的自治管理。在参考架构中，有三类业务应用服务。</p>
<p>（1）组件服务（Component Service）：为可重用的组件提供应用的运行时容器管理服务，如对象持久化、组件安全管理和事务管理等。</p>
<p>（2）核心服务（Core Service）：提供运行时的服务，包括内存管理、对象实例化和对象池、性能管理和负载均衡、可用性管理等。</p>
<p>（3）接口服务（Interface Service）：提供和其他企业系统集成的接口，如其他企业应用，数据库、消息系统和管理框架。</p>
<p>3）整合客户和业务伙伴（B2C/B2B ）——伙伴服务</p>
<p>以服务为中心的企业集成通过伙伴服务提供与企业外部的B2B的集成能力。因为业务伙伴系统的异构性，伙伴服务需要支持多种传输协议和数据格式。在参考架构中，提供如下服务。</p>
<p>（1）社区服务（Community Service）：用于管理和企业贸易的业务伙伴，支持以交易中心（Trade Hub）为主的集中式管理和以伙伴为中心的自我管理。</p>
<p>（2）文档服务（Document Service）：用于支持和业务伙伴交换的文档格式，以及交互的流程和状态管理，支持主流的RosettaNet、EDI和AS1/AS2等。</p>
<p>（3）协议服务（Protocol Service）：为文档的交互提供传输层的支持，包括认证和路由等。</p>
<h4 id="控制服务"><a href="#控制服务" class="headerlink" title="控制服务"></a>控制服务</h4><p>1）数据整合——信息服务</p>
<p>企业数据的分布性和异构性是应用系统方便访问企业数据和在企业数据之上提供增值服务的主要障碍。数据集成和聚合技术在这种背景下诞生，用于提供对分布式数据和异构数据的透明访问。</p>
<p>以服务为中心的企业集成通过信息服务提供集成数据的能力，目前主要包括如下集中信息服务。</p>
<p>（1）联邦服务（Federation Service）：提供将各种类型的数据聚合的能力，它既支持关系型数据，也支持像XML数据、文本数据和内容数据等非关系型数据。同时，所有的数据仍然按照自己本身的方式管理。</p>
<p>（2）复制服务（Replication Service）：提供远程数据的本地访问能力，它通过自动的实时复制和数据转换，在本地维护一个数据源的副本。本地数据和数据源在技术实现上可以是独立的。</p>
<p>（3）转换服务（Transformation Service）：用于数据源格式到目标格式的转换，可以是批量的或者是基于记录的。</p>
<p>（4）搜索服务（Search Service）：提供对企业数据的查询和检索服务，既支持数据库等结构化数据，也支持像PDF等非结构化数据。</p>
<p>2）流程整合——流程服务</p>
<p>企业部门内部的IT系统通过将业务活动自动化来提高业务活动的效率。但是这些部门的业务活动并不是独立的，而是和其他部门的活动彼此关联的。毋庸置疑，将彼此关联的业务活动组成自动化流程可以进一步提高业务活动的效率。业务流程集成正是在这一背景下诞生的。</p>
<p>以服务为中心的企业集成通过流程服务来完成业务流程集成。在业务流程集成中，粒度的业务逻辑被组合成业务流程，流程服务提供自动执行这些业务流程的能力。在参考架构中，流程服务包括如下内容。</p>
<p>（1）编排服务（Choreography Service）：通过预定义的流程逻辑控制流程中业务活动的执行，并帮助业务流程从错误中恢复。</p>
<p>（2）事务服务（Transaction Service）：用于保证流程执行中的事务特性（ACID）。对于短流程，通常采用传统的两阶段提交技术；对于长流程，一般采用补偿的方法。</p>
<p>（3）人工服务（Staff Service）：用于将人工的活动集成到流程中。一方面，它通过关联的交互服务使得人工可以参与到流程执行中；另一方面，它需要管理由于人工参与带来的管理任务，如任务分派，授权和监管等。</p>
<p>3）用户访问整合——交互服务</p>
<p>将适当的信息、在适当的时间、传递给适当的人一直是信息技术追求的目标。用户访问集成是实现这一目标的重要一环，它负责将信息系统中的信息传递给客户，不管它在哪里，以什么样的设备接入。</p>
<p>以服务为中心的企业集成，通过交互服务来实现用户访问集成。参考架构中的交互服务包括如下类型。</p>
<p>（1）交付服务（Delivery Service）：提供运行时的交互框架，它通过各种技术支持同样的交互逻辑可以在多种方式（图形界面、语音和普及计算消息）和设备（桌面、PDA和无线终端等）上运行，例如通过页面聚合和标签翻译使得同一个Portlet可以在桌面浏览器和PDA浏览器上展现。</p>
<p>（2）体验服务（Experience Service）：通过用户为中心的服务增强用户体验，其中的技术包括个性化、协作和单点登录等。</p>
<p>（3）资源服务（Resource Service）：提供运行时交互组件的管理，如安全配置、界面皮肤等。</p>
<h4 id="开发支持"><a href="#开发支持" class="headerlink" title="开发支持"></a>开发支持</h4><p>企业集成涉及面很广，不仅需要开发新的应用并使其成为可以被用于企业集成的功能组件，而且需要将被包装的已有的应用和数据用于集成；不仅有企业内部的集成，而且需要和企业外部的系统集成；不仅有交互集成和数据集成，还有功能和应用集成。考虑到这其中的每部分在技术上都会涉及到各种平台和中间件，企业集成的技术复杂性是普通应用开发不可比拟的。这种技术复杂性需要更强有力的开发工具支持。企业集成的开发工具需要有标准的工具框架，这些工具能够以即插即用方式支持来自多家厂商的开发工具。同时，企业集成的开发工具需要支持整个软件开发周期，以提高开发过程中各种角色的生产力。</p>
<p>在以服务为中心的企业集成中，除了需要支持整个软件开发周期和标准的工具框架以外，开发服务需要提供和服务开发相关的技术。</p>
<p>（1）用于支持以服务为中心的企业集成方法学和建模，如SODA和IBM的SOMA（Service Oriented Modeling and Architecture）。</p>
<p>（2）用于服务为中心的编程模型，如WSDL、BPEL4WS、SCA和SDO等。</p>
<p>开发环境和工具中为不同开发者的角色提供的功能被称为开发服务。根据开发过程中开发者角色和职责的不同，有如下4类服务。</p>
<p>（1）建模服务（Model Service）：用于构建可视化的业务流程模型。</p>
<p>（2）设计服务（Design Service）：根据业务模型，进一步分解为服务组件，设计服务用于设计和开发这些服务组件。</p>
<p>（3）实现服务（Implementation Service）：用于将设计和开发的服务组件部署到生产环境中。</p>
<p>（4）测试服务（Test Service）：支持服务组件的单元测试和系统的集成测试。</p>
<h4 id="业务创新和优化"><a href="#业务创新和优化" class="headerlink" title="业务创新和优化"></a>业务创新和优化</h4><p>一方面，以服务为中心的企业集成通过各种集成提高信息流转速度，从而提高生产效率。另一方面，以服务为中心的企业集成也为业务创新和优化提供了支持平台——业务创新和优化服务。</p>
<p>业务创新和优化服务以业务性能管理（Business Process Management，BPM）技术为核心提供业务事件发布、收集和关键业务指标监控能力。具体而言，业务创新和优化服务由以下服务组成。</p>
<p>（1）公共事件框架服务（Common Event Infrastructure Service）：通过一个公共事件框架提供IT和业务事件的激发、存储和分类等。</p>
<p>（2）采集服务（Collection Service）：通过基于策略的过滤和相关性分析检测感兴趣的服务。</p>
<p>（3）监控服务（Monitoring Service）：通过事件与监控上下文间的映射，计算和管理业务流程的关键性能指标（Key Performance Indicators，KPI）。</p>
<p>业务创新和优化服务与开发服务是紧密相联的。在建模阶段被确定的业务流程的关键性能指标，被转为特别的事件标志构建到业务流程中，建模过程中的业务流程也被转换为用于监控服务的监控上下文。在业务流程执行过程中，这些事件标志激发的事件被公共事件框架服务截获，经过采集服务的过滤被传递给监控服务用于计算关键性能指标。关键性能指标作为重要的数据被用于重构或优化业务流程，这种迭代的方法使得业务流程处于不断的优化中。</p>
<h4 id="管理支持"><a href="#管理支持" class="headerlink" title="管理支持"></a>管理支持</h4><p>为业务流程和服务提供安全、高效和健康的运行环境，也是以服务为中心的企业集成重要的部分，它由IT服务管理来完成。IT服务管理包括如下两部分。</p>
<p>（1）安全和目录服务（Security and Directory Service）：企业范围的用户、认证和授权管理，如单点登录（SSO）。</p>
<p>（2）系统管理和虚拟化服务（System Management and Virtualization Service）：用于管理服务器、存储、网络和其他IT资源。</p>
<p>IT服务管理中相当一部分服务是面向软硬件管理的；而另外一部分服务，特别是安全和目录服务，以及操作系统和中间件管理，会通过企业服务总线和其他服务集成在一起，用于实现业务流程和服务的非功能性需求，如性能、可用性和安全性等。</p>
<h3 id="SOA主要技术和标准"><a href="#SOA主要技术和标准" class="headerlink" title="SOA主要技术和标准"></a>SOA主要技术和标准</h3><p>Web服务作为实现SOA中服务的最主要手段。首先来了解跟Web Service相关的标准，它们大多以WS-作为名字的前缀，所以统称WS-*。Web服务最基本的协议包括UDDI、WSDL和SOAP，通过它们，可以提供直接而又简单的Web Service支持，如图20-3所示。</p>
<details><summary>图20-3　基本Web服务协议</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170421.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170421.png';" /></details>

<h4 id="UDDI协议"><a href="#UDDI协议" class="headerlink" title="UDDI协议"></a>UDDI协议</h4><p>UDDI（统一描述、发现和集成协议）计划是一个广泛的、开放的行业计划，它使得商业实体能够彼此发现；定义它们怎样在Internet上互相作用，并在一个全球的注册体系架构中共享信息。UDDI是这样一种基础的系统构筑模块，它使商业实体能够快速、方便地使用它们自身的企业应用软件来发现合适的商业对等实体，并与其实施电子化的商业贸易。</p>
<p>UDDI同时也是Web服务集成的一个体系框架，包含了服务描述与发现的标准规范。UDDI规范利用了W3C和Internet工程任务组织的很多标准作为其实现基础，如XML、HTTP和DNS等协议。另外，在跨平台的设计特性中，UDDI主要采用了已经被提议给W3C的SOAP（Simple Object Access Protocol，简单对象访问协议）规范的早期版本。</p>
<h4 id="WSDL规范"><a href="#WSDL规范" class="headerlink" title="WSDL规范"></a>WSDL规范</h4><p>WSDL（Web Services Description Language，Web服务描述语言），是一个用来描述Web服务和说明如何与Web服务通信的XML语言。它是Web服务的接口定义语言，由Ariba、Intel、IBM和MS等共同提出，通过WSDL，可描述Web服务的三个基本属性。</p>
<p>（1）服务做些什么——服务所提供的操作（方法）。</p>
<p>（2）如何访问服务——和服务交互的数据格式以及必要协议。</p>
<p>（3）服务位于何处——协议相关的地址，如URL。</p>
<p>WSDL文档以端口集合的形式来描述Web服务，WSDL服务描述包含对一组操作和消息的一个抽象定义，绑定到这些操作和消息的一个具体协议，和这个绑定的一个网络端点规范。WSDL文档被分为两种类型：服务接口（service interface）和服务实现（service implementations）。文档基本结构框架如图20-4所示。</p>
<details><summary>图20-4　文档基本结构框架</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170506.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170506.png';" /></details>

<p>服务接口文档中主要元素的作用分别如下。</p>
<p>●　types：定义了Web服务使用的所有数据类型集合，可被元素的各消息部件所引用。它使用某种类型系统（一般使用XML Schema中的类型系统）。</p>
<p>●　message：通信消息数据结构的抽象类型化定义。使用Types所定义的类型来定义整个消息的数据结构。</p>
<p>●　operation：对服务中所支持操作的抽象描述。一般单个operation描述了一个访问入口的请求/响应消息对。</p>
<p>●　portType：对于某个访问入口点类型所支持操作的抽象集合。这些操作可以由一个或多个服务访问点来支持。</p>
<p>●　binding：包含了如何将抽象接口的元素（portType）转变为具体表示的细节，具体表示也就是指特定的数据格式和协议的结合；特定端口类型的具体协议和数据格式规范的绑定。</p>
<p>●　port：定义为协议/数据格式绑定与具体Web访问地址组合的单个服务访问点。</p>
<p>●　service：这是一个粗糙命名的元素，代表端口的集合；相关服务访问点的集合。</p>
<h4 id="SOAP协议"><a href="#SOAP协议" class="headerlink" title="SOAP协议"></a>SOAP协议</h4><p>SOAP是在分散或分布式的环境中交换信息的简单的协议，是一个基于XML的协议。它包括4个部分：SOAP封装（Envelop），定义了一个描述消息中的内容是什么，是谁发送的，谁应当接收并处理它以及如何处理它们的框架；SOAP编码规则（Encoding Rules），用于表示应用程序需要使用的数据类型的实例；SOAP RPC表示（RPC Representation），表示远程过程调用和应答的协定；SOAP绑定（Binding），使用底层协议交换信息。</p>
<p>虽然这4个部分都作为SOAP的一部分，作为一个整体定义的，但它们在功能上是相交的、彼此独立的。特别地，信封和编码规则是被定义在不同的XML命名空间（Namespace）中，这样使得定义更加简单。</p>
<p>SOAP的两个主要设计目标是简单性和可扩展性，这就意味着有一些传统消息系统或分布式对象系统中的某些性质将不是SOAP规范的一部分。例如，分布式垃圾收集（Distributed Garbage Collection）、成批传送消息（Boxcarring or atching of messages）、对象引用（Objects-by-reference which requires distributed garbage collection）和对象激活（Activation which requires objects-by-reference）等。</p>
<p>但是，基本协议无法保证企业计算需要的安全性和可靠性，所以需要增加这方面的协议，例如WS-Security、WS-Reliability和WS-ReliableMessaging；对于复杂的业务场景，我们需要WS-BPEL和WS-CDL这样的语言来将多个服务编排成为业务流程；管理服务的协议如WS-Manageability、WSDM等。跟Web服务相关的标准，还在快速发展当中。目前在SOA产品和实践中，除了基本协议外，比较重要的还包括BPEL、WS-Security、WS-Policy和SCA/SDO。</p>
<h3 id="SOA的特性"><a href="#SOA的特性" class="headerlink" title="SOA的特性"></a>SOA的特性</h3><h4 id="文档标准化"><a href="#文档标准化" class="headerlink" title="文档标准化"></a>文档标准化</h4><p>SOA服务具有平台独立的自我描述XML文档。Web服务描述语言是用于描述服务的标准语言。</p>
<h4 id="通信协议标准"><a href="#通信协议标准" class="headerlink" title="通信协议标准"></a>通信协议标准</h4><p>SOA服务用消息进行通信，该消息通常使用XML Schema来定义（也叫做XSD，XML Schema Definition）。消费者和提供者、或消费者和服务之间的通信多见于不知道提供者的环境中。服务间的通信也可以看作企业内部处理的关键商业文档。</p>
<h4 id="应用程序统一登记与集成"><a href="#应用程序统一登记与集成" class="headerlink" title="应用程序统一登记与集成"></a>应用程序统一登记与集成</h4><p>在一个企业内部，SOA服务通过一个扮演目录列表（Directory Listing）角色的登记处（Registry）来进行维护。应用程序在登记处（Registry）寻找并调用某项服务。统一描述、定义和集成是服务登记的标准。</p>
<h4 id="服务品质"><a href="#服务品质" class="headerlink" title="服务品质"></a>服务品质</h4><p>每项SOA服务都有一个与之相关的服务品质（Quality of Service，QoS）。QoS的一些关键元素有安全需求（例如认证和授权）、可靠通信（译注：可靠消息是指确保消息“仅且仅仅”发送一次，从而过滤重复信息）以及谁能调用服务的策略。</p>
<p>在企业中，关键任务系统（Mission-critical System，译注：关键任务系统是指如果一个系统的可靠性对于一个组织是至关重要的，那么该系统就是该企业的关键任务系统。例如，电话系统对于一个电话促销企业来说就是关键任务系统，而文字处理系统就不那么关键了。）用来解决高级需求，例如安全性、可靠性和事务。当一个企业开始采用服务架构作为工具来进行开发和部署应用的时候，基本的Web服务规范，像WSDL、SOAP以及UDDI就不能满足这些高级需求。正如前面所提到的，这些需求也称作服务品质。与QoS相关的众多规范已经由一些标准化组织（Standards Bodies）提出，像W3C和OASIS（the Organization for the Advancement of Structured Information Standards）。下面的部分将会讨论一些QoS服务和相关标准。</p>
<h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><p>在典型的SOA环境中，服务消费者和服务提供者之间会有几种不同的文档在进行交换。具有诸如“仅且仅仅传送一次（Once-and-only-once Delivery）”、“最多传送一次（At-most-once Delivery）”、“重复消息过滤（Duplicate Message Elimination）”和“保证消息传送（Guaranteed Message Delivery）”等特性消息的发送和确认，在关键任务系统（Mission-critical Systems）中变得十分重要。WS-Reliability和WS-ReliableMessaging是两个用来解决此类问题的标准。这些标准现在都由OASIS负责。</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>Web服务安全规范用来保证消息的安全性。该规范主要包括认证交换、消息完整性和消息保密。该规范吸引人的地方在于它借助现有的安全标准，例如，SAML（as Security Assertion Markup Language）实现Web服务消息的安全。OASIS正致力于Web服务安全规范的制定。</p>
<h5 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h5><p>服务提供者有时候会要求服务消费者与某种策略通信。例如，服务提供商可能会要求消费者提供Kerberos安全标示才能取得某项服务。这些要求被定义为策略断言（Policy Assertions），一项策略可能会包含多个断言。WS-Policy用来标准化服务消费者和服务提供者之间的策略通信。</p>
<h5 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h5><p>在SOA中，进程是使用一组离散的服务创建的。BPEL4WS或者WSBPEL（Web Service Business Process Execution Language）是用来控制这些服务的语言。当企业着手于服务架构时，服务可以用来整合数据仓库（silos of data），应用程序，以及组件。整合应用意味着像异步通信，并行处理，数据转换，以及校正等进程请求必须被标准化。</p>
<h5 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h5><p>随着企业服务的增长，所使用的服务和业务进程的数量也随之增加，一个用来让系统管理员管理所有，运行在多种环境下的服务的管理系统就显得尤为重要。WSDM（Web Services for Distributed Management）的制定，使任何根据WSDM实现的服务都可以由一个WSDM适应（WSDM-compliant）的管理方案来管理。</p>
<p>其他的QoS特性，例如合作方之间的沟通和通信，多个服务之间的事务处理，都在WS-Coordination和WS-Transaction标准中描述，这些都是OASIS的工作。</p>
<h3 id="SOA的作用"><a href="#SOA的作用" class="headerlink" title="SOA的作用"></a>SOA的作用</h3><p>在一个企业内部，可能存在不同的应用系统，而这些应用系统由于开发的时间不同，采用的开发工具不同，一个业务请求很难有效地调用所有的应用系统。用简单的语言来表述，这些已有应用系统是孤立的，也就是我们常说的“信息孤岛”。</p>
<p>不同种类的操作系统，应用软件，系统软件和应用基础结构（Application Infrastructure）相互交织，这是“信息孤岛”的表现症状。一些现存的应用程序被用来处理当前的业务流程（Business Processes），因此从头建立一个新的基础环境是不可能的。企业应该能对业务的变化做出快速的反应，利用对现有的应用程序和应用基础结构的投资来解决新的业务需求，为客户、商业伙伴以及供应商提供新的互动渠道，并呈现一个可以支持有机业务（Organic Business）的构架。SOA凭借其松耦合的特性，使得企业可以按照模块化的方式来添加新服务或更新现有服务，以解决新的业务需要，提供选择从而可以通过不同的渠道提供服务，并可以把企业现有的或已有的应用作为服务，从而保护了现有的IT基础建设投资。</p>
<p>在SOA得以普及之前，解决企业内部信息系统“信息孤岛”的问题通常是采用EAI（企业应用整合）的方式。为了保证所有的应用能够互通互用，每一个应用都需要一个EAI Server来对应。打个简单的比方，EAI Server就好像一个“翻译”一样，让每两个应用之间可以对话，可以互相调用。但是，这样会带来EAI Server呈几何倍数的增长，当一个企业只有两个应用的时候需要一个“翻译”，当企业有三个应用需要互通的时候需要三个“翻译”，当有四个应用的时候就需要六个“翻译”，五个应用互通就需要十个“翻译”……这显然不是解决“信息孤岛”的妥善办法。</p>
<p>SOA对于实现企业资源共享，打破“信息孤岛”的步骤如下。</p>
<p>（1）把应用和资源转换成服务。</p>
<p>（2）把这些服务变成标准的服务，形成资源的共享。</p>
<p>从这个意义上讲，SOA不仅仅是一个技术，而是一个软件架构。企业的决策者只需要根据企业的策略来制定流程，把应用作为服务“拿来就用”，而无需考虑底层的集成。这样就可以实现IT和企业业务之间同步。</p>
<p>一个服装零售组织拥有500家国际连锁店，它们常常需要更改设计来赶上时尚的潮流。这可能意味着不仅需要更改样式和颜色，甚至还可能需要更换布料、制造商和可交付的产品。如果零售商和制造商之间的系统不兼容，那么从一个供应商到另一个供应商的更换可能就是一个非常复杂的软件流程。通过利用WSDL接口在操作方面的灵活性，每个公司都可以将它们的现有系统保持现状，而仅仅匹配WSDL接口并制订新的服务级协定，这样就不必完全重构它们的软件系统了。这是业务的水平改变，也就是说，它们改变的是合作伙伴，而所有的业务操作基本上都保持不变。这里，业务接口可以作少许改变。而内部操作却不需要改变。之所以这样做，仅仅是为了能够与外部合作伙伴一起工作。</p>
<h3 id="SOA设计原则"><a href="#SOA设计原则" class="headerlink" title="SOA设计原则"></a>SOA设计原则</h3><p>SOA架构中，继承了来自对象和组件设计的各种原则，如封装、自我包含等。那些保证服务的灵活性、松散耦合和重用能力的设计原则，对SOA架构来说同样是非常重要的。</p>
<p>结构上，服务总线是SOA的架构模式之一。</p>
<p>关于服务，一些常见和讨论的设计原则如下。</p>
<p>（1）无状态。以避免服务请求者依赖于服务提供者的状态。</p>
<p>（2）单一实例。避免功能冗余。</p>
<p>（3）明确定义的接口。服务的接口由WSDL定义，用于指明服务的公共接口与其内部专用实现之间的界线。WS-Policy用于描述服务规约，XML模式（Schema）用于定义所交换的消息格式（即服务的公共数据）。使用者依赖服务规约调用服务，所以服务定义必须长时间稳定，一旦公布，不能随意更改；服务的定义应尽可能明确，减少使用者的不适当使用；不要让使用者看到服务内部的私有数据。</p>
<p>（4）自包含和模块化。服务封装了那些在业务上稳定、重复出现的活动和组件，实现服务的功能实体是完全独立自主的，独立进行部署、版本控制、自我管理和恢复。</p>
<p>（5）粗粒度。服务数量不应该太大，依靠消息交互而不是远程过程调用（RPC），通常消息量比较大，但是服务之间的交互频度较低。</p>
<p>（6）服务之间的松耦合性。服务使用者看到的是服务的接口，其位置、实现技术和当前状态等对使用者是不可见的，服务私有数据对服务使用者是不可见的。</p>
<p>（7）重用能力。服务应该是可以重用的。</p>
<p>（8）互操作性、兼容和策略声明。为了确保服务规约的全面和明确，策略成为一个越来越重要的方面。这可以是技术相关的内容，例如一个服务对安全性方面的要求；也可以是跟业务有关的语义方面的内容，例如需要满足的费用或者服务级别方面的要求，这些策略对于服务在交互时是非常重要的。WS-Policy用于定义可配置的互操作语义，来描述特定服务的期望、控制其行为。在设计时，应该利用策略声明确保服务期望和语义兼容性方面的完整和明确。</p>
<h3 id="SOA的设计模式"><a href="#SOA的设计模式" class="headerlink" title="SOA的设计模式"></a>SOA的设计模式</h3><h4 id="服务注册表模式"><a href="#服务注册表模式" class="headerlink" title="服务注册表模式"></a>服务注册表模式</h4><p>服务注册表（Service Registry）主要在SOA设计时段使用，虽然它们常常也具有运行时段的功能。注册表支持驱动SOA治理的服务合同、策略和元数据的开发、发布和管理。因此，它们提供一个主控制点，或者称为策略执行点（Policy Enforcement Point，PEP）。在这个点上，服务可以在SOA中注册和被发现。</p>
<p>注册表可以包括有关服务和相关软件组件的配置、遵从性和约束配置文件。任何帮助注册、发现和检索服务合同、元数据和策略的信息库、数据库、目录或其他节点都可以被认为是一个注册表。</p>
<p>主要的服务注册厂商分为两个阵营。一个阵营是提供服务、策略和元数据注册表及信息库的纯SOA厂商，其中包括Flashline、Infravio、LogicLibrary、SOA Software和Systinet（Mercury Interactive下属分公司）；另一个阵营是SOA平台厂商，这些厂商将注册表作为集成产品套件的一个组件，他们的集成产品套件常常包括应用服务器、门户、数据库管理系统、BI工具、集成中间件和其他功能组件。提供注册表的SOA平台厂商包括BEA、IBM、Microsoft、Novell、Oracle、SAP、Sun和WebMethods。UDDI（通用描述、发现与集成）标准定义了SOA的一种主要注册环境，尽管这绝非唯一的环境。</p>
<p>大多数纯SOA厂商和SOA平台厂商还提供SOA开发、集成和管理工具。没有自已注册表的SOA厂商，常常通过UDDI v3和其他开放标准与一个或多个第三方注册表产品进行集成。大多数商用服务注册产品支持下面的SOA治理功能。</p>
<p>（1）服务注册：应用开发者，也叫服务提供者，向注册表公布他们的功能。他们公布服务合同，包括服务身份、位置、方法、绑定、配置、方案和策略等描述性属性。实现SOA治理最有效的方法之一，是限制哪类新服务可以向主注册表发布、由谁发布以及谁批准和根据什么条件批准。此外，许多注册表包含开发向注册表发布服务可能需要的说明性服务模板。</p>
<p>（2）服务位置：也就是服务应用开发者，帮助他们查询注册服务，寻找符合自身要求的服务。注册表让服务的消费者检索服务合同。对谁可以访问注册表，以及什么服务属性通过注册表暴露的控制，是另一些有效的SOA治理手段，注册表产品一般都支持此类功能。</p>
<p>（3）服务绑定：服务的消费者利用检索到的服务合同来开发代码，开发的代码将与注册的服务绑定、调用注册的服务以及与它们实现互动。开发者常常利用集成的开发环境自动将新开发的服务与不同的新协议、方案和程序间通信所需的其他接口绑在一起。工具驱动对服务绑定的控制，有效地管理服务在ESB上的互动。</p>
<p>设计时段，SOA治理中新出现的最佳实践之一是注册表中的配置文件（Profile）管理。配置文件用于说明服务目前的生命周期阶段和该阶段的相关策略。Fiorano公司的CTO Atul Saini是这样描述服务配置是如何在开发时段发挥作用的：“有人可能想在某台使用某个输入参数集合的机器上运行一项服务。机器名和参数成为与服务连接在一起的开发配置文件的一部分，一旦服务被开发，它可以被升级到质量保证阶段，运行在使用不同参数的不同机器上。第二台机器/参数集合构成一个新配置文件。这样，可以为某个服务创建多个配置文件，只需在任意时间将不同的配置文件与服务建立联系，这个服务就可以在其生命周期中的不同阶段之间移动。”</p>
<p>配置文件管理常常假设开发部门拥有一个将服务升级到下一阶段的结构化流程。一些SOA开发工具包含嵌入式工作流环境，帮助企业满足这方面的设计时段治理需要。LogicLibrary公司CTO、合作创始人Brent Carlson说：“公司的Logidex工具帮助开发部门将检查点、角色和多步骤工作流配置到SOA开发流程之中。”</p>
<p>他说：“您可以自动执行将服务提升到下一阶段所涉及的审查和验证，如果发现定义不一致，在服务向注册表发布之前，可将它退回开发者加以改正。”</p>
<h4 id="企业服务总线模式"><a href="#企业服务总线模式" class="headerlink" title="企业服务总线模式"></a>企业服务总线模式</h4><p>在企业基于SOA实施EAI、B2B和BMP的过程中，如果采用点对点的集成方式存在着复杂度高，可管理性差，复用度差和系统脆弱等问题。企业服务总线（Enterprise Service Bus，ESB）技术在这种背景下产生，其思想是提供一种标准的软件底层架构，各种程序组件能够以服务单元的方式“插入”到该平台上运行，并且组件之间能够以标准的消息通信方式来进行交互。它的定义通常如下：企业服务总线是由中间件技术实现的支持面向服务架构的基础软件平合，支持异构环境中的服务以基于消息和事件驱动模式的交互，并且具有适当的服务质量和可管理性。</p>
<p>如图20-5所示，ESB本质上是以中间件形式支持服务单元之间进行交互的软件平台。各种程序组件以标准的方式连接在该“总线”上，并且组件之间能够以格式统一的消息通信的方式来进行交互。一个典型的在ESB环境中组件之间的交互过程是：首先由服务请求者触发一次交互过程，产生一个服务请求消息，并将该消息按照ESB的要求标准化，然后标准化的消息被发送给服务总线。ESB根据请求消息中的服务名或者接口名进行目的组件查找，将消息转发至目的组件，并最终将处理结果逆向返回给服务请求者。这种交互过程不再是点对点的直接交互模式，而是由事件驱动的消息交互模式。通过这种方式，ESB最大限度上解耦了组件之间的依赖关系，降低了软件系统互连的复杂性。连接在总线上的组件无需了解其他组件和应用系统的位置及交互协议，只需要向服务总线发出请求，消息即可获得所需服务。服务总线事实上实现了组件和应用系统的位置透明和协议透明。技术人员可以通过开发符合ESB标准的组件（适配器）将外部应用连接至服务总线，实现与其他系统的互操作。同时，ESB以中间件的方式，提供服务容错、负载均衡、QoS保障和可管理功能。</p>
<details><summary>图20-5　ESB示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170839.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170839.png';" /></details>


<p>（1）提供位置透明性的消息路由和寻址服务。</p>
<p>（2）提供服务注册和命名的管理功能。</p>
<p>（3）支持多种消息传递范型（如请求/响应、发布/订阅等）。</p>
<p>（4）支持多种可以广泛使用的传输协议。</p>
<p>（5）支持多种数据格式及其相互转换。</p>
<p>（6）提供日志和监控功能。</p>
<p>由于采用了基于标准的互连技术，ESB使得企业内部以及外部系统之间可以很容易地进行异步或同步交互。它采用的面向服务的架构为系统提供了易扩展性和灵活性，在提高集成应用的开发效率的同时降低了成本。ESB技术克服了传统应用集成技术的缺陷，能够对各种技术和应用系统提供支持，具有很强的灵活性和可扩展性，可以说是目前理想的EAI、B2B应用系统集成支撑平台。</p>
<p>ESB本身为EAI提供了良好的支持平台，但是，作为最终的企业用户需要的则是包含业务集成软件基础平台、各种预制服务组件、集成应用开发、部署、管理和监控工具为一体的EAI环境。因此，作为软件厂商只是以ESB中间件作为基础软件平台，为用户提供整套立体的完善的企业应用软件集成平台。</p>
<p>案例研究</p>
<p>协同企业服务总线SynchroESB就是基于SOA体系结构，以ESB为底层架构，包含丰富的预制程序组件，集中式管理工具和可视化应用程序开发界面的服务整合软件平台。该产品在国家高新技术产业化计划的支持下，由西安协同时光软件公司和西北工业大学计算机学院联合研究开发的。系统结构如图20-6所示，系统分为4个层次设计。</p>
<details><summary>图20-6　SynchroESB层次结构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904170856.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904170856.png';" /></details>


<p>服务总线层为整个EAI应用环境提供底层支持。ESB层之上的数据转换与适配器层为各种EAI应用提供接入功能，它要解决的是应用集成服务器与被集成系统之间的连接和数据接口的问题。其上是流程整合层，它将不同的应用系统连接在一起，进行协同工作，并提供业务流程管理的相关功能，包括流程设计、监控和规划，实现业务流程的管理。最上端的用户交互层，则是为用户在界面上提供一个统一的信息服务功能入口，通过将内部和外部各种相对分散独立的信息组成一个统一的整体。</p>
<p>SynchroESB支持企业构建可管理的、可扩展的和经济实用的EAI解决方案。它提供简单经济可扩展的方法和工具，以组件化的方式灵活构建业务流程。应用独创的“粗颗粒”组件编程模型技术构建可重用的组件库，使得诸如构建、原型化、生产和管理分布式复杂应用的活动，变得和今天我们习惯使用的电子表格操作一样简单。SynchroESB支持企业以基于标准的、面向服务架构的方式将应用系统和流程跨越企业进行集成。通过分布式架构和集中式管理，SynchroESB解决了集中式的集成方式中存在的问题，它使企业能够利用企业内任何地方的现有业务系统来快速组建一个有效的解决方案。SynchroESB采用事件驱动架构使得企业能够更快地响应业务的变化。</p>
<h3 id="构建SOA架构时应该注意的问题"><a href="#构建SOA架构时应该注意的问题" class="headerlink" title="构建SOA架构时应该注意的问题"></a>构建SOA架构时应该注意的问题</h3><h4 id="原有系统架构中的集成需求"><a href="#原有系统架构中的集成需求" class="headerlink" title="原有系统架构中的集成需求"></a>原有系统架构中的集成需求</h4><p>当架构师基于SOA来构建一个企业级的系统架构时，一定要注意对原有系统架构中的集成需求进行细致的分析和整理。我们都知道，面向服务的体系结构是当前及未来应用程序系统开发的重点。面向服务的体系结构本质上来说是一种具有特殊性质的体系结构，它由具有互操作性和位置透明的组件集成构建并互连而成。基于SOA的企业系统架构通常都是在现有系统架构投资的基础上发展起来的，我们并不需要彻底重新开发全部的子系统，SOA可以通过利用当前系统已有的资源（开发人员、软件语言、硬件平台、数据库和应用程序）来重复利用系统中现有的系统和资源。SOA是一种可适应的、灵活的体系结构类型，基于SOA构建的系统架构可以在系统的开发和维护中缩短产品上市时间，因而可以降低企业系统开发的成本和风险。因此，当SOA架构师遇到一个十分复杂的企业系统时，首先考虑的应该是如何重用已有的投资而不是替换遗留系统，因为如果考虑到有限的预算，整体系统替换的成本是十分高昂的。</p>
<p>当SOA架构师分析原有系统中的集成需求时，不应该只限定为基于组件构建的已有应用程序的集成，真正的集成比这要宽泛得多。在分析和评估一个已有系统体系结构的集成需求时，必须考虑一些更加具体的集成的类型，这主要包括以下几个方面：应用程序集成的需求，终端用户界面集成的需求，流程集成的需求以及已有系统信息集成的需求。当SOA架构师分析和评估现有系统中所有可能的集成需求时，可以发现实际上所有集成方式在任何种类的企业中都有一定程度的体现。针对不同的企业类型，这些集成方式可能是简化的，或者没有明确地进行定义的。因而，SOA架构师在着手设计新的体系结构框架时，必须要全面地考虑所有可能的集成需求。例如，在一些类型的企业系统环境中可能只有很少的数据源类型，因此，系统中对消息集成的需求就可能会很简单。但在一些特定的系统中，例如航运系统中的EDI（Electronic Data Interchange，电子数据交换）系统，会有大量的电子数据交换处理的需求，因此也就会存在很多不同的数据源类型，在这种情况下整个系统对于消息数据的集成需求就会比较复杂。因此，如果SOA架构师希望所构建的系统架构能够随着企业的成长和变化成功地继续得以保持，则整个系统构架中的集成功能就应该由服务提供，而不是由特定的应用程序来完成。</p>
<h4 id="服务粒度的控制以及无状态服务的设计"><a href="#服务粒度的控制以及无状态服务的设计" class="headerlink" title="服务粒度的控制以及无状态服务的设计"></a>服务粒度的控制以及无状态服务的设计</h4><p>当SOA架构师构建一个企业级的SOA系统架构时，关于系统中最重要的元素，也就是SOA系统中服务的构建有两点需要特别注意的地方：首先是对于服务粒度的控制，另外就是对于无状态服务的设计。</p>
<h5 id="服务粒度的控制"><a href="#服务粒度的控制" class="headerlink" title="服务粒度的控制"></a>服务粒度的控制</h5><p>SOA系统中服务粒度的控制是一项十分重要的设计任务。通常来说，对于将暴露在整个系统外部的服务推荐使用粗粒度的接口，而相对较细粒度的服务接口通常用于企业系统架构的内部。从技术上讲，粗粒度的服务接口可能是一个特定服务的完整执行，而细粒度的服务接口可能是实现这个粗粒度服务接口的具体的内部操作。举个例子来说，对于一个基于SOA架构的网上商店来说，粗粒度的服务可能就是暴露给外部用户使用的提交购买表单的操作，而系统内部细粒度的服务可能就是实现这个提交购买表单服务的一系列的内部服务，如创建购买记录、设置客户地址和更新数据库等一系列的操作。虽然细粒度的接口能为服务请求者提供更加细化和更多的灵活性，但同时也意味着引入较难控制的交互模式易变性，也就是说服务的交互模式可能随着不同的服务请求者而不同。如果我们暴露这些易于变化的服务接口给系统的外部用户，就可能造成外部服务请求者难于支持不断变化的服务提供者所暴露的细粒度服务接口；而粗粒度服务接口保证了服务请求者将以一致的方式使用系统中所暴露出的服务。虽然面向服务的体系结构并不强制要求一定要使用粗粒度的服务接口，但是建议使用它们作为外部集成的接口。通常架构设计师可以使用BPEL来创建由细粒度操作组成的业务流程的粗粒度的服务接口。</p>
<h5 id="无状态服务的设计"><a href="#无状态服务的设计" class="headerlink" title="无状态服务的设计"></a>无状态服务的设计</h5><p>SOA系统架构中的具体服务应该都是独立的、自包含的请求，在实现这些服务的时候不需要前一个请求的状态，也就是说服务不应该依赖于其他服务的上下文和状态，即SOA架构中的服务应该是无状态的服务。当某一个服务需要依赖时，最好把它定义成具体的业务流程（BPEL）。</p>
<p>在服务的具体实现机制上，可以通过使用EJB组件来实现粗粒度的服务。我们通常会利用无状态的Session Bean来实现具体的服务，如果基于Web Service技术，就可以将无状态的Session Bean暴露为外部用户可以调用到的Web服务，也就是把传统的Session Facade模型转化为EJB的Web服务端点。这样，就可以向Web服务客户提供粗粒度的服务。</p>
<p>如果要在J2EE的环境下（基于WebSphere）构建Web服务，Web服务客户可以通过两种方式访问J2EE应用程序。客户可以访问用JAX-RPC API创建的Web服务（使用Servlet来实现）；Web服务客户也可以通过EJB的服务端点接口访问无状态的Session Bean，但Web服务客户不能访问其他类型的企业Bean，如有状态的Session Bean、实体Bean和消息驱动Bean。后一种选择（公开无状态EJB组件作为Web服务）有很多优势，基于已有的EJB组件，可以利用现有的业务逻辑和流程。在许多企业中，现有的业务逻辑可能已经使用EJB组件编写，通过Web服务公开它可能是实现从外界访问这些服务的最佳选择。EJB端点是一种很好的选择，因为它使业务逻辑和端点位于同一层上。另外，EJB容器会自动提供对并发的支持，作为无状态Session Bean实现的EJB服务端点不必担心多线程访问，因为EJB容器必须串行化对无状态会话Bean任何特定实例的请求。由于EJB容器都会提供对于Security和Transaction的支持，因此Bean的开发人员可以不需要编写安全代码以及事务处理代码。性能问题对于Web服务来说一直都是一个问题，由于几乎所有EJB容器都提供了对无状态会话Bean群集的支持以及对无状态Session Bean池与资源管理的支持，因此当负载增加时，可以向群集中增加机器。Web服务请求可以定向到这些不同的服务器，同时由于无状态Session Bean池改进了资源利用和内存管理，使Web服务能够有效地响应多个客户请求。由此可以看到，通过把Web服务模型化为EJB端点，可以使服务具有更强的可伸缩性，并增强了系统整体的可靠性。</p>
<h3 id="SOA实施的过程"><a href="#SOA实施的过程" class="headerlink" title="SOA实施的过程"></a>SOA实施的过程</h3><h4 id="选择SOA解决方案"><a href="#选择SOA解决方案" class="headerlink" title="选择SOA解决方案"></a>选择SOA解决方案</h4><p>在实施SOA之前，选择最佳的解决方案，是保证SOA实施成功的前提条件。总体来说，必须从以下三个方面进行选择。</p>
<h5 id="尽量选择能进行全局规划的方案"><a href="#尽量选择能进行全局规划的方案" class="headerlink" title="尽量选择能进行全局规划的方案"></a>尽量选择能进行全局规划的方案</h5><p>SOA的实施，有很大的技术因素在其中，作为用户来讲，既需要选择适当的工具，还需要有专业的技术人才。</p>
<p>作为用户，实施SOA，首先要对自己的系统做全面的评估，要了解自己已有的系统能用多少，有多少需要改造，还需要上哪些新的系统，自己将来的系统该如何满足自己的需求，自己可能为这个新的系统投入的资本大概有多少等。总之，要有整体的规划，这也是实施SOA最为基础的一步。其次，要选择适合的工具和技术。上什么系统，建什么平台，先改造哪个系统，需要一步一步来，而在这个过程中，所选择的产品也必然有所不同，一定要做到心中有数。最后，就是开发的过程了，开发对于大多数的用户来说，也是一个边学习、边实践的过程。</p>
<h5 id="选择时充分考虑企业自身的需求"><a href="#选择时充分考虑企业自身的需求" class="headerlink" title="选择时充分考虑企业自身的需求"></a>选择时充分考虑企业自身的需求</h5><p>评估SOA项目的方式与评估传统软件项目有所不同，SOA在企业范围内通过各种渠道表现自己的优势。SOA通过共享服务来优化业务流程，使全面创新成为可能，其“价值机会”远远超过了传统的软件项目。要建立强大的业务实例，通过SOA实现业务创新是一个重要的分水岭。必须认识到，用于构建SOA项目的前期投资将产生巨大效益，这些好处会随着时间的推移越来越明显地表现出来。</p>
<p>SOA具体实施的进度和资金投入一方面取决于企业对IT应用的沉淀，另一方面取决于实行SOA的目标层次。</p>
<h5 id="从平台、实施等技术方面进行考察"><a href="#从平台、实施等技术方面进行考察" class="headerlink" title="从平台、实施等技术方面进行考察"></a>从平台、实施等技术方面进行考察</h5><p>用户在选择SOA产品和技术时，应该从平台的选择、实施方法与途径、供应商的选择三个方面进行考量。在选择软件平台时，用户首先要考虑的是平台的开放性和对标准的支持。在实施方法与途径方面，以往的成功经验总结有6个方面：业务战略和流程、基础架构、构建模块、项目和应用、成本和效益以及规划和管理。在实施SOA时，CIO应该综合考虑这6方面的因素。SOA的实施涉及到整个企业的IT系统以及业务流程的调整和改变，离不开相应的咨询和专业服务。因此，在选择供应商时，首先要看它的产品是否符合企业的实际需求、是否已经有很多成功的应用案例、现有客户对它的评价如何；其次，还要仔细考察供应商的专业服务能力，是否能够帮助用户分析企业IT现状，提出建设性的意见。</p>
<h4 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h4><h5 id="建立服务模型"><a href="#建立服务模型" class="headerlink" title="建立服务模型"></a>建立服务模型</h5><p>1） 自顶向下分解法</p>
<p>自上而下的领域分解方式从业务着手进行分析，选择端到端的业务流程进行逐层分解至业务活动，并对其间涉及的业务活动和业务对象进行变化分析。</p>
<p>业务组件模型是业务领域分解的输入之一。业务组件模型是一种业务咨询和转型的工具，它根据业务职责、职责间的关系等因素，将业务细分为业务领域、业务执行层次和业务组件。由于企业内部和外部环境的不同，每个业务组件在成本、投资和竞争力等方面不尽相同。因此，每个业务组件在企业发展的过程中战略职责和演化的路径也是不同的。由于角度的不同，就形成了所谓的业务组件的“热点视图”。对于面向服务的分析和设计，业务组件模型提供了进行服务划分的依据，而且这种划分的方法可以平滑地从业务视图细化到服务视图。</p>
<p>端到端的业务流程是业务领域分解的另一个输入。将业务流程分解成子流程或者业务活动，逐级进行，直到每个业务活动都是具备业务含义的最小单元。流程分解得到的业务活动树上的每一个节点，都是服务的候选者，构成了服务候选者组合。业务领域分解可以帮助发现主要的服务候选者，加上自下而上和中间对齐方式发现的新服务候选者，最终会构成一个服务候选者列表。在SOA的方法中，服务是业务组件间的契约，因此将服务候选者划分到业务组件，是服务分析中不可或缺的一步。服务候选者列表经过业务组件的划分，会最终形成层次化的服务目录。</p>
<p>变化分析的目的是将业务领域中易变的部分和稳定的部分区分开来，通过将易变的业务逻辑及相关的业务规则剥离出来，保证未来的变化不会破坏现有设计，从而提升架构应对变化的能力。变化分析可能会从未来需求的分析中发现一些新的服务候选者，这些服务候选者需要加入到服务候选者目录中。</p>
<p>2）业务目标分析法</p>
<p>通过关键性能指标分析来验证已有服务候选者以及发现遗漏的服务候选者，这也可以叫做“目标服务建模（Goal Service Modeling）”。它的思想是这样的：从企业的业务目标出发，目标分解为子目标，子目标再分派给相关的服务来实现，这样就形成了一棵“目标服务树”，处于叶子节点上的每个服务都能回溯到具体的业务目标。第一步的工作必须基于之前对企业关键性能指标的分析之上。</p>
<p>3）自底向上分析法</p>
<p>自下而上方式的目的是利用已有资产来实现服务，已有资产包括已有系统、套装或定制应用、行业规范或业务模型等。这也可以叫做“遗留资产分析”，它的主要思想是：通过建立已有系统所具有的功能模块目录列表，可以方便地发现那些在不同的系统中被重复实现的功能模块以及可以复用的功能模块，从而将这些模块包装成服务发布出来。遗留资产分析的来源一般是原有系统的分析和设计文档，遗留系统分析的结果是可以重用的服务列表。</p>
<p>通过对已有资产的业务功能、技术平台、架构及实现方式的分析，除了能够验证服务候选者或者发现新的服务候选者，还能够通过分析已有系统、套装或定制应用的技术局限性，尽早验证服务实现决策的可行性，为服务实现决策提供重要的依据。</p>
<h5 id="建立业务流程"><a href="#建立业务流程" class="headerlink" title="建立业务流程"></a>建立业务流程</h5><p>1）建立业务对象</p>
<p>业务对象（Business Object，BO）是对数据进行检索和处理的组件，是简单的真实世界的软件抽象。业务对象通常位于中间层或者业务逻辑层。</p>
<p>业务对象可以在一个应用中自动地加入一个特定的功能来获得增值效应，使知识重用变为可能。例如，如果要开发一个包含多货币处理的应用，可以选择使用一个已经开发完成的，包含所有多货币处理功能的业务对象来开始你的开发，使开发工作极大地减少。</p>
<p>业务对象的分类如下。</p>
<p>（1）实体业务对象。表达了一个人、地点、事物或者概念。根据业务中的名词从业务域中提取，如客户、订单和物品。</p>
<p>（2）过程业务对象。表达应用程序中业务处理过程或者工作流程任务，通常依赖于实体业务对象，是业务的动词。</p>
<p>（3）事件业务对象。表达应用程序中由于系统的一些操作造成或产生的一些事件。</p>
<p>通过对业务对象的抽象，你的架构系统将体现更高的架构体系高度。</p>
<p>2）建立服务接口</p>
<p>在实现SOA解决方案的上下文中，服务接口的结构非常重要。设计糟糕的服务接口可能会极大地导致使用此接口的很多服务使用者应用程序的开发过程变得非常复杂。从业务角度而言，设计糟糕的服务接口可能使得业务流程的开发和优化变得复杂；相反，设计良好的服务接口可以加速开发计划的执行，并对业务级别的灵活性起到促进作用。</p>
<p>服务接口通常应该包含多个操作，定义为单个服务接口一部分的操作应该从语义上相关，仅包含单个操作或少量操作的大部分服务都表明服务粒度不恰当；反过来，采用很少的服务（或者单个服务）来包含大量操作也同样表明服务粒度不恰当。</p>
<p>服务之间的交换可以为有状态、也可以为无状态。当服务提供者保留关于在之前的操作调用期间服务使用者和服务提供者之间交换的数据信息时，服务之间进行的是有状态（或对话型）交换。例如，服务接口可以定义为setCustomerNumber()和getCustomerInfo()的操作。在有状态交换中，服务请求者将首先调用setCustomerNumber()操作，并同时传入客户编号；服务提供者在内存中保留客户编号；接下来，服务请求者调用getCustomerInfo()操作，服务提供者将随后返回与之前调用中设置的客户编号对应的客户信息响应。</p>
<p>在构建SOA的过程中，将无状态接口视为最好的选择。无状态接口可以方便地供很多服务使用者应用程序重用，可以采用最适合每个应用程序的方式管理状态。传入操作的请求消息应该包含完成该操作所必要的所有信息，而不受到调用其他接口操作的顺序的影响。</p>
<p>3）建立业务流程</p>
<p>流程是指定的活动顺序，包含明确确定的用于提供业务值的输入和输出。例如，技术文档搜索流程从Web页面提取客户的搜索请求，并生成可选的文档列表。</p>
<p>对流程进行建模应当确保捕获的相关信息的一致性及完整性，以便业务分析员及开发人员能够理解模型所捕获的业务需求。在建模过程中，除了正常操作以外，标准流程的其他操作和异常必须获取，具有不同领域兴趣的专职人员和专家可以构建适合于大范围业务对象的流程模型。例如，分析员需要对流程有高度的见解以做出战略性决策，并进行诸如仿真之类的流程分析；开发人员将流程模型作为输入来实现解决方案。</p>
<p>分析员基于从业务需求所有者中所收集的需求构建业务流程（Business Process，BP）模型。通过使用适当的工具（例如PowerPoint、spreadsheets、IBM Rational Requisite Pro或者其他任意工具组合，并且在适当的时候可能是流程建模工具本身）来收集这些需求，分析员将这些需求及对现有流程的分析作为构建模型的输入条件，现有的流程模型用于对其进行分析或者通过修改现有的模型来创建新的流程模型，而不用从头重新创建。</p>
<p>通过将BP分成子流程开始建模过程。随后是对感兴趣的各子流程进行分析以确定组件、服务、输入输出数据、策略及测量。通过使用WebSphere Business Integration Modeler软件工具（Business Integration Modeler）将这些元素编码到BP模型中。</p>
<p>使用一种名为流程元素的建模构件来定义BP段，将其设计为可复用。流程元素是一种定义流程段的构件资产，在BP模型中，这种流程段被设计为可复用的构件来管理。它们将已建立的一系列任务、决策、对数据对象的引用、策略、角色及测试合并起来，例如，登录流程元素包含一系列活动，登录证书数据以及完成用户登录过程的登录规则。</p>
<p>这些流程元素表示可接受的操作行为，类似的需求也可复用它们。例如，作为子流程模型可检验并为购物篮中的商品定价。</p>
<p>BP分析员与BP所有者及领域专家协作来获取所需的全部信息以构建BP模型。例如，分析员使用适当的工具收集角色、任务、序列信息、资源、数据、叙述和需求等，并将它们作为构建BP模型的输入内容。通过在Business Integration Modeler中创建流程模型，业务分析员所获取的信息可以轻易地导出给工作流开发人员，使他们在Application Developer工具中使用这些信息。</p>
<p>为流程建模的任务包括定义业务流程的细节，并为所有数据、资源及流程中所使用的其他元素建模。业务流程包含一些流程步骤，它们通过控制流相连接，这些控制流将活动与决策点相连。决策点遵循业务规则（转换条件），使用这些业务规则来确定流程应当依照什么路线进行。建模包括将BP分解成子流程并将所需的流程元素添加到模型中；分析员可以将现有的模型构件（例如，服务或流程元素）用于促进并加速模型的构建。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch19-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch19-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch19-嵌入式系统设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:58:13" itemprop="dateCreated datePublished" datetime="2021-07-19T12:58:13+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 16:54:08" itemprop="dateModified" datetime="2021-09-04T16:54:08+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="嵌入式系统设计"><a href="#嵌入式系统设计" class="headerlink" title="嵌入式系统设计"></a>嵌入式系统设计</h2><p>嵌入式软件是与硬件最为相关的软件系统。随着嵌入式设备的增长，嵌入式软件复杂度也不断增加。本章介绍了嵌入式系统的特点及针对嵌入式系统的软件设计。</p>
<h3 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h3><h4 id="嵌入式系统概念"><a href="#嵌入式系统概念" class="headerlink" title="嵌入式系统概念"></a>嵌入式系统概念</h4><h5 id="嵌入式系统的基本概念"><a href="#嵌入式系统的基本概念" class="headerlink" title="嵌入式系统的基本概念"></a>嵌入式系统的基本概念</h5><p>嵌入式系统是一种以应用为中心，以计算机技术为基础，可以适应不同应用对功能、可靠性、成本、体积和功耗等方面的要求，集可配置可裁减的软、硬件于一体的专用计算机系统。主要由嵌入式硬件平台、相关支撑硬件、嵌入式操作系统、支撑软件以及应用软件组成。</p>
<p>嵌入式系统具有以下特点。</p>
<p>（1）系统专用性强。</p>
<p>（2）系统实时性强。</p>
<p>（3）软、硬件依赖性强。</p>
<p>（4）处理器专用。</p>
<p>（5）多种技术紧密结合。</p>
<p>（6）系统透明性。</p>
<p>（7）系统资源受限。</p>
<h5 id="嵌入式系统的实时概念"><a href="#嵌入式系统的实时概念" class="headerlink" title="嵌入式系统的实时概念"></a>嵌入式系统的实时概念</h5><p>兼有实时系统的特性和嵌入式系统特性的系统称为实时嵌入式系统。它们之间的关系如图19-1所示。</p>
<details><summary>图19-1　实时嵌入式系统</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163613.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163613.png';" /></details>

<h5 id="嵌入式系统的分类"><a href="#嵌入式系统的分类" class="headerlink" title="嵌入式系统的分类"></a>嵌入式系统的分类</h5><p>按照嵌入方式、嵌入程度、实时性和系统的复杂程度4种准则可以对现有的嵌入式系统进行如下分类。</p>
<p>根据嵌入方式分类：整机式嵌入、部件式嵌入和芯片式嵌入。</p>
<p>根据嵌入程度分类：深度嵌入、中度嵌入和浅度嵌入。</p>
<p>根据实时性分类：实时嵌入式系统和非实时嵌入式系统。</p>
<p>根据系统的复杂程度分类：单微处理器嵌入式系统、组件式嵌入式系统和分布式嵌入式系统。</p>
<h5 id="嵌入式系统的应用领域"><a href="#嵌入式系统的应用领域" class="headerlink" title="嵌入式系统的应用领域"></a>嵌入式系统的应用领域</h5><p>嵌入式系统和嵌入式软件的主要应用领域如下。</p>
<p>（1）工业控制领域。</p>
<p>（2）家电领域。</p>
<p>（3）商业和金融领域。</p>
<p>（4）交通运输领域。</p>
<p>（5）通信领域。</p>
<p>（6）建筑领域。</p>
<p>（7）环境监测领域。</p>
<p>（8）医疗卫生领域。</p>
<h4 id="嵌入式系统的基本架构"><a href="#嵌入式系统的基本架构" class="headerlink" title="嵌入式系统的基本架构"></a>嵌入式系统的基本架构</h4><h5 id="嵌入式系统-1"><a href="#嵌入式系统-1" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h5><p>嵌入式系统一般由软件和硬件两个部分组成，其中嵌入式处理器、存储器和外部设备等（如图19-2所示）构成整个系统的硬件基础。嵌入式系统的软件部分可以分为多个层次（如图19-3所示），其中系统软件和支撑软件是基础，应用软件则是最能体现整个嵌入式系统的特点和功能的部分。</p>
<details><summary>图19-2　典型嵌入式系统硬件架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163725.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163725.png';" /></details>

<h5 id="硬件平台的系统架构"><a href="#硬件平台的系统架构" class="headerlink" title="硬件平台的系统架构"></a>硬件平台的系统架构</h5><p>微处理器是整个嵌入式系统的核心，负责控制系统的执行。根据目前的使用情况，嵌入式处理器可以分为如下几类。</p>
<p>（1）嵌入式微处理器。</p>
<p>（2）嵌入式微控制器。</p>
<p>（3）嵌入式数字信号处理器。</p>
<p>（4）嵌入式片上系统。</p>
<h5 id="嵌入式系统的软件架构"><a href="#嵌入式系统的软件架构" class="headerlink" title="嵌入式系统的软件架构"></a>嵌入式系统的软件架构</h5><p>一个完整的嵌入式软件体系如图19-3所示。这个体系自底向上由以下部分组成：设备驱动管理层、嵌入式操作系统、支撑软件和应用软件。</p>
<details><summary>图19-3　一种基于Linux的嵌入式软件架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163809.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163809.png';" /></details>

<p>例如，在Linux核心操作系统的架构中，文件系统、网络支持等部分都以模块化的方式与核心协调工作。整个Linux核心的源代码树可以通过工程手段根据需要进行剪裁，从中剔除掉不必要的设备驱动程序、文件系统、语言和显示等的支持，从而在保证核心具备必须功能的前提下达到精简核心尺寸的目的。</p>
<p>存储方案支持固化Flash、CF卡、DOC/DOM/DOF以及各种低噪音的嵌入式硬盘。在实际的开发过程中，存储方案的选择与具体的应用模式相结合，根据不同的应用模式来采用相应的存储方案。实际上，存储方案的选择就是在嵌入式Linux系统的可靠性、尺寸、功能、成本之间寻求最佳的平衡点。</p>
<p>因此，嵌入式软件需要通过裁减与组合，以适应各种应用场合和成本需要。嵌入式软件架构需要很好的可配置性和扩展性。</p>
<h4 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h4><h5 id="嵌入式操作系统的概念与特点"><a href="#嵌入式操作系统的概念与特点" class="headerlink" title="嵌入式操作系统的概念与特点"></a>嵌入式操作系统的概念与特点</h5><p>嵌入式操作系统是指运行在嵌入式计算机系统上支持嵌入式应用程序的操作系统，是用于控制和管理嵌入式系统中的硬件和软件资源、提供系统服务的软件集合。嵌入式操作系统是嵌入式软件的一个重要组成部分。</p>
<p>与通用操作系统相比，嵌入式操作系统主要有以下特点。</p>
<p>（1）微型化。</p>
<p>（2）代码质量高。</p>
<p>（3）专业化。</p>
<p>（4）实时性强。</p>
<p>（5）可裁减、可配置。</p>
<h5 id="嵌入式操作系统的分类"><a href="#嵌入式操作系统的分类" class="headerlink" title="嵌入式操作系统的分类"></a>嵌入式操作系统的分类</h5><p>从嵌入式操作系统的获得形式上，可以分为商业型和非商业型两类。</p>
<p>根据嵌入式操作系统的实时性，可以分为实时嵌入式操作系统和非实时嵌入式操作系统两类。</p>
<h5 id="嵌入式操作系统的一般结构"><a href="#嵌入式操作系统的一般结构" class="headerlink" title="嵌入式操作系统的一般结构"></a>嵌入式操作系统的一般结构</h5><p>嵌入式操作系统的一般结构如图19-4所示。嵌入式操作系统主要由应用程序接口、设备驱动和操作系统内核等几部分组成。</p>
<details><summary>图19-4　嵌入式操作系统的一般结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163855.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163855.png';" /></details>

<p>嵌入式操作系统是一个按时序方式调度执行、管理系统资源并为应用代码提供服务的基础软件。每个嵌入式操作系统都有一个内核。另一方面，嵌入式操作系统也可以是各种模块的有机组合，包括内核、文件系统、网络协议栈和其他部件。但是，如图19-5所示，大多数内核都包含以下三个公共部件：调度器、内核对象和内核服务。</p>
<details><summary>图19-5　嵌入式操作系统的内核部件</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163914.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163914.png';" /></details>

<h5 id="嵌入式操作系统的多任务调度"><a href="#嵌入式操作系统的多任务调度" class="headerlink" title="嵌入式操作系统的多任务调度"></a>嵌入式操作系统的多任务调度</h5><p>1）基本概念</p>
<p>（1）任务。</p>
<p>（2）任务对象。</p>
<p>（3）多任务。</p>
<p>（4）调度器。</p>
<p>（5）可调度实体。</p>
<p>（6）上下文切换。</p>
<p>（7）可重入性。</p>
<p>（8）分发器。</p>
<p>（9）调度算法。</p>
<p>（10）优先级。</p>
<p>目前，大多数内核支持两种普遍的调度算法，即基于优先级的抢占调度（Preemptive Priority-Based Scheduling）和时间轮转调度算法（Round-Robin Scheduling）。</p>
<p>2）调度算法</p>
<p>（1）任务优先级分配方法。</p>
<p>一般地，可以采用单调执行速率调度法RMS（Rate Monotonic Scheduling）来给任务分配优先级，执行最频繁的任务优先级最高。</p>
<p>（2）时间轮转调度。</p>
<p>基于优先级抢占式扩充时间轮转调度，对于优先级相同的任务使用时间片获得相等的CPU执行时间。内核在满足以下条件时，把CPU控制权转交给下一个就绪态的任务。</p>
<p>（3）任务操作。</p>
<p>内核提供任务管理服务，也提供一个允许开发者操作任务的系统调用。典型的任务操作有任务创建和删除、任务调度控制、任务信息获取。</p>
<h5 id="嵌入式操作系统的内核对象"><a href="#嵌入式操作系统的内核对象" class="headerlink" title="嵌入式操作系统的内核对象"></a>嵌入式操作系统的内核对象</h5><p>实时嵌入式操作系统的用户可以使用内核对象来解决系统设计中的问题，如并发、同步与互斥、数据通信等。内核对象包括信号量、消息队列、管道、事件与信号等。</p>
<h5 id="实时嵌入式操作系统的内核服务"><a href="#实时嵌入式操作系统的内核服务" class="headerlink" title="实时嵌入式操作系统的内核服务"></a>实时嵌入式操作系统的内核服务</h5><p>实时嵌入式操作系统的内核服务有异常和中断、计时器、I/O管理。</p>
<h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><p>不论嵌入式系统的类型如何，对内存系统的普遍要求是最高的内存利用率、最小的管理负载和确定的分配时间。管理内容如下。</p>
<p>（1）嵌入式系统中固定尺寸内存池的内存管理。</p>
<p>（2）阻塞与非阻塞的内存函数。</p>
<p>（3）硬件内存管理单元。</p>
<p>（4）同步与通信。</p>
<h4 id="典型嵌入式操作系统"><a href="#典型嵌入式操作系统" class="headerlink" title="典型嵌入式操作系统"></a>典型嵌入式操作系统</h4><p>嵌入式操作系统分为从不同的通用操作系统发展来的通用嵌入式操作系统，如WinCE、Linux等，大多数是特定领域专用操作系统，如表19-1所示。</p>
<details><summary>表19-1　主要嵌入式操作系统</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164038.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164038.png';" /></details>

<details><summary>表19-1　主要嵌入式操作系统-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164053.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164053.png';" /></details>

<p>以VxWrorks为例，VxWrorks是一个运行在目标机上的高性能、可裁减的嵌入式实时操作系统。VxWrorks是专门为实时嵌入式系统设计开发的操作系统内核，为程序员提供了高效的实时多任务调度、中断管理、实时的系统资源以及实时的任务间通信。VxWrorks在各种CPU平台上提供了统一的编程接口和一致的运行特性，尽可能地屏蔽了不同CPU之间的底层差异。</p>
<p>VxWrorks以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空和航天等高精尖技术及实时性要求极高的领域中，如卫星通信、军事演习、弹道制导和飞机导航等。</p>
<p>VxWrorks操作系统的基本构成部件主要有以下5个部分：板级支持包BSP（Board Support Package）、微内核Wind、网络系统、文件系统和I/O系统。</p>
<p>VxWorks系统具有高性能的微内核设计、可裁剪的运行软件、综合的网络工具、兼容POSIX 1003.1b标准、平台的选择、方便地移植到用户硬件上及操作系统选件等特色。</p>
<h4 id="嵌入式数据库管理"><a href="#嵌入式数据库管理" class="headerlink" title="嵌入式数据库管理"></a>嵌入式数据库管理</h4><h5 id="嵌入式数据库管理系统概述"><a href="#嵌入式数据库管理系统概述" class="headerlink" title="嵌入式数据库管理系统概述"></a>嵌入式数据库管理系统概述</h5><p>通常，嵌入式数据库管理系统就是在嵌入式设备上使用的数据库管理系统。由于用到嵌入式数据库管理系统的系统大多数都是移动信息设备，所以，嵌入式数据库也称为移动数据库或嵌入式移动数据库。其作用主要是解决移动计算环境下数据的管理问题，移动数据库是移动计算环境中的分布式数据库。</p>
<h5 id="嵌入式数据库管理系统使用环境的特点"><a href="#嵌入式数据库管理系统使用环境的特点" class="headerlink" title="嵌入式数据库管理系统使用环境的特点"></a>嵌入式数据库管理系统使用环境的特点</h5><p>嵌入式数据库系统是一个包含嵌入式数据库管理系统在内的跨越移动通信设备、工作站或台式机以及数据服务器的综合系统。其使用环境的特点可以简单地归纳如下。</p>
<p>（1）设备随时移动性。</p>
<p>（2）网络频繁断接。</p>
<p>（3）网络条件多样化。</p>
<p>（4）通信能力不对称。</p>
<h5 id="嵌入式数据库管理系统组成与关键技术"><a href="#嵌入式数据库管理系统组成与关键技术" class="headerlink" title="嵌入式数据库管理系统组成与关键技术"></a>嵌入式数据库管理系统组成与关键技术</h5><p>1）嵌入式数据库管理系统组成</p>
<p>一个完整的嵌入式数据库管理系统包括主数据库管理系统、同步服务器、嵌入式数据库管理系统和连接网络等几个子系统，如图19-6所示。</p>
<details><summary>图19-6　嵌入式数据库系统组成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164159.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164159.png';" /></details>

<p>2）嵌入式移动数据库在应用中的关键</p>
<p>嵌入式移动数据库在实际应用中必须解决好数据的一致性（复制性）、高效的事务处理和数据的安全性等问题。</p>
<p>3）移动数据库管理系统的特性</p>
<p>由于嵌入式移动数据库管理系统在移动计算的环境下应用在嵌入式操作系统之中，是一种动态分布式数据库管理系统，其特点和功能如下。</p>
<p>（1）微核结构。</p>
<p>（2）对标准SQL的支持。</p>
<p>（3）事务管理功能。</p>
<p>（4）完善的数据同步机制。</p>
<p>（5）支持多种连接协议。</p>
<p>（6）完备的嵌入式数据库管理功能。</p>
<p>（7）支持多种嵌入式操作系统。</p>
<p>还应考虑的因素有对断接操作的支持、对跨区长事务的支持、对位置相关查询的支持、对查询优化的特殊考虑以及对提高有限资源的利用率和对系统效率的考虑等。</p>
<h5 id="嵌入式移动数据库管理系统的应用"><a href="#嵌入式移动数据库管理系统的应用" class="headerlink" title="嵌入式移动数据库管理系统的应用"></a>嵌入式移动数据库管理系统的应用</h5><p>嵌入式数据库管理系统主要用于以移动信息设备为终端、并需要定期汇总的金融、零售、医疗、公安、保险、工业制造、仓储以及电信等多个行业和领域。</p>
<h5 id="嵌入式数据库管理系统案例"><a href="#嵌入式数据库管理系统案例" class="headerlink" title="嵌入式数据库管理系统案例"></a>嵌入式数据库管理系统案例</h5><p>SQL Anywhere Studio是Sybase公司开发的一个嵌入式数据库系统，主要用于笔记本式计算机、手持设备和智能电器等领域。</p>
<p>Adaptive Server Anywhere嵌入式数据库管理系统具有支持多种操作系统、支持Java、支持Internet、支持多种应用程序接口、易于管理及系统规模配置灵活等主要特性。</p>
<h4 id="嵌入式网络及其他"><a href="#嵌入式网络及其他" class="headerlink" title="嵌入式网络及其他"></a>嵌入式网络及其他</h4><p>嵌入式网络是用于连接各种嵌入式系统，使之可以互相传递信息、共享资源的网络系统。嵌入式系统在不同的场合采用不同的连接技术，如在家庭居室采用家庭信息网，在工业自动化领域采用现场总线，在移动信息设备等嵌入式系统则采用移动通信网。此外，还有一些专用连接技术用于连接嵌入式系统。</p>
<h5 id="现场总线网"><a href="#现场总线网" class="headerlink" title="现场总线网"></a>现场总线网</h5><p>现场总线（Field Bus）是将数字传感器、变换机、工业仪表及控制执行机构等现场设备与工业过程控制单元、现场操作站等相互连接而成的网络。它具有全数字化、分散、双向传输和多分支的特点，是工业控制网络向现场级发展的产物。</p>
<p>嵌入式现场控制系统将专用微处理器置入传统的测量控制仪表，使其具备数字计算和数字通信能力。</p>
<p>现场总线主要有总线型与星型两种拓扑结构。现场总线控制系统通常由以下部分组成：现场总线仪表、控制器、现场总线线路、监控、组态计算机，并通过现场总线网卡、通信协议软件连接到网上。</p>
<p>现场总线控制系统的优点如下。</p>
<p>（1）全数字化。</p>
<p>（2）全分布。</p>
<p>（3）双向传输。</p>
<p>（4）自诊断。</p>
<p>（5）节省布线及控制室空间。</p>
<p>（6）多功能。</p>
<p>（7）开放性。</p>
<p>（8）互操作性。</p>
<p>（9）智能化与自治性。</p>
<p>具有代表性的实例有德国BOSCH公司的CAN（Control Area Network），Echelon公司的LONGWORKS。</p>
<h5 id="家庭信息网"><a href="#家庭信息网" class="headerlink" title="家庭信息网"></a>家庭信息网</h5><p>家庭信息网是把家庭范围内的个人计算机，家用电器，水、电、气仪表，照明设备和网络设备及安全设备等连接在一起的局域网。其主要功能是集中控制上述设备并将其接入Internet，以共享网络资源和服务。</p>
<p>家庭信息网需要解决的两个基本问题如下。</p>
<p>（1）如何将家用电器，水、电、气仪表，照明设备等互相连接起来。</p>
<p>（2）如何实现这些连在一起的设备之间的互操作。</p>
<p>家庭信息网的拓扑结构有总线型和星型等。</p>
<p>目前，家庭信息网的传输技术有两类：一类是有线连接技术，包括以太网、电话线、电力线、IEEE1394以及USB等。另一类是无线连接技术，包括蓝牙（BlueTooth）、红外线（InfraRed）、无线USB以及802.11x等相关无线标准。</p>
<h5 id="无线数据通信网"><a href="#无线数据通信网" class="headerlink" title="无线数据通信网"></a>无线数据通信网</h5><p>无线数据通信网是一种通过无线电波传送数据的网络系统。通过无线数据通信网，智能手机、PDA及笔记本式计算机可以互相传递数据信息，并接入因特网。</p>
<p>无线数据通信网分为短程无线网和无线因特网。短程无线网主要包括802.11、蓝牙、IrDA及HomeRF等。无线因特网或移动因特网主要采用两种无线连接技术：一种是移动无线接入技术，如GSM（Global System for Mobile）、GPRS（General Packet Radio Service）和CDPD（Cellular Digital Packet Data）等。另一种是固定无线接入技术，包括微波、扩频通信、卫星及无线光传输等。</p>
<p>无线局域网（Wireless LocalArea Network，WLAN）是计算机网络与无线通信技术相结合的产物。无线局域网的传输媒体是红外线（IR）或者无线电波（RF），目前无线电波的使用更广泛一些。</p>
<p>目前常见的无线网络标准以IEEE802.11x系列为主。</p>
<h5 id="嵌入式因特网"><a href="#嵌入式因特网" class="headerlink" title="嵌入式因特网"></a>嵌入式因特网</h5><p>随着Internet和嵌入式技术的飞速发展，越来越多的信息电器都要求与Internet连接，来共享Internet所提供的方便、快捷、无处不在的信息资源和服务，即嵌入式Internet技术。嵌入式Internet技术在智能交通、家政系统、家庭自动化、工业自动化、POS及电子商务等领域具有广阔的应用前景。</p>
<p>嵌入式因特网有直接接入因特网和通过网关接入因特网两种接入方法。</p>
<h5 id="嵌入式系统的其他支撑软件"><a href="#嵌入式系统的其他支撑软件" class="headerlink" title="嵌入式系统的其他支撑软件"></a>嵌入式系统的其他支撑软件</h5><p>嵌入式系统的支撑软件通常包括窗口系统、网络系统、数据库管理系统及Java虚拟机等几个部分。</p>
<h5 id="嵌入式窗口系统"><a href="#嵌入式窗口系统" class="headerlink" title="嵌入式窗口系统"></a>嵌入式窗口系统</h5><p>嵌入式窗口系统是用于控制嵌入式系统中的位映像显示设备与输入设备的软件系统，管理屏幕、窗口、字体、光标、图形图像以及输入设备等资源。</p>
<p>图形用户界面系统是指计算机系统以图形方式向用户提供的人机交互的操作环境，如图19-7所示。</p>
<h5 id="嵌入式窗口系统实例分析"><a href="#嵌入式窗口系统实例分析" class="headerlink" title="嵌入式窗口系统实例分析"></a>嵌入式窗口系统实例分析</h5><p>嵌入式系统往往是一种定制的设备，它们对图形用户界面的需求也各不相同，因此很多嵌入式系统需要自己特定的嵌入式图形用户界面。常用的嵌入式图形用户界面有MiniGUI、Microwindows、OpenGUI和Qt/Embedded。</p>
<h5 id="嵌入式系统的Java虚拟机"><a href="#嵌入式系统的Java虚拟机" class="headerlink" title="嵌入式系统的Java虚拟机"></a>嵌入式系统的Java虚拟机</h5><p>Java最初是由Sun公司开发的编程语言，可以在网络环境下为不同类型的计算机和操作系统开发软件。目前，在智能手机、机顶盒等嵌入式系统中得到了广泛的应用。</p>
<p>运行J2ME（Java 2 Platform Micro-Edition）微型版的嵌入式设备主要有两大类：受限连接设备（Connected Limited Device）和连接设备（Connected Device）。如图19-8所示，J2ME的结构分为4个层次：框架、配置、Java虚拟机及嵌入式操作系统，J2ME的核心是Java虚拟机。</p>
<details><summary>图19-7　图形用户界面系统的层次模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164511.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164511.png';" /></details>

<details><summary>图19-8　J2ME的层次结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164521.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164521.png';" /></details>


<p>KVM（K Virtual Machine）和CVM（C Virtual Machine）都是JVM的子集，均可被看做是一种Java虚拟机，它们是J2SE JVM的压缩版。框架、配置、虚拟机与嵌入式操作系统之间的关系如图19-9所示。</p>
<details><summary>图19-9　框架、配置、虚拟机与嵌入式操作系统之间的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164714.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164714.png';" /></details>

<p>目前，在J2ME中，主要有MIDP、Personal、PDA、Foundation和RMI等框架。</p>
<p>移动信息设备框架（Mobile Information Device Profile，MIDP）是一个Java API集合，它处理诸如用户界面、持久存储和联网等问题。</p>
<h3 id="嵌入式系统的设计"><a href="#嵌入式系统的设计" class="headerlink" title="嵌入式系统的设计"></a>嵌入式系统的设计</h3><h4 id="嵌入式系统分析与设计"><a href="#嵌入式系统分析与设计" class="headerlink" title="嵌入式系统分析与设计"></a>嵌入式系统分析与设计</h4><h5 id="嵌入式系统设计的核心技术"><a href="#嵌入式系统设计的核心技术" class="headerlink" title="嵌入式系统设计的核心技术"></a>嵌入式系统设计的核心技术</h5><p>嵌入式系统的核心技术有三种：处理器技术、IC技术和设计/验证技术。</p>
<p>1）处理器技术</p>
<p>处理器技术与实现系统功能的计算引擎结构有关，不可编程的数字系统也可以视为处理器，这些处理器的差别在于其面向特定功能的专用化程度，导致其设计指标与其他处理器不同。</p>
<p>（1）通用处理器。</p>
<p>这类处理器可用于不同类型的应用，一个重要的特征就是存储程序，由于设计者不知道处理器将会运行何种运算，所以无法用数字电路建立程序。另一个特征就是通用的数据路径，为了处理各类不同的计算，数据路径是通用的，其数据路径一般有大量的寄存器以及一个或多个通用的算术逻辑单元。设计者只需要对处理器的存储器编程来执行所需的功能，即设计相关的软件。</p>
<p>在嵌入式系统中使用通用处理器具有设计指标上的一些优势：上市时间快和成本较低；设计者只需编写程序，而不需要做任何数字电路设计；灵活性高，功能的改变通过修改程序进行。与自行设计处理器相比，小批量时单位成本较低。</p>
<p>当然，这种方式也有一些设计指标上的缺陷，数量大时的单位成本相对较高。因为数量大时，自行设计的成本分摊下来，可降低单位成本。同时，对于某些应用，性能可能很差。由于包含了非必要的处理器硬件，系统的体积和功耗可能变大。</p>
<p>（2）单用途处理器。</p>
<p>单用途处理器是设计用于执行特定程序的数字电路，也指协处理器、加速器和外设等。如JPEG编码解码器执行单一程序，压缩或解压视频信息。嵌入式系统设计者可通过设计特定的数字电路来建立单用途的处理器，也可以采用预先设计好的商品化的单用途处理器。</p>
<p>在嵌入式系统中使用单用途处理器，在指标上有一些优缺点。这些优缺点与通用处理器基本相反，性能可能更好，体积与功率可能较小，数量大时的单位成本可能较低，而设计时间与NRE成本可能较高，灵活性较差，数量小时的单位成本较高，对某些应用性能不如通用处理器。</p>
<p>（3）专用处理器。</p>
<p>专用指令集处理器（ASIP）是一个可编程处理器，针对某一特定类型的应用进行最优化。这类特定应用具有相同的特征，如嵌入式控制、数字信号处理等。在嵌入式系统中使用ASIP，可以在保证良好的性能、功率和大小的情况下，提供更大的灵活性，但这类处理器仍需要昂贵的NRE成本建立处理器本身和编译器。单片机和数字信号处理器是两类应用广泛的ASIP，数字信号处理器是一种针对数字信号进行常见运算的微处理器，而单片机是一种针对嵌入式控制应用进行最佳化的微处理器。通常控制应用中的常见外设，如串行通信外设、定时器、计数器、脉宽调制器及数/模转换器等都集成到了微处理器芯片上，从而使得产品的体积更小、成本更低。</p>
<p>2）IC技术</p>
<p>（1）全定制/VLSI。</p>
<p>在全定制IC技术中，需要根据特定的嵌入式系统的数字实现来优化各层设计人员从晶体管的版图尺寸、位置、连线开始设计，以达到芯片面积利用率高、速度快、功耗低的最优化性能。利用掩膜在制造厂生产实际芯片，全定制的IC设计也常称为大规模集成电路设计（VLSI），具有很高的成本，很长的制造时间，适用于大量或对性能要求严格的应用。</p>
<p>（2）半定制ASIC。</p>
<p>半定制ASIC是一种约束型设计方法，包括门阵列设计法和标准单元设计法。它是在芯片上制作一些具有通用性的单元元件和元件组的半成品硬件，设计者仅需要考虑电路的逻辑功能和各功能模块之间的合理连接即可。这种设计方法灵活方便、性价比高，缩短了设计周期，提高了成品率。</p>
<p>（3）可编程ASIC。</p>
<p>可编程器件中所有各层都已经存在，设计完成后，在实验室里即可烧制出设计的芯片，不需要IC厂家参与，开发周期显著缩短。可编程ASIC具有较低的成本，单位成本较高，功耗较大，速度较慢。</p>
<p>3）设计/验证技术</p>
<p>嵌入式系统的设计技术主要包括硬件设计技术和软件设计技术两大类。其中，硬件设计领域的技术主要包括芯片级设计技术和电路板级设计技术两个方面。</p>
<p>芯片级设计技术的核心是编译/综合、库/IP、测试/验证。编译/综合技术使设计者用抽象的方式描述所需的功能，并自动分析和插入实现细节。库/IP技术将预先设计好的低抽象级实现用于高级。测试/验证技术确保每级功能正确，减少各级之间反复设计的成本。</p>
<p>软件设计技术的核心是软件语言。软件语言经历了从低级语言（机器语言、汇编语言）到高级语言（如结构化设计语言、面向对象设计语言）的发展历程，推动其发展的是汇编技术、分析技术、编译/解释技术等诸多相关技术。</p>
<p>早期，随着通用处理器概念的逐渐形成，软件技术迅速发展，软件的复杂度也开始增加，软件设计和硬件设计的技术和领域完全分开。设计技术和工具在这两个领域同步得到发展，也使得行为描述可以在越来越抽象的级别上进行，以适应设计复杂度不断增长的需要。采用UML等建模，进行分析与设计已成为统一共识。</p>
<h5 id="系统的设计流程"><a href="#系统的设计流程" class="headerlink" title="系统的设计流程"></a>系统的设计流程</h5><p>嵌入式系统软件的开发过程可以分为项目计划、可行性分析、需求分析、概要设计、详细设计、程序建立、下载、调试、固化、测试及运行等几个阶段，这些阶段的次序和关系如图19-10所示。</p>
<details><summary>图19-10　嵌入式软件开发的一般过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904164859.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904164859.png';" /></details>

<p>（1）评估用户的需求采用计算机的必要性。从经济效益和社会效益这两个侧面来考虑。</p>
<p>（2）用户需求调查与分析，并提炼出规格说明。</p>
<p>（3）选择处理器。在用户需求调查清楚的基础上，再仔细进行分析。理解满足用户需求所需什么样的速度、什么样的精度、什么样规模的嵌入式系统可以实现用户的需求。在此基础上，首先确定作为系统的核心部件的处理器。选择合适的处理器对实现用户需求、提高系统性能、降低系统成本以及缩短开发周期都是十分重要的。选择处理器可从字长、速度、中断能力、环境的适应能力、硬件和软件的支持能力、开发和调试手段几个方面来考虑。</p>
<p>（4）制订系统方案。在系统的核心部件处理器确定后，便可以根据需求来制订系统的总体方案。这包括硬件系统方案和软件系统方案两个方面，并对总体方案进行评审。</p>
<p>（5）软、硬件分别设计。</p>
<p>（6）实验室联调。</p>
<p>（7）现场调试和试运行。</p>
<p>（8）鉴定或验收。</p>
<p>1）需求分析阶段</p>
<p>当确定要为用户设计开发嵌入式计算机系统后，接下来重要的一步就是对用户的需求进行认真仔细的调查和分析。这一步极为重要，因为此后系统设计的所有工作都是以用户的需求为依据的。用户的需求没有做好，则设计一定是失败的；用户没有要求的功能在设计中做了，有可能是锦上添花，也可能是画蛇添足。因此，最重要的在于满足用户的需求。</p>
<p>用户的需求调查一定要仔细进行，全面详细地了解要求，仔细地倾听用户的解释，经分析以文字的形式写出来并形成文档。而且使设计者的理解与用户的解释完全一致，不能存在二义性。</p>
<p>在需求调查时，除了仔细了解用户的需求外，还要对用户使用嵌入式系统的环境进行调查。这些内容也许用户没有意识到它们的重要性，但系统设计者必须予以高度重视。</p>
<p>一般都将形成文档的用户需求报告作为系统开发研制合同的附件，因为它既是开发的依据，又可在出现争议时备查。</p>
<p>2）规格说明</p>
<p>对用户需求进行提炼便可得到系统的规格说明。规格说明里包含了进行系统体系结构设计所需要的足够信息。将客户的描述转化为系统设计者的描述的结构化方法就是从客户的需求中获取一组一致性的需求，然后从中整理出正式的规格说明。</p>
<p>规格说明起到客户和生产者之间合同的作用，所以规格说明必须小心编写，以便精确地反映客户的需求并且作为设计时必须明确遵循的要求。</p>
<p>规格说明还应该足够明晰，以便别人可以验证它是否符合系统需求并且是否能完全满足客户的期望，它亦不能有歧义。</p>
<p>3）设计阶段</p>
<p>稍具规模的嵌入式系统设计过程都是系统工程，需多个技术人员齐心协力共同以最快的速度加以实现。单靠一个人，即使有能力解决所有问题，但一个系统设计做出来可能就需好多年。当几年后系统完成时也就成为落后和无用的东西了，因为这个领域的技术发展非常快。</p>
<p>在硬件好分割的地方将硬件分割成若干模块。在软件好分割的地方、界面比较简单的地方将软件分割成若干模块，然后将硬件模块和软件模块分别交给不同的技术人员同时进行设计。</p>
<p>在设计过程中，规定设计进度，限定时间将各自的模块设计并调试出来。在此过程中，对出现的问题要进行协调。若有方案上的变更，要以文字的形式通知设计人员。各设计人员在设计和调试自己的模块过程中要做必要的记录。</p>
<p>4）系统集成与测试阶段</p>
<p>当软、硬件各模块都设计调试完成后，便可在实验室进行联调。</p>
<p>将硬件模块逐块加到硬件系统上，逐块模板进行调试。直到所有硬件模块都调试出来，证明它们可以正常工作。</p>
<p>同时，对各自设计的软件模块逐块进行连接并调试，证明软件系统可以工作。</p>
<p>将软、硬件结合在一起，对整个系统进行调试，并在实验室里进行模拟试运行。在实验室模拟试运行中，如果需要，可在实验室里产生模拟信号。例如，称重传感提供0～20mV的称重信号，也许实验室里没有称重传感器，但实验室里一定可以产生0～20mV的信号代替传感器的输出。同样，实验室里可能没有需要0～5mV的执行机构，但用万用表便可测量出系统硬件是否能够输出执行机构所需要的0～5mV的信号。</p>
<p>经过不断的模拟试运行，仔细观察并分析出现的现象和状态。判断系统工作是否正常，决不要放过任何的异常，对出现的问题随时加以解决。</p>
<p>由于用户需求的复杂性、多样性，使得系统的硬件和软件变得复杂得多。因此，在实验室里进行模拟试运行时，一定要想办法使用户程序的每一条路径都能走到，即测试用户程序的各种可能。同时，要使系统连续运行较长的时间，以便发现可能隐藏的软、硬件故障。</p>
<p>5）现场调试和试运行</p>
<p>在实验室模拟试运行确认系统工作是正确的情况下，便可将系统运往用户现场，在现场进行安装和调试。这时，系统所连接的专用外设都是系统真正要使用的，在调试时也应逐个进行外设的连接，逐个进行调试。</p>
<p>在调试通过后，即可使系统开始试运行。在试运行的过程中，一定要密切注视系统运行的状态，不要放过任何的异常情况；对系统运行的状态和数据进行详细记录；如果出现问题，应立即予以解决；要使系统无故障地、正常运行半年或更长的时间。</p>
<p>如果可能，最好多做几套样机，并将它们安装在不同的用户现场上，进行半年或更长时间的试运行，以便确定系统的工作性能。</p>
<h4 id="嵌入式软件设计模型"><a href="#嵌入式软件设计模型" class="headerlink" title="嵌入式软件设计模型"></a>嵌入式软件设计模型</h4><h5 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h5><p>有限状态机（FSM）是一种描述系统状态及其状态转换的节点网，包括节点和边，节点表示状态，边表示状态之间的转换关系。边上面标注事件，表示状态转换对该事件敏感。在一个典型的有限状态机中，系统总是处于单个状态，事件通信可以是广播、同步和非阻塞方式。图19-11显示了一个有限状态机的示例。</p>
<details><summary>图19-11　有限状态机示例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904165025.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904165025.png';" /></details>


<p>有限状态机适合于对控制领域的系统建模。但是，由于缺乏并发和层次化支持，创建系统的规模受限，无法对并发系统建模，这是由于有限状态机总是假设系统处于单个状态而造成的。</p>
<p>状态机被描述为：输入事件的集合；输出事件的集合；状态集合；把状态和输入事件映射到输出事件的集合；把状态和输入事件映射到状态的集合；对初始状态的描述；有限状态机是有限状态的机器。有限状态机可被用作提出和解决问题的开发工具，也可被用作为以后开发者描述解决方案的正式工具。有很多种显示状态机的方法，从简单的表格到图形示例。所谓状态机模型，是一个描述状态变迁的方法，它总是将一种状态向另一种状态的变迁视为由输入消息激励所产生的结果。这样，每当消息促使事务需要做出某种操作时，有限状态机的当前状态也随之改变，这种改变是根据预先制定好的规则来实现的。</p>
<p>状态机模型具有如下特点。</p>
<p>（1）输出由当前的输入和当前的状态决定。这是状态机模型和组合模型之间的最大区别。</p>
<p>（2）当前的状态由过去的输入决定。很显然，一个对象之所以拥有当前状态，是因为它在此前经历过初始化并响应过若干次外界的操作请求（即接受了外界的输入）。</p>
<p>（3）当前的状态是上一步输出的反映。被测对象处于当前状态的直接原因是对象对上一次的输入做了有效的回应，即产生了上一步的输出。</p>
<p>（4）输出受输入顺序的影响。因为对状态机模型而言，当前状态加上当前输入才可以得到预期的输出。如果把当前输入放在上一步输入之前，那时状态机既然不是处于当前状态之下，就无法得到预期的输出了。</p>
<h5 id="数据流模型"><a href="#数据流模型" class="headerlink" title="数据流模型"></a>数据流模型</h5><p>数据流图允许系统作为操作网进行建模，特别适合于对实现进行分区的系统模型。这些模型的长度能够描述系统控制和数据域，这使得它们能够适合于对异构系统的建模。</p>
<p>数据流模型主要包括布尔数据流、层次化的流图和Petri网。</p>
<p>1）布尔数据流</p>
<p>布尔数据流克服了同步数据流模型中数据依赖操作的缺陷，引入了开关结点，能够根据输入值选择输出，支持对复杂算法的建模和实现。图19-12显示了一个布尔数据流模型。</p>
<details><summary>图19-12　布尔数据流模型示例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904165159.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904165159.png';" /></details>

<p>2）层次化的流图</p>
<p>层次化的流图包括节点和边，节点表示操作，边表示依赖。操作可以是条件、计算、等待和循环操作。条件操作支持在图模型中使用数据依赖。通信可以是阻塞式（Wait）和非阻塞式（Receive）。层次化的流图用于在系统中执行分区、调度和综合。</p>
<p>3）Petri网</p>
<p>Petri网是一种流程建模机制，其基本形式是由Petri提出的，所以命名为Petri网。目前，Petri网得到了广泛应用，特别是在离散事件仿真、实时调度、工业控制和工作流等方面。基本Petri网通常包括库所（Places）、操作（Transitions）和有向边（弧）。库所上的数据称为令牌（Tokens）。输入库所上的令牌可以触发迁移，消耗输入库所上的令牌，并为输出库所生成令牌。图19-13显示了一个Petri网的示例。</p>
<details><summary>图19-13　Petri网示例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904165240.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904165240.png';" /></details>

<h5 id="并发进程模型"><a href="#并发进程模型" class="headerlink" title="并发进程模型"></a>并发进程模型</h5><p>并发进程模型包括CSP与CCS等。</p>
<p>1）CSP模型</p>
<p>CSP（Communicating Sequential Processes）通信顺序进程是C. A. R. Hoare于1978年提出的一种并发、分布式程序设计语言模型。CSP一经出现就被广泛地应用于计算机科学的诸多领域，如网络通信协议的形式化描述等。</p>
<p>CSP将输入、输出操作列为程序语言的基本要素，而将实现顺序进程间通信的并行组合作为基本的程序控制结构。用这种语言设计的一个程序，就是一组进程，它们通过一个通信网络彼此通信。</p>
<p>CSP模型的目的是描述一种在计算机应用的广泛领域中适用的最简单的数学理论，其主要贡献是把计算机所涉及的各种计算形式及其性质建立在一套严密的形式系统上。其新版本TCSP在并发和通信方法及语义的研究方面与Milner的CCS很类似，对“失效语义”给出了精确的数学描述，使CSP理论更加可靠完善。</p>
<p>2）CCS模型</p>
<p>CCS（Calculus of Communicating System）通信演算系统是R. Milner于1980年发表的一个建立于极小原语集上的函数式程序设计语言模型，为通信的、非确定的并发系统提供了一个通用数学模型。</p>
<p>CCS模型是在一种较弱条件下建立起来的并发进程模型，企图俘获并发性及通信的一般数学性质。其主要贡献是关于并发系统构成的等价性研究，其中有代表性的是建立在双模拟基础上的等价概念。</p>
<p>CCS从简单的事实出发，以严谨、优美的数学形式，建立了并发系统行为的形式理论。</p>
<h5 id="面向对象模型"><a href="#面向对象模型" class="headerlink" title="面向对象模型"></a>面向对象模型</h5><p>面向对象模型的出发点，就是要把现实世界中物与物的关系怎样不变地用程序表示出来，并把现实世界的组织结构在计算机上再现。这种结构直观、易懂。现实世界中的万物都有自己的功能和任务，自己能干的事情自己完成，自己不能干的事情托他人代办，只要取得结果就可以了。因此，就要注意现实世界中各事物——即对象之间的联系，为每个对象分配任务，对象之间也相互传递任务，进行工作。这就是面向对象的方法。</p>
<p>面向对象的基本结构可用6个术语来描述，即对象、类、属性、消息、操作和关系。系统的结构中心是对象，每个对象中有属性和操作，属性和操作封装在一个盒子里。对象之间通过传送消息来协调工作。每个对象又进一步抽象为类，类是对象实体的模板。对象之间的相互地位用关系表示。关系大致分为三大类，即关联关系、Part-Of关系和Is-a关系。关联关系表示对象之间对等访问或利用关系。对象之间存在关联，表示相连的对象之间可以传递消息。Part-Of关系表示一方是他方对象的一部分的包含关系，是对象间的集约关系。Is-a关系则是类间的包含关系。在Is-a关系中，子类既继承父类的性质，又有自己独有的性质。这里的性质是指属性、操作和关系。</p>
<p>面向对象的模型特征可以从以下几个方面体现。</p>
<p>1）抽象化</p>
<p>通过对象来抽象现实世界有两点好处：首先是能自然地表示现实世界，通过对现实世界的模仿，就可以类推出需要的功能和操作；其次，是很容易明确分析焦点，只要把现实世界的一个重要侧面模型化，在以后的分析中必须注重的焦点就自然明确了。抽象化除把现实世界的事物抽象为对象外，还把性质相同的对象群进一步抽象为类。通过这种层次式的抽象，便可构造事物的体系，很自然地把握现实世界。</p>
<p>2）封装化</p>
<p>封装化可以把对象内部的数据和操作过程隐藏起来，可以控制模块间信息公开和隐藏的范围。对外，只让看到过程的规格说明，使得对象的规格说明和实现相分离。封装化的最大效果是把对象的提供者和对象的使用者分开，对象的使用者只知道在对象中定义的操作的规格说明，对象内部的数据结构和操作过程是不知道的。有些过程群是为了访问特定的数据结构而设置的，可以集中放在类中，也不会影响到对象使用者的信息，为需求的变更带来方便，同时还可以拒绝非法使用者的访问，达到保密的目的。</p>
<p>3）继承化</p>
<p>面向对象模型中，父类的概念可继承到子类，且子类还可以有自己的新性质，这就叫继承性。继承性可有效地重用资源、提高生产效率，具体体现在两点上：一是可以把类作为体系化的手段，即多个子类的共同性质抽象为一个父类。由此，父类容易明白子类之间性质的不同及分类观点，也便于子类追加自己的性质。二是可利用继承性来定义新类，只要定义出与现有类的不同点就可以了，有利于产品重用和更改管理。</p>
<p>4）状态</p>
<p>对象中所定义的过程能否使用，实际上是通过内部的属性值来决定的。根据属性值，可以把对象分成多个不同的状态。每种状态下，都标识出此刻可使用的过程。把状态的概念放入对象规格说明中，使得对象的提供者能把正确接收消息的过程作为状态转移图，提供给使用者。</p>
<p>由面向对象模型的分析可看出，面向对象方法论的特征是能在早期获取模型结构和现实世界结构的对应关系，所有的软件都可以看成是现实世界的模拟。</p>
<p>类—责任—协作者（Class-Responsibility-Collaborator，CRC）模型是面向对象建模的对象描述工具，用于标识类、指明类的责任（属性和操作）以及类之间的协作（多个类协同完成某些操作）。面向对象模型还包括对象信息、行为模型等，它们从不同侧面（静态、动态）描述系统。</p>
<h4 id="嵌入式系统软件开发环境"><a href="#嵌入式系统软件开发环境" class="headerlink" title="嵌入式系统软件开发环境"></a>嵌入式系统软件开发环境</h4><h5 id="嵌入式系统开发概述"><a href="#嵌入式系统开发概述" class="headerlink" title="嵌入式系统开发概述"></a>嵌入式系统开发概述</h5><p>嵌入式系统的软件开发采用交叉平台开发方法（Cross Platform Development），即软件在一个通用的平台上开发，而在另一个嵌入式目标平台上运行。这个用于开发嵌入式软件的通用平台通常叫做宿主机系统，被开发的嵌入式系统称为目标机系统。而当软件执行环境和开发环境一致时的开发过程则称为本地开发（Native Development）。</p>
<h5 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h5><p>在嵌入式系统的实际开发实践中，经常采用的调试方法有直接测试法、调试监控法、在线仿真法、片上调试法及模拟器法等。</p>
<h5 id="开发环境分类"><a href="#开发环境分类" class="headerlink" title="开发环境分类"></a>开发环境分类</h5><p>嵌入式系统的开发环境可以分为如下几类。</p>
<p>（1）与嵌入式操作系统配套的开发环境。</p>
<p>（2）与处理器芯片配套的开发环境。</p>
<p>（3）与具体应用平台配套的开发环境。</p>
<p>（4）其他类。</p>
<h5 id="开发环境举例"><a href="#开发环境举例" class="headerlink" title="开发环境举例"></a>开发环境举例</h5><p>目前业界应用最广泛的集成开发环境为Tornadoll，美国WindRiver公司的VxWorks操作系统是Tornadoll嵌入式开发环境的关键组成部分。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch18-%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch18-%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch18-面向方面的编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:57:48" itemprop="dateCreated datePublished" datetime="2021-07-19T12:57:48+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 16:34:09" itemprop="dateModified" datetime="2021-09-04T16:34:09+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="面向方面的编程"><a href="#面向方面的编程" class="headerlink" title="面向方面的编程"></a>面向方面的编程</h2><p>随着计算机越来越广泛地应用于社会各个行业，应用软件的规模不断扩大，复杂度不断提高。传统的软件开发方法，如过程化程序设计、面向对象程序设计等已渐渐不能适应这种变化。近年来，一种新的程序开发方法——AOP（Aspect Oriented Programming，面向方面编程）引起了国内外的广泛关注，并被《MIT技术评论》杂志评为21世纪10种对经济和人类生活工作方式最具影响力的技术之一。</p>
<ul>
<li>切面相当于装饰器</li>
</ul>
<h3 id="方面编程的概念"><a href="#方面编程的概念" class="headerlink" title="方面编程的概念"></a>方面编程的概念</h3><h4 id="AOP产生的背景"><a href="#AOP产生的背景" class="headerlink" title="AOP产生的背景"></a>AOP产生的背景</h4><h5 id="面向过程编程面临的问题"><a href="#面向过程编程面临的问题" class="headerlink" title="面向过程编程面临的问题"></a>面向过程编程面临的问题</h5><p>面向过程编程是一种自顶向下的编程方法，其实质是对软件进行功能性分解。它适用于小型软件系统，例如某一算法的实现。在大型应用系统中，自顶向下逐步求精的方法无论在系统体系结构的确立，系统的进化和维护，以及软件重用性方面都存在其不足之处。</p>
<h5 id="传统面向对象编程面临的问题"><a href="#传统面向对象编程面临的问题" class="headerlink" title="传统面向对象编程面临的问题"></a>传统面向对象编程面临的问题</h5><p>传统的面向对象语言由于其良好的封装性、层次化性以及继承性等特性而取得了很大的成功，并且对象模型可以很好地映射到实际领域。但是，在软件的生命周期中，它存在以下不足之处。</p>
<p>（1）设计阶段，由于以类为单位组织建模，因此它不能全面地反映软件系统的需求。</p>
<p>（2）编码阶段，将数据和方法封装到类中的思想增强了数据的安全性和软件的模块化，但是有一些数据和方法是特定于应用的，因此这种编码阶段的封装减少了代码重用的可能性。</p>
<p>（3）维护阶段，由于类中夹杂了各种特定于应用的代码，使得维护人员难以理解代码。此外，完成某个特定需求的代码分散在各个类中，当这些代码需要改变时，很难把它们全部找到，这就给程序的健壮性带来了隐患。</p>
<p>由于上述这些问题的产生，需要一种新的程序设计方法从更高的层次上对软件系统进行抽象，将传统的按功能或按对象划分程序模块的方法转化为按系统特征划分程序模块，这就是AOP的基本思想。</p>
<h5 id="AOP的产生"><a href="#AOP的产生" class="headerlink" title="AOP的产生"></a>AOP的产生</h5><p>在1997年的欧洲面向对象编程大会（ECOOP97）上，施乐公司Palo Alto研究中心首席科学家、大不列颠哥伦比亚大学教授Gregor Kiczales等人首次提出了AOP的概念，此后每年的ECOOP上都有AOP相关的专题研讨会，各大公司、大学、研究机构纷纷投入人员进行研究。2001年3月15日，Palo Alto研究中心发布了首种支持AOP的语言AspectJ。</p>
<h4 id="面向方面的原因"><a href="#面向方面的原因" class="headerlink" title="面向方面的原因"></a>面向方面的原因</h4><p>为了理解和完成一个复杂的程序，通常要把程序划分为若干较小的子程序。理想的划分准则已成为众多研究的题目——这些研究的目标对开发人员在程序的设计、发展、维护和更新方面有所帮助。</p>
<p>当一个程序按实现过程编写时，应用程序依照实现的行为和步骤模块化。当使用面向对象的方法时，程序的模块化组则基于类中封装的数据。两种情况下，某些操作较难实现模块化。我们称涉及到这些操作的代码是分散的。</p>
<h5 id="代码分散现象"><a href="#代码分散现象" class="headerlink" title="代码分散现象"></a>代码分散现象</h5><p>无论是使用面向对象程序设计还是其他方法，代码分散的问题与特定的程序设计语言没有关系，且其影响已经在大量的应用程序中表现出来。事实上，代码分散可能出现在任何编程环境——从J2SE或J2EE下的Java，到.NET下的C#，到其他语言。但对此现象最广泛的研究是用Java实现的。</p>
<p>例如，AspectJ小组分析了Tomcat服务器的容器。他们认识到，如果像URL模式匹配和XML分析这些操作在一个或两个类中完全模块化，其他操作会高度分散在引用程序中，例如日志功能和对使用者通信的管理。</p>
<h5 id="关于代码分散的分析"><a href="#关于代码分散的分析" class="headerlink" title="关于代码分散的分析"></a>关于代码分散的分析</h5><p>知道了代码分散的出现，那么是否可以不同地组织类的结构或用其他方法设计程序来消除这个问题呢？</p>
<p>代码分散现象发生的主要原因与服务的可用方式和其使用方式的不同有关。一个类通过它的方法提供一个或多个服务。在同一个类中，聚集可用的服务是相对容易的。然而，一旦这些服务被若干个类所使用，将对这些方法的调用聚集在一起并重新构建这个应用程序会变得困难。因此，一个基本的服务在应用程序中到处被调用就没有什么奇怪的了。</p>
<p>代码分散现象在所有复杂程序中都会表现出来。然而，它的出现实际上依赖于一个具体的问题，代码分散问题很难去除。</p>
<p>应用程序中的代码分散减慢了程序的发展、维护和更新的速度。当若干个操作被分散，情况就会变得更复杂，因为代码包含了许多对多种关系的调用，这些关系逻辑上联系松散但需要结合在一起。</p>
<h5 id="一个模块化的新因素"><a href="#一个模块化的新因素" class="headerlink" title="一个模块化的新因素"></a>一个模块化的新因素</h5><p>AOP主要的贡献在于在某一方面提供了一种融合代码的方式——否则这些代码会分散在整个应用程序中。</p>
<p>方面的定义：一个设计来用于捕捉应用程序横切面功能的程序单位。</p>
<p>一个方面通常描述为一个横切程序的结构。实际上，方面这个概念的发明者Gregor Kiczales提到，“AOP是用来捕捉一个横切的结构。”</p>
<p>方面的定义几乎和类一样普通。当对一个问题建模时，人们用类来表示对象（顾客、命令和供应者等）的种类，且每个对象包含适当的数据（属性）和过程（操作）。同样地，方面用于实现一个应用程序中的功能性（安全性、持续性、日志记录等等），而这些功能性要求同样的数据和处理。使用AOP时，一个应用程序包含各个类和方面。方面与类的不同在于它实现了横切程序的功能。在面向过程和面向对象的案例中，横切的功能就是那些遍及应用程序的代码。程序中包括类和方面意味着模块性可以在两个因素上实现：类实现基本的功能性（这个因素叫做结构性），方面实现横切的功能性（这个因素叫做可操作性）。</p>
<p>图18-1说明了方面在应用程序的代码优化上的作用。图18-1（a）表现了一个含有三个类的程序。水平线表示代码行相应的横切的功能性，如日志功能。这种功能横切整个应用程序，因其可影响所有类。图18-1（b）显示使用了方面处理日志功能的同样的程序（带阴影的矩形）。实现这个功能的代码已完全被这个方面所包含，而类则与这些代码分离了。用这种方法设计的程序比没用使用方面的程序容易编写、维护和改编。</p>
<details><summary>图18-1　横切功能中方面的影响</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904155143.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904155143.png';" /></details>


<h5 id="横切功能的综合"><a href="#横切功能的综合" class="headerlink" title="横切功能的综合"></a>横切功能的综合</h5><p>方面由两个部分组成：切入点和通知代码。</p>
<p>通知代码包括要执行的代码，切入点定义了程序中要执行的代码处的点。</p>
<p>显然，方面所包含的代码（或更准确地说，通知代码）依赖于你所要执行的操作。例如，若你想保证数据的持久性，需要在数据库编写保存数据的代码。虽然可以根据基本原理编写这些代码，但你极少会这样做。通常认为的良好的习惯做法是使用一个专门的API，例如Hibernate，通过这种类型的框架，这个方面的代码只是调用了API。这种工作方式意味着方面并不需要知道服务是怎样执行的，因而方面就与一个特定的执行独立了。</p>
<p>根据这种最优方法，一个方面只允许你整合一个贯穿程序的功能到程序中，这个功能利用一个专门的API执行。在图18-2中，方面PersistenceAspect使用Hibernate整合维持数据持续性的功能到类1和类3中。</p>
<details><summary>图18-2　使用方面实现横切的数据持续性功能的综合</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904155215.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904155215.png';" /></details>

<p>严格地说，一个方面并不直接执行一个横切程序的功能，而是使用了一个专门的API去实现。但为了使这方面的知识容易理解，仍可以说一个方面执行了一个横切程序的功能。</p>
<h5 id="非功能的服务和方面"><a href="#非功能的服务和方面" class="headerlink" title="非功能的服务和方面"></a>非功能的服务和方面</h5><p>大多数应用程序有两种考虑：商业的和非功能的。商业的考虑，也叫做功能上的需求，符合真实世界需要建模的行为。非功能的考虑，或非功能的需求，是附加的服务，这些服务是应用程序必须执行的——事实上，这是出于技术上的或系统级上的考虑。例如，在一个管理人力资源的应用程序中，添加和删除雇员的功能是出于商业上的考虑，而程序安全性和权限的问题是非功能的。</p>
<p>无论如何，在利用这种差别的时候要仔细，因为一个服务可以在一个程序中是非功能性的，但在另一个程序中却是功能性的。很多情况下，非功能性的服务会被遍及各处的商业层面上的代码调用。因此，非功能性的服务在AOP中会像方面一样实现，而商业的考虑则会向类一样实现。然而某些情况下，商业的考虑也可能横切程序——使其适合像方面一样实现。</p>
<h5 id="依赖性的颠倒"><a href="#依赖性的颠倒" class="headerlink" title="依赖性的颠倒"></a>依赖性的颠倒</h5><p>在面向对象或程序化编程中，一旦程序从API使用一个技术服务，设备与服务之间的一种依赖性就建立了，每个程序对API外在的调用会发生一种联系。当API改变了或它的语义发展了，整个程序中对它服务的调用就必须作出改变。这种修改有可能是非常昂贵的——尤其是当API被用在程序中众多不同的地方时。</p>
<p>另外，要使用API还需要理解它的主要原理。要知道应调用什么方法，应按什么顺序调用，应传递哪些参数等。非功能的服务要被包含进每个开发它的新程序中。所以，即使API只开发一次，它可能要包含进许多不同的应用程序中。</p>
<p>通过使用AOP，程序的开发者并不需要担心非功能的服务。方面开发者除了编写提供服务的代码外，还要管理程序中服务的融合。方面开发者的优势在于，专门的方面开发者比一般的程序开发者对服务有着更好的了解，而一般的程序开发者只是API的使用者。特别地，方面开发者能确定通过实现服务使用方式的某些约束，使服务的融合是合适的。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ivan820819/article/details/79744797">浅谈IOC–说清楚IOC是什么</a></li>
</ul>
<h4 id="AOP技术"><a href="#AOP技术" class="headerlink" title="AOP技术"></a>AOP技术</h4><p>AOP可以说是OOP（Object-Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当需要为分散的对象引入公共行为时，OOP则显得无能为力。也就是说，OOP允许定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能，日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为Aspect，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却被业务模块所共同调用的逻辑或责任封装起来，以减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为，那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天工的妙手将这些剖开的切面复原，不留痕迹。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似，例如权限认证、日志、事务处理。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>
<p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。然而殊途同归，实现AOP的技术特性却是相同的。</p>
<p>（1）join point（连接点）：是程序执行中的一个精确执行点，例如类中的一个方法。它是一个抽象的概念，在实现AOP时，并不需要去定义一个join point。</p>
<p>（2）point cut（切入点）：本质上是一个捕获连接点的结构。在AOP中，可以定义一个point cut，来捕获相关方法的调用。</p>
<p>（3）advice（通知）：是point cut的执行代码，是执行“方面”的具体逻辑。</p>
<p>（4）aspect（方面）：point cut和advice结合起来就是aspect，它类似于OOP中定义的一个类，但它代表的更多的是对象间横向的关系。</p>
<p>（5）introduce（引入）：为对象引入附加的方法或属性，从而达到修改对象结构的目的。有的AOP工具又将其称为mixing。</p>
<p>上述的技术特性组成了基本的AOP技术，大多数AOP工具均实现了这些技术。它们也可以是研究AOP技术的基本术语。</p>
<h4 id="AOP特性"><a href="#AOP特性" class="headerlink" title="AOP特性"></a>AOP特性</h4><p>衡量软件质量高低的要素主要包括可靠性、可扩展性、可重用性、兼容性以及易用性、易维护性等。AOP作为一种程序设计方法学，关注于提高软件的抽象程度和模块性，从而在很大程度上改善了软件的可扩展性、重用性、易理解性和易维护性，并由此提高影响软件质量的其他因素。下面通过对OOP和AOP在提高软件可扩展性、可重用性和易理解性、易维护性等方面的能力比较来阐述AOP特性。</p>
<p>（1）可扩展性：指软件系统在需求更改时程序的易更改能力。OOP主要通过提供继承和重载机制来提高软件的可扩展性，因此它的扩展性体现在类一级。AOP提供系统的扩展机制，通过扩展Aspect（AspectJ支持Aspect的继承机制）或增加Aspect，系统相关的各个部分都随之产生变化。由此带来的另一好处是在软件测试中，通过屏蔽某些Aspect，可以大大简化软件的测试复杂度，提高测试精度。</p>
<p>（2）可重用性：是指某个应用系统中的元素被应用到其他系统的能力。OOP的类机制作为一种抽象数据类型，提供了比过程化更好的重用性。泛化机制也使可重用性得到很大提高。OOP所提供的重用性对非特定于系统的功能模块有很好的支持，如对于堆栈的操作或窗口机制的实现等。但在特定于系统的功能模块中，一个类通常包含很多应用系统相关的数据及对其的操作，此时类的重用性变得十分困难。此外，OOP的重用性也限于类一级，对于不能封装成类的元素，如异常处理等，很难实现有效的重用。AOP中的系统模块包括系统组件和影响这些组件的特性，通过将实现基本功能的组件和特定于应用的系统特性分离，使得组件（包括类或者函数）的重用性得到提高，并使不能封装为类或函数的系统元素（Aspect）的重用成为可能。</p>
<p>（3）易理解性和易维护性：是影响软件质量的内在因素，它对软件开发人员和维护人员产生影响。在OOP中，类机制的引入使其具有比过程化编程更好的模块性，因此也更易于被程序员理解和维护。但是如上所述的代码缠结问题的存在，使OOP技术在易理解性和易维护性方面都难有更大的提高。Kiczales经过统计发现：“如果一个他人写的程序有37处需要改动，对于一个最优秀的软件开发人员，也大概只能找到35个”。而对于AOP，对一个aspect的修改可以通过联结器影响到系统相关的各个部分，从而大大提高了系统的易维护性。另外，对系统特征的模块化封装无疑也能提高程序的易理解性。</p>
<h4 id="AOP程序设计"><a href="#AOP程序设计" class="headerlink" title="AOP程序设计"></a>AOP程序设计</h4><h5 id="AOP程序结构"><a href="#AOP程序结构" class="headerlink" title="AOP程序结构"></a>AOP程序结构</h5><p>基于AOP的应用程序结构与传统高级语言的应用程序结构基本类似。传统的高级语言系统实现由以下三部分组成。</p>
<p>（1）一种编程语言。</p>
<p>（2）特定于这种语言的编译器。</p>
<p>（3）利用这种语言编写的应用程序。</p>
<p>基于AOP的系统实现也有以上三个主要部分，但由于AOP中有了动态aspect的概念，因此可进一步细化为如下部分。</p>
<p>（1）一种组件语言，一种或多种aspect语言。</p>
<p>（2）一个用来合并两者的aspect编织器（weaver）。</p>
<p>（3）利用组件语言实现的系统组件，利用aspect实现的aspect组件。</p>
<h5 id="AOP的程序设计步骤"><a href="#AOP的程序设计步骤" class="headerlink" title="AOP的程序设计步骤"></a>AOP的程序设计步骤</h5><p>AOP应用程序包括以下三个主要的开发步骤。</p>
<p>（1）将系统需求进行功能性分解，区分出普通关注点以及横切关注点，确定哪些功能是组件语言必须实现的，哪些功能可以以aspect的形式动态加入到系统组件中。</p>
<p>（2）单独完成每一个关注点的编码和实现，构造系统组件和系统aspect。这里的系统组件，是实现该系统的基本模块，对OOP语言，这些组件可以是类；对于过程化程序设计语言，这些组件可以是各种函数和API。系统aspect是指用AOP语言实现的将横切关注点封装成的独立的模块单元。</p>
<p>（3）用联结器指定的重组规则，将组件代码和aspect代码进行组合，形成最终系统。为达到此目的，应用程序需要利用或创造一种专门指定规则的语言，用它来组合不同应用程序片断。这种用来指定联结规则的语言可以是一种已有编程语言的扩展，也可以是一种完全不同的全新语言。将以上过程用图18-3的形式来表示，该图中将系统需求看作一束光线，需求光束通过可标识关注点的棱镜将每个关注点区分开，形成单独关注点的实现，最后通过另一个Weaver棱镜将这些关注点整合，形成最终的应用程序。</p>
<details><summary>图18-3　AOP系统开发过程示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904155824.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904155824.png';" /></details>

<h4 id="AOP的优势"><a href="#AOP的优势" class="headerlink" title="AOP的优势"></a>AOP的优势</h4><p>面向方面的技术具有很多潜在的优势，它为在系统中详细指定并封装横切点提供了方法。随着它们的发展，允许我们更好地进行系统维护。AOP还将使我们对现存系统以一种有组织的方式增加新的特点。表达及结构方面的提高允许我们保持系统运行更长的时间，并且不会带来完全改写的开销就可以增量地对其维护。</p>
<p>AOP还是质量专业人员工具箱的利器。使用AOP语言，可以自动测试应用程序代码而不会对代码带来干扰。这将消除可能的代码错误。</p>
<p>在理解AOSD（方面面向软件设计）全部潜能中我们还处于一个初始阶段。显然，这项技术为保证未来的探索与实验提供了足够多的优点。距离每日使用AOP语言进行应用程序开发还有多远？这取决于我们向谁询问这个问题。</p>
<p>现在已经看到了一些优点，下面来看一些关于AOSD的风险，以及将其引入软件开发主流所需要的东西。</p>
<h5 id="质量及风险"><a href="#质量及风险" class="headerlink" title="质量及风险"></a>质量及风险</h5><p>基于从质量的角度所做出的考察以及所完成的对AspectJ的探索，我已经看到了伴随着优点所带来的潜在风险。下面将讨论三个问题，以说明随着AOSD越来越普遍所带来的我们需要面对的关于质量的问题。</p>
<p>（1）如何修正我们的过程来适合AOP。最有效的探测软件缺陷的技术之一是通过代码检查及复审。在复审中，一组程序员评论代码，以决定其是否满足了需求。在面向对象程序设计中，可以对类或一组相关类进行复审，并进行推论。可以查看代码并确定其是否正确处理了意料之外的事件，是否具有逻辑上的缺陷等。在OO系统中，每个类完全封装了特定概念的数据以及行为。</p>
<p>但是，在AOP中，仅仅通过代码查看，我们不再能够进行推论。我们并不知道代码是否被来自某些方面的通知所增长，或是完全被这种通知所取代。为了能够对应用程序代码做推断，我们必须能够查看来自每个类的代码，以及能够影响这个类行为的任何一个方面的代码。但是，也许这些方面还没有被编写出来。如果这样，那么当我们孤立地考虑它的时候，我们实际上能够对这个应用程序类的代码行为理解多少呢？</p>
<p>实际上，考虑AOP代码正确性的方法与我们考虑面向对象的程序设计代码是相反。在OOP中，我们自内向外：我们考虑一个类，对它的上下文环境做假设，然后通过孤立的以及按照它如何与其他类交互的两种方式推断它的正确性。在AOP中，需要从外向内来看，并确定在可能的连接点上每个方面的效果。确定如何才能正确推断AOP，以及开发适宜的技术和工具来帮助我们是一个值得研究的领域。</p>
<p>（2）测试工具以及技术的开发，特别是单元测试。由于代码可以被某一个方面所改变，当一个可以完美运行的单元测试的类被集成入一个AOP系统中时，可能会出现完全不同的运行状况。下面的例子说明了这一点。</p>
<p>例如，堆栈是一种数据结构，被用来以后进先出的模式增加或移除条目。如果向堆栈压入数据2、4、6，然后弹出栈两次，将按照顺序得到6与4。可以很直观地写出对堆栈类的单元测试，并能够很好地保证实现是正确的。但当用AspectJ实现了一个简单的改变——对每个条目做增一操作时，向栈上压入2、4、6，然后从栈顶弹出两个元素。单元测试的代码并没有改变，但是行为改变了。不再是6和4，而是变成了7和5。</p>
<p>这是一个很小的例子，在真实环境中不太可能发生，但是它显示了一个恶意的程序员可以很容易地导致许多损害。即使我们忽略这种恶意的程序员，由于我们所做出的改变存在着许多副作用，许多错误仍然可能发生。要保证一个为非常有效推断所实现的方面不会对现存程序功能带来多余的效果是非常困难的。</p>
<p>（3）测试过程本身。一旦我们有了一组工具及技术，如何修改我们的测试过程以有效地使用它们并且能够支持我们整体的开发目标？虽然这个问题也许并不是一个主要的问题，我仍然相信在我们可以真正地对采用方面所构件的软件进行很好的测试以前需要解决它。</p>
<p>对AOSD采用的其他障碍</p>
<p>质量问题也许是对AOSD方法采用的最大阻碍，但是它们并不是唯一的。AOSD是一种新的范例。正如其他范例一样，当它们刚刚出现时（例如面向对象的软件开发），由于所包含的学习曲线，需要经历一段时间才能被广泛采用。首先，我们需要学习基本技术以及结构，然后是高级技术，再然后是如何更好地应用技术以及什么时候它们才是最适合的。</p>
<p>工具在AOP中具有很重要的地位。除了编译器以及编辑器之外，我们需要能够帮助我们推断系统，确定潜在横切关注点，以及能够帮助我们对所存在的方面进行测试的工具。例如在UML中描述方面，我们的工具必须发展以支持这些方法。</p>
<p>此外，其他类似于AOP的范例也正在出现中。例如，关注点范例的多维分离，已在IBM研究院处于发展中（<a target="_blank" rel="noopener" href="http://www.alphaworks.ibm.com/tech/hyperj%EF%BC%89%E3%80%82%E4%BB%BB%E4%BD%95%E5%AF%B9%E6%96%B0%E8%8C%83%E4%BE%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E9%83%BD%E6%98%AF%E6%9C%89%E9%A3%8E%E9%99%A9%E7%9A%84%EF%BC%8C%E7%9B%B4%E8%87%B3%E5%AF%B9%E4%BD%A0%E6%89%80%E4%BD%BF%E7%94%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%E8%A2%AB%E5%BB%BA%E7%AB%8B%E8%B5%B7%E6%9D%A5%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8CAspectJ%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%8D%E7%84%B6%E5%8F%91%E5%B1%95%E7%9A%84AOP%E5%AE%9E%E7%8E%B0%E3%80%82%E9%A3%8E%E9%99%A9%E6%98%AF%EF%BC%8C%E4%B9%9F%E8%AE%B8%E4%BD%A0%E5%BC%80%E5%8F%91%E4%BA%86%E5%90%88%E5%B9%B6%E5%85%A5%E6%A8%AA%E5%88%87%E7%82%B9%E7%9A%84%E8%BD%AF%E4%BB%B6%EF%BC%8C%E4%BD%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E6%88%96%E8%80%85%E5%B0%86%E4%B8%8D%E5%86%8D%E8%A2%AB%E6%94%AF%E6%8C%81%EF%BC%8C%E6%88%96%E8%80%85%E8%A6%81%E5%81%9A%E5%BE%88%E5%A4%A7%E7%9A%84%E6%94%B9%E5%8A%A8%E3%80%82">http://www.alphaworks.ibm.com/tech/hyperj）。任何对新范例的使用都是有风险的，直至对你所使用语言的标准实现被建立起来。例如，AspectJ是一个仍然发展的AOP实现。风险是，也许你开发了合并入横切点的软件，你的实现方案或者将不再被支持，或者要做很大的改动。</a></p>
<h5 id="向构建软件的更好方法前进"><a href="#向构建软件的更好方法前进" class="headerlink" title="向构建软件的更好方法前进"></a>向构建软件的更好方法前进</h5><p>很显然，我们具有一种能够为使AOP对日常应用可行化而开发工具与过程的方法。但是，这里讨论的任何问题不代表不可克服的困难。当为AOP开发出经得起考验的一组工具与流程时，可以找到比今天所做的更好的构建软件的方法。</p>
<p>正如Barry M. Boehm所述的关于敏捷流程，我们必须小心的采用AOP。无论是作为早期应用者或是等待这种技术成为主流，都需要确保软件投资者在今天或是未来能够提供可接受的回报，这是非常好的商业判断力。</p>
<h4 id="当前的AOP技术"><a href="#当前的AOP技术" class="headerlink" title="当前的AOP技术"></a>当前的AOP技术</h4><p>当前，各种AOP技术层出不穷，其中相当成熟完善适用于商业开发的AOP技术主要包括AspectJ、AspectWerkz、JBoss AOP和Spring AOP，这些皆适合用于商业开发中的开源项目。AOP是一种概念，不同的技术可以有不同的实现。</p>
<p>在语法方面，AspectWerkz、JBoss AOP和Spring AOP都在没有改变Java语言语法的情况下加入了方面语义，而AspectJ则对Java语言进行了扩展。</p>
<p>在声明方式方面，AspectJ在代码中对方面进行声明。AspectWerkz和JBossAOP支持用元数据对Java代码进行注释，或者在独立的XML文件中对方面进行声明。在SpringAOP中，则完全用XML对方面进行声明，比起JBossAOP和AspectWerkz，SpringAOP提供了更加精细的配置。</p>
<p>在性能方面，AspectJ通过编译时对目标二进制类的增强获得面向方面能力，所以在编译时会带来开销，运行时可获得更快的速度。JBossAOP和SpringAOP基于拦截技术则在运行时有更多的工作要做，对比之下，AspectJ的构建时开销最多，AspectWerkz次之，JBossAOP再次，SpringAOP没有构建时开销。</p>
<p>下面将重点介绍AspectJ和SpringAOP的概念构造与实践。</p>
<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><h4 id="AspectJ概述"><a href="#AspectJ概述" class="headerlink" title="AspectJ概述"></a>AspectJ概述</h4><p>AspectJ既是一个语言规范，又是一个AOP语言实现。语言规范部分定义了多种语言构造以及它们支持面向方面范型的方式；语言实现部分则提供了编译、调试及从代码生成文档的工具。</p>
<p>AspectJ的语言构造是从Java语言中扩展而来的，因此所有合法的Java程序也都是合法的AspectJ程序。AspectJ编译器生成的是符合Java字节码规范的．class文件，这使得所有符合规范的Java虚拟机都可以解释、执行其所生成的代码。通过选择Java为基础语言，AspectJ继承了Java的所有优点并使Java程序员能够比较容易地上手。</p>
<p>AspectJ还提供了许多有用的工具。它有一个方面编织器（以编译器的方式）、一个调试器、文档生成工具以及一个独立的可用来以可视化的方式观察通知是如何切入系统各部分的方面浏览器。另外，AspectJ还提供了与流行IDE的集成，如Sun公司的Forte、Borland公司的JBuilder以及Emacs等，这使得AspectJ成为一个很有用的AOP实现，特别是对Java开发者而言。</p>
<h4 id="AspectJ语言概念和构造"><a href="#AspectJ语言概念和构造" class="headerlink" title="AspectJ语言概念和构造"></a>AspectJ语言概念和构造</h4><h5 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h5><p>连接点是AspectJ中的一个重要概念，它是程序执行过程中明确定义的点。连接点可能定义在方法调用、条件检测、循环的开始或是赋值动作处。连接点有一个与之相关联的上下文。例如，一个方法调用连接点的上下文可能会包含一个目标对象及调用参数等。</p>
<p>虽然程序执行过程中所有可以确认的点都可以是连接点，但并不是每个点都是有用的。在AspectJ中，有下列可用的连接点。</p>
<p>（1）方法的调用（call）和执行（execution）。</p>
<p>（2）构造器（constructor）的调用和执行。</p>
<p>（3）对属性（field）的读/写访问。</p>
<p>（4）异常处理的执行。</p>
<p>（5）对象和类的初始化执行。</p>
<p>AspectJ中没有提供在像if条件检查或for循环这样细粒度语言构造上的连接点。</p>
<h5 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h5><p>切入点是用来指明所需连接点的程序构造，可以用它来指明一系列的连接点。同时，它还可以为在连接点上执行的通知提供上下文信息。例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160125.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160125.png';" /></details>


<p>其中，pointcut关键字表明其后是一个命名的切入点的声明。接着，callSayMessagc()是切入点的名字，这与方法声明类似。其后的空括号表明此切入点不需要上下文信息。</p>
<p>再往后，call (public static void HelloWorld.say*(…)) 捕获所需的连接点。call表明此切入点捕获对指定方法的调用，而不是方法的执行或是别的什么。public static void HelloWorld.say*(…) 是将会产生影响的方法的签名。void是说所捕获的方法必须要有一个void返回类型。HelloWorld.say<em>指明将要捕获的方法的类和名字。这里，我们指定HelloWorld类；say</em>使用通配符，来说明要捕获的方法应以say开始。最后，（…）指明了将要捕获的方法的参数列表。这里使用了“…”，表示任何形式的参数列表都在考虑范围之内。</p>
<p>现在，你已经知道了如何指定切入点来捕获连接点，下面再来看一下其他的切入点类型。</p>
<p>1）方法调用和构造器调用切入点</p>
<p>方法调用和构造器切入点捕获执行中准备好了方法参数后而尚未执行方法本身时的那个点。它们的形式是call（方法或是构造器的签名）。</p>
<p>2）方法执行和构造器执行切入点</p>
<p>方法执行和构造器执行切入点捕获方法的执行，与调用切入点相比，执行切入点体现在方法和构造器本身。其形式为execution（方法或是构造器的签名）。</p>
<p>3）属性访问切入点</p>
<p>属性访问切入点捕获对一个类中属性的读写访问。可以捕获所有对System类中的out属性的访问，如System.out；也可以仅捕获读访问或写访问。举个例子来说，可以捕获对MyClass的属性x的写访问，其形式为MyClass.x=5。读访问切入点的形式为get（FieldSignature）；写访问切入点的形式则为set（FieldSignature）。其中FieldSignature可以用与调用或执行切入点里的McthodOrConstructor同样的方式使用通配符。</p>
<p>4）异常处理切入点</p>
<p>异常处理切入点捕获特定类型异常处理的执行，其形式为handler（ExceptionTypePattern）。</p>
<p>5）类初始化切入点</p>
<p>类初始化切入点捕获类初始化部分中静态部分的执行，这里静态部分是指类定义中Static代码块中指定的代码。其形式为staticinitialization（TypePattarn）。</p>
<p>6）基于语法结构的切入点</p>
<p>基于语法结构的切入点捕获一个类或方法中所有语法结构里的连接点。捕获类（包括内部类）中的语法结构连接点的切入点形式为within（TypePattern），捕获类方法或类构造器中的语法结构连接点的切入点形式为withincode（Method-OrConstructor-Signature）。</p>
<p>7）基于控制流的切入点</p>
<p>基于控制流的切入点捕获所有指定范围的控制流（程序的指令流）内的连接点。例如，在某个执行过程里，方法a调用方法b，方法b就在方法a的控制流里。通过使用基于控制流的切入点，可以捕获由于一个方法调用而引发的所有方法调用、属性访问及异常处理等。这种类型的切入点可捕获在其控制流内的其他切入点，如果包括其自身，形式为cflow（pointcut）；如果不包括其自身，则形式为cflowbelow（Pointcut）。</p>
<p>8）基于当前对象、目标对象及参数类型的切入点</p>
<p>此类切入点可捕获定义在对象自身、目标对象或参数上的连接点。它是唯一可以在连接点上取得上下文的语言构造，捕获基于当前对象的连接点的切入点形式为this（TypePattern或Objecctldentifier），捕获某个目标对象的连接点的切入点形式为target（TypePattern or ObjectIdentifier），基于参数的切入点形式为args （TypePattern orObjectIdentifier，…）。</p>
<p>9）条件测试切入点</p>
<p>这种切入点基于某种条件测试捕获连接点，其形式为if（BooleanExpression）。</p>
<h5 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h5><p>通知指定当到达特定切入点处应执行的代码。AspectJ提供了三种把通知关联到连接点的方式：before、after及around。before通知在连接点的前面运行；after通知在连接点的后面运行。对于after通知而言，还可以指定是在正常返回后运行还是在抛出异常后运行，或者也可以是两种情况下都运行。around通知包在连接点的外面，并有权决定是否运行此连接点，还可以在此处修改连接点上下文环境。</p>
<h5 id="方面"><a href="#方面" class="headerlink" title="方面"></a>方面</h5><p>方面是AspectJ的模块单元，其地位就像是Java里的类。它把切入点和通知包在一起。和类相似，方面也可以包含方法和属性、从其他类或方面扩展以及实现接口等。与类不同的是，不能用new来建立一个方面实例。</p>
<p>AspectJ允许在类中声明切入点，但在类中只能声明static的切入点。而且AspectJ不允许类里包含通知，只有方面可以包含通知。</p>
<p>方面可以标记其自身和任何切入点为抽象的（abstract）。抽象的切入点，其概念与抽象类相似，允许把细节实现推迟到派生方面里。一个具体的方面可以从抽象的方面扩展而来，它要提供抽象方面里切入点的具体定义。</p>
<h4 id="AspectJ实践"><a href="#AspectJ实践" class="headerlink" title="AspectJ实践"></a>AspectJ实践</h4><p>AspectJ也许是已知最好的，并且应用最广泛的AOP实现。</p>
<p>图18-4描述了一种可以进行系统修正的方法。金融系统具有一个接口以及数个方法以更新雇员金融数据。方法名均以单词update开头（例如，updateFederalTaxlnfo），并且每个金融更新均以雇员对象做实参。雇员个人信息也通过雇员对象，使用图10-5所示的方法做更新。</p>
<p>我们的任务是，每一次当调用任何更新函数，或是更新成功完成后，写入一个日志消息。为了简单起见，我们说我们向标准输出打印了一个日志消息。在实际系统中，我们将写入一个日志文件。下面将通过三个步骤采用AspectJ实现我们的解决方案。</p>
<p>确定在代码中需要插入日志代码的位置。这被称作在AspectJ中定义连接点，编写日志代码，编译新代码并将其编织入系统中。下面详细描述每一个步骤。</p>
<h5 id="定义连接点"><a href="#定义连接点" class="headerlink" title="定义连接点"></a>定义连接点</h5><p>一个连接点是在代码中被良好定义的，我们所关注的应用程序横切的点。典型的，对每一个关注点存在着许多连接点。如果仅有一两个，通过很少的努力，就可以手工改写代码。</p>
<details><summary>图18-4　与更新雇员信息相关的类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160255.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160255.png';" /></details>

<p>在AspectJ中，通过将连接点分组为切点对其进行定义（AspectJ的语法十分丰富，我们将试图在此对其进行完整的描述）。初始，定义两个切点，分别将雇员类及IEmployeeFinance组件中的连接点分组。下列代码定义了这两个切点。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160314.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160314.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160321.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160321.png';" /></details>

<p>第一个切点称作employeeUpdates，描述了我们调用雇员对象中以字符串update开头，以字符串Info结尾，且无实参的方法的连接点位置，它还通过target指示器明确指定了在雇员类中定义的方法。第二个切点employeeFinanceUpdates，描述了所有以update开头，以Info结尾的，具有一个Employee类型实参的方法的调用点。合起来，这两个切点定义了所有我们关注的连接点。如果要为雇员类或IEmployeeFinance组件增加更多的更新方法，只要保持同样的命名规则，对它们的调用会自动被包含于切点中。这意味着当每次增加更新方法时，不需要特意地去包含日志代码。</p>
<h5 id="编写日志代码"><a href="#编写日志代码" class="headerlink" title="编写日志代码"></a>编写日志代码</h5><p>实现日志的代码与Java中其他任何方法都很相似，但是被置于一个称作方面的新风格中。方面是用来对与某一特定关注相关联的代码进行封装的一种机制。对雇主数据变更日志的方面实现如下所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160353.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160353.png';" /></details>

<p>首先，注意到方面的结构与Java中的类结构很相似。典型地，方面被置于它独有的文件中，正如Java的类一样。虽然通常的方法是在方面代码中包含以往定义的切点，但是也可以将它们更紧密地包括在含有切点的代码中。</p>
<p>在切点之后，有一段与常规Java代码中方法相似的代码，这被称作AspectJ中的通知。存在着三种不同类型的通知：before、after和around。它们分别在连接点之前、之后，或是取代连接点而执行。还存在着许多可以使用的变种以定制你自己的通知。在我们的例子中，选择连接点返回中的更新方法之后立即运行日志。还要注意到，我们通过在冒号之后的通知头中立即分别对它们命名，以及通过逻辑“或”的方式组合两个切点。因为每个切点都有一个雇员参数，因此可以很容易地完成这项工作。</p>
<p>随着雇员名字，通知中的两条语句打印出了雇员信息被改变的事实。既然受到影响的雇员对象作为实参被传递给通知，那么这很容易安排。第二条语句指明了通知被执行的确切连接点，并且应用了AspectJ的JoinPoint类。只要通知执行，仅存在一个被thisJoinPoint引用的关联连接点。</p>
<h5 id="编译及测试"><a href="#编译及测试" class="headerlink" title="编译及测试"></a>编译及测试</h5><p>现在，已经编写了日志代码，接下来需要编译并将其集成入现存的系统。为了方便起见，已经实现了两个类：Employee和EmployeeFinance。我们还拥有一个具有主函数的简单测试类，如下所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160416.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160416.png';" /></details>

<p>这个代码不需要任何AOP实现就可以很好地运行。为了我们的例子，所有更新方法的函数体仅包含一个打印语句。当运行这个例子时，得到如下输出：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904160434.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904160434.png';" /></details>

<p>为了将我们的方面合并入系统，我们向项目中增加了方面的源代码，并且采用AspectJ编译器，ajc进行编译。编译器接受每一个方面，并建立包含通知代码的类文件。然后，在这些类文件中对适当方法的调用被编织入原始应用程序代码。在当前AspectJ的发行版中，这种编织在Java字节码级别发生，因此不存在可以进行查阅以对最终代码进行审查的中间源文件。但是，如果你很好奇，可以对Java字节码进行反编译。</p>
<p>在开发中，我使用Eclipse，而AspectJ插件保证采用正确的实参调用编译器。一旦利用AspectJ编译器对项目进行了编译，得到如下输出：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904162920.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904162920.png';" /></details>

<p>现在，我们知道哪个雇员信息被改变，以及改变是在哪里发生的。当然，日志可以更精细，但是基本的方法没有变化。</p>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="Spring-AOP概述"><a href="#Spring-AOP概述" class="headerlink" title="Spring AOP概述"></a>Spring AOP概述</h4><p>在有很多的开放源代码和专有的J2EE Framework时，Spring Framework能够脱颖而出，并且一枝独秀，我们应该相信Spring是独特的。Spring定位的领域是许多其他流行的Framework不具有的，Spring是全面的和模块化的，引入了方面（Aspect）提供一种新的方法来管理你的业务对象。Spring有分层的体系结构，这意味着你能选择使用它的任何部分，它的架构仍然是内在稳定的。</p>
<p>Spring的架构性，能有效地组织你的中间层对象，无论你是否选择使用了EJB。如果你仅仅使用了Struts或其他的包含了J2EE特有APIs的framework，你会发现Spring关注了遗留下来的问题，Spring能消除在许多工程上对Singleton的过多使用。Spring能够消除各类属性文件的定制，在Spring应用中大多数业务对象没有依赖于Spring，创建的应用程序更易于单元测试。</p>
<p>Spring为已建立的企业级应用提供了一个轻量级的解决方案，这个方案包括声明式事务管理，通过RMI或webservices远程访问业务逻辑，mail支持工具以及数据库持久化的多种选择。Spring还提供了一个MVC应用框架、可以透明地把AOP集成到你的软件中的途径和一个优秀的异常处理体系，包括自动从Spring特有的异常体系中映射。</p>
<p>Spring是潜在的一站式解决方案，定位于与典型应用相关的大部分基础结构。同时，Spring也是组件化的，允许使用它的部分组件而不需牵涉其他部分。可以使用Bean容器，在前台展现层使用Struts；还可以只使用Hibernate集成部分或是JDBC抽象层。Spring是无侵入性的，意味着根据实际使用的范围，应用对框架的依赖几乎没有或是绝对最小化的。</p>
<p>Spring包含许多功能和特性，并被很好地组织在图18-5所示的7个模块中。</p>
<details><summary>图18-5　Spring框架图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163021.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163021.png';" /></details>

<p>Core包是框架的基础部分，并提供依赖注入特性来管理Bean容器功能。这里的基础概念是BeanFactory，它提供Factory模式来消除对程序性单例的需要，并允许从程序逻辑中分离出依赖关系的配置和描述。</p>
<p>构建于Beans包上的Context包，提供了一种框架式的Bean访问方式，有些像JNDI注册。Context包的特性得自Beans包，并添加了文本消息的发送，通过资源串、事件传播、资源装载的方式和Context的透明创建，如通过Servlet容器。</p>
<p>DAO包提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。该包也提供了一种方法实现编程性和声明性事务管理，不仅仅是针对实现特定接口的类，而且对所有的POJO。</p>
<p>ORM包为流行的关系——对象映射APIs提供了集成层，包括JDO、Hibernate和iBatis。通过ORM包，可与所有Spring提供的其他特性相结合来使用这些对象/关系映射，如前边提到的简单声明性事务管理。</p>
<p>Spring的AOP包提供与AOP联盟兼容的面向方面编程实现，允许定义，如方法拦截器和切点，来干净地给从逻辑上说应该被分离的功能实现代码解析。使用源码级的元数据功能，可将各种行为信息合并到你的代码中。</p>
<p>Spring的Web包提供了基本的面向Web的综合特性，如Multipart功能，使用Servlet监听器的Context的初始化和面向Web的application Context。当与WebWork或Struts一起使用Spring时，这个包使Spring可与其他框架结合。</p>
<p>Spring的Web MVC包提供了面向Web应用的Model-View-Controller实现。Spring的MVC实现不仅仅是一种实现，它提供了一种domain model代码和web form的清晰分离，这使用户可使用Spring框架的所有其他特性，如校验。</p>
<h4 id="Spring语言概念和构造"><a href="#Spring语言概念和构造" class="headerlink" title="Spring语言概念和构造"></a>Spring语言概念和构造</h4><p>前面提到，AOP提供从另一个角度来考虑程序结构以完善面向对象编程。面向对象将应用程序分解成各个层次的对象，而AOP将程序分解成各个方面或者说关注点。这使得可以模块化诸如事务管理等这些横切多个对象的关注点，称作横切关注点。</p>
<p>Spring的一个关键组件就是AOP框架。Spring IoC容器（BeanFactory和Application-Context）并不依赖于AOP，这意味着如果不需要，可以不使用AOP。AOP完善了Spring IoC，使之成为一个有效的中间件解决方案。</p>
<h5 id="AOP在Spring中的使用"><a href="#AOP在Spring中的使用" class="headerlink" title="AOP在Spring中的使用"></a>AOP在Spring中的使用</h5><p>（1）提供声明式企业服务，特别是作为EJB声明式服务的替代品。这些服务中最重要的是声明式事务管理，这个服务建立在Spring的事务管理抽象之上。</p>
<p>（2）允许用户实现自定义的方面，用AOP完善他们的OOP的使用。这样，可以把Spring AOP看作是对Spring的补充，它使得Spring不需要EJB就能提供声明式事务管理；或者使用Spring AOP框架的全部功能来实现自定义的方面。</p>
<h5 id="Spring-AOP的功能"><a href="#Spring-AOP的功能" class="headerlink" title="Spring AOP的功能"></a>Spring AOP的功能</h5><p>Spring AOP用纯Java实现，不需要特别的编译过程，区别于AspectJ的实现。Spring AOP不需要控制类装载器，因此适用于J2EE Web容器或应用服务器。</p>
<p>Spring目前支持拦截方法调用。成员变量拦截器没有实现，虽然加入成员变量拦截器支持并不破坏Spring AOP核心API。Spring提供代表切入点或各种通知类型的类。Spring使用术语advisor来表示代表方面的对象，它包含一个通知和一个指定特定连接点的切入点。各种通知类型有MethodInterceptor，来自AOP联盟的拦截器APD和定义在org.springframework.aop包中的通知接口。所有通知必须实现org.aopalliance.aop.Advice标签接口。取出就可使用的通知有MethodInterceptor、ThrowsAdvice、BeforeAdvice和AfterReturningAdvice。</p>
<p>Spring实现AOP的途径不同于其他大部分AOP框架，它的目标不是提供及其完善的AOP实现（虽然Spring AOP非常强大）；而是提供一个和Spring IoC紧密整合的AOP实现，帮助解决企业应用中的常见问题。因此，例如Spring AOP的功能通常是和Spring IoC容器联合使用的。AOP通知是用普通的bean定义语法来定义的（虽然可以使用autoproxying功能）。通知和切入点本身由Spring IoC管理，这是一个重要的其他AOP实现的区别。有些是使用Spring AOP无法容易或高效地实现，例如通知非常细粒度的对象。这种情况AspectJ可能是最合适的选择。但是，我们的经验是Spring针对J2EE应用中大部分能用AOP解决的问题提供了一个优秀的解决方案。</p>
<h5 id="Spring-AOP的重要概念"><a href="#Spring-AOP的重要概念" class="headerlink" title="Spring AOP的重要概念"></a>Spring AOP的重要概念</h5><p>前面已经提到了AOP的重要概念，下面介绍在Spring中的定义和实现。</p>
<p>（1）方面：一个关注点的模块化，这个关注点的实现可能横切另外多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的Advisor或拦截器实现。</p>
<p>（2）连接点：程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</p>
<p>（3）通知：在特定的连接点，AOP框架执行的动作。各种类型的通知包括around、before和throws通知。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。</p>
<p>（4）切入点：指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点。例如，使用正则表达式。</p>
<p>（5）引入：添加方法或字段到被通知的类。Spring允许引入新的接口到任何被通知的对象。例如，可以使用一个引入使任何对象实现IsModified接口，来简化缓存。</p>
<p>（6）目标对象：包含连接点的对象。也被称作被通知或被代理对象。</p>
<p>（7）AOP代理：AOP框架创建的对象，包含通知。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
<p>（8）织入：组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<p>特别指出，Spring默认使用JDK动态代理实现AOP代理。这使得任何接口或接口的集合能够被代理。Spring也可以是CGLIB代理。这可以代理类，而不是接口。如果业务对象没有实现一个接口，CGLIB被默认使用。但是，作为一针对接口编程而不是类编程的良好实践，业务对象通常实现一个或多个业务接口。</p>
<p>前面提到横切关注点是AOP中的重要因素，使之独立于OO的层次选定目标，横切点到系统的切入点理所当然是构成系统的结构要素。下面看看Spring是如何处理切入点这个重要因素的。</p>
<p>Spring的切入点模型能够使切入点独立于通知类型被重用，同样的切入点有可能接受不同的通知。org.springframework.aop.Pointcut接口是重要的接口，用来指定通知到特定的类和方法目标。完整的接口定义如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163154.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163154.png';" /></details>

<p>将Pointcut接口分成两个部分有利于重用类和方法的匹配部分，并且组合细粒度的操作（如和另一个方法匹配器执行一个“并”的操作）。ClassFilter接口被用来将切入点限制到一个给定的目标类的集合。如果matches永远返回true，所有的目标类都将被匹配。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163209.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163209.png';" /></details>

<p>MethodMatcher接口通常更加重要。完整的接口如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904163221.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904163221.png';" /></details>

<p>matches（Method，Class）方法被用来测试这个切入点是否匹配目标类的给定方法。这个测试可以在AOP代理创建的时候执行，避免在所有方法调用时都需要进行测试。如果两个参数的匹配方法对某个方法返回true，并且MethodMatcher的isRuntime()也返回true，那么三个参数的匹配方法将在每次方法调用时被调用。这使得切入点能够在目标通知被执行之前立即查看传递给方法调用的参数。</p>
<p>大部分MethodMatcher都是静态的，意味着isRuntime()方法返回false。这种情况下，三个参数的匹配方法永远不会被调用。如果可能，尽量使切入点是静态的，使当AOP代理被创建时，AOP框架能够缓存切入点的测试结果。当然，目前的技术只实现了方面静态织入，无法动态地在运行状态下组合方面。</p>
<h4 id="Spring-AOP应用"><a href="#Spring-AOP应用" class="headerlink" title="Spring AOP应用"></a>Spring AOP应用</h4><p>Spring AOP是Spring框架的重要组成部分，它实现了AOP联盟约定的接口。Spring AOP是由纯Java开发完成的，它实现了方法级别的连接点，而在J2EE应用中，AOP拦截到方法级的操作已经足够了。由于OOP倡导的是基于setter/getter的方法访问，而非直接访问域，所以Spring仅仅提供方法级的连接点。为了使控制反转（IoC）很方便地使用健壮、灵活的企业服务，需要Spring AOP来实现，因为它在运行时才创建Advice对象。下面讨论使用Spring AOP松散耦合的几种方式。</p>
<h5 id="创建通知"><a href="#创建通知" class="headerlink" title="创建通知"></a>创建通知</h5><p>为实现AOP，开发者需要开发AOP通知（Advice）。AOP通知包含了方面（Aspect）的业务逻辑。当创建一个Advice对象时，就编写了实现横切（cross-cutting）功能的代码。Spring的连接点是用方法拦截器实现的，这就意味着编写的Spring AOP通知将在方法调用的不同点织入程序中。由于在调用一个方法时有几个不同的时间点，Spring可以在不同的时间点织入程序。</p>
<p>Spring AOP中，提供了如下4种通知的接口。</p>
<p>（1）MethodBeforeAdvice：用于在目标方法调用前触发。</p>
<p>（2）AfterReturningAdvice：用于在目标方法调用后触发。</p>
<p>（3）ThrowsAdvice：用于在目标方法抛出异常时触发。</p>
<p>（4）MethodInterceptor：用于实现Around通知（Advice），在目标方法执行的前后触发。</p>
<p>如果要实现相应的功能，则需要实现上述接口。例如，实现Before通知（Advice）需要实现方法void before（Method method，Object[] args，Object target）；实现After通知（Advice）需要实现方法void afterReturning（Method method，Object[] args，Object target）。</p>
<h5 id="在Spring中定义切入点"><a href="#在Spring中定义切入点" class="headerlink" title="在Spring中定义切入点"></a>在Spring中定义切入点</h5><p>在不能明确调用方法时，通知就很不实用。切入点则可以决定特定的类、特定的方法是否匹配特定的标准。如果匹配，则通知将应用到此方法上。Spring切入点允许用很灵活的方式将通知组织进我们的类中。Spring中的切入点框架的核心是Pointcut接口，此接口允许定义织入通知中的类和方法。许多方面就是通过一系列的通知和切入点组合来定义的。</p>
<p>在Spring中，一个advisor就是一个方面的完整的模块化表示。Spring提供了PointcutAdvisor接口把通知和切入点组合成一个对象。Spring中很多内建的切入点都有对应的PointcutAdvisor，因此可以很方便地在一个地方管理切入点和通知。Spring中的切入点分为两类：静态和动态。因为静态切入点的性能要优于动态切入点，所以优先考虑使用静态切入点。Spring为我们提供创建静态切入点很实用的类StaticMethodMatherPointcut，在这个类中，只需要关心setMappedName和setMappedNams方法，可以使用具体的类名，也可以使用通配符。例如，设置mappedName属性为set*，则匹配所有的set方法。Spring还提供了通过正则表达式来创建静态切入点的实用类RegexpMethodPointcut。通过使用Perl样式的正则表达式来定义感兴趣的方法。当切入点需要用运行时参数值来执行通知时，则使用动态切入点。Spring提供了一个内建的动态切入点ControlFlowPointcut，此切入点匹配基于当前线程的调用堆栈。只有在当前线程运行时找到特定的类和特定的方法才返回true，使用动态切入点有很大的性能损耗。大多数的切入点可以静态确定，我们很少有机会创建动态切入点。为了增加切入点的可重用性，Spring提供了切入点上的集合操作——交集和并集。</p>
<h5 id="用ProxyFactoryBean创建AOP代理"><a href="#用ProxyFactoryBean创建AOP代理" class="headerlink" title="用ProxyFactoryBean创建AOP代理"></a>用ProxyFactoryBean创建AOP代理</h5><p>ProxyFactoryBean和其他Spring的FactoryBean实现一样，引入一个间接的层次。如果定义一个名字为myfactory的ProxyFactoryBean，引用myfactory的对象所看到的不是ProxyFactoryBean实例本身，而是由实现ProxyFactoryBean的类的getObject()方法所创建的对象。这个方法将创建一个包装了目标对象的AOP代理。使用ProxyFactoryBean或者其他IoC可知的类来创建AOP代理最重要的一个优点是IoC可以管理通知和切入点。这是一个非常强大的功能，能够实现其他AOP框架很难实现的特定的方法。例如，一个通知本身可以引用应用对象（除了目标对象，它在任何AOP框架中都可以引用应用对象），这完全得益于依赖注入所提供的可插入性。通常，不需要ProxyFactoryBean的全部功能，因为我们常常只对一个方面感兴趣。例如，事务管理。当我们仅仅对一个特定的方面感兴趣时，可以使用许多便利的工厂来创建AOP代理，如TransactionProxyFactoryBean。</p>
<h5 id="自动代理"><a href="#自动代理" class="headerlink" title="自动代理"></a>自动代理</h5><p>在应用规模比较小，只有很少类需要被通知时，ProxyFactoryBean可以很好地工作。当有许多类需要被通知时，创建每个代理就显得很烦琐。幸运的是，Spring提供了使用自动通过容器来创建代理的功能。这时，只需要配置一个Bean来做烦琐的工作。Spring提供了两个类实现自动代理：BeanNameAutoProxyCreator和DefaultAdvisorAutoProxyCreator。BeanNameAutoProxyCreator为匹配名字的Bean产生代理，它可将一个或者多个方面应用在命名相似的Bean中。自动代理框架将自动产生代理要暴露出的接口。如果目标Bean没有实现任何接口，就会动态产生一个子类。而更强大的自动代理是DefaultAdvisorAutoProxyCreator，只需要在BeanFactory中包含它的配置就可完成代理。这个类的奇妙之处在于它实现了BeanPostProcessor接口。当Bean定义被加载到Spring容器中后，DefaultAdvisorAutoProxyCreator将搜索上下文中的Advisor，最后它将Advisor应用到匹配Advisor切入点的Bean中。这个代理只对Advisor起作用，它需要通过Advisor来得到需要通知的Bean。元数据自动代理（MetaDataAutoProxy）配置依赖于源代码属性而不是外部XML配置文件。这可以非常方便地将源代码和AOP元数据组织在同一个地方。元数据自动代理最常用的地方是用来声明事务，Spring提供了很强的AOP框架来声明事务。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch17-%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch17-%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch17-企业集成架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:57:20" itemprop="dateCreated datePublished" datetime="2021-07-19T12:57:20+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 15:36:39" itemprop="dateModified" datetime="2021-09-04T15:36:39+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="企业集成架构设计"><a href="#企业集成架构设计" class="headerlink" title="企业集成架构设计"></a>企业集成架构设计</h2><p>企业信息集成是解决“孤岛”问题的需要，技术发展的同时也推动了集成架构等相关的研究。企业集成平台的核心是企业集成架构，包括信息、过程、应用集成的架构。本章从集成平台概念出发，探讨相关的标准、规范、技术及设计模型，包括面向企业整体集成模型和作用。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42801723/article/details/105395540">信息化孤岛问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21516296">OA系统和EIP系统的区别？</a></li>
</ul>
<h3 id="企业集成平台"><a href="#企业集成平台" class="headerlink" title="企业集成平台"></a>企业集成平台</h3><p>信息时代的企业集成需要在一个开放的计算机支撑环境下实现。企业集成平台（Enterprise Integration Platform, EIP）技术是近年来用于企业信息系统集成的一种先进的计算机软件技术，其目的是能够根据业务模型的变化快速地进行信息系统的配置和调整，保证不同系统、应用、服务或操作人员之间顺畅地互操作，进而提高企业适应市场变化的能力，使企业能够在复杂多变的市场环境中生存。</p>
<p>企业集成的水平在很大程度上取决于企业内部各种系统、应用或服务的集成化运行水平，良好的软件支持工具可以帮助企业加快实现企业系统集成。作为支持企业集成化运行的工具，企业集成平台的主要功能是为企业中各种数据、系统和过程等多种对象的协同运行提供各种公共服务及运行时的支撑环境，从而降低实现企业内部的信息孤岛集成的复杂度，提高应用间集成的有效性，将信息系统实施规划中确定的企业中各种应用系统、服务、人员、信息资源及数字化设备的协同关系物化到集成化运行的可执行系统中去。</p>
<h4 id="企业集成平台的概念"><a href="#企业集成平台的概念" class="headerlink" title="企业集成平台的概念"></a>企业集成平台的概念</h4><p>企业集成平台概念的提出和发展来自于企业应用需求和计算机技术发展两方面的驱动。一方面，企业中各种业务信息系统（包含各种遗留信息系统）数量的增加为企业集成平台产生了需求拉动的作用；另一方面，计算机及软件技术的发展是产生企业集成平台的技术推动力。</p>
<p>实现企业集成的技术和手段多种多样，早期比较简单的集成方式是通过在不同的应用之间开发一对一的专用接口来实现应用之间的数据集成，即采用点到点的集成方式。这种点到点的集成方式的优点是比较直观，在企业应用数量少时易实现。但这种方式也存在比较多的问题：工作量大；集成系统的维护费用高，系统升级和扩展困难；不易于标准化，由于接口数量多，给系统管理造成比较大的困难；一般仅能够解决应用系统之间的数据集成问题，难以用来支持过程集成和应用之间的协调。</p>
<p>为了克服点到点集成方式给企业应用系统集成和维护管理带来的困难，人们提出了采用集成平台的方式来实现企业集成。企业集成平台是一个支持复杂信息环境下信息系统开发、集成和协同运行的软件支撑环境。它基于各种企业经营业务的信息特征，在异构分布环境（操作系统、网络、数据库）下为应用提供一致的信息访问和交互手段，对其上运行的应用进行管理，为应用提供服务，并支持企业信息环境下各特定领域的应用系统的集成。</p>
<p>经过多年的发展，集成平台已经成为支持企业集成的先进和有效的方法。基于集成平台，可以使分散的信息系统通过一个单一的接口，以可管理、可重复的方式实现单点集成，使企业内的所有应用都可以通过集成平台进行通信和数据交换，实现广义范围内和深层次上的企业资源共享和集成。图17-1给出了企业集成平台的示意图。</p>
<details><summary>图17-1　企业集成平台的应用架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151753.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151753.png';" /></details>

<p>企业集成平台的产生和发展，使得企业应用软件的开发方式较传统方式发生了很大变化，也使得应用系统维护和扩展的难度及费用大为减少。应用集成平台提供的应用软件集成机制和接口可以实现应用间的透明信息交换，使得在异构分布环境下的应用软件通过该接口集成到平台上，共享平台所拥有的资源。采用集成平台可以大大降低集成的复杂度，提高集成的有效性。</p>
<p>由于其诸多的优点，从20世纪80年代中期以后，集成平台的概念和产品在全世界范围内得到了广泛的推广应用，出现了狭义的集成平台和广义的集成平台两种概念。狭义的集成平台是指一个软件平台，它为企业内多个应用软件系统或组件间的信息共享与互操作提供所需的通用服务，达到降低企业内（间）多个应用软件系统或系统之间的集成复杂性的目的。广义的集成平台则是指由支撑软件系统（狭义集成平台）同其他完成不同业务的逻辑功能的各应用系统一起组成数字化企业的协同运行环境。但无论是广义的集成平台，还是狭义的集成平台，其核心的内容都是为企业提供集成所需要的服务，并对集成系统进行管理。</p>
<p>集成平台是支持企业集成的支撑环境，包括硬件、软件、软件工具和系统，通过集成各种企业应用软件形成企业集成系统。由于硬件环境和应用软件的多样性，企业信息系统的功能和环境都非常复杂，因此，为了能够较好地满足企业的应用需求，作为企业集成系统支持环境的集成平台，其基本功能主要如下。</p>
<p>1）通信服务</p>
<p>提供分布环境下透明的同步/异步通信服务功能，使用户和应用程序无需关心具体的操作系统和应用程序所处的网络物理位置，而以透明的函数调用或对象服务方式完成它们所需的通信服务要求。</p>
<p>2）信息集成服务</p>
<p>为应用提供透明的信息访问服务，通过实现异种数据库系统之间数据的交换、互操作、分布数据管理和共享信息模型定义（或共享信息数据库的建立），使集成平台上运行的应用、服务或用户端能够以一致的语义和接口实现对数据（数据库、数据文件、应用交互信息）的访问与控制。</p>
<p>3）应用集成服务</p>
<p>通过高层应用编程接口来实现对相应应用程序的访问，这些高层应用编程接口包含在不同的适配器或代理中，被用来连接不同的应用程序。这些接口以函数或对象服务的方式向平台的组件模型提供信息，使用户在无需对原有系统进行修改（不会影响原有系统的功能）的情况下，只要在原有系统的基础上加上相应的访问接口就可以将现有的、用不同的技术实现的系统互联起来，通过为应用提供数据交换和访问操作，使各种不同的系统能够相互协作。</p>
<p>4）二次开发工具</p>
<p>是集成平台提供的一组帮助用户开发特定应用程序（如实现数据转换的适配器或应用封装服务等）的支持工具，其目的是简化用户在企业集成平台实施过程中（特定应用程序接口）的开发工作。</p>
<p>5）平台运行管理工具</p>
<p>是企业集成平台的运行管理和控制模块，负责企业集成平台系统的静态和动态配置、集成平台应用运行管理和维护、事件管理和出错管理等。通过命名服务、目录服务、平台的动态静态配置，以及其中的关键数据的定期备份等功能来维护整个服务平台的系统配置及稳定运行。</p>
<h4 id="集成平台的标准化"><a href="#集成平台的标准化" class="headerlink" title="集成平台的标准化"></a>集成平台的标准化</h4><p>集成平台上集成的应用软件系统通常都是由不同的软件厂家提供的产品，具有很强的异构性，所以在集成平台中需要广泛采用新的开放性标准。研究和发展系统集成的相关标准，不断地使平台的接口和服务标准化，可以显著提高集成平台系统的适应性和可扩展性，减少异构性给集成带来的障碍。采用标准化的技术也是提高集成平台系统开放性和软件模块可重用性的重要方法。</p>
<p>集成平台的标准化内容涉及通信协议、中间件、企业建模、工作流管理系统、Internet环境下的数据交换、产品数据标准和应用系统集成的标准等。Goldstone技术公司在国际标准化组织定义的开放系统互联（ISO/OSI）的7层网络应用模型的基础上，给出了图17-2所示的集成平台的12层OSI模型。</p>
<details><summary>图17-2　企业集成平台的12层OSI模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151834.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151834.png';" /></details>

<p>在这个12层OSI模型中，下面的7层依然是采用ISO关于网络应用7个层次的定义。第8层为支持应用集成的中间件层，它为集成平台提供商实施企业系统集成提供了可扩展集成的架构。第9层为应用开发商定义的应用间方法（服务）调用、接收/发送消息格式的接口语法层。第10层为应用提供商和集成平台提供商共同提供的用来描述应用软件系统结构和内涵的应用语义层。第11层作为业务语义描述层，供业务操作人员和信息管理人员用来定义基于模型操作的业务对象的数据结构及其语义。第12层为业务过程层，用来为业务操作人员定义企业关键业务流程及流程之间的交互关系。</p>
<h4 id="实现技术的发展趋势"><a href="#实现技术的发展趋势" class="headerlink" title="实现技术的发展趋势"></a>实现技术的发展趋势</h4><p>通过分析国内外集成平台的应用及发展情况，结合企业集成系统对集成平台实施提出的要求和计算机软件技术的发展趋势，企业集成技术有如下的发展趋势。</p>
<h5 id="集成的技术实现从2层到n层过渡"><a href="#集成的技术实现从2层到n层过渡" class="headerlink" title="集成的技术实现从2层到n层过渡"></a>集成的技术实现从2层到n层过渡</h5><p>传统的集成实现一般采用图17-3所示的两层C/S或B/S结构，这样的系统将业务逻辑和应用表示逻辑封装在一起。这个封装在一起的逻辑模块可以安装在客户端应用上，也可以安装在服务器上，但是无论是在服务器端，还是在客户端， 由于业务逻辑和应用表示逻辑的紧密捆绑，对系统的升级和扩展都带来了比较大的困难。</p>
<details><summary>图17-3　集成技术的两层实现</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151917.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151917.png';" /></details>

<p>未来的集成平台将采用图17-4所示的n层系统集成方式，将业务过程逻辑、业务表示逻辑等进行分离，将每层的功能集中在一个特定的角色上，这样可以得到一个非常便于进行系统功能扩展、逻辑修改的应用集成框架，进而提高集成平台和集成系统的柔性。</p>
<details><summary>图17-4　集成技术的n层实现</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151937.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151937.png';" /></details>

<h5 id="集成支持的方式从面向信息集成扩充到面向过程集成、服务集成"><a href="#集成支持的方式从面向信息集成扩充到面向过程集成、服务集成" class="headerlink" title="集成支持的方式从面向信息集成扩充到面向过程集成、服务集成"></a>集成支持的方式从面向信息集成扩充到面向过程集成、服务集成</h5><p>面向信息的集成主要是针对设计、制造和管理部门中大量存在的自动化孤岛和信息孤岛而提出来的，其目的是为了解决企业内不同应用和系统间的数据共享和集成。这些应用系统分布在网络环境下的异构计算机系统中，它们所管理和操作的数据格式和存储方式各异，实现信息集成就是要实现数据的转换（不同数据格式和存储方式之间的转换）、数据源的统一（同一个数据仅有一个数据入口）、数据一致性的维护、异构环境下不同的应用系统之间的数据传送。面向信息的集成主要应用于企业内的数据库和数据源上，其具体的实现方法主要有数据复制、数据捆绑和基于接口的信息集成三种方式。</p>
<p>（1）面向过程的集成（这里主要是指技术层面的过程集成）：通过工作流引擎对企业内业务流程模型的执行来实现业务应用数据或信息在不同应用、子过程或执行任务的人员之间流动（如图17-5所示）。采用工作流管理方式可以对业务过程逻辑和应用逻辑进行分离，实现过程建模和数据、功能的分离，从而可以在保持具体功能单元不变的情况下，通过修改过程模型来改变系统功能，进而提高系统的柔性。面向过程集成需要在信息集成的基础上进行，或者说面向过程集成可能会对信息集成提出新的要求，因为在执行过程模型时，过程模型中包含的各种活动之间（特别是自动应用之间）同样需要信息共享与集成。过程集成更重要的是一种策略行为，它还具有过程逻辑可视化、业务执行过程自动化、业务过程执行状态和性能的实时监控等功能。</p>
<details><summary>图17-5　面向过程集成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152003.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152003.png';" /></details>

<p>（2）面向服务的集成（如图17-6所示）：主要是为支持大范围内的公共业务过程集成而提出的一种动态集成方式（如供应链企业群体内），可以较好地实现（企业间）具有松散耦合关系的不同应用间的互操作。在这种集成方式中，服务提供者（平台、企业）将应用作为服务部署在Web上，通过使用Web服务描述语言来描述Web服务提供的功能，并通过统一的服务发布与发现协议（Universal Description, Discovery and Integration, UDDI）将其注册到UDDI中心。服务请求者使用UDDI协议定义的API向UDDI中心提出服务请求，UDDI为其寻求到它所需要的服务，并由UDDI中心返回服务请求，同时与特定服务进行绑定，在此基础上，服务请求者继而通过SOAP协议完成应用服务的调用。基于服务的集成方式对于集成企业原有的系统同样十分方便，在不需要对原有系统进行修改的情况下，只要在原有系统的基础上增加一个对它们进行访问的SOAP接口，就可以完成原有系统到集成平台的集成。面向服务的集成将以前主要在企业内部网络基础上实施的集成扩展到了面向开放网络环境下的集成，从而大大扩展了集成的范围。基于服务的集成方式具有最好的柔性和开放性，然而，这种松散的动态集成方式牺牲了性能和网络流量。</p>
<details><summary>图17-6　面向服务集成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152029.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152029.png';" /></details>

<h5 id="集成规范的标准化程度不断提高"><a href="#集成规范的标准化程度不断提高" class="headerlink" title="集成规范的标准化程度不断提高"></a>集成规范的标准化程度不断提高</h5><p>开放性和标准化在集成的实现技术中的重要性已经得到广泛的认同。从数据描述的角度来看，数据结构的定义已经由原来的各个应用专有数据类型、行业内的标准数据表达（如STEP、EDI等），逐渐过渡到具有自描述功能的基于XML语言的数据表达与存储。从应用间集成接口的实现与接口表现形式来看，已经从最初的自定义应用编程接口、基于IDL接口定义（如CORBA或COM的接口描述语言），发展到更通用的基于XML语言的Web服务接口定义语言（WSDL）的集成接口描述。从业务过程定义方面来看，则由不同产品给出的自定义业务过程描述方式，工作流联盟为实现不同工作流产品间互操作而提出的工作流过程定义语言（WPDL），到近来出现的关于如何利用Web服务集成架构实现过程集成的基于XML语言的商业流程模型描述语言（如WSFL、BPEL等）。标准化技术的采用增强了集成平台的开放性和通用性，从而为企业集成提供了更强有力的技术支持。</p>
<h5 id="所支持的集成耦合度及集成的粒度的变化"><a href="#所支持的集成耦合度及集成的粒度的变化" class="headerlink" title="所支持的集成耦合度及集成的粒度的变化"></a>所支持的集成耦合度及集成的粒度的变化</h5><p>随着编程技术的发展，集成平台所采用的集成实现形式也在不断发展，应用集成的耦合度（松散集成、紧密集成）不断降低，集成范围不断扩大，而集成粒度（对象、组件、服务）也在不断缩小，图17-7给出了集成的范围和集成耦合度的对应关系。</p>
<p>随着集成范围的不断扩大，集成的耦合度不断降低。集成耦合度最高的对象间集成方式比较适合于功能单元之间的集成，集成耦合度最低的服务集成方式则能够比较好地实现企业间的集成，集成耦合度中等的组件集成方式可以较好地完成企业内的集成。对象间集成主要通过程序代码级对象之间的调用来实现。组件之间的集成方式则主要通过构建企业内分布式计算环境、采用远程过程调用来实现跨语言、进程和计算机间的基于组件的集成。基于服务的集成方式包括基于消息中间件服务和基于Web服务两种。基于消息中间件的服务集成通过消息中间件（如MSMQ）来实现应用或系统之间的互操作，基于Web服务的集成通过SOAP消息交换协议（防火墙透明的）来实现Internet环境下的分布式计算。由于Web服务的方式具有良好的松散耦合集成结构，因此它更适合于用来支持企业间应用的集成。</p>
<details><summary>图17-7　集成尺度与范围、耦合度的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152106.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152106.png';" /></details>


<h4 id="集成平台的发展趋势"><a href="#集成平台的发展趋势" class="headerlink" title="集成平台的发展趋势"></a>集成平台的发展趋势</h4><p>企业集成平台技术已经逐步成熟，国外已经出现了许多商用产品。从功能上可以将其划分为企业应用集成和业务到业务的集成（B2B）两种。其中，EAI主要侧重于企业内部的纵向集成，B2B侧重于支持企业间业务往来的横向集成。目前在市场上的产品主要有Active Enterprise 3.0（Tibco公司）、Mercator（Mercator公司）、MQ Series Integrator（IBM公司）、WebMethods Enterprise（WebMethods公司）和Business Ware。</p>
<h5 id="Active-Enterprise-3-0（Tibco公司）"><a href="#Active-Enterprise-3-0（Tibco公司）" class="headerlink" title="Active Enterprise 3.0（Tibco公司）"></a>Active Enterprise 3.0（Tibco公司）</h5><p>Tibco公司主要为具有基本信息技术应用知识的企业用户提供端到端的异构信息系统集成方案。其产品Active Enterprise 3.0采用了模块化的结构，它的每一个组件（如数据仓库、集成服务器、消息代理以及监控工具等）都可以在不同机器上独立运行，组件间的通信通过一个连接所有组件的信息总线实现。信息总线采用其独有的串行UDP技术实现，能够保证在发生系统级事件（包括通信错误）时及时向相关组件发送通知。考虑到在企业有大量的系统需要集成的情况下，对于整个集成系统的管理和监控将会很复杂，Tibco采用一个轻型代理实现对整个平台所有层次上的系统和过程进行全面的监控。轻型代理采用广播的形式向信息总线上的所有组件发送必要的监控和管理消息，采用这种方式可以将监控系统对平台系统性能造成的影响降到最低。通过轻型代理和信息总线的协同作用，可以使Active Enterprise对新接入的应用或服务具有动态发现能力。另外，Active Enterprise利用工作流技术为用户提供了强大的业务过程管理能力，用户可以在简单、直观的过程建模工具的支持下，建立相应的业务过程模型，并通过其工作流引擎同时支持自动化过程和人工型工作流的执行。</p>
<h5 id="Mercator（Mercator公司）"><a href="#Mercator（Mercator公司）" class="headerlink" title="Mercator（Mercator公司）"></a>Mercator（Mercator公司）</h5><p>Mercator由Enterprise Broker、Web Broker和Commerce Broker三个独立的产品构成。其中Enterprise Broker用于企业内应用的集成。Web Broker是B2以外，配合以上产品提供了企业间的流程设计的GUI工具Integration Flow Designer。目前，全世界已经有5000套Mercator投入运行，Mercator在集成SAP R/3用户方面具有很强的优势。</p>
<h5 id="MQ-Series-Integrator（IBM公司）"><a href="#MQ-Series-Integrator（IBM公司）" class="headerlink" title="MQ Series Integrator（IBM公司）"></a>MQ Series Integrator（IBM公司）</h5><p>MQ Series Integrator由消息中间件MQSeries、消息代理Integrator以及实现业务流程自动化的MQSeries Workflow构成。MQSeries是IBM开发和销售的消息中间件产品，是消息中间件事实上的标准，它支持35种以上的协议，可以用统一的API进行异构机种间的连接，主要是进行异步消息处理，但也可以实现实时消息的连接。MQSeries符合JMS标准，可以很容易地与WebLogic和WebSphere等应用服务器实现连接。MQSeries Workflow可以采用图形的方式方便地定义跨不同企业系统间的业务流程，也可以对工作流的实例状态进行控制和调整。特别是MQSeries Workflow可以将规则嵌入到流程节点中来，这点得到了用户广泛的好评。目前IBM已将WebSphere B2B Integrator加到这些产品中，以提供包含企业内和企业间集成的综合解决方案。</p>
<h5 id="WebMethods-Enterprise（WebMethods公司）"><a href="#WebMethods-Enterprise（WebMethods公司）" class="headerlink" title="WebMethods Enterprise（WebMethods公司）"></a>WebMethods Enterprise（WebMethods公司）</h5><p>该产品是WebMethods公司面向技术型用户提供的B2B解决方案，其核心部件是Active Works。Active Works提供了通信协议转换、队列管理和队列分配、60多种适配器、业务流程的控制，XML变换和Web应用接口等EAI的基本功能。需要指出的是，WebMethods Enterprise实现了EAI功能的一体化，即各种EAI功能可以在一个界面上统一进行设计和操作，所以容易进行应用系统开发和实施。特别地，每一次定义的业务流程都可以以模板的方式进行保存。WebMethods Enterprise采用总线型体系结构，利用Java框架来实现客户适配器的开发，因此具有良好的可扩展性和可用性，特别适用于大型企业的系统集成。WebMethods Enterprise消息交换的可靠性也较高，它包含一个异步事务协调引擎，并带有一个可用于MQSeries的适配器。监控代理、适配器及其各自的流程能够在死机的情况下自动恢复，也可以进行事件的自动重送。在对可靠性有更高要求的应用情况下，还可以在系统的外部配置作业控制器的相关服务模块。在收购了Active（EAI）和IntelliFrame（工作流管理系统）后，WebMethods公司具有为企业提供全面的端到端的集成方案的能力，它为许多主流的ERP、CRM、基于消息的中间件系统提供了广泛可用的内置适配器。一旦在技术上实现与这些并购产品的全面集成，WebMethods的领先地位将从目前的B2B领域扩展到EAI领域。</p>
<h5 id="BusinessWare（Vitria-Technology公司）"><a href="#BusinessWare（Vitria-Technology公司）" class="headerlink" title="BusinessWare（Vitria Technology公司）"></a>BusinessWare（Vitria Technology公司）</h5><p>Business Ware产品主要面向技术型用户，它采用以过程为核心的方式实现系统集成。BusinessWare产品具体由业务流程管理工具、可作为系统连接的EAI平台、实时监视工作流状态的实时分析工具、在应用层担当B2B集成的功能模块4个部分构成。它的业务流程管理工具具有友好的用户界面，用户可以在不需要事先编程和配置连接器的条件下，进行业务过程的可视化设计。Business Ware以CORBA技术为核心，采用通道/Hub（集线器）式的系统体系结构，与各系统连接的连接器控制各通道的输入输出，使用连接器开发工具包来支持客户化适配器的开发。BusinessWare中可以用多个类来定义发布/订阅通道的消息，通道采用与域名服务运行方式类似的联邦式分散结构，以实现对不同企业间集成化业务运作提供高性能和高可靠性的服务。在实时分析工具的界面上可以监视所设计流程的运行状态和性能。BusinessWare可以为那些希望自己进行业务过程建模的企业用户提供标准化的集成服务。</p>
<p>集成平台产品的发展具有以下的主要趋势。</p>
<p>（1）与商用工作流产品的融合发展。</p>
<p>集成平台产品通过与商用工作流产品的融合，一方面将基于工作流的业务流程分析、优化及过程管理功能引入到平台中来，并增强支持业务过程的自动执行能力及平台的可实施性；另一方面，利用商用工作流系统与用户的友好交互能力将人的因素集成到自动执行的企业业务操作过程中来，从而提高系统的柔性与可用性。</p>
<p>（2）与底层集成服务器产品的融合发展。</p>
<p>集成平台产品通过与底层集成服务器产品的融合，一方面可以增加集成平台产品内部各组件模块的无缝集成性，进而提高集成到平台上各应用系统间的互操作能力；另一方面，利用商用构件对企业用户提供从底层服务支撑技术到上层应用、过程集成的一体化支持，以保证集成平台的成功实施。</p>
<p>（3）兼容点到点（Point-to-Point）集成和端到端（End-to-End）集成。</p>
<p>集成平台厂商通过将其传统产品支持的点到点集成（主要指同步集成）方式扩展到端到端集成（侧重于异步集成）方式，以分别适用于企业内部集成所需要的大流量数据交换模式和企业间协同所需要的灵活的小流量数据交换模式。</p>
<p>（4）基于模型的集成与协调。</p>
<p>通过采用统一定义和表示的模型（在一些协议或规则的辅助下实现模型的构造和控制）实现不同应用系统之间的协同工作（应用软件通过模型操作接口实现对模型中定义的产品、过程、资源数据的访问，从而实现不同应用软件之间的无缝集成），这样就可以通过模型在整个生命周期的不断演化来实现企业集成信息系统的演化。</p>
<h3 id="企业集成平台的实现"><a href="#企业集成平台的实现" class="headerlink" title="企业集成平台的实现"></a>企业集成平台的实现</h3><h4 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h4><p>构建企业集成平台的首要目的是实现数据集成，即为平台上运行的各种应用、系统或服务，提供具有完整性、一致性和安全性的数据访问、信息查询及决策支持服务。数据集成主要为了解决不同应用和系统间的数据共享和交换需求，具体包括共享信息管理、共享模型管理和数据操作管理三个部分。其中，共享信息管理通过定义统一的集成服务模型和共享信息访问机制，完成对集成平台运行过程中产生数据信息的共享、分发和存储管理；共享模型管理则提供数据资源配置管理、集成资源关系管理、资源运行生命周期管理及相应的业务数据协同监控管理等功能；数据操作管理则为集成平台用户提供数据操作服务，包括多通道的异构模型之间的数据转换、数据映射、数据传递和数据操作等功能服务。</p>
<p>企业运行的业务应用系统采用的体系结构与其实现技术的标准化（规范化）程度，对数据集成的水平有非常大的影响。企业现有各种应用系统的规范化程度不高是影响企业数据集成水平的主要问题，因此，采用先进的软件体系结构和规范化的实现技术是实现良好的数据集成的基础。</p>
<p>企业集成技术架构层次如图17-8所示。</p>
<details><summary>图17-8　企业集成技术架构层次图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152345.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152345.png';" /></details>

<p>数据集成主要有以下三种模式：数据联邦、数据复制和基于接口的数据集成。如图17-9所示，它们分别描述了对多个异构数据源透明、一致访问的三种实现方法。</p>
<details><summary>图17-9　三种典型的数据集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152404.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152404.png';" /></details>


<h5 id="数据联邦"><a href="#数据联邦" class="headerlink" title="数据联邦"></a>数据联邦</h5><p>数据联邦是指不同的应用共同访问一个全局虚拟数据库，通过全局虚拟数据库管理系统为不同的应用提供全局信息服务，实现不同的应用和数据源之间的信息共享和数据交换，其具体实现由客户端应用、全局信息服务和若干个局部数据源三部分组成。</p>
<h5 id="数据复制模式"><a href="#数据复制模式" class="headerlink" title="数据复制模式"></a>数据复制模式</h5><p>在数据复制模式中，通过底层应用数据源之间的一致性复制来实现（访问不同数据库的）不同应用之间的信息共享和互操作，其实现的关键是必须能够提供在两个或多个数据库系统之间实现数据转换和传输的基础结构（以屏蔽不同数据库间数据模型的差异）。</p>
<h5 id="基于接口的数据集成模式"><a href="#基于接口的数据集成模式" class="headerlink" title="基于接口的数据集成模式"></a>基于接口的数据集成模式</h5><p>在基于接口的数据集成模式中，不同的应用系统之间利用适配器（或接口代理）提供的应用编程接口来实现相互调用。应用适配器或接口代理通过其开放或私有接口将业务信息从其所封装的具体应用系统中提取出来，进而实现不同的应用系统之间业务数据的共享与互交换。接口调用的方式可以采用同步调用方法，也可以采用基于消息中间件的异步方法来实现。</p>
<h4 id="应用集成"><a href="#应用集成" class="headerlink" title="应用集成"></a>应用集成</h4><p>应用集成是指两个或多个应用系统根据业务逻辑的需要而进行的功能之间的相互调用和互操作。应用集成需要在数据集成的基础上完成。应用集成在底层的网络集成和数据集成的基础上实现异构应用系统之间语用层次上的互操作。它们共同构成了实现企业集成化运行最顶层会聚集成所需要的，技术层次上的基础支持。</p>
<p>应用集成最初主要采用点对点的紧耦合方式。这种集成方式虽然不需要对应用系统做较大的改动，但用这种方式集成的系统缺乏必要的柔性，不能适应业务系统快速重构的需求。随着应用软件系统设计和实现过程中标准化程度的不断提高，系统的开放性（可配置性、可扩展性）越来越好，组件化的系统实现及松散耦合（它是实现系统柔性的基础）的应用集成方式逐渐成为构建企业业务处理系统的主流。</p>
<p>应用集成模式包括集成适配器、集成信使、集成面板和集成代理4种，每种应用集成模式都是对具有业务功能依赖关系的多个应用之间互操作实现方法的总结。在具体应用中，集成模式可能以某种变形（这是一种扩展集成模式的主要方式）的形式出现，这些变形可能不仅仅只是一种模式的实例化，也可能是一种具有广泛适用性的集成方式。</p>
<h5 id="适配器集成模式"><a href="#适配器集成模式" class="headerlink" title="适配器集成模式"></a>适配器集成模式</h5><p>在EAI技术发展的初期，广泛采用在需要交互的系统之间加入适配器（Adapter）的解决方案来实现企业原有应用系统与新实施系统之间的互操作。在应用系统提供的API的基础上（在应用系统没有提供API的情况下，可以在其数据库表结构已知的条件下直接完成对其数据库的写入与读出），通过适配器完成不同的系统间数据格式及访问方式的转换与映射，进而实现不同的系统之间业务功能及业务数据的集成，如图17-10所示。</p>
<details><summary>图17-10　适配器集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152517.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152517.png';" /></details>

<h5 id="信使集成模式"><a href="#信使集成模式" class="headerlink" title="信使集成模式"></a>信使集成模式</h5><p>随着企业中业务应用系统个数的增多，应用系统间的接口问题变得越来越复杂。为了更灵活地实现应用系统间点对点的集成问题，提出了图17-11所示的基于信使的集成结构。在这种集成结构中，系统之间的通信和数据交换通过信使（消息代理）来实现，每个应用只需要建立与集成信使之间的接口连接，就可实现与所有通过集成信使相联的应用系统间的交互。这种结构大大减少了接口连接数量，同时由于采用了信使（消息代理）作为信息交流的中介，可以将应用之间的交互对通信服务能力的依赖程度降到最低。另外，当某一系统发生改变时、只需要改变信使中相应的部分，从而降低系统维护工作量和系统升级的难度。</p>
<details><summary>图17-11　信使集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152546.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152546.png';" /></details>

<h5 id="面板集成模式"><a href="#面板集成模式" class="headerlink" title="面板集成模式"></a>面板集成模式</h5><p>面板集成模式和面向对象的软件设计方法中的面板模式很相似，它是从应用交互实现的层面来描述客户端应用和服务器端应用集成的一种方法。图17-12给出了面板集成模式框架图。集成面板可以为一对多、多对一、多对多等多种应用提供集成接口，在这种模式中包含有一个或多个客户端应用、一个集成面板、一个或多个服务器端应用。集成面板通过对服务器端应用功能的抽象和简化，为客户端应用访问与调用服务器端应用提供了一种简化的公共接口。集成面板在得到客户端应用服务请求后，将客户端的服务请求转换成服务器端应用能理解的形式，并将该请求提交给服务器端应用。</p>
<details><summary>图17-12　面板集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152613.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152613.png';" /></details>

<h5 id="代理集成模式"><a href="#代理集成模式" class="headerlink" title="代理集成模式"></a>代理集成模式</h5><p>面板集成模式实现了服务器端应用交互逻辑的分离。在代理集成模式中，由于不存在很明显的客户端应用和服务器端应用的划分，它仅需要将待集成的应用间的交互逻辑从应用中分离出来，并对应用间的交互逻辑进行封装，进而由集成代理来引导多个应用之间的交互，如图17-13所示。</p>
<details><summary>图17-13　代理集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152642.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152642.png';" /></details>

<h4 id="企业集成"><a href="#企业集成" class="headerlink" title="企业集成"></a>企业集成</h4><p>企业应用软件系统从功能逻辑上可以分为表示、业务逻辑和数据三个层次，其中表示层负责完成系统与用户交互的接口（界面）定义，业务逻辑层主要根据具体业务规则完成相应业务数据的处理，数据层负责存储由业务逻辑层处理或产生的业务数据，它是系统中相对稳定的部分。按照这些逻辑功能层次间是否分离和分离的程度，在软件系统具体实现上可以大致分为如下4类。</p>
<p>（1）单层结构系统。</p>
<p>很多企业遗留应用系统属于这一类，这种应用一般是采用传统的编程方法得到的一个紧密结构应用，三个层次之间没有进行分离，因此某个层次的变化通常需要重新设计与开发其他两个层次的内容。</p>
<p>（2）两层结构系统。</p>
<p>通常是将表示层与业务逻辑层（胖客户）紧密地耦合在一起，或者是将业务逻辑和数据库层紧密地耦合在一起（只将表示层分离出来为瘦客户）。这种结构实现了三个层次间部分的分离，这样在应用的某个部分发生变化时仅需要修改与其紧密耦合的部分，而无需重新开发所有的代码。如将表示层分离出来，可以使同样的业务功能采用不同的图形化用户接口及显示器屏幕模式，改变客户端接口（如增加Web界面）并不需要修改业务的逻辑功能来实现。</p>
<p>（3）三层结构系统。</p>
<p>这是当前比较流行的系统实现方式。它将业务应用系统的表示、业务逻辑和数据三个层次分成独立的模块实现。这样，应用系统的各层可以并行开发，各层也可以选择各自最适合的开发环境和编程语言。这种系统结构不但提高了系统的可维护性，也有利于系统的安全管理。</p>
<p>（4）n层结构系统。</p>
<p>将三层系统结构进一步细化（主要是将业务逻辑及数据库层分成更多、粒度更小的分布式业务对象来分别实现），其目的是提高系统不同业务功能模块的独立性。在提高了系统的可配置能力的同时，可以使系统具有最好的柔性及可扩展能力。</p>
<p>支持企业间应用集成和交互的集成平台在系统结构上通常都采用多层的结构，其目的是在最大程度上提高系统的柔性。在集成平台的具体设计开发中，还需要按照功能的通用性程度（通用功能、面向特定领域的功能、专业化功能）对系统实现模块进行分层（分成不同的中间件）。</p>
<p>根据企业集成平台功能的支持范围，可以将其划分为侧重于支持企业内部集成化运行的EAI和侧重于支持企业间业务集成的B2B。一般来说，EAI是B2B的基础，下面主要讨论EA1的实现模式。</p>
<p>从企业集成运行的实现策略上看，EAI主要有如下三种实现模式。</p>
<p>（1）前端集成模式。</p>
<p>所谓前端集成模式，是指EAI侧重于业务应用系统表示层的集成，它主要通过单一的用户入口实现跨多个应用事务的运作。这种方式适合于用户启动的业务过程会产生多个跨应用的事务，而且这些事务都需要实时响应的情况（主要指B2C的环境）。另外，采用前端集成模式还可以实现对已经运行的核心业务应用系统增加功能或特征的目的。</p>
<p>（2）后端集成模式。</p>
<p>后端集成模式主要侧重于应用系统数据层面的集成。它通过专门的数据维护及转换工具实现不同应用或数据源之间的信息交换，维护企业整体业务数据的完整性和一致性。</p>
<p>后端集成模式就像一个方便多个应用系统之间数据自动交互的数据管道，后端集成模式的实施同样需要得到数据集成及应用集成的支持。后端集成模式实现起来相对比较简单，因为EAI服务器不需要跨应用的事务维护，而只需要维护一些相对简单的业务规则。基于EAI服务器提供的存储——转发机制可以方便地实现对合作伙伴企业之间大量业务数据交换（主要指B2B集成）的支持。</p>
<p>（3）混合集成模式。</p>
<p>混合集成模式是前端集成模式和后端集成模式的组合。客户通过基于Web浏览器的客户端（瘦客户）实现对业务应用或EAI服务器的访问，服务请求可以由前端应用系统执行，也可以通过EAI服务器将服务请求路由到后端，由后端的业务应用来执行。这种模式几乎具有前端集成模式和后端集成模式的所有特征，主要应用于既需要响应大量服务请求、又需要维护多个数据源的完整性和一致性的情况。</p>
<h3 id="企业集成的关键应用技术"><a href="#企业集成的关键应用技术" class="headerlink" title="企业集成的关键应用技术"></a>企业集成的关键应用技术</h3><h4 id="数据交换格式"><a href="#数据交换格式" class="headerlink" title="数据交换格式"></a>数据交换格式</h4><p>企业业务数据可以分为结构化数据（表单）和非结构化数据（文档），它们一般存储在不同的数据库或文档管理系统中。不同的应用系统、数据库所处理的文档和数据格式有很大差别，建立各个应用都可以识别和访问的通用数据模型及表示规范，是实现不同的应用系统之间交互和互操作的最基本方法。企业数据集成中常用的几种数据交换格式如下。</p>
<h5 id="EDI"><a href="#EDI" class="headerlink" title="EDI"></a>EDI</h5><p>EDI（Electronic Data Interchange，电子数据交换）是一种利用计算机进行商务处理的方法，它将贸易、运输、保险、银行和海关等行业的信息，用一种国际公认的标准格式，通过计算机通信网络，供有关部门、公司与企业之间进行数据交换与处理，并完成以贸易为中心的全部业务过程。</p>
<p>EDI格式处理的目的是将在功效上与纸介质文件等同的电子表单用统一的（或标准的）格式进行表示，以保证各个独立开发的计算机应用间能够实现表单数据共享与集成。用于描述电子表单格式的标准称为EDI格式标准或EDI标准，目前广泛使用的EDI格式标准主要有UN/EDIFACT和ANSIX12，分别由联合国欧洲经济委员会（The United Nations Economic Commission for Europe, UN/ECE）和美国国家标准化协会（American National Standard Institute, ANSI）制定。</p>
<p>国际标准化组织采用UN/EDIFACT作为国际标准（IS09735）。按照UN/EDIFACT标准，贸易伙伴之间一次交换的内容称为一个交换，交换由交换头/尾、功能组头/尾、报文头/尾、数据段（或段组）和数据元（简单数据元和复合数据元）等组成。为简化起见，数据段（或段组）、数据元等在本文中都被称为报文项。图17-14给出了EDIFACT报文的数据结构。</p>
<details><summary>图17-14　EDIFACT报文的数据结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152807.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152807.png';" /></details>


<h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>XML是国际组织W3C制定的一个面向各类信息的数据存储工具和可配置载体的开放式标准。提出XML的目的是为了更好地适应Web应用的需求，解决HTML在表达能力、可扩展性和交互性等方面的缺陷。XML是通过对SGML标准进行简化而形成的元标记语言，具有语法清晰简单和结构无歧义等优点。它利用一套定义标记的规则将文件的内容和外观进行分离，实现了XML文档的可延伸性及自我描述特性，从而使各种业务信息可以在全球信息网或企业间的应用系统中传递、处理及储存。这里需要指出的是，虽然XML称为可扩展标记语言，但它本身并不是一种标记语言，而是一种创建、设计和使用标记语言的根规则集，是一种创建标记语言（如HTML）的元语言。图17-15给出了XML相关标准的层次图。</p>
<h5 id="STEP"><a href="#STEP" class="headerlink" title="STEP"></a>STEP</h5><p>STEP标准（Standard for the Exchange of Product Model Data）是一个描述如何表达和交换数字化产品信息的ISO标准（ISO10303），其目的是提供一种不依赖于具体系统的中性模型和机制，并将其用来描述整个生命周期内的产品数据。</p>
<p>图17-16给出了STEP标准的结构，其核心由描述产品数据的形式化语言规范（描述方法）、STEP实现方法、集成资源和一致性测试标准4部分组成，而围绕该核心定义的各种应用协议及抽象测试套件构成了对STEP的外层支持。描述方法用于集成资源的定义，由集成资源模型产生应用协议，应用协议和实现方法相结合产生一种STEP实现，一致性测试则用于测试STEP实现是否与STEP标准相一致。</p>
<details><summary>图17-15　XML标准体系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152849.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152849.png';" /></details>

<details><summary>图17-16　SETP标准的结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152903.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152903.png';" /></details>

<h5 id="PDML"><a href="#PDML" class="headerlink" title="PDML"></a>PDML</h5><p>PDML的技术目标是提供一种灵活的方法，使得不同应用软件系统中的产品数据能够进行交换。它是在STEP和XML基础上实现不同系统间产品数据交换和集成的一种新模式。</p>
<p>PDML中主要应用了STEP的集成资源和EXPRESS数据规范语言两个部分。在PDML中，与特定领域词汇表（或数据字典）相应的组件被称为应用事务集（Application Service Set，ATS），与跨多个应用领域的通用词汇表相应的组件被称为集成方案，集成方案的设计基于STEP的集成资源。</p>
<p>PDML使用XML来描述所有业务应用软件系统中的产品数据，并通过提供一系列的标准DTD来进行产品数据的导入和导出。由于EXPRESS在（产品相关的）语义和约束的表达能力方面要比XML的DTD优越很多，因此EXPRESS被选择作为定义PDML模式的规范。为了充分利用EXPRESS语言在数据建模和XML语言在数据交换方面的优点，PDML定义了一个从EXPRESS模式到XMLDTD的转换机制。</p>
<p>PDML不是单一的产品数据规范，而是一个用来发布和使用集成产品数据的相关标准和工具的集合。PDML由7个应用事务集、一个集成大纲、应用事务集和集成大纲间的映射规范、PDML工具集4部分组成。图17-17给出了应用事务集、集成大纲和映射规范之间的关系。</p>
<details><summary>图17-17　PDML各组成部分之间的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152930.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152930.png';" /></details>

<h4 id="分布式应用集成基础框架"><a href="#分布式应用集成基础框架" class="headerlink" title="分布式应用集成基础框架"></a>分布式应用集成基础框架</h4><p>随着计算机网络应用的不断深入和普及，大规模的计算机网络将不断增加，在这种计算机网络中，不仅硬件设备型号、种类、规模相异，而且操作系统平台、程序设计环境及应用也各不相同，这就是大规模计算机网络的重要特征——异构性。人们迫切希望通过在这种计算机网络上建立一套体系结构和一组规范来保证分布式系统的互操作性、可迁移性和可重用性，进而实现分布式环境下的信息共享与应用集成。因此，在面向对象技术和分布式计算基础上产生的分布式对象计算（Distributed Object Computing，DOC），成为20世纪90年代计算机技术发展的一个热点。而在当今众多的分布式对象技术中，比较有影响的分布式软件对象（组件）标准有下面三种。</p>
<h5 id="CORBA"><a href="#CORBA" class="headerlink" title="CORBA"></a>CORBA</h5><p>CORBA（Common Object Request Broker Architecture，公共对象请求代理体系结构）是对象管理组织（OMG）为解决分布式处理环境中硬件和软件系统的互连而提出的一种标准的面向对象应用程序体系规范。</p>
<p>OMG组织给出了分布计算的参考模型，称为对象管理参考模型（Object Management Architecture，OMA）。OMA模型中把软件作为对象，并通过对象请求代理与其他对象进行通信。其体系结构如图17-18所示。</p>
<details><summary>图17-18　对象管理参考模型的体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153004.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153004.png';" /></details>

<p>OMA体系结构的核心是对象请求代理（Object Request Broker，ORB），CORBA规范对ORB的组成和功能进行了定义，它支持对象服务、通用设施、领域接口和应用接口之间的交互和通信。</p>
<p>ORB是CORBA的对象互操作中介，作为应用对象间服务请求响应的中间代理，接收对象请求并把请求转给相应的对象，服务完成后又把执行结果或异常情况返回给请求者。ORB可以使对象以语言、位置和平台独立的方式发出请求和提供服务，相互协同工作，从而建立真正的分布处理，是实现分布对象互操作的核心。COBAR ORB的组成结构如图17-19所示。</p>
<details><summary>图17-19　CORBAORB结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153020.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153020.png';" /></details>

<h5 id="COM＋"><a href="#COM＋" class="headerlink" title="COM＋"></a>COM＋</h5><p>COM+是Microsoft公司基于Windows平台的一个分布式企业应用模型，它与Windows操作系统紧密结合，是沿着DDE-OLE-OLE2-COM-DOOM-COM+的路线发展而来。目前，COM、DCOM和COM+应用比较广泛。</p>
<p>COM是一个开放的组件标准，有很强的扩充和扩展能力。COM组件标准的基础是COM核心，它规定了组件对象与客户通过二进制接口标准进行交互的原则。COM主要由COM接口、COM对象、COM服务器、类工厂和类型库等组成。其中，COM接口是和COM对象之间互相调用相关的一组语义规范，每个接口有一个唯一标识（UUID）；COM对象则为一个或多个COM接口提供具体的服务（功能实现），对COM对象的调用是通过一个指向其接口的指针实现的；COM服务器提供COM运行的环境，完成COM对象的管理，并向COM客户提供服务；类工厂则是用于创建、注册COM对象的特殊对象，它为COM对象的实例化提供一种标准机制；类型库是一个二进制资源文件，包含COM服务器中对象与接口的类型信息。在COM系统中，客户对组件对象功能的调用接口一般采用COM IDL来描述。COM定义了两类服务器，即进程内服务器和进程外服务器。进程内服务器即本地机上的DLL，进程外服务器分为两类：一是本地机上的EXE可执行程序，二是远程机上的DLL或EXE程序。服务器内部包括组件接口的实现和类工厂，类工厂生产组件对象，将对象的接口指针返回给客户。组件服务器的定位由COM库完成并返回对象指针。COM对象位置的透明性处理由COM的服务控制机制保证。进程外的对象必须先调用服务控制机制提供的代理，代理生成服务对象的远程过程调用（Remote Process Call，RPC）。基于COM的系统调用原理如图17-20所示。</p>
<p>另外，COM组件标准还包括结构化存储、统一数据传输和智能命名等。其中结构化存储定义了复合文档的存储格式以及创建文档的接口，统一数据传输约定了组件之间数据交换的标准接口，智能命名则给予对象一个系统可识别的唯一标识。COM组件标准为COM对象之间的相互操作奠定了基础。</p>
<details><summary>图17-20　COM调用原理</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153058.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153058.png';" /></details>

<h5 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h5><p>J2EE（Java 2 Platform Enterprise Edition，Java 2平台企业版）是由Sun公司制定的基于Java技术的分布式组件计算平台规范。</p>
<p>Sun设计J2EE的初衷是为了解决两层模式的弊端，即系统难于升级或改进、可扩展性差，而且经常基于某种专有的协议。它使得重用业务逻辑和界面逻辑非常困难。J2EE将两层化系统模型中的不同层面切分成许多层，从而形成了一个多层的端到端的分布式应用系统架构。在图17-21给出的基于J2EE标准的典型运行结构中，主要包含客户层、Web层、业务逻辑层和数据层（包含遗留系统）4个层次。</p>
<details><summary>图17-21　J2EE运行结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153127.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153127.png';" /></details>

<p>J2EE很好地融合了Internet技术，有利于企业建立基于Web、具有n层结构的分布式应用，同时它也为应用系统集成提供了良好的解决办法。J2EE的应用集成架构如图17-22所示。J2EE的基础是核心Java平台或Java2平台的标准版，J2EE将J2SE集成到自己的体系结构中，不仅巩固了标准版中的许多优点，同时也使J2EE供应商能够独立于操作系统与硬件平台来实现应用程序产品。各种组件可以通过J2EE配置工具将其部署到相应的J2EE容器中，客户端对各种组件的访问及各种组件之间的调用都通过容器及服务器来完成。</p>
<details><summary>图17-22　基于J2EE的应用集成架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153143.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153143.png';" /></details>

<h5 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h5><p>Web Service（Web服务）是指服务提供者将应用作为服务部署在Web上，通过使用Web服务描述语言来描述特定Web服务提供的功能。服务请求者在需要一种Web服务时，可以通过Internet，在Web服务的注册机构中查找分布在Web站点上的Web服务，并自动实现与服务的绑定，完成数据交换，在这个过程中无须人工干预。Web服务的工作原理如图17-23所示。由于Web服务的系统架构和实现技术基本上基于已有的技术，因此，Web服务可以看成是现有应用面向Internet的一个延伸。</p>
<p>实现Web服务需要相关技术标准的支持，目前支持Web服务的技术标准主要有：用于进行数据交换和表达的元语言标准XML，XML用来在Web服务中表示服务请求和应答的内容；UDDI（Universal Description，Discovery &amp; Integration），UDDI用于Web服务注册和服务查找；WSDL，WSDL用于描述Web服务的接口和操作功能；SOAP（Simple Object Access Protocol），SOAP为建立Web服务和服务请求之间的通信提供支持。图17-24给出了支持Web服务实现的体系结构。</p>
<details><summary>图17-23　Web服务的发布、请求和绑定过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153210.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153210.png';" /></details>

<details><summary>图17-24　Web服务的体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153221.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153221.png';" /></details>

<h3 id="面向整体解决方案的企业模型"><a href="#面向整体解决方案的企业模型" class="headerlink" title="面向整体解决方案的企业模型"></a>面向整体解决方案的企业模型</h3><h4 id="企业模型在整体解决方案中的作用"><a href="#企业模型在整体解决方案中的作用" class="headerlink" title="企业模型在整体解决方案中的作用"></a>企业模型在整体解决方案中的作用</h4><p>企业模型是人们了解企业并经过抽象得到的对于企业某个或者某些方面的描述，它是实施企业信息化工程与实现企业集成的基础。企业建模在企业信息化整体解决方案中发挥的作用主要表现在以下几个方面。</p>
<p>（1）企业模型可以为信息化整体解决方案提供对企业公共一致的、规范的表达和描述。</p>
<p>模型为信息化工作中的所有人员提供一个公共的企业表达，所有的规划和决策人员可以站在同一个理解层面上讨论信息化的开展和实施，同时也为信息系统或部件的设计提供一个公共的模型规范，避免在每个信息系统设计时都直接去抽取需要的数据，减少由于这种工作方式带来的不同信息系统反映的企业数据的不一致问题。</p>
<p>（2）建模和基于模型的分析是企业信息化工作的入手点和建立有效的实施途径的基础。</p>
<p>实施企业信息化，首先必须要明确信息化的目的和范围。信息化应该从企业中最迫切需要改革、最影响和制约企业业务目标实现的环节开始，因此企业信息化实施的第一步应该是企业诊断。企业建模是有效并准确地进行企业诊断和分析的必要基础，通过模型来总结概括企业的现状，使信息化工作建立在一个具体、准确的需求的基础上。通过建模过程以及基于模型的诊断来辅助发现企业生产经营中需要解决的企业瓶颈问题和实现企业战略目标的业务需求，指明信息化需要解决的企业实际问题，为企业决策提供科学的支持。</p>
<p>（3）建模可以对信息系统规划方案进行预评价。</p>
<p>信息化工程是一项风险工程，会牵涉到企业的过程、组织、人员和资源等方面。在企业诊断之后，要进行企业信息化规划，对信息系统方案进行选择和论证。企业建模可以用于建立企业的改进模型，并基于对改进模型的分析来评价改进的效果以及对整个企业的影响。信息化过程也是企业的一种改进过程，企业建模可以描述按照某种规划方案布置了信息系统后的企业业务运行模型（模拟企业未来业务运作的模型），通过对该模型的仿真分析，并与企业现状模型进行比较，评价这个信息系统规划方案的效果以及需要付出的代价。通过对多种不同方案的比较分析，可以选择一种相对优异的信息系统规划方案。</p>
<p>（4）基于模型的工作流执行可以导航和监控各信息系统之间及信息系统与外界的交互。</p>
<p>面向工作流执行的企业模型可以准确地描述贯穿企业所有信息系统的业务过程，以及过程执行中传递的信息，并且可以定义信息系统交互过程中出现的异常情况的处理过程。在信息化工程进入实施阶段后，企业模型可以对集成的信息系统运行的导航和监控起到一定的支持作用。</p>
<p>由以上各方面看出，可以把整体解决方案的求解问题转化为更加具体的，基于企业模型的整体解决方案的求解。这样，在企业信息化整体解决方案的每个部分中都会包含企业模型、企业建模、模型管理、模型操作、模型标准、模型评价、模型转换和参考模型等相应的内容及工具。</p>
<h4 id="整体解决方案中的企业模型重"><a href="#整体解决方案中的企业模型重" class="headerlink" title="整体解决方案中的企业模型重"></a>整体解决方案中的企业模型重</h4><p>通过企业模型重用可以提高企业建模的效率与效果，进而更好地支持企业信息化整体解决方案的实施。不同的企业虽然在生产经营诸多方面都有其特殊性，但是它们都是企业系统的实例，都具有企业最本质的行为和特征，如为了完成企业的目标，都要进行一系列活动（或过程）。可以将构成企业的所有要素（无论是物质实体还是抽象过程）分成三类：一类是最通用的，适用于任何企业；第二类是在一定范围内通用，例如在一个行业内；第三类是某个企业专有的。对应这种分类，集成化企业建模体系框架中定义了三个实现企业模型重用的通用性层次：通用层、部分通用层和专用层。</p>
<p>（1）通用层：提供了整个集成化企业建模体系结构的基本构成成分，既包括不同的建模阶段、不同的建模视图的基本模型构件，也包括与建模活动相关的约束、规则、术语、服务和协议等。该层次的内容具有最强的通用性，能够广泛地适用于各类企业。</p>
<p>（2）部分通用层：在通用模型层的基础上，以生产经营方式类似的企业为背景，通过对它们典型业务流程和企业行为特征的分析和提炼，形成一组适合于某一行业的部分通用模型（模板），即行业参考模型。每种行业的部分通用模型拥有该行业中大部分企业共有的典型结构参考模型，它可以适用于这一个行业的所有或大部分企业。</p>
<p>（3）专用层：根据企业实际情况和需求，选择一定的参考模型并进行适当改动，形成适合于一个特定企业的专有模型，该模型仅能够用于所描述的企业。</p>
<p>通用性层次的划分使企业建模活动能够从简单到复杂、从抽象到具体、从一般到特殊逐步进行，形成一个层次化过程。利用模型构件可以组成参考模型，参考模型又可以派生出具体的专用模型，对专用模型再进行抽象后又可以形成新的参考模型。</p>
<p>企业通用模型构件及参考模型是在大量工程应用案例的基础上，对诸多企业的共同特征进行抽取而得到的。模型构件及参考模型库的建立和维护可以为企业信息化工程不同阶段的工作提供有实际应用价值的模型框架基础，并有助于进行企业诊断和模型优化，为提高企业建模质量、缩短企业建模周期、减少企业建模成本提供直接的支持。</p>
<p>企业模型可以采用从零开始的方法来建立，但是这种方法存在建模周期长和建模质量低等问题。因此，基于参考模型建立企业具体的专用模型是较好的方法。其实现过程包括两个阶段：参考模型的选择和参考模型的实例化。其中参考模型的选择具体包括以下几个步骤。</p>
<p>（1）确定企业建模的目标和基本需求。</p>
<p>（2）划定企业建模的范围。企业建模可以覆盖整个企业，也可以覆盖企业的某一部分。</p>
<p>（3）提出候选参考模型。参考模型的选择要依据企业规模相关性、行业相关性、产品相关性、生产经营模式相关性和领域相关性等准则。</p>
<p>（4）确定最终使用的参考模型。在候选参考模型中，经过进一步的分析和评价，最终确定一个或一组参考模型。</p>
<p>参考模型的实例化是在参考模型的基础上完成的，实例化过程在具体操作中可以采用的方法如下。</p>
<p>（1）继承：将参考模型中的模型构件或组件直接继承为企业应用模型的一部分。</p>
<p>（2）剪裁：对选取的参考模型，根据企业建模的目的和范围，进行适当的剪裁，作为企业应用模型的一部分。</p>
<p>（3）细化：在参考模型的基础上，根据企业建模的目的和需求，对模型中的某些部分作进一步的分解、细化和完善。</p>
<p>（4）扩充：按照参考模型的结构，对参考模型没有覆盖的企业建模范围加以扩充，形成企业应用模型。</p>
<p>（5）修改：对参考模型中的某些部分按照企业的实际需要进行修改，或者对参考模型中某些组件进行重组。</p>
<p>在具体的建模过程中，通用层、部分通用层和专用层三个层次又具有相互迭代的关系。当为某个行业里多个具体企业建立起企业模型后，通过抽取模型中共有的行业特性，可以总结出一个适合于这个行业的参考模型。当行业参考模型的内容非常丰富时，可以从中抽取出一些通用的建模构件。反过来，当拥有了足够多且好用的建模构件后，可以通过这些建模构件来搭建新的参考模型。当拥有了足够完善的参考模型后，可以通过实例化参考模型来快速建立起一个具体的企业模型。图17-25给出了这一迭代过程的图示化表示。</p>
<details><summary>图17-25　企业模型中的三个层次间的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153315.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153315.png';" /></details>

<h4 id="整体解决方案中企业模型演化"><a href="#整体解决方案中企业模型演化" class="headerlink" title="整体解决方案中企业模型演化"></a>整体解决方案中企业模型演化</h4><p>企业信息化整体解决方案实施的不同阶段在一定程度上也反映了企业模型及建模过程的阶段性，在不同的阶段，对模型的广度、深度和粒度要求都是不同的，各阶段需要采用哪些视图、各视图采用什么样的描述方法也都会有所不同。所以，在企业信息化整体解决方案的实施中，企业模型处于不断演化的状态之中。信息系统实施的生命周期可以分成需求分析阶段、系统设计阶段、系统实施阶段和运行维护阶段。下面分别介绍这4个阶段对企业模型的要求和在建模过程中需要完成的工作。</p>
<h5 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h5><p>需求分析阶段主要完成企业业务策略、信息技术/系统策略的确定与分析，并在完成业务调查及建立企业现状模型的基础上，结合用户需求，发现企业现有的优缺点，并针对缺点和瓶颈提出优化需求以及优化目标。在这一阶段通过对用户需求的抽象形成需求分析模型，以作为下一个阶段的输入。所建立的需求分析模型应该包含有较高层次上的企业业务流程、资源分配、组织结构和产品结构等信息。最后还需要确定系统的总体目标和评价标准。</p>
<h5 id="系统设计阶段"><a href="#系统设计阶段" class="headerlink" title="系统设计阶段"></a>系统设计阶段</h5><p>在确定了信息系统的需求之后，系统设计阶段则主要完成企业目标模型的确定和信息系统集成框架的求解，从未来的信息系统相关的业务模型中抽取出功能模型和信息模型，用它们来设计和构造信息系统。功能模型描述系统功能的划分和逐级分解，每一个功能单元对应信息系统的一个功能模块，功能模型是对业务过程模型中过程和活动所实现功能的归纳。信息模型描述信息系统需要使用到的数据结构和数据之间的关系，为建立信息系统数据库进行概念建模和物理建模。信息模型中的内容也来源于需求分析阶段建立的业务核心模型。</p>
<h5 id="系统实施阶段"><a href="#系统实施阶段" class="headerlink" title="系统实施阶段"></a>系统实施阶段</h5><p>系统实施阶段主要完成整体解决方案指导下的信息系统构建，将企业集成框架物化为实现企业集成化运作的协同信息系统。这一阶段实现了企业模型从设计模型向可执行模型的转化。在设计模型的基础上，通过定义具体的操作者、执行器、资源实体、组织单元和应用软件等，形成系统的实施模型。在给定的软硬件和网络环境下，将所得到的实施模型按照系统规划的实施步骤逐步投入运行。具体的工作包括将经过优化后得到的过程模型进行实例化，为业务流程中需要使用的人员、资源和产品指派实际的对象，建立企业信息的物理数据库供实际业务系统使用。</p>
<h5 id="运行维护阶段"><a href="#运行维护阶段" class="headerlink" title="运行维护阶段"></a>运行维护阶段</h5><p>运行维护阶段则主要完成对投入运行的企业集成化系统的运行维护，通过文档管理、版本控制等方法实现对运行系统的有效管理和监控，并通过集成需求管理软件工具来对运行过程中企业不断提出的新的需求进行记录和管理，所积累的需求和文档是下一个生命周期的输入。</p>
<p>企业的优化是一个持续的过程，一个系统实施后在运行维护阶段搜集的问题和需求又会启动一个新的生命周期。所以整个企业模型演化构成一个闭环，每个阶段的结果（输出）是下一个阶段的输入，上一个生命周期的运行维护阶段得到的结果（输出）是下一个生命周期需求分析阶段的输入。这个不断循环的生命周期以螺旋式上升的形式实现企业相关状态及行为的改进与扩展。企业模型演化的生命周期如图17-26所示。</p>
<details><summary>图17-26　企业模型演化的生命周期</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153422.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153422.png';" /></details>

<h4 id="模型驱动的企业集成系统演化"><a href="#模型驱动的企业集成系统演化" class="headerlink" title="模型驱动的企业集成系统演化"></a>模型驱动的企业集成系统演化</h4><p>采用企业信息化整体解决方案的目标是通过系统化的理论与方法来指导企业信息系统的规划与实施，构建一个既能够满足当前企业需求、又具有可持续发展能力的集成化业务计算环境。企业可持续发展必然要求支持企业各种资源（包括数据、应用、业务流程、服务及人员等）协同运作的企业集成系统具有可逐步发展和演化的特性。</p>
<details><summary>图17-27　基于模型的企业集成系统演化模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153447.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153447.png';" /></details>

<p>图17-27给出了基于模型的企业集成系统演化模式。首先，经过集成平台实施形成了（根据企业业务模型确定的）企业信息系统集成框架，以及在集成平台支持下的满足企业当前需求的协同信息系统（可能只实现了集成框架下的部分功能）。由于这种实施是根据企业当前的市场策略、业务过程规划和当前的信息技术现状进行的，它只能够在当前的企业和市场状态下，通过信息技术支持企业实现其竞争优势。在这样的集成平台支持下的业务运作，是和企业的业务逻辑（反映市场环境）与业务功能实现技术（反映技术现状）密切相关的。随着市场的变化、技术的进步，企业的核心能力及竞争策略可能要做相应的调整，而这种根据市场、技术的变化调整业务流程或资源配置结构的需求必然要在（在各种信息系统支持下的）业务协同运作过程中得以体现。随着这种需求的不断增加，企业的管理层需要对企业竞争战略或业务流程作必要的调整或改进，从而将这种调整业务模型的需求反馈到（转变为）描述企业业务特征的企业集成化模型中，进而驱动了企业目标模型的演化，企业目标模型的演化又推动了基于模型的企业集成框架和支持业务协同运作的企业集成平台的演化（业务逻辑模型修改或升级信息系统），这个不断循环的过程导致企业信息化工程以螺旋的方式不断上升。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch16-%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch16-%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch16-层次式架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:57:09" itemprop="dateCreated datePublished" datetime="2021-07-19T12:57:09+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 18:56:43" itemprop="dateModified" datetime="2021-09-04T18:56:43+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="层次式架构设计"><a href="#层次式架构设计" class="headerlink" title="层次式架构设计"></a>层次式架构设计</h2><h3 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h3><p>1968年，在Garmish召开的国际软件工程会议上，人们迫切地感到了软件危机给计算机软件产业的发展带来的巨大阻力。软件危机的两个比较大的问题是：软件的规模越来越大，软件复杂度越来越高。伴随着这两个问题的日益突出，整个软件系统结构的设计与规格说明便显得比算法选择和计算问题的数据结构更为重要。因此，代码级别的软件复用已经远远不能满足大型软件开发的需求，由此便引入了“软件体系结构”这一概念。</p>
<p>软件体系结构可定义为：软件体系结构为软件系统提供了结构、行为和属性的高级抽象，由构成系统的元素描述、这些元素的相互作用、指导元素集成的模式以及这些模式的约束组成。软件体系结构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些设计决策的基本原理，是构建于软件系统之上的系统级复用。</p>
<p>软件体系结构贯穿于软件研发的整个生命周期内，具有重要的影响。这主要从以下三个方面来进行考察。</p>
<p>（1）利益相关人员之间的交流。软件体系结构是一种常见的系统抽象，代码级别的系统抽象仅仅可以成为程序员的交流工具，而包括程序员在内的绝大多数系统的利益相关人员都借助软件体系结构来作为相互沟通的基础。</p>
<p>（2）系统设计的前期决策。软件体系结构是我们所开发的软件系统最早期设计决策的体现，而这些早期决策对软件系统的后续开发、部署和维护具有相当重要的影响。这也是能够对系统进行分析的最早时间点。</p>
<p>（3）可传递的系统级抽象。软件体系结构是关于系统构造以及系统各个元素工作机制的相对较小、却又能够突出反映问题的模型。由于软件系统具有的一些共通特性，这种模型可以在多个系统之间传递，特别是可以应用到具有相似质量属性和功能需求的系统中，并能够促进大规模软件的系统级复用。</p>
<p>分层设计是一种最常见的架构设计方法，能有效地使设计简化，使设计的系统机构清晰，便于提高复用能力和产品维护能力。</p>
<h3 id="表现层框架设计"><a href="#表现层框架设计" class="headerlink" title="表现层框架设计"></a>表现层框架设计</h3><h4 id="使用MVC模式设计表现层"><a href="#使用MVC模式设计表现层" class="headerlink" title="使用MVC模式设计表现层"></a>使用MVC模式设计表现层</h4><p>MVC是一种目前广泛流行的软件设计模式。近年来，随着J2EE（Java 2Enterprise Edition）的成熟，MVC成为了J2EE平台上推荐的一种设计模式。MVC强制性地把一个应用的输入、处理、输出流程按照视图、控制、模型的方式进行分离，形成了控制器、模型、视图三个核心模块。</p>
<p>（1）控制器（Controller）：接受用户的输入并调用模型和视图去完成用户的需求。该部分是用户界面与Model的接口。一方面它解释来自于视图的输入，将其解释成为系统能够理解的对象，同时它也识别用户动作，并将其解释为对模型特定方法的调用；另一方面，它处理来自于模型的事件和模型逻辑执行的结果，调用适当的视图为用户提供反馈。</p>
<p>（2）模型（Model）：应用程序的主体部分。模型表示业务数据和业务逻辑。一个模型能为多个视图提供数据。由于同一个模型可以被多个视图重用，所以提高了应用的可重用性。</p>
<p>（3）视图（View）：用户看到并与之交互的界面。视图向用户显示相关的数据，并能接收用户输入的数据，但是它并不进行任何实际的业务处理。视图可以向模型查询业务状态，但不能改变模型。视图还能接受模型发出的数据更新事件，从而对用户界面进行同步更新。</p>
<p>三者的协作关系如图16-1所示。</p>
<details><summary>图16-1　MVC设计模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142745.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142745.png';" /></details>


<p>从图16-1中可以看到，首先，控制器接收用户的请求，并决定应该调用哪个模型来处理；然后，模型根据用户请求进行相应的业务逻辑处理，并返回数据；最后，控制器调用相应的视图来格式化模型返回的数据，并通过视图呈现给用户。</p>
<p>使用MVC模式来设计表现层，可以有以下的优点。</p>
<p>1）允许多种用户界面的扩展。在MVC模式中，视图与模型没有必然的联系，都是通过控制器发生关系，这样如果要增加新类型的用户界面，只需要改动相应的视图和控制器即可，而模型则无需发生改动。</p>
<p>（2）易于维护。控制器和视图可以随着模型的扩展而进行相应的扩展，只要保持一种公共的接口，控制器和视图的旧版本也可以继续使用。</p>
<p>（3）功能强大的用户界面。用户界面与模型方法调用组合起来，使程序的使用更清晰，可将友好的界面发布给用户。</p>
<p>MVC是构建应用框架的一个较好的设计模式，可以将业务处理与显示分离，将应用分为控制器、模型和视图，增加了应用的可拓展性、强壮性及灵活性。基于MVC的优点，目前比较先进的Web应用框架都是基于MVC设计模式的。</p>
<h4 id="使用XML设计表现层，统一Web-Form与Windows-Form的外观"><a href="#使用XML设计表现层，统一Web-Form与Windows-Form的外观" class="headerlink" title="使用XML设计表现层，统一Web Form与Windows Form的外观"></a>使用XML设计表现层，统一Web Form与Windows Form的外观</h4><p>XML（可扩展标记语言）与HTML类似，是一种标记语言。与主要用于控制数据的显示和外观的HTML标记不同，XML标记用于定义数据本身的结构和数据类型。XML已被公认为是优秀的数据描述语言，并且成为了业内广泛采用的数据描述标准。</p>
<p>由于XML的设计目标是描述数据并集中于数据的内容，所以虽然XML和HTML类似，但是业内很少采用XML作为表现层技术，表现层技术仍然是HTML唱主角。但是，由于Web应用程序对特定浏览器的局限以及性能问题，基于窗体表现形式的胖客户端应用程序又开始有了卷土重来的趋势。这两种应用程序各有优势，在未来很长一段时间这两种技术架构都会并存。因此，许多开发厂商在开发新产品时提出了既要支持胖客户端的表现形式，又要支持Web的表现形式。于是，有人提出将GUI用一个标准的形式描述，对于不同的表现形式，提供特定形式的转换器，根据GUI的描述转换成相应的表现形式。这就要求描述语言有非常好的通用性和扩展性，XML恰恰是这种描述语言理想的载体。</p>
<p>对于大多数应用系统，GUI主要是由GUI控件组成。控件可以看成是一个数据对象，其包含位置信息、类型和绑定的事件等。这些信息在XML中都可以作为数据结点保存下来，每一个控件都可以被描述成一个XML结点，而控件的那些相关属性都可以描述成这个XML结点的Attribute。由于XML本身就是一种树型结构描述语言，所以可以很好地支持控件之间的层次结构。同时，XML标记由架构或文档的作者定义，并且是无限制的，所以架构开发人员可以随意约定控件的属性，例如可以约定type=”button”是一个按钮，type=”panel”是一个控件容器，type=”Constraint”是位置等。这样，整个GUI就可以完整而且简单地通过XML来描述。例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142823.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142823.png';" /></details>

<p>这么一段XML很清晰地表示一个控件容器位置是（16,22,78,200），包含了一个不可视按钮。用上述的XML形式将GUI按照数据描述的形式保存下来代替原先特有的表现形式所需要的GUI描述载体。然后，对于特定的表现技术，实现不同的解析器解析XML配置文件。根据XML中的标签，按照特有的表现技术实例化的GUI控件实例对象。例如，解析器遇到button，JFC解析器会给予JLabel对象，XSLT解析器会给予<code>&lt;button id=… &gt;</code>这样一个HTML字符串，再调用特定表现技术的API将实例化出来的组件对象添加到GUI上显示。</p>
<p>从设计模式的角度来说，整个XML表现层解析的机制是一种策略模式。在调用显示GUI时，不是直接的调用特定的表现技术的API，而是装载GUI对应的XML配置文件，然后根据特定的表现技术的解析器解析XML，得到GUI视图实例对象。这样，对于GUI开发人员来说，GUI视图只需要维护一套XML文件即可。</p>
<h4 id="表现层中UIP设计思想"><a href="#表现层中UIP设计思想" class="headerlink" title="表现层中UIP设计思想"></a>表现层中UIP设计思想</h4><p>应用程序通常要用代码来管理用户界面，例如一个窗体可以决定下一个要呈现给用户的窗体。开发人员可以把这些代码写在UI代码中间，但是会使得代码复杂，不易复用、维护和扩展。另一方面，应用程序要运行在其他的平台也变得相当困难，因为它进行控制的逻辑和状态都不能被复用。</p>
<p>在大多数情况下，应用程序需要维护一个状态，如状态存储在窗体中，代码需要访问这个窗体以重新恢复状态。这样做会比较困难并且代码也会变得不雅，同时也会对用户接口的重用性和可扩展性产生影响。</p>
<p>用户应用系统的时候，他可能会先启动一个任务，离开一段时间后再回来继续。如果在中间用户关闭了应用程序，它将失去当前的状态，要想继续任务的话必须一切从头开始。因此设计程序的时候，必须分开来考虑工作流、导航、与商业服务的交互等各个组成部分，以获取数据并呈现给用户。</p>
<p>UIP (User Interface Process Application Block) 是微软社区开发的众多Application Block中的其中之一，它是开源的。UIP提供了一个扩展的框架，用于简化用户界面与商业逻辑代码的分离的方法，可以用它来写复杂的用户界面导航和工作流处理，并且它能够复用在不同的场景、并可以随着应用的增加而进行扩展。</p>
<p>使用UIP框架的应用程序把表现层分为了以下几层。</p>
<p>●　User Interface Components：这个组件就是原来的表现层，用户看到的和进行交互都是这个组件，它负责获取用户的数据并且返回结果。</p>
<p>●　User Interface Process Components：这个组件用于协调用户界面的各部分，使其配合后台的活动，例如导航和工作流控制，以及状态和视图的管理。用户看不到这一组件，但是这些组件为User Interface Components提供了重要的支持功能。</p>
<p>图16-2展示了这两层在基于.Net的分布式应用程序中的位置。</p>
<details><summary>图16-2　UI Components和UIP Components</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143122.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143122.png';" /></details>

<p>UIP的组件主要负责的功能是：管理经过User Interface Components的信息流；管理UIP中各个事件之间的事务；修改用户过程的流程以响应异常；将概念上的用户交互流程从实现或者涉及的设备上分离出来；保持内部的事务关联状态，通常是持有一个或者多个的与用户交互的事务实体。因此，这些组件也能进行从UI组件收集数据以执行服务器的成组的升级或是跟踪UIP中的任务过程的管理。</p>
<h4 id="表现层动态生成设计思想"><a href="#表现层动态生成设计思想" class="headerlink" title="表现层动态生成设计思想"></a>表现层动态生成设计思想</h4><p>基于XML的界面管理技术可实现灵活的界面配置、界面动态生成和界面定制。其思路是用XML生成配置文件及界面所需的元数据，按不同需求生成界面元素及软件界面。</p>
<p>基于XML界面管理技术，包括界面配置、界面动态生成和界面定制三部分，如图16-3所示。</p>
<details><summary>图16-3　基于XML的界面管理技术框图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143152.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143152.png';" /></details>

<p>界面配置是对用户界面的静态定义，通过读取配置文件的初始值对界面配置。由界面配置对软件功能进行裁剪、重组和扩充，以实现特殊需求。</p>
<p>界面定制是对用户界面的动态修改过程，在软件运行过程中，用户可按需求和使用习惯，对界面元素（如菜单、工具栏、键盘命令）的属性（如文字、图标、大小和位置等）进行修改。软件运行结束，界面定制的结果被保存。</p>
<p>系统通过DOM API读取XML配置文件的表示层信息（初始界面大小、位置等），通过数据存取类读取数据库中的数据层信息，运行时由界面元素动态生成界面。界面配置和定制模块在软件运行前后修改配置文件、更改界面内容。</p>
<p>基于XML的界面管理技术实现的管理信息系统实现了用户界面描述信息与功能实现代码的分离，可针对不同用户需求进行界面配置和定制，能适应一定程度内的数据库结构改动。只需对XML文件稍加修改，即可实现系统的移植。</p>
<h3 id="中间层架构设计"><a href="#中间层架构设计" class="headerlink" title="中间层架构设计"></a>中间层架构设计</h3><h4 id="业务逻辑层组件设计"><a href="#业务逻辑层组件设计" class="headerlink" title="业务逻辑层组件设计"></a>业务逻辑层组件设计</h4><p>业务逻辑组件分为接口和实现类两个部分。</p>
<p>接口用于定义业务逻辑组件，定义业务逻辑组件必须实现的方法是整个系统运行的核心。通常按模块来设计业务逻辑组件，每个模块设计一个业务逻辑组件，并且每个业务逻辑组件以多个DAO组件作为基础，从而实现对外提供系统的业务逻辑服务。增加业务逻辑组件的接口，是为了提供更好的解耦，控制器无须与具体的业务逻辑组件耦合，而是面向接口编程。</p>
<h5 id="业务逻辑组件的实现类"><a href="#业务逻辑组件的实现类" class="headerlink" title="业务逻辑组件的实现类"></a>业务逻辑组件的实现类</h5><p>业务逻辑组件以DAO组件为基础，必须接收Spring容器注入的DAO组件，因此必须为业务逻辑组件的实现类提供对应的setter方法。业务逻辑组件的实现类将DAO组件接口实例作为属性（面向接口编程），而对于复杂的业务逻辑，可能需要访问多个对象的数据，那么只需在这个方法里调用多个DAO接口，将具体实现委派给DAO完成。</p>
<h5 id="业务逻辑组件的配置"><a href="#业务逻辑组件的配置" class="headerlink" title="业务逻辑组件的配置"></a>业务逻辑组件的配置</h5><p>由于业务逻辑组件的DAO组件从未被初始化过，那么业务方法如何完成？DAO组件初始化是由Spring的反向控制（Inverse of Control, IoC）或者称为依赖注入（Dependency Injection, DI）机制完成的。为此，还需要在applicationContext.xml里面配置FacadeManager组件。</p>
<p>定义FacadeManager组件时必须为其配置所需要的DAO组件，配置信息表示BaseManager继承刚才配置的事务代理模板。并且由容器给BaseManager注入dao的组件，即BaseDAOHibernate。而target则是TransactionProxy FactoryBean需要指定的属性，TransactionProxyFactoryBean负责为某个bean实例生成代理，代理必须有个目标，target属性则用于指定目标。</p>
<p>当然，也可以不使用事务代理模板及嵌套bean，而是为组件指定单独的事务代理属性，让事务代理的目标引用容器中已经存在的bean。</p>
<p>applicationContext.xml文件的源代码配置了应用的数据源和SessionFactory等bean，而业务逻辑组件也被部署在该文件中。</p>
<p>在配置文件中，采用继承业务逻辑组件的事务代理，将原有的业务逻辑组件作为嵌套bean配置，避免了直接调用没有事务特性的业务逻辑组件。</p>
<p>系统实现了所有的后台业务逻辑，并且向外提供了统一的Facade接口，前台Web层仅仅依赖这个Facade接口。这样，Web层与后台业务层的耦合已经非常松散，系统可以在不同的Web框架中方便切换，即使将整个Web层替换掉也非常容易。</p>
<h4 id="业务逻辑层工作流设计"><a href="#业务逻辑层工作流设计" class="headerlink" title="业务逻辑层工作流设计"></a>业务逻辑层工作流设计</h4><p>工作流管理联盟（Workflow Management Coalition）将工作流定义为：业务流程的全部或部分自动化，在此过程中，文档、信息或任务按照一定的过程规则流转，实现组织成员间的协调工作以达到业务的整体目标。</p>
<p>工作流管理一直是企业界和学术界关注的热点领域。1993年，国际上专门成立了工作流管理联盟（Workflow Management Coalition, WFMC），以便对工作流实现标准化管理。它是一种反映业务流程的计算机化的模型，是为了在先进计算机环境支持下实现经营过程集成与经营过程自动化而建立的可由工作流管理系统执行的业务模型。它解决的主要问题是：使在多个参与者之间按照某种预定义的规则传递文档、信息或任务的过程自动进行，从而实现某个预期的业务目标，或者是促使此目标的实现。</p>
<details><summary>图16-4　工作流参考模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143343.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143343.png';" /></details>

<p>（1）interface 1：过程定义导入/导出接口。这个接口的特点是：转换格式和API调用，从而支持过程定义信息间的互相转换。这个接口也支持已完成的过程定义或过程定义的一部分之间的互相转换。早期标准是WPDL，后来发展为XPDL。</p>
<p>（2）interface 2：客户端应用程序接口。通过这个接口工作流机可以与任务表处理器交互，代表用户资源来组织任务。然后由任务表处理器负责，从任务表中选择、推进任务项。由任务表处理器或者终端用户来控制应用工具的活动。</p>
<p>（3）interface 3：应用程序调用接口。允许工作流机直接激活一个应用工具，来执行一个活动。典型的是调用以后台服务为主的应用程序，没有用户接口。当执行活动要用到的工具，需要与终端用户交互，通常是使用客户端应用程序接口来调用那个工具，这样可以为用户安排任务时间表提供更多的灵活性。</p>
<p>（4）interface 4：工作流机协作接口。其目标是定义相关标准，以使不同开发商的工作流系统产品相互间能够进行无缝的任务项传递。WFMC定义了4个协同工作模型，包含多种协同工作能力级别。</p>
<p>（5）interface 5：管理和监视接口。提供的功能包括用户管理、角色管理、审查管理、资源控制、过程管理和过程状态处理器等。</p>
<p>用工作流的思想组织业务逻辑，优点是：将应用逻辑与过程逻辑分离，在不修改具体功能的情况下，通过修改过程模型改变系统功能，完成对生产经营部分过程或全过程的集成管理，可有效地把人、信息和应用工具合理地组织在一起，发挥系统的最大效能。</p>
<h4 id="业务逻辑层实体设计"><a href="#业务逻辑层实体设计" class="headerlink" title="业务逻辑层实体设计"></a>业务逻辑层实体设计</h4><p>业务逻辑层实体具有以下特点：业务逻辑层实体提供对业务数据及相关功能（在某些设计中）的状态编程访问。业务逻辑层实体可以使用具有复杂架构的数据来构建，这种数据通常来自数据库中的多个相关表。业务逻辑层实体数据可以作为业务过程的部分I/O参数传递。业务逻辑层实体可以是可序列化的，以保持它们的当前状态。例如，应用程序可能需要在本地磁盘、桌面数据库（如果应用程序脱机工作）或消息队列消息中存储实体数据。业务逻辑层实体不直接访问数据库，全部数据库访问都是由相关联的数据访问逻辑组件提供的。业务逻辑层实体不启动任何类型的事务处理，事务处理由使用业务逻辑层实体的应用程序或业务过程来启动。</p>
<p>在应用程序中表示业务逻辑层实体的方法有很多（从以数据为中心的模型到更加面向对象的表示法），如XML、通用DataSet、有类型的DataSet等。</p>
<p>以下示例显示了如何将一个简单的业务逻辑层实体表示为XML。该业务逻辑层实体包含一个产品。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143420.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143420.png';" /></details>

<p>将业务逻辑层实体表示为XML的优点如下。</p>
<p>（1）标准支持。XML是World Wide Web Consortium (W3C)的标准数据表示格式。</p>
<p>（2）灵活性。XML能够表示信息的层次结构和集合。</p>
<p>（3）互操作性。在所有平台上，XML都是与外部各方及贸易伙伴交换信息的理想选择。</p>
<p>如果XML数据将由ASP.NET应用程序或Windows窗体应用程序使用，则还可以把这些XML数据装载到一个DataSet中，以利用DataSet提供的数据绑定支持。</p>
<p>将业务逻辑层实体表示为通用DataSet。通用DataSet是DataSet类的实例，它是在ADO.NET的System.Data命名空间中定义的。DataSet对象包含一个或多个DataTable对象，用于表示数据访问逻辑组件从数据库检索到的信息。</p>
<p>图16-5所示为用于Product业务逻辑层实体的通用DataSet对象。该DataSet对象具有一个DataTable，用于保存产品信息。该DataTable具有一个UniqueConstraint对象，用于将ProductID列标记为主键。DataTable和UniqueConstraint对象是在数据访问逻辑组件中创建该DataSet时创建的。</p>
<details><summary>图16-5　用于Product业务逻辑层实体的通用DataSet</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143433.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143433.png';" /></details>

<p>图16-6所示为用于Order业务逻辑层实体的通用DataSet对象。此DataSet对象具有两个DataTable对象，分别保存订单信息和订单详细信息。每个DataTable具有一个对应的UniqueConstraint对象，用于标识表中的主键。此外，该DataSet还有一个Relation对象，用于将订单详细信息与订单相关联。</p>
<details><summary>图16-6　用于Order业务逻辑层实体的通用DataSet</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143453.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143453.png';" /></details>

<p>将业务逻辑层实体表示为通用DataSet的优点如下。</p>
<p>（1）灵活性。DataSet可以包含数据的集合，能够表示复杂的数据关系。</p>
<p>（2）序列化。在层间传递时，DataSet本身支持序列化。</p>
<p>（3）数据绑定。可以把DataSet绑定到ASP.NET应用程序和Windows窗体应用程序的任意用户界面控件。</p>
<p>（4）排序与过滤。可以使用DataView对象排序和过滤DataSet。应用程序可以为同一个DataSet创建多个DataView对象，以便用不同方式查看数据。</p>
<p>（5）与XML的互换性。可以用XML格式读写DataSet。</p>
<p>（6）开放式并发。在更新数据时，可以配合使用数据适配器与DataSet方便地执行开放式并发检查。</p>
<p>（7）可扩展性。如果修改了数据库架构，则适当情况下数据访问逻辑组件中的方法可以创建包含修改后的DataTable和DataRelation对象的DataSet。</p>
<p>将业务逻辑层实体表示为有类型的DataSet。有类型的DataSet是包含具有严格类型的方法、属性和类型定义以公开DataSet中的数据和元数据的类。</p>
<p>将业务逻辑层实体表示为有类型的DataSet的优点如下。</p>
<p>（1）代码易读。要访问有类型的DataSet中的表和列，可以使用有类型的方法和属性。</p>
<p>（2）有类型的方法和属性的提供使得使用有类型的DataSet比使用通用DataSet更方便。使用有类型的DataSet时，IntelliSense将可用。</p>
<p>（3）编译时类型检查，无效的表名称和列名称将在编译时而不是在运行时检测。</p>
<h4 id="业务逻辑层框架"><a href="#业务逻辑层框架" class="headerlink" title="业务逻辑层框架"></a>业务逻辑层框架</h4><p>业务框架位于系统架构的中间层，是实现系统功能的核心组件。采用容器的形式，便于系统功能的开发、代码重用和管理。图16-7便是在吸收了SOA思想之后的一个三层体系结构的简图。</p>
<details><summary>图16-7　业务框架在整个系统架构中的位置</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143533.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143533.png';" /></details>

<p>从图16-7中可以看到，业务层采用业务容器（Business Container）的方式存在于整个系统当中，采用此方式可以大大降低业务层和相邻各层的耦合，表示层代码只需要将业务参数传递给业务容器，便不需要业务层多余的干预。如此一来，可以有效地防止业务层代码渗透到表示层。</p>
<p>在业务容器中，业务逻辑是按照Domain Model—Service—Control思想来实现的。</p>
<p>（1）Domain Model是领域层业务对象，它仅仅包含业务相关的属性。</p>
<p>（2）Service是业务过程实现的组成部分，是应用程序的不同功能单元，通过在这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。这种具有中立的接口定义（没有强制绑定到特定的实现上）的特征称为服务之间的松耦合。松耦合系统的好处有两点，一是它的灵活性，二是当组成整个应用程序的每个服务的内部结构和实现逐渐地发生改变时，它能够继续存在。</p>
<p>（3）Control服务控制器，是服务之间的纽带，不同服务之间的切换就是通过它来实现的。通过服务控制器控制服务切换可以将服务的实现和服务的转向控制分离，提高了服务实现的灵活性和重用性。</p>
<p>以下是Domain Model-Service-Control三者的互动关系。</p>
<p>（1）Service的运行会依赖于Domain Model的状态，反之，Service也会根据业务规则改变Domain Model的状态。</p>
<p>（2）Control作为服务控制器，根据Domain Model的状态和相关参数决定Service之间的执行顺序及相互关系。</p>
<p>Domain Model—Service—Control的互动关系，是吸取了Model—View—Control的优点，在“控制和显示的分离”的基础之上演变而来的，通过将服务和服务控制隔离，使程序具备高度的可重用性和灵活性。</p>
<h3 id="数据访问层设计（持久层架构设计）"><a href="#数据访问层设计（持久层架构设计）" class="headerlink" title="数据访问层设计（持久层架构设计）"></a>数据访问层设计（持久层架构设计）</h3><h4 id="5种数据访问模式"><a href="#5种数据访问模式" class="headerlink" title="5种数据访问模式"></a>5种数据访问模式</h4><h5 id="在线访问"><a href="#在线访问" class="headerlink" title="在线访问"></a>在线访问</h5><p>在线访问是最基本的数据访问模式，也是在实际开发过程中最常采用的。</p>
<p>如图16-8所示，这种数据访问模式会占用一个数据库连接，读取数据，每个数据库操作都会通过这个连接不断地与后台的数据源进行交互。</p>
<details><summary>图16-8　在线访问模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143641.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143641.png';" /></details>


<h5 id="Data-Access-Object"><a href="#Data-Access-Object" class="headerlink" title="Data Access Object"></a>Data Access Object</h5><p>如图16-9所示，DAO模式是标准J2EE设计模式之一，开发人员常常用这种模式将底层数据访问操作与高层业务逻辑分离开。</p>
<details><summary>图16-9　DAO模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143708.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143708.png';" /></details>

<p>一个典型的DAO实现通常有以下组件。</p>
<p>（1）一个DAO工厂类。</p>
<p>（2）一个DAO接口。</p>
<p>（3）一个实现了DAO接口的具体类。</p>
<p>（4）数据传输对象。</p>
<p>这当中具体的DAO类包含访问特定数据源的数据的逻辑。</p>
<h5 id="Data-Transfer-Object"><a href="#Data-Transfer-Object" class="headerlink" title="Data Transfer Object"></a>Data Transfer Object</h5><p>如图16-10所示，Data Transfer Object是经典EJB设计模式之一。DTO本身是这样一组对象或是数据的容器，它需要跨不同的进程或是网络的边界来传输数据。这类对象本身应该不包含具体的业务逻辑，并且通常这些对象内部只能进行一些诸如内部一致性检查和基本验证之类的方法，而且这些方法最好不要再调用其他的对象行为。</p>
<details><summary>图16-10　DTO模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143734.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143734.png';" /></details>

<p>在具体设计这类对象（DTO）时，通常可以有如下两种选择。</p>
<p>（1）使用编程语言内置的集合对象，它通常只需要一个类，就可以在整个应用程序中满足任何数据传输目的；而且几乎所有的编程语言都内置了集合类型，不需要再另外编写实现代码。同时，使用内置的集合对象来实现DTO对象的时候，客户端必须按位置序号（在简单数组的情况下）或元素名称（在键控集合的情况下）访问集合内的字段。不过，集合存储的是同一类型（通常是最基本的Object类型）的对象，这有时会导致在编译时碰到一些无法检测到的编码错误。</p>
<p>（2）通过创建自定义类来实现DTO对象，通过定义显示的get或是set方法来访问数据。这种方式能够提供与任何其他对象完全一样的、客户端应用程序可访问的强类型对象。这种对象可以提供编译时的类型检查，但是增加了编码的工作量，若应用程序发出许多远程调用的话，需要编写大量的调用代码。</p>
<p>具体实现中有许多方法试图将上述这两种方法的优点结合在一起。第一种方法是代码生成技术，该技术可以生成脱离现有元数据（如可扩展标记语言XML架构）的自定义DTO类的源代码；第二种方法是提供更强大的集合，尽管它也是平台内置的一般的集合，但它将关系和数据类型信息与原始数据存储在一起，例如IBM提出的SDO技术或是微软ADO.NET中的DataSet就支持这类方法。</p>
<h5 id="离线数据模式"><a href="#离线数据模式" class="headerlink" title="离线数据模式"></a>离线数据模式</h5><p>离线数据模式是以数据为中心，数据从数据源获取之后，将按照某种预定义的结构（这种结构可以是SDO中的Data图表结构，也同样可以是ADO.NET中的关系结构）存放在系统中，成为应用的中心。离线，对数据的各种操作独立于各种与后台数据源之间的连接或是事务；与XML集成，数据可以方便地与XML格式的文档之间互相转换；独立于数据源，离线数据模式的不同实现定义了数据的各异的存放结构和规则，这些都是独立于具体的某种数据源的。</p>
<h5 id="对象-关系映射（Object-Relation-Mapping-O-R-Mapping）"><a href="#对象-关系映射（Object-Relation-Mapping-O-R-Mapping）" class="headerlink" title="对象/关系映射（Object/Relation Mapping, O/R Mapping）"></a>对象/关系映射（Object/Relation Mapping, O/R Mapping）</h5><p>在最近几年，采用OR映射的指导思想来进行数据持久层的设计似乎已经成了一种潮流。对象/关系映射的基本思想来源于这样一种现实：大多数应用中的数据都是依据关系模型存储在关系型数据库中；而很多应用程序中的数据在开发或是运行时则是以对象的形式组织起来的。那么，对象/关系映射就提供了这样一种工具或是平台，能够帮助将应用程序中的数据转换成关系型数据库中的记录；或是将关系数据库中的记录转换成应用程序中代码便于操作的对象。</p>
<h4 id="工厂模式在数据访问层应用"><a href="#工厂模式在数据访问层应用" class="headerlink" title="工厂模式在数据访问层应用"></a>工厂模式在数据访问层应用</h4><p>在应用程序的设计中，数据库的访问是非常重要的，数据库的访问需要良好的封装性和可维护性。在.Net中，数据库的访问，对于微软自家的SqlServer和其他数据库（支持OleDb），采用不同的访问方法，这些类分别分布于System.Data.SqlClient和System.Data.OleDb名称空间中。微软后来又推出了专门用于访问Oracle数据库的类库。我们希望在编写应用系统的时候，不因这么多类的不同而受到影响，尽量做到数据库无关。</p>
<p>这就需要在实际开发过程中将这些数据库访问类再作一次封装。经过这样的封装，不仅可以达到上述的目标，还可以减少操作数据库的步骤，减少代码编写量。工厂设计模式是使用的主要方法。</p>
<p>工厂模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。这里可能会处理对多种数据库的操作，因此，需要首先定义一个操纵数据库的接口，然后根据数据库的不同，由类工厂决定实例化哪个类。</p>
<p>下面首先来定义这个访问接口。为了方便说明问题，在这里只列出了比较少的方法，其他的方法是很容易参照添加的。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143944.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143944.png';" /></details>

<p>因为DataAccess的具体实现类有一些共同的方法，所以先从DataAccess实现一个抽象的AbstractDataAccess类，包含一些公用方法。然后，分别为Sql Server、Oracle和OleDb数据库编写三个数据访问的具体实现类。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144006.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144006.png';" /></details>

<p>现在已经完成了所要的功能，下面需要创建一个Factory类，来实现自动数据库切换的管理。这个类很简单，主要的功能就是根据数据库类型，返回适当的数据库操纵类。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144029.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144029.png';" /></details>

<p>现在一切都完成了，客户端在代码调用的时候，可能就是采用如下形式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144047.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144047.png';" /></details>

<p>或者，如果事先设定了DataAccessFactory的DefaultPersistenceProperty属性，可以直接使用DataAccess db= DataAccessFactory.CreateDataAccess()方法创建DataAccess实例。</p>
<p>当数据库发生变化时，只需要修改PersistenceProperty的值，客户端不会感觉到变化，也不用去关心。这样，实现了良好的封装性。当然，前提是你在编写程序时，没有用到特定数据库的特性，例如，Sql Server的专用函数。</p>
<h4 id="ORM、Hibernate与CMP2-0设计思想"><a href="#ORM、Hibernate与CMP2-0设计思想" class="headerlink" title="ORM、Hibernate与CMP2.0设计思想"></a>ORM、Hibernate与CMP2.0设计思想</h4><p>ORM（Object-Relation Mapping）在关系型数据库和对象之间作一个映射，这样，在具体操作数据库时，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作即可。</p>
<p>当你开发一个应用程序的时候（不使用OR Mapping），可能会涉及许多数据访问层的代码，用来从数据库保存、删除和读取对象信息等，然而这些代码写起来总是重复的。</p>
<p>一个更好的办法就是引入OR Mapping。实质上，一个OR Mapping会为你生成DAL。与其自己写DAL代码，不如用OR Mapping，你只需要关心对象就好。</p>
<p>使用ORM可以大大降低学习和开发成本。而在实际的开发中，真正对客户有价值的是其独特的业务功能，而不应该把大量时间花费在编写数据访问、CRUD方法、后期的Bug查找和维护上。在使用ORM之后，ORM框架已经把数据库转变成了我们熟悉的对象，我们只需要了解面向对象开发就可以实现数据库应用程序的开发，不需要浪费时间在SQL上。同时也可减少代码量，减少数据层出错机会。</p>
<p>通过Cache的实现，能够对性能进行调优，实现了ORM区隔了实际数据存储和业务层之间的关系，能够对每一层进行单独跟踪，增加了性能优化的可能。</p>
<p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了轻量级的对象封装，使Java程序员可以随心所欲地使用对象编程思维来操纵数据库。它不仅提供了从Java类到数据表之间的映射，还提供了数据查询和恢复机制。相对于使用JDBC和SQL来手工操作数据库，Hibernate可以大大减少操作数据库的工作量。另外，Hibernate可以利用代理模式来简化载入类的过程，这将大大减少利用Hibernate QL从数据库提取数据的代码的编写量。Hibernate可以和多种Web服务器或者应用服务器良好集成，如今已经支持几乎所有流行的数据库服务器。</p>
<p>Hibernate技术本质上是一个提供数据库服务的中间件，它的架构如图16-11所示。</p>
<details><summary>图16-11　Hibernate架构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144125.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144125.png';" /></details>

<p>图16-11显示了Hibernate件（如hibernate.properties）的工作原理，它是利用数据库以及其他一些配置XML Mapping等来为应用程序提供数据持久化服务的。</p>
<p>Hibernate具有很大的灵活性，但同时它的体系结构比较复杂，提供了好几种不同的运行方式。在轻型体系中，应用程序提供JDBC连接，并且自行管理事务，这种方式使用了Hibernate的一个最小子集。在全面解决体系中，对于应用程序来说，所有底层的JDBC/JTA API都被抽象了，Hibernate会替你照管所有的细节。</p>
<p>Hibernate是一个功能强大，可以有效地进行数据库数据到业务对象的0/R映射方案。Hibernate推动了基于普通Java对象模型，用于映射底层数据结构的持久对象的开发。通过将持久层的生成自动扩展到一个更大的范围，Hibernate使开发人员专心实现业务逻辑而不用分心于繁琐的数据库方面的逻辑，同时提供了更加合理的模块划分的方法。</p>
<h4 id="灵活运用Xml-Schema"><a href="#灵活运用Xml-Schema" class="headerlink" title="灵活运用Xml Schema"></a>灵活运用Xml Schema</h4><p>XML Schema用来描述XML文档合法结构、内容和限制。XML Schema由XML 1.0自描述，并且使用了命名空间，有丰富的内嵌数据类型及其强大的数据结构定义功能，充分地改造了并且极大地扩展了DTDs（传统描述XML文档结构和内容限制的机制）的能力，将逐步替代DTDs，成为XML体系中正式的类型语言，同XML规范、Namespace规范一起成为XML体系的坚实基础。</p>
<p>XML Schema由诸如类型定义和元素声明的组件组成，可以用来评估一个格式良好元素和属性信息的有效性。XML Schema是Schema组件的集合，这些组件分为三组：基本组件、组件和帮助组件。其中基本组件包括简单类型定义、复杂类型定义、属性声明和元素声明；组件包括属性组、完整性约束定义、模型组和符号声明；帮助组件包括注释、模型组、小品词、通配符和属性使用。Schema组件详细说明了抽象数据模型的每个组件的严格语义，每个组件在XML中的表示，一个XML Schema文档类型的DTD和XML Schema引用。</p>
<p>XML Schema提供了创建XML文档必要的框架，详细说明了一个XML文档的不同元素和属性的有效结构、限制和数据类型。XML Schema规范由如下三部分组成。</p>
<p>（1）XML Schema PartO: Primer。一个非标准化的文档，提供了XML Schema的一个简单可读的描述，目的是快速地理解如何利用XML Schema语言创建一个Schema（框架）。</p>
<p>（2）XML Schema Part1: Structures。这一部分详细说明了XML Schema定义语言，这个语言为描述XML 1.0文档的结构和内容限制提供了便利，包括开发了XMLNamespace（命名空间）的使用。</p>
<p>（3）XML Schema Part2: Datatypes。这一部分定义了可用于XML Schema和其他XML规范中的定义数据类型的方法。这个数据类型语言，本身由XML 1.0自描述，提供了说明元素和属性数据类型的XML 1.0文档类型定义（DTDs）的一个超集。这部分提出了标准的数据类型内容集合，其中讲述了目的、需求、范围和术语。XML Schema与DTD相比，有其独特的特点，提供了丰富的数据类型，实现了继承和复用，与命名空间紧密联系，易于使用。</p>
<p>与DTD不同，XML Schema规范提供了丰富的数据类型。其中不仅包括一些内嵌的数据类型，如string、integer、Boolean、time和date等，还提供了定义新类型的能力，如complexType和simpleType。开发者可以利用内嵌的数据类型和用户定义的数据类型，有效地定义和限制XML文档的属性和元素值。</p>
<p>XML Schema支持继承是它的另一特点。可以利用从已经存在的schema中获得某些类型而构造新的schema，也可以在不需要时使获得的类型无效。同时，XML Schema能将一个schema分成单独的组件，这样，在写Schema时，就可以正确地引用已经定义的组件。继承性使得软件复用更加有效，帮助开发者避免了每一次创建都要从零开始，极大地提高了软件开发和维护的效率。</p>
<p>XML Schema与XML Namespace紧密联系，使得在一个命名空间中创建元素和属性非常容易。这种联系简化了使用多个命名空间定义多个schema的XML文档的创建和验证文档有效性。</p>
<h4 id="事务处理设计"><a href="#事务处理设计" class="headerlink" title="事务处理设计"></a>事务处理设计</h4><p>事务是现代数据库理论中的核心概念之一。如果一组处理步骤或者全部发生或者一步也不执行，我们称该组处理步骤为一个事务。当所有的步骤像一个操作一样被完整地执行，我们称该事务被提交。由于其中的一部分或多步执行失败，导致没有步骤被提交，则事务必须回滚（回到最初的系统状态）。事务必须服从ISO/IEC所制定的ACID原则。ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）的缩写。事务的原子性表示事务执行过程中的任何失败都将导致事务所做的任何修改失效。一致性表示当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态。隔离性表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见。持久性表示已提交的数据在事务执行失败时，数据的状态都应该正确。</p>
<p>一般情况下，J2EE应用服务器支持JDBC事务、JTA （Java Transaction API）事务和容器管理事务。一般情况下，最好不要在程序中同时使用上述三种事务类型，例如在JTA事务中嵌套JDBC事务。另外，事务要在尽可能短的时间内完成，不要在不同方法中实现事务的使用。下面举列说明两种事务处理方式。</p>
<h5 id="JavaBean中使用JDBC方式进行事务处理"><a href="#JavaBean中使用JDBC方式进行事务处理" class="headerlink" title="JavaBean中使用JDBC方式进行事务处理"></a>JavaBean中使用JDBC方式进行事务处理</h5><p>在JDBC中怎样将多个SQL语句组合成一个事务呢？在JDBC中，打开一个连接对象Connection时，默认是auto-commit模式，每个SQL语句都被当作一个事务，即每次执行一个语句，都会自动地得到事务确认。为了能将多个SQL语句组合成一个事务，要将auto-commit模式屏蔽掉。在auto-commit模式屏蔽掉之后，如果不调用commit()方法，SQL语句不会得到事务确认。在最近一次commit()方法调用之后的所有SQL会在方法commit()调用时得到确认。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144235.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144235.png';" /></details>

<h5 id="SessionBean中的JTA事务"><a href="#SessionBean中的JTA事务" class="headerlink" title="SessionBean中的JTA事务"></a>SessionBean中的JTA事务</h5><p>JTA是事务服务的J2EE解决方案。本质上，它是描述事务接口（例如UserTransaction接口，开发人员直接使用该接口或者通过J2EE容器使用该接口来确保业务逻辑能够可靠地运行）的J2EE模型的一部分。JTA具有的三个主要的接口，分别是UserTransaction接口、TransactionManager接口和Transaction接口。这些接口共享公共的事务操作，例如commit()和rollback()；但是也包含特殊的事务操作，例如suspend()、resume()和enlist()，它们只出现在特定的接口上，以便在实现中允许一定程度的访问控制。例如，UserTransaction能够执行事务划分和基本的事务操作，而TransactionManager能够执行上下文管理。</p>
<p>应用程序可以调用UserTransaction.begin()方法开始一个事务，该事务与应用程序正在其中运行的当前线程相关联。底层的事务管理器实际处理线程与事务之间的关联。UserTransaction.commit()方法终止与当前线程关联的事务。UserTransaction.rollback()方法将放弃与当前线程关联的当前事务。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144309.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144309.png';" /></details>

<h4 id="连接对象管理设计"><a href="#连接对象管理设计" class="headerlink" title="连接对象管理设计"></a>连接对象管理设计</h4><p>在基于JDBC的数据库应用开发中，数据库连接的管理是一个难点，因为它是决定该应用性能的一个重要因素。</p>
<p>对于共享资源，有一个很著名的设计模式——资源池。该模式正是为了解决资源频繁分配、释放所造成的问题。把该模式应用到数据库连接管理领域，就是建立一个数据库连接池，提供一套高效的连接分配、使用策略。</p>
<p>建立连接池的第一步，就是要建立一个静态的连接池。所谓静态，是指池中的连接是在系统初始化时就分配好的，并且不能够随意关闭。Java中给我们提供了很多容器类，可以方便地用来构建连接池，如Vector、Stack等。在系统初始化时，根据配置创建连接并放置在连接池中，以后所使用的连接都是从该连接池中获取的，这样就可以避免连接随意建立、关闭造成的开销（当然，我们没有办法避免Java的Garbage Collection带来的开销）。</p>
<p>有了这个连接池，下面就可以提供一套自定义的分配、释放策略。当客户请求数据库连接时，首先看连接池中是否有未分配出去的连接。如果存在空闲连接则把连接分配给客户，并作相应处理。具体处理策略，在关键议题中会详述，主要的处理策略就是标记该连接为已分配。若连接池中没有空闲连接，就在已经分配出去的连接中，寻找一个合适的连接给客户，此时该连接在多个客户间复用。</p>
<p>当客户释放数据库连接时，可以根据该连接是否被复用，进行不同的处理。如果连接没有使用者，就放入到连接池中，而不是被关闭。可以看出，正是这套策略保证了数据库连接的有效复用。</p>
<h3 id="数据架构规划与设计"><a href="#数据架构规划与设计" class="headerlink" title="数据架构规划与设计"></a>数据架构规划与设计</h3><h4 id="数据库设计与类的设计融合"><a href="#数据库设计与类的设计融合" class="headerlink" title="数据库设计与类的设计融合"></a>数据库设计与类的设计融合</h4><p>对类和类之间关系的正确识别是数据模型的关键所在。本节将讨论如何发现、识别以及描述类。要想将建模过程缩减为一个简单的、逐步进行的过程是不太可能的。从本质上讲，建模是一项艺术。对一个给定的复杂情况而言，不存在唯一正确的数据模型，然而却存在好的数据模型。一个企业或机构的某个数据模型可能会优于另一个数据模型，但就如何为一个特定的系统建立数据模型，却没有唯一的解决方案。</p>
<p>好模型的目标是将工程项目整个生存期内的花费减至最小，同时也会考虑到随时间的推移系统将可能发生的变化，因而设计时也要很容易地能适应这些变化。因此，将目光集中在最大限度地降低开发费用上是一个错误。</p>
<h4 id="数据库设计与XML设计融合"><a href="#数据库设计与XML设计融合" class="headerlink" title="数据库设计与XML设计融合"></a>数据库设计与XML设计融合</h4><p>WWW的迅速发展，使其成为全球信息传递和共享日益重要和最具潜力的资源，电子商务、电子图书和远程教育等全新领域的需求和发展，使Web数据变得更加复杂和多样化，利用传统数据库技术很难存储和管理所有不同的Web数据。</p>
<p>目前，XML正在成为Internet上数据描述和交换的标准，并且将来会代替HTML而成为Web上保存数据的主要格式。</p>
<p>XML文档分为两类：一类是以数据为中心的文档，这种文档在结构上是规则的，在内容上是同构的，具有较少的混合内容和嵌套层次，人们只关心文档中的数据而并不关心数据元素的存放顺序，这种文档简称为数据文档，它常用来存储和传输Web数据。另一类是以文档为中心的文档，这种文档的结构不规则，内容比较零散，具有较多的混合内容，并且元素之间的顺序是有关的，这种文档常用来在网页上发布描述性信息、产品性能介绍和E-mail信息等。</p>
<p>Web上存有大量的XML文档，并需要持久保存，这一需求引发了人们对XML文档的存储技术研究。已经提出的XML文档的存储方式有两种：基于文件的存储方式和数据库存储方式。</p>
<p>（1）基于文件的存储方式。基于文件的存储方式是指将XML文档按其原始文本形式存储，主要存储技术包括操作系统文件库、通用文档管理系统和传统数据库的列（作为二进制大对象BLOB或字符大对象CLOB）。这种存储方式需维护某种类型的附加索引，以建立文件之间的层次结构。基于文件的存储方式的特点：无法获取XML文档中的结构化数据；通过附加索引可以定位具有某些关键字的XML文档，一旦关键字不确定，将很难定位；查询时，只能以原始文档的形式返回，即不能获取文档内部信息；文件管理存在容量大、管理难的缺点。</p>
<p>（2）数据库存储方式。数据库在数据管理方面具有管理方便、存储占用空间小、检索速度快、修改效率高和安全性好等优点。一种比较自然的想法是采用数据库对XML文档进行存取和操作，这样可以利用相对成熟的数据库技术处理XML文档内部的数据。数据库存储方式的特点：能够管理结构化和半结构化数据；具有管理和控制整个文档集合本身的能力；可以对文档内部的数据进行操作；具有数据库技术的特性，如多用户、并发控制和一致性约束等；管理方便，易于操作。</p>
<p>在某种程度上，XML及其一系列相关技术就是一个数据库系统。它提供了传统数据库所具有的特点，如存储（以XML文档形式）、数据库的模式（DTD或XMLSchema）、查询语言（XQuery、XPath、XQL和XML-QL等）和编程接口（如SAX、DOM）等。但与传统数据库相比，它在存储、索引、安全、多用户访问和事务管理等方面还存在不足之处。在一定的环境下，例如当数据量和操作用户较少并且性能要求不高的情况下，XML文档能够作为数据库在应用程序中使用。如果应用程序有许多操作用户，并且要求严格的数据完整性和性能要求，则不宜采用XML文档。</p>
<p>XML数据库是一组XML文档的集合，并且是持久的和可操作的；有专门的DBMS管理（不是XML文件系统）；文档都是有效的（即符合某一模式）；文档的集合可能基于多个模式文件（即文件扩展名为.xsd），多个模式文件之间可能有语法和语义上的相互联系。</p>
<h3 id="实战案例——电子商务网站（网上商店PetShop）"><a href="#实战案例——电子商务网站（网上商店PetShop）" class="headerlink" title="实战案例——电子商务网站（网上商店PetShop）"></a>实战案例——电子商务网站（网上商店PetShop）</h3><p>PetShop是一个范例，微软用它来展示.Net企业系统开发的能力。PetShop随着版本的不断更新，至现在基于.Net 2.0的PetShop4.0为止，整个设计逐渐变得成熟而优雅，有很多可以借鉴之处。PetShop是一个小型的项目，系统架构与代码都比较简单，却也凸现了许多颇有价值的设计与开发理念。</p>
<h4 id="PetShop的系统架构设计"><a href="#PetShop的系统架构设计" class="headerlink" title="PetShop的系统架构设计"></a>PetShop的系统架构设计</h4><p>PetShop的表示层是用ASP.Net设计的，也就是说，它应是一个BS系统。在.Net中，标准的BS分层式结构如图16-12所示。</p>
<details><summary>图16-12　Net中标准的BS分层式结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144722.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144722.png';" /></details>

<p>随着PetShop版本的更新，其分层式结构也在不断的完善，例如PetShop 2.0，就没有采用标准的三层式结构，如图16-13所示。</p>
<details><summary>图16-13　PetShop 2.0的体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144739.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144739.png';" /></details>

<p>从图16-13中可以看到，并没有明显的数据访问层设计。这样的设计虽然提高了数据访问的性能，但也同时导致了业务逻辑层与数据访问的职责混乱。一旦要求支持的数据库发生变化，或者需要修改数据访问的逻辑，由于没有清晰的分层，会导致项目做大的修改。而随着硬件系统性能的提高，以及充分利用缓存、异步处理等机制，分层式结构所带来的性能影响几乎可以忽略不计。</p>
<p>PetShop 3.0纠正了此前层次不明的问题，将数据访问逻辑作为单独的一层独立出来。PetShop 3.0的体系架构如图16-14所示。</p>
<details><summary>图16-14　PetShop 3.0的体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144756.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144756.png';" /></details>

<p>PetShop 4.0基本上延续了3.0的结构，但在性能上作了一定的改进，引入了缓存和异步处理机制，同时又充分利用了ASP.Net 2.0的新功能MemberShip。因此，PetShop 4.0的系统架构如图16-15所示。</p>
<details><summary>图16-15　PetShop 4.0的体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144820.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144820.png';" /></details>

<p>比较3.0和4.0的系统架构图，其核心的内容并没有发生变化。在数据访问层（DAL）中，仍然采用DAL Interface抽象出数据访问逻辑，并以DAL Factory作为数据访问层对象的工厂模块。对于DAL Interface而言，分别有支持MS-SQL的SQL Server DAL和支持Oracle的Oracle DAL具体实现，而Model模块则包含了数据实体对象，其详细的模块结构如图16-16所示。</p>
<p>可以看到，在数据访问层中，完全采用了“面向接口编程”思想。抽象出来的IDAL模块，脱离了与具体数据库的依赖，从而使得整个数据访问层有利于数据库迁移。DALFactory模块专门管理DAL对象的创建，便于业务逻辑层访问。SQLServerDAL和OracleDAL模块均实现IDAL模块的接口，其中包含的逻辑就是对数据库的Select、Insert、Update和Delete操作。因为数据库类型的不同，对数据库的操作也有所不同，代码也会因此有所区别。</p>
<p>此外，抽象出来的IDAL模块，除了解除了向下的依赖之外，对于其上的业务逻辑层同样仅存在弱依赖关系，如图16-17所示。</p>
<details><summary>图16-17　业务逻辑层的模块结构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144850.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144850.png';" /></details>

<p>图16-17中，BLL是业务逻辑层的核心模块，它包含了整个系统的核心业务。在业务逻辑层中，不能直接访问数据库，而必须通过数据访问层。注意，图16-17中对数据访问业务的调用，是通过接口模块IDAL来完成的。既然与具体的数据访问逻辑无关，则层与层之间的关系就是松散耦合的。如果此时需要修改数据访问层的具体实现，只要不涉及到IDAL的接口定义，那么业务逻辑层就不会受到任何影响。毕竟，具体实现的SQLServerDAL和OracalDAL根本就与业务逻辑层没有半点关系。</p>
<p>因为在PetShop 4.0中引入了异步处理机制，插入订单的策略可以分为同步和异步，两者的插入策略明显不同。但对于调用者而言，插入订单的接口是完全一样的，所以PetShop 4.0中设计了IBLLStrategy模块。虽然在IBLLStrategy模块中，仅仅是简单的IOrderStategy，但同时也给出了一个范例和信息，那就是在业务逻辑的处理中，如果存在业务操作的多样化或者是今后可能的变化，均应利用抽象的原理、或者使用接口、或者使用抽象类，从而脱离对具体业务的依赖。不过在PetShop中，由于业务逻辑相对简单，这种思想体现得不够明显。也正因为此，PetShop将核心的业务逻辑都放到了一个模块BLL中，并没有将具体的实现和抽象严格地按照模块分开。所以表示层和业务逻辑层之间的调用关系，其耦合度相对较高。</p>
<p>图16-18表示层的模块结构图中，各个层次中还引入了辅助的模块，如数据访问层的Messaging模块，是为异步插入订单的功能提供，采用了MSMQ（Microsoft Messaging Queue）技术，而表示层的CacheDependency则提供缓存功能。</p>
<details><summary>图16-18　表示层的模块结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144906.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144906.png';" /></details>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch15-%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E7%AE%A1%E7%90%86%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch15-%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E7%AE%A1%E7%90%86%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch15-架构师的管理实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:56:44" itemprop="dateCreated datePublished" datetime="2021-07-19T12:56:44+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 14:25:20" itemprop="dateModified" datetime="2021-09-04T14:25:20+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="架构师的管理实践"><a href="#架构师的管理实践" class="headerlink" title="架构师的管理实践"></a>架构师的管理实践</h2><p>在实践过程中，软件架构的主要障碍往往在于组织方面而非技术。创造切实可行的软件架构需要对技术的深入把握、良好的认知能力和沟通技巧以及大量艰苦的工作。技术上出色的架构往往由于没有全面地处理好组织管理因素而失败。架构师利用自己的知识影响团队，常被大家认为是无冕之王，因此架构师需要管理技巧。本章介绍了架构师的VRAPS实践。</p>
<h3 id="VRAPS组织管理原则"><a href="#VRAPS组织管理原则" class="headerlink" title="VRAPS组织管理原则"></a>VRAPS组织管理原则</h3><p>VRAPS是为实践软件架构的组织管理原则提出的，包括构想、节奏、预见、协作和简化5个相关联的原则。每项原则都是实际可操作的，原则的提出都来源于构建软件架构的直接经验，并且都可以用来解释实践。VRAPS模型的焦点在开发和使用软件架构过程的组织管理方面，其应用环境不仅包括建立和部署架构的团队，还包括利用架构开发和利用产品线的团队和使用这些产品的客户。</p>
<p>受益人是指建立并长期保持架构的价值有重要影响的人或组织。受益人一般包括发起人、应用开发人员和应用客户，还可能包括其他重要的参与者，如技术供应方。</p>
<p>（1）构想原则：说明了如何向架构的受益人描述一幅一致的、有约束力和灵活的未来图景。</p>
<p>（2）节奏原则：刻画了一种在整个组织范围内的协调程度，即定期地根据可预测的速度、内容和质量对制品生产进行检查与规划。</p>
<p>（3）预见原则：要在预测未来与检查并适应现状之间做出平衡。</p>
<p>（4）协作原则：解决了如何识别对架构成功关键的团体，以及如何确保这些合作伙伴的有效支持。</p>
<p>（5）简化原则：要求理解组织的结构，了解架构最小的基本特征并最小化架构。</p>
<p>各个原则之间不是相互孤立的，图15-1解释了构想原则如何与其他原则交互。构想原则确立了总体方向，使得节奏原则所要求的协调工作能够进行。而一个好的节奏又可以使组织朝着构想原则制定的目标不断提供递增的进展。构想原则中的假设根据预见原则进行测试和验证。在架构演化中，应注意环境的变化，并把这些变化加入到构想中。构想帮助建立准则，以挑选合作伙伴和理解他人给架构带来的价值。这些合作伙伴的约束是一个好的构想的关键要素。构想对简化原则也起到了作用。预期的价值经过解释被运用到架构的决策中，而反过来又帮助完善构想。</p>
<details><summary>图15-1　构想与其他原则之间的交互关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140553.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140553.png';" /></details>

<p>所有其他的原则也是彼此之间相互影响的。例如，节奏原则中的协调组活动如果没有了协作是不可能完成的。通过在每个开发周期中关注最小的关键需求，节奏原则又帮助了简化原则的进行。</p>
<h3 id="概念框架"><a href="#概念框架" class="headerlink" title="概念框架"></a>概念框架</h3><p>为了更好地使用VRAPS原则，我们用准则、模式和反模式来对各项原则进行补充。准则用于判断每项原则的实施效果如何。模式描述了开发和使用软件架构时可能遇到的常见问题和解决方法，能够帮助组织改进原则。反模式则描述了组织在实践中可能遇到的陷阱。</p>
<h4 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h4><p>为了把原则运用到实践中，需要可操作的实施细节。准则把广泛的原则翻译成是否和如何执行原则的细节。</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>第一项原则都附有一组模式，它描述了开发或者使用软件架构时可能遇到的常见问题的解决方法。模式更注重于解决特定情况下的问题，传达了在给定背景和多方竞争因素下针对常见问题的解决方案。</p>
<h4 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h4><p>反模式描述了组织在实践中可能遇到的陷阱，描述了不该做的事情，或者用在错误背景下的解决方案，可以帮助更深入地理解原则。</p>
<h3 id="形成并统一构想"><a href="#形成并统一构想" class="headerlink" title="形成并统一构想"></a>形成并统一构想</h3><p>构想描述了架构的未来，提供了架构使用的环境和动机。构想是未来价值到架构约束的映射，构想要成功，则必须把它所能提供的价值与客户的约束相对应。构想也必须是明晰的、有约束力的、一致的和灵活的，从而能够被其受益人理解并有效地运用。</p>
<p>例如，在大型组织中，管理层可能把项目架构师与维护产品构想的高级经理分隔开来。这种距离会维持构想一致性，导致架构难以满足维护要求，引发后期运行成本问题。为了应对类似组织结构产生的复杂性，高级经理和架构师之间建立稳固的、积极的关系以及共享统一的构想至关重要。</p>
<p>把价值映射为架构约束，要求开发人员把约束诸如接口、开发语言和模块边界等映射到特定的客户价值上。促使受益人把约束与客户价值捆绑需要高超的技艺，用例建模是把架构的预期使用与能够被满足的切实的用户目标连接起来的一种方法。例如，识别并表达出似乎无关的用例之间的实质性联系是建立构想的一个重要内容。</p>
<h4 id="形成构想"><a href="#形成构想" class="headerlink" title="形成构想"></a>形成构想</h4><p>构想需要维持一致性与协调性。一致性是指受益人的各种期望之间妥协，以及它们与现在和将来的架构之间的需求满足程度。灵活性是指受益人在不破坏架构的情况下，在现有架构之上完成事先没有预料到的需求的容易程度。</p>
<p>一致性并不意味着所有受益人之间拥有一张完全一致的构想视图，而是指各受益人共享的视图根据他们不同的视角保持一致。RUP的“4＋1架构视图”体现了获得这种一致性的方法。RUP通过逻辑视图（Logic View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）和用例视图（Use case View）建立了架构视图。这些架构视图的不同点在于，它们根据不同目的表示系统（例如，用例视图表示了系统的最终用户功能）。</p>
<p>架构师常负有将现实引入业务构想和将构想变成现实的责任。架构师可以推荐技术，包括如何以及何时采用这些技术， 由此来帮助确定业务构想的哪些部分可以在短期内实现，以及各部分实现的次序。</p>
<p>架构师更像管理者而并非实施者，Dean Thompson说：“作为架构师更多地意味着权衡业务、组织运作和使用技术，而不仅仅是技术细节。”例如，架构师应该全面研究整个组织，找出各利益方关注的重点，然后妥善平衡，建立符合主要关注问题的架构描述。</p>
<p>多方整合能促进构想的形成。多方整合是组织各利益方的机制，用于确保获得构想并使其稳定；是指在一个公共的组织层次上对信息、决策和资源进行协调。多方整合能使从事硬件设计的基层经理理解软件设计和开发人员，以及市场营销、客户支持和市场营销的同事的期望，包括增强组织与客户和外部供应者沟通的能力。</p>
<p>Thompson归纳了形成架构构想的三步方法：清楚明确地阐述一条迫切的客户价值；将客户价值映射为少数特定的能解决的问题；将以上问题转译成一组特定的约束条件。</p>
<p>成功的架构师用明确的客户价值映射规划未来，以使用户及它们的客户能将其与约束联系起来。架构师必须格外关注产品开发人员和最终的客户，而且为了成功，还要发动所有其他人做类似的事情。</p>
<h4 id="将构想原则付诸实践"><a href="#将构想原则付诸实践" class="headerlink" title="将构想原则付诸实践"></a>将构想原则付诸实践</h4><p>下面的准则、反模式和模式能帮助建立、形成、维护一个被共享的构想，将构想原则付诸实践。</p>
<p>用于检验构想原则是否起作用的准则如下。</p>
<p>（1）架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>（2）实施人员是否信任并使用架构。</p>
<p>（3）关于架构和构件的潜藏知识对其用户（开发团队）是否是可见的、可获得的。</p>
<p>构想原则中准则到模式、反模式的映射如表15-1所示。</p>
<details><summary>表15-1　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140731.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140731.png';" /></details>

<p>下面详细介绍与各准则相关的反模式和模式。</p>
<p>准则1：架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>为了获得一致、迫切和灵活的架构，需要产品线经理、架构师和实施经理等达成共识。而如果没有阐明用户价值，则会导致构想脱离了重点。</p>
<p>与准则1相关的反模式与模式如下。</p>
<p>1）反模式：风险后置</p>
<p>形容这样统一受益人的构想：用最小的妥协、最大的优化规划出一个构件以满足所有冲突利益的需要。这种统一方法的问题是，设计出来的构件往往在理论上可行，但实际运行中出现风险。</p>
<p>一条新产品线的架构师或经理，需要开发看似很棒但实现有风险的构件。这些要完成构件可能需要打破“物理定律”才能完成，这些风险可能在制品交付的最后才能显现。可是有一批工程师仍然坚持开发这些构件。风险构件被安排到最后完成，以为这样可以有时间消除风险。可是，当计划好的完成日期临近时，依然无法交付。尽管架构在演示的幻灯片上运转良好，实际上却无法正常工作。</p>
<p>面对这种情况，需要分析并阐明风险， 向高级经理提供一个选择，要么承认风险，要么调整任务。</p>
<p>2）模式：前后一致</p>
<p>要求推动架构投资的高级经理积极地维护构想，并防止构想受到短期压力的影响。</p>
<p>一个公共的架构被几个产品共享，它已经变得比预期要复杂得多。而客户们针对每件产品又提出了以前没有预计到的功能特性。如果加入这些功能特性，则不能保证进度，但如果不开发这个特性则可能失去一位重要客户。</p>
<p>这样的情况下，需要评估架构构想的质量和稳定性。只有当两者都正常时，才能采取进一步行动。如果该新特性不属于原来的产品构想支持的代价范围，那就应该放弃开发这个新特性。如果构想不明确，在短期内就交付很可能导致大量缺陷。此时应与客户、架构师和销售、产品、支持人员以及开发经理一起加强产品的构想。如果这个特性确实属于一个稳定的产品构想，那么应该在开发组织内核实这种一致性。</p>
<p>准则2：实施人员信任并使用架构。</p>
<p>只有使用架构，才能从中获得价值。然而，要让开发人员对架构构想充分信任需要做更多的工作，仅仅靠不断兑现承诺是不够的。开发人员需要把他们对构想的了解与他们认为对下一步行动有用的东西联系起来。开发人员在利用架构的过程中，可能会使架构向许多不同的方向发展。一个良好架构应与构想保持一致，同时又能满足用户的需求。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：墙头草</p>
<p>描述了这样一种情况：因为没有良好的构想，导致架构方向在竞争和客户压力的影响下经常改变。这种构想永远不能达到稳定以便有效地被共享。</p>
<p>在开发过程中，经常会出现这样一种情况：来自客户、竞争对手和高级经理的压力使得需要在一次发布的中途加入一些代价高昂的功能，高级经理甚至可能在没有咨询架构师的情况下决定提供这些功能。可是一旦交付了某个激进的功能，组织马上就会陷入对该功能的支持工作中。以后的发布会因需要提供向后兼容而变得更为复杂。</p>
<p>在这种情况下，要做的是理解并阐明构想。方便变更需求是成功构想的一部分，要对其进行规划。高级主管要与架构师一起紧密地工作，理解变更的后果并做出正确的权衡。在建立了构想之后，可以用前后一致模式来评估特定的变更建议。在把功能特性加入到发布之前，要坚持达成一致意见。这需要一种固定的机制，以使达成一致成为正常业务的一部分。如果架构满足了高层的约束条件，那么在细节的实施方面可以允许更多的灵活性。在最极端的情况下，解决墙头草问题可能需要寻找新的、期望更为接近的受益人。</p>
<p>2）模式：三个臭皮匠</p>
<p>三个臭皮匠：反映了这样一种认识，即架构师并非总是架构构想的来源，架构师和客户一起充实、完善构想。</p>
<p>一个共同的架构或平台是产品线战略的关键，架构发起人希望产品团体能开发出“杀手解决方案”，而同时又能避免追随新的标准、潮流带来的困扰。</p>
<p>在这种情况下，需要抵制创建一个无所不能的架构的诱惑，建立一种能让架构师及其用户都能丰富、实现功能特性的构想。高级经理只提供构想、目标和原则，把架构和平台留给架构师，把实现细节留给合适的团队或层次。一个成功的产品线架构必须能为适应市场变化，能适应和采用新技术，能解决在概念阶段还不知道的但变化场景可预见的问题。</p>
<p>这是一项很少有架构师能独立完成的任务，然而，通过高级经理建立正确的顶层业务构想，架构师采取实现构想的正确行动就能取得成功。</p>
<p>准则3：关于架构和构件的潜藏知识对其用户是可见的、可获得的。</p>
<p>1）反模式：一叶障目</p>
<p>一叶障目：发生在这种情况下：开发人员过分专注于应用，以致不知道其他架构解决同类问题的通用的解决方案。</p>
<p>在一个组织中，工程团队正在实践代码所有制模式，工程师们都把精力集中在自己眼前的任务和职责上，没有把自己当作一个共享资源的看护者。陷入本反模式的工程师的视野很窄，面对其他开发同事的请求往往只求解决问题，不愿意多加考虑。这样导致的工作结果可能变得非常复杂、脆弱而且容易出错，这是由一名工程师所无法预见的情况造成的。</p>
<p>要解决上面的问题，需创造一种分享知识的愿望。例如，工程师培训等方式就可以起到一些作用，整个组织的人员启用知识管理平台也能促进产生这种愿望。</p>
<p>2）模式：轮流工作</p>
<p>轮流工作：要求参与架构的工作人员轮流在架构的不同部分上工作。这样能使他们对架构有更多的了解，并有机会发展非正式的人际网络。</p>
<p>当一个产品线的销售增长到一定程度，一个单一的、聚集的团队已无法支撑架构和实现，人员被重新组织到地理上分布不同的团队中。已有的沟通管道与新的形势已经不相适应。</p>
<p>通过帮教制（Apprenticeship）模式阶段性地轮流交换构件的所有权可以解决上面的问题。组织和鼓励构件的前任负责人抽出时间帮助新的负责人，轮转周期应该尽可能地与发布进度保持同步。该方法能使开发人员更容易地发现如何找到有关构件的知识，团队成员掌握某个构件或者在出现问题时知道应该问谁的可能性也大大增加了。因此，意外发生的次数减少了。</p>
<h3 id="节奏：保证节拍、过程和进展"><a href="#节奏：保证节拍、过程和进展" class="headerlink" title="节奏：保证节拍、过程和进展"></a>节奏：保证节拍、过程和进展</h3><p>节奏原则使得软件架构在跨越组织边界的情况下开发和使用成为可能。由于许多参与开发和使用架构的团体是自治性的，不可能自上而下地协调这些团体，节奏原则提供了一个随时间变化的框架，可使团体同步各自的活动与期望。有了节奏，参与者就能知道何时关心和应该关心哪些活动。不仅计划中的活动可以被协调管理，节奏原则也可以协调那些非正式的但很关键的活动，例如团体间的交流，这样参与者就可以知道何时应该或不应该提出对于信息或支持的要求。</p>
<h4 id="节奏定义"><a href="#节奏定义" class="headerlink" title="节奏定义"></a>节奏定义</h4><p>节奏是一个架构团体内部及它与客户和供应者之间反复出现的、可预测的工件交换活动。节奏有三个元素：速度、内容和质量。速度是指一个团体与另一个团体之间同类型交接发生的频率，例如架构团队与产品开发工程师之间。如果交接的时间是可预测的，移交则容易管理。稳定的发布计划是速度的一个例子。内容是指一个团体向另一个团体提供的价值。例如，一个团体开发一种新的或者要修改的特性被另一个团体用于满足某种需要。质量的含义是遵循开发过程确保架构没有缺陷。组织可以通过省略非增值的步骤来加快速度，但是如果重要的流程被截掉了，节奏就会遭到破坏。</p>
<p>节奏在团体和组织之间与内部提供一种协调活动的稳定力量，帮助移交管理。当节奏很强时，受益人能培养很强的预见、实施移交和交接的技能。节奏还能驱动活动完结，拥有良好节奏的组织通过建立有规律的阶段间隙来推动评估、再评估和其他工作的进展。</p>
<h4 id="将节奏原则付诸实践"><a href="#将节奏原则付诸实践" class="headerlink" title="将节奏原则付诸实践"></a>将节奏原则付诸实践</h4><p>没有建立节奏会导致客户不满意、不期望的错误发生和工件无法一起工作。只有当以下准则出现时，才说明节奏原则起了作用。</p>
<p>（1）经理们定期地再评估、同步和调整架构。</p>
<p>（2）架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>（3）通过节奏协调明确的活动。</p>
<p>节奏原则中，准则到模式、反模式的映射如表15-2所示。</p>
<details><summary>表15-2　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904141235.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904141235.png';" /></details>

<p>准则1：经理们定期地再评估、同步和调整架构。</p>
<p>好的节奏需要有规律的节拍。对于架构组织的管理者，这意味着他们必须在稳定的间隙上再评估、同步和调整他们的架构计划。节奏的节拍还能提供一个计划过程的框架。具有良好节奏的一个组织用节拍而不是时间来衡量进度。</p>
<p>相关的反模式和模式如下。</p>
<p>1）反模式：一步成功</p>
<p>一步成功：是指当组织变得过于专注地向市场推出某项功能特性而导致内部节奏遭到破坏时发生的情形。组织被竞争所蒙蔽，全身心地专注于向市场提供该特性，却削减了质量，甚至可能破坏本来的节奏。</p>
<p>相关的解决办法有：把关键的功能特性作为团队节奏的一个组成部分来实现。围绕一个特定的主题来进行一次特定的发布，利用主题帮助抓住市场上的机会。如果关键特性特别复杂，则采用几次迭代来实现。但如果在实现关键特性的时候难以保持节奏，说明该特性的风险和复杂度比预计的要大，需要重新规划。</p>
<p>2）模式：发布委员会</p>
<p>发布委员会：描述了一种协调参与发布新架构的相关各方的方法。该模式向经理们介绍了一种在架构发布的最后阶段再评估、同步和调整架构的方法。</p>
<p>定期举办由组织中每个关键受益人参加的正式会议以引导发布的进程。在会议中，要复审产品功能特性和优先级的变更，从而使产品文档、市场承诺、公共关系、测试和开发保持一致。在适合的地方采用测量指标度量发布的进展，分享责任和依赖，做出如何前进的决定，并记录和传达会议的决定。参加委员会的成员应该保持稳定，会议成员的组成应保持一致，与会人员也应该有足够的决定权。</p>
<p>准则2：架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>如果架构用户不信任架构发布的进度和内容，那么用户就可能不采用新的架构发布，或者可能选择另一个架构。用户对架构发布的进度和内容缺乏信心是一个警告信号，说明没有建立一个良好的节奏。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：超敏捷</p>
<p>超敏捷：发生在组织试图在开发过程中抄近路以维持稳定的发布节拍的时候。该反模式对用户所期望的架构质量和内容进行了妥协。</p>
<p>过程执行的合适方法取决于组织文化。在有些组织中，阶段性的软件审计可以用于保证过程被遵守。然而，在许多组织中，审计并不是一种改变或约束行为的有效方法，高层管理的行动能更直接地改变组织行为。是否已经分配了足够的资源来执行计划中的步骤，经理们是否创建明确的目标来保证对节奏的维持都有非常重要的影响。</p>
<p>2）模式：舍兵保帅</p>
<p>舍兵保帅：探讨了组织如何通过把不太重要的特性移到后面的发布周期以保持一个节拍。通过保持节奏，该模式可以使用户获得对架构发布进度更多的信心。</p>
<p>如果对构件的修订看上去无法及时完成时，而且该修订并不非常重要，应该尽快向受益人说明。在不对延误构件做变更的情况下，继续发布架构。为了避免因用户没有阅读或看见特性变更说明而造成的问题，应该确保从预发布开始就放弃该特性，这样用户就能在α或β测试中体验到变化，而不是在正式的产品发布中。可以在以后的发布中再把该构件的变更加进来。通过上面的方法可以保持发布的速度，使架构发布后的活动计划能按进度进行。该方法还能推动构件负责人按时完成他们的修订工作。因为架构的发布实现了承诺，开发人员增强了信任感，他们对下一次如期发布也有了更多的信心。</p>
<p>准则3：通过节奏协调明确的活动。</p>
<p>软件架构的受益人分布在许多不同的组织中。一个共享的架构节奏能帮助这些自治团体跨越组织边界协同工作，因为它能帮助建立关于关键事件何时发生以及如何发生的共同假定。例如，如果一位产品开发员知道每年有一个架构主发布和若干季节性的维护发布，他就可以根据预期的架构发布安排产品发布时间，更好地利用新的架构特性。</p>
<p>与准则3相关的反模式与模式如下。</p>
<p>1）反模式：销售未检验的产品</p>
<p>销售未检验的产品在此情况下发生：一个组织试图实现定期的建立，但这些建立经常编译失第15章　架构师的管理实践</p>
<p>在实践过程中，软件架构的主要障碍往往在于组织方面而非技术。创造切实可行的软件架构需要对技术的深入把握、良好的认知能力和沟通技巧以及大量艰苦的工作。技术上出色的架构往往由于没有全面地处理好组织管理因素而失败。架构师利用自己的知识影响团队，常被大家认为是无冕之王，因此架构师需要管理技巧。本章介绍了架构师的VRAPS实践。</p>
<p>15.1　VRAPS组织管理原则</p>
<p>VRAPS是为实践软件架构的组织管理原则提出的，包括构想、节奏、预见、协作和简化5个相关联的原则。每项原则都是实际可操作的，原则的提出都来源于构建软件架构的直接经验，并且都可以用来解释实践。VRAPS模型的焦点在开发和使用软件架构过程的组织管理方面，其应用环境不仅包括建立和部署架构的团队，还包括利用架构开发和利用产品线的团队和使用这些产品的客户。</p>
<p>受益人是指建立并长期保持架构的价值有重要影响的人或组织。受益人一般包括发起人、应用开发人员和应用客户，还可能包括其他重要的参与者，如技术供应方。</p>
<p>（1）构想原则：说明了如何向架构的受益人描述一幅一致的、有约束力和灵活的未来图景。</p>
<p>（2）节奏原则：刻画了一种在整个组织范围内的协调程度，即定期地根据可预测的速度、内容和质量对制品生产进行检查与规划。</p>
<p>（3）预见原则：要在预测未来与检查并适应现状之间做出平衡。</p>
<p>（4）协作原则：解决了如何识别对架构成功关键的团体，以及如何确保这些合作伙伴的有效支持。</p>
<p>（5）简化原则：要求理解组织的结构，了解架构最小的基本特征并最小化架构。</p>
<p>各个原则之间不是相互孤立的，图15-1解释了构想原则如何与其他原则交互。构想原则确立了总体方向，使得节奏原则所要求的协调工作能够进行。而一个好的节奏又可以使组织朝着构想原则制定的目标不断提供递增的进展。构想原则中的假设根据预见原则进行测试和验证。在架构演化中，应注意环境的变化，并把这些变化加入到构想中。构想帮助建立准则，以挑选合作伙伴和理解他人给架构带来的价值。这些合作伙伴的约束是一个好的构想的关键要素。构想对简化原则也起到了作用。预期的价值经过解释被运用到架构的决策中，而反过来又帮助完善构想。</p>
<p>alt</p>
<p>图15-1　构想与其他原则之间的交互关系</p>
<p>所有其他的原则也是彼此之间相互影响的。例如，节奏原则中的协调组活动如果没有了协作是不可能完成的。通过在每个开发周期中关注最小的关键需求，节奏原则又帮助了简化原则的进行。</p>
<p>15.2　概念框架</p>
<p>为了更好地使用VRAPS原则，我们用准则、模式和反模式来对各项原则进行补充。准则用于判断每项原则的实施效果如何。模式描述了开发和使用软件架构时可能遇到的常见问题和解决方法，能够帮助组织改进原则。反模式则描述了组织在实践中可能遇到的陷阱。</p>
<p>1．准则</p>
<p>为了把原则运用到实践中，需要可操作的实施细节。准则把广泛的原则翻译成是否和如何执行原则的细节。</p>
<p>2．模式</p>
<p>第一项原则都附有一组模式，它描述了开发或者使用软件架构时可能遇到的常见问题的解决方法。模式更注重于解决特定情况下的问题，传达了在给定背景和多方竞争因素下针对常见问题的解决方案。</p>
<p>3．反模式</p>
<p>反模式描述了组织在实践中可能遇到的陷阱，描述了不该做的事情，或者用在错误背景下的解决方案，可以帮助更深入地理解原则。</p>
<p>15.3　形成并统一构想</p>
<p>构想描述了架构的未来，提供了架构使用的环境和动机。构想是未来价值到架构约束的映射，构想要成功，则必须把它所能提供的价值与客户的约束相对应。构想也必须是明晰的、有约束力的、一致的和灵活的，从而能够被其受益人理解并有效地运用。</p>
<p>例如，在大型组织中，管理层可能把项目架构师与维护产品构想的高级经理分隔开来。这种距离会维持构想一致性，导致架构难以满足维护要求，引发后期运行成本问题。为了应对类似组织结构产生的复杂性，高级经理和架构师之间建立稳固的、积极的关系以及共享统一的构想至关重要。</p>
<p>把价值映射为架构约束，要求开发人员把约束诸如接口、开发语言和模块边界等映射到特定的客户价值上。促使受益人把约束与客户价值捆绑需要高超的技艺，用例建模是把架构的预期使用与能够被满足的切实的用户目标连接起来的一种方法。例如，识别并表达出似乎无关的用例之间的实质性联系是建立构想的一个重要内容。</p>
<p>15.3.1　形成构想</p>
<p>构想需要维持一致性与协调性。一致性是指受益人的各种期望之间妥协，以及它们与现在和将来的架构之间的需求满足程度。灵活性是指受益人在不破坏架构的情况下，在现有架构之上完成事先没有预料到的需求的容易程度。</p>
<p>一致性并不意味着所有受益人之间拥有一张完全一致的构想视图，而是指各受益人共享的视图根据他们不同的视角保持一致。RUP的“4＋1架构视图”体现了获得这种一致性的方法。RUP通过逻辑视图（Logic View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）和用例视图（Use case View）建立了架构视图。这些架构视图的不同点在于，它们根据不同目的表示系统（例如，用例视图表示了系统的最终用户功能）。</p>
<p>架构师常负有将现实引入业务构想和将构想变成现实的责任。架构师可以推荐技术，包括如何以及何时采用这些技术， 由此来帮助确定业务构想的哪些部分可以在短期内实现，以及各部分实现的次序。</p>
<p>架构师更像管理者而并非实施者，Dean Thompson说：“作为架构师更多地意味着权衡业务、组织运作和使用技术，而不仅仅是技术细节。”例如，架构师应该全面研究整个组织，找出各利益方关注的重点，然后妥善平衡，建立符合主要关注问题的架构描述。</p>
<p>多方整合能促进构想的形成。多方整合是组织各利益方的机制，用于确保获得构想并使其稳定；是指在一个公共的组织层次上对信息、决策和资源进行协调。多方整合能使从事硬件设计的基层经理理解软件设计和开发人员，以及市场营销、客户支持和市场营销的同事的期望，包括增强组织与客户和外部供应者沟通的能力。</p>
<p>Thompson归纳了形成架构构想的三步方法：清楚明确地阐述一条迫切的客户价值；将客户价值映射为少数特定的能解决的问题；将以上问题转译成一组特定的约束条件。</p>
<p>成功的架构师用明确的客户价值映射规划未来，以使用户及它们的客户能将其与约束联系起来。架构师必须格外关注产品开发人员和最终的客户，而且为了成功，还要发动所有其他人做类似的事情。</p>
<p>15.3.2　将构想原则付诸实践</p>
<p>下面的准则、反模式和模式能帮助建立、形成、维护一个被共享的构想，将构想原则付诸实践。</p>
<p>用于检验构想原则是否起作用的准则如下。</p>
<p>（1）架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>（2）实施人员是否信任并使用架构。</p>
<p>（3）关于架构和构件的潜藏知识对其用户（开发团队）是否是可见的、可获得的。</p>
<p>构想原则中准则到模式、反模式的映射如表15-1所示。</p>
<p>表15-1　准则到模式、反模式的映射</p>
<p>alt</p>
<p>下面详细介绍与各准则相关的反模式和模式。</p>
<p>准则1：架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>为了获得一致、迫切和灵活的架构，需要产品线经理、架构师和实施经理等达成共识。而如果没有阐明用户价值，则会导致构想脱离了重点。</p>
<p>与准则1相关的反模式与模式如下。</p>
<p>1）反模式：风险后置</p>
<p>形容这样统一受益人的构想：用最小的妥协、最大的优化规划出一个构件以满足所有冲突利益的需要。这种统一方法的问题是，设计出来的构件往往在理论上可行，但实际运行中出现风险。</p>
<p>一条新产品线的架构师或经理，需要开发看似很棒但实现有风险的构件。这些要完成构件可能需要打破“物理定律”才能完成，这些风险可能在制品交付的最后才能显现。可是有一批工程师仍然坚持开发这些构件。风险构件被安排到最后完成，以为这样可以有时间消除风险。可是，当计划好的完成日期临近时，依然无法交付。尽管架构在演示的幻灯片上运转良好，实际上却无法正常工作。</p>
<p>面对这种情况，需要分析并阐明风险， 向高级经理提供一个选择，要么承认风险，要么调整任务。</p>
<p>2）模式：前后一致</p>
<p>要求推动架构投资的高级经理积极地维护构想，并防止构想受到短期压力的影响。</p>
<p>一个公共的架构被几个产品共享，它已经变得比预期要复杂得多。而客户们针对每件产品又提出了以前没有预计到的功能特性。如果加入这些功能特性，则不能保证进度，但如果不开发这个特性则可能失去一位重要客户。</p>
<p>这样的情况下，需要评估架构构想的质量和稳定性。只有当两者都正常时，才能采取进一步行动。如果该新特性不属于原来的产品构想支持的代价范围，那就应该放弃开发这个新特性。如果构想不明确，在短期内就交付很可能导致大量缺陷。此时应与客户、架构师和销售、产品、支持人员以及开发经理一起加强产品的构想。如果这个特性确实属于一个稳定的产品构想，那么应该在开发组织内核实这种一致性。</p>
<p>准则2：实施人员信任并使用架构。</p>
<p>只有使用架构，才能从中获得价值。然而，要让开发人员对架构构想充分信任需要做更多的工作，仅仅靠不断兑现承诺是不够的。开发人员需要把他们对构想的了解与他们认为对下一步行动有用的东西联系起来。开发人员在利用架构的过程中，可能会使架构向许多不同的方向发展。一个良好架构应与构想保持一致，同时又能满足用户的需求。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：墙头草</p>
<p>描述了这样一种情况：因为没有良好的构想，导致架构方向在竞争和客户压力的影响下经常改变。这种构想永远不能达到稳定以便有效地被共享。</p>
<p>在开发过程中，经常会出现这样一种情况：来自客户、竞争对手和高级经理的压力使得需要在一次发布的中途加入一些代价高昂的功能，高级经理甚至可能在没有咨询架构师的情况下决定提供这些功能。可是一旦交付了某个激进的功能，组织马上就会陷入对该功能的支持工作中。以后的发布会因需要提供向后兼容而变得更为复杂。</p>
<p>在这种情况下，要做的是理解并阐明构想。方便变更需求是成功构想的一部分，要对其进行规划。高级主管要与架构师一起紧密地工作，理解变更的后果并做出正确的权衡。在建立了构想之后，可以用前后一致模式来评估特定的变更建议。在把功能特性加入到发布之前，要坚持达成一致意见。这需要一种固定的机制，以使达成一致成为正常业务的一部分。如果架构满足了高层的约束条件，那么在细节的实施方面可以允许更多的灵活性。在最极端的情况下，解决墙头草问题可能需要寻找新的、期望更为接近的受益人。</p>
<p>2）模式：三个臭皮匠</p>
<p>三个臭皮匠：反映了这样一种认识，即架构师并非总是架构构想的来源，架构师和客户一起充实、完善构想。</p>
<p>一个共同的架构或平台是产品线战略的关键，架构发起人希望产品团体能开发出“杀手解决方案”，而同时又能避免追随新的标准、潮流带来的困扰。</p>
<p>在这种情况下，需要抵制创建一个无所不能的架构的诱惑，建立一种能让架构师及其用户都能丰富、实现功能特性的构想。高级经理只提供构想、目标和原则，把架构和平台留给架构师，把实现细节留给合适的团队或层次。一个成功的产品线架构必须能为适应市场变化，能适应和采用新技术，能解决在概念阶段还不知道的但变化场景可预见的问题。</p>
<p>这是一项很少有架构师能独立完成的任务，然而，通过高级经理建立正确的顶层业务构想，架构师采取实现构想的正确行动就能取得成功。</p>
<p>准则3：关于架构和构件的潜藏知识对其用户是可见的、可获得的。</p>
<p>1）反模式：一叶障目</p>
<p>一叶障目：发生在这种情况下：开发人员过分专注于应用，以致不知道其他架构解决同类问题的通用的解决方案。</p>
<p>在一个组织中，工程团队正在实践代码所有制模式，工程师们都把精力集中在自己眼前的任务和职责上，没有把自己当作一个共享资源的看护者。陷入本反模式的工程师的视野很窄，面对其他开发同事的请求往往只求解决问题，不愿意多加考虑。这样导致的工作结果可能变得非常复杂、脆弱而且容易出错，这是由一名工程师所无法预见的情况造成的。</p>
<p>要解决上面的问题，需创造一种分享知识的愿望。例如，工程师培训等方式就可以起到一些作用，整个组织的人员启用知识管理平台也能促进产生这种愿望。</p>
<p>2）模式：轮流工作</p>
<p>轮流工作：要求参与架构的工作人员轮流在架构的不同部分上工作。这样能使他们对架构有更多的了解，并有机会发展非正式的人际网络。</p>
<p>当一个产品线的销售增长到一定程度，一个单一的、聚集的团队已无法支撑架构和实现，人员被重新组织到地理上分布不同的团队中。已有的沟通管道与新的形势已经不相适应。</p>
<p>通过帮教制（Apprenticeship）模式阶段性地轮流交换构件的所有权可以解决上面的问题。组织和鼓励构件的前任负责人抽出时间帮助新的负责人，轮转周期应该尽可能地与发布进度保持同步。该方法能使开发人员更容易地发现如何找到有关构件的知识，团队成员掌握某个构件或者在出现问题时知道应该问谁的可能性也大大增加了。因此，意外发生的次数减少了。</p>
<p>15.4　节奏：保证节拍、过程和进展</p>
<p>节奏原则使得软件架构在跨越组织边界的情况下开发和使用成为可能。由于许多参与开发和使用架构的团体是自治性的，不可能自上而下地协调这些团体，节奏原则提供了一个随时间变化的框架，可使团体同步各自的活动与期望。有了节奏，参与者就能知道何时关心和应该关心哪些活动。不仅计划中的活动可以被协调管理，节奏原则也可以协调那些非正式的但很关键的活动，例如团体间的交流，这样参与者就可以知道何时应该或不应该提出对于信息或支持的要求。</p>
<p>15.4.1　节奏定义</p>
<p>节奏是一个架构团体内部及它与客户和供应者之间反复出现的、可预测的工件交换活动。节奏有三个元素：速度、内容和质量。速度是指一个团体与另一个团体之间同类型交接发生的频率，例如架构团队与产品开发工程师之间。如果交接的时间是可预测的，移交则容易管理。稳定的发布计划是速度的一个例子。内容是指一个团体向另一个团体提供的价值。例如，一个团体开发一种新的或者要修改的特性被另一个团体用于满足某种需要。质量的含义是遵循开发过程确保架构没有缺陷。组织可以通过省略非增值的步骤来加快速度，但是如果重要的流程被截掉了，节奏就会遭到破坏。</p>
<p>节奏在团体和组织之间与内部提供一种协调活动的稳定力量，帮助移交管理。当节奏很强时，受益人能培养很强的预见、实施移交和交接的技能。节奏还能驱动活动完结，拥有良好节奏的组织通过建立有规律的阶段间隙来推动评估、再评估和其他工作的进展。</p>
<p>15.4.2　将节奏原则付诸实践</p>
<p>没有建立节奏会导致客户不满意、不期望的错误发生和工件无法一起工作。只有当以下准则出现时，才说明节奏原则起了作用。</p>
<p>（1）经理们定期地再评估、同步和调整架构。</p>
<p>（2）架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>（3）通过节奏协调明确的活动。</p>
<p>节奏原则中，准则到模式、反模式的映射如表15-2所示。</p>
<p>表15-2　准则到模式、反模式的映射</p>
<p>alt</p>
<p>准则1：经理们定期地再评估、同步和调整架构。</p>
<p>好的节奏需要有规律的节拍。对于架构组织的管理者，这意味着他们必须在稳定的间隙上再评估、同步和调整他们的架构计划。节奏的节拍还能提供一个计划过程的框架。具有良好节奏的一个组织用节拍而不是时间来衡量进度。</p>
<p>相关的反模式和模式如下。</p>
<p>1）反模式：一步成功</p>
<p>一步成功：是指当组织变得过于专注地向市场推出某项功能特性而导致内部节奏遭到破坏时发生的情形。组织被竞争所蒙蔽，全身心地专注于向市场提供该特性，却削减了质量，甚至可能破坏本来的节奏。</p>
<p>相关的解决办法有：把关键的功能特性作为团队节奏的一个组成部分来实现。围绕一个特定的主题来进行一次特定的发布，利用主题帮助抓住市场上的机会。如果关键特性特别复杂，则采用几次迭代来实现。但如果在实现关键特性的时候难以保持节奏，说明该特性的风险和复杂度比预计的要大，需要重新规划。</p>
<p>2）模式：发布委员会</p>
<p>发布委员会：描述了一种协调参与发布新架构的相关各方的方法。该模式向经理们介绍了一种在架构发布的最后阶段再评估、同步和调整架构的方法。</p>
<p>定期举办由组织中每个关键受益人参加的正式会议以引导发布的进程。在会议中，要复审产品功能特性和优先级的变更，从而使产品文档、市场承诺、公共关系、测试和开发保持一致。在适合的地方采用测量指标度量发布的进展，分享责任和依赖，做出如何前进的决定，并记录和传达会议的决定。参加委员会的成员应该保持稳定，会议成员的组成应保持一致，与会人员也应该有足够的决定权。</p>
<p>准则2：架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>如果架构用户不信任架构发布的进度和内容，那么用户就可能不采用新的架构发布，或者可能选择另一个架构。用户对架构发布的进度和内容缺乏信心是一个警告信号，说明没有建立一个良好的节奏。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：超敏捷</p>
<p>超敏捷：发生在组织试图在开发过程中抄近路以维持稳定的发布节拍的时候。该反模式对用户所期望的架构质量和内容进行了妥协。</p>
<p>过程执行的合适方法取决于组织文化。在有些组织中，阶段性的软件审计可以用于保证过程被遵守。然而，在许多组织中，审计并不是一种改变或约束行为的有效方法，高层管理的行动能更直接地改变组织行为。是否已经分配了足够的资源来执行计划中的步骤，经理们是否创建明确的目标来保证对节奏的维持都有非常重要的影响。</p>
<p>2）模式：舍兵保帅</p>
<p>舍兵保帅：探讨了组织如何通过把不太重要的特性移到后面的发布周期以保持一个节拍。通过保持节奏，该模式可以使用户获得对架构发布进度更多的信心。</p>
<p>如果对构件的修订看上去无法及时完成时，而且该修订并不非常重要，应该尽快向受益人说明。在不对延误构件做变更的情况下，继续发布架构。为了避免因用户没有阅读或看见特性变更说明而造成的问题，应该确保从预发布开始就放弃该特性，这样用户就能在α或β测试中体验到变化，而不是在正式的产品发布中。可以在以后的发布中再把该构件的变更加进来。通过上面的方法可以保持发布的速度，使架构发布后的活动计划能按进度进行。该方法还能推动构件负责人按时完成他们的修订工作。因为架构的发布实现了承诺，开发人员增强了信任感，他们对下一次如期发布也有了更多的信心。</p>
<p>准则3：通过节奏协调明确的活动。</p>
<p>软件架构的受益人分布在许多不同的组织中。一个共享的架构节奏能帮助这些自治团体跨越组织边界协同工作，因为它能帮助建立关于关键事件何时发生以及如何发生的共同假定。例如，如果一位产品开发员知道每年有一个架构主发布和若干季节性的维护发布，他就可以根据预期的架构发布安排产品发布时间，更好地利用新的架构特性。</p>
<p>与准则3相关的反模式与模式如下。</p>
<p>1）反模式：销售未检验的产品</p>
<p>销售未检验的产品在此情况下发生：一个组织试图实现定期的建立，但这些建立经常编译失败或无法通过自动测试。这表明协作的失效。</p>
<p>由于团队不把编译和测试用例的失败当回事，认为在以后的开发过程中能消除这些不一致的情况，导致积累下来的问题越来越多，无法按时发布。</p>
<p>在这样的情况下，要确保对定期建立的承诺。管理层必须明确无误地告诉开发人员，定期建立应该成功。软件建立不仅应该包括编译产品，还应该包括某种形式的自动测试。对定期建立的流程进行修改，防止在修正失败的建立之前开展新的工作。同样地，以前曾经通过的失败测试用例应该马上处理。</p>
<p>2）模式：同步发布</p>
<p>同步发布是一种把节奏理念扩展到组织边界以外的技术。该模式提供了一种同步架构团队及其用户的活动的方法。</p>
<p>和你的合作伙伴一起确定交付架构特性的先后顺序，以便他们利用架构开发产品。应尽可能在架构的早期发布中包括这些特性。如果架构中的一些变化需要互补产品做出重大变更，那么应让这些变化出现在最早的预发布中。应该告知合作伙伴何时能够获得哪些特性。作为调整早期发布方式的回报，应与合作伙伴签订协议让他们把包含或需要你的架构的产品迅速推向市场。</p>
<h3 id="预测、验证和调整"><a href="#预测、验证和调整" class="headerlink" title="预测、验证和调整"></a>预测、验证和调整</h3><p>为了使对软件产品线的长期投资能产生回报，组织必须确保架构满足许多应用的需求。组织应能够预见变化并对变化做出反应，包括那些在设计架构时还没想到的需求。架构必须能够适应新的技术、标准、市场和竞争对手。刚开始设计架构时正确的假设几年以后可能就失效了，这就要求组织必须能够对架构进行预测和演化。</p>
<h4 id="预测、验证和调整的定义"><a href="#预测、验证和调整的定义" class="headerlink" title="预测、验证和调整的定义"></a>预测、验证和调整的定义</h4><p>预见是指建立和实现架构的人员根据变化的技术、竞争和客户需求预测、验证和调整架构的程度。</p>
<p>软件架构师不可能总能预测到未来。但是，既然一个成功的架构将被持续使用很长时间，架构师至少要对未来将发生什么做出合理的猜测。架构师必须考虑架构用户可能怎么变化，竞争形势将如何改变，未来的运行环境是怎样的。架构必须能够适应新的组织结构，特别是在一些像银行业这样合并和接管司空见惯的领域中。许多计划建立在对未来的假定上，但是预测意味着这些假定是作为架构描述的一部分而明确表述的。例如，有关的假定可能基于这样一种未来的情况：处理器速度依然遵循摩尔定律，在以后的10年里每18个月翻一番。当然，除非架构师有预知未来的超自然能力，否则这些预测不可能总是正确，所以需要验证。</p>
<p>验证不仅局限于传统软件工程的测试和检查技术，也包括对架构的基础假定的测试。例如，用户真的想要计划好的东西吗？现有的技术能实现用户的需求吗？分析这些假定的重要原因是，架构师及其发起人做出了许多关于架构的艰难决策。在架构成型前要对这些假定进行检查和确认，否则会导致代价高昂的错误。</p>
<p>软件架构的长期成功依赖于对假定的变更和通过预测及验证所获信息的适应程度。调整就是对架构计划及架构本身修正以加入新特性，从而能参与新兴市场的竞争或者在新的环境中生存。因此，调整要求组织具有敏捷性。调整可能不仅包含架构本身，还包括计划，甚至整个架构构想。</p>
<h4 id="将预见原则付诸实践：准则、反模式与模式"><a href="#将预见原则付诸实践：准则、反模式与模式" class="headerlink" title="将预见原则付诸实践：准则、反模式与模式"></a>将预见原则付诸实践：准则、反模式与模式</h4><p>下面的准则、反模式和模式为帮助判定组织在预见验证、调整架构方面提供了指导。当以下情况发生时，说明预见原则发生了作用。</p>
<p>（1）不断增强架构的响应能力：预见到的风险和架构客户及其客户的需求；市场驱动的标准和演变的技术；战略性业务方向的改变。</p>
<p>（2）通过快速复审和开发周期，评估技术和业务上的风险与机会。</p>
<p>（3）当认识到关键的估计或假设有错时，及时调整功能特性、预算。</p>
<details><summary>表15-3　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142106.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142106.png';" /></details>

<details><summary>表15-3　准则到模式、反模式的映射-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142120.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142120.png';" /></details>

<p>准则1：不断增强架构的能力以响应预见到的风险和架构客户及其客户的需求，市场驱动的标准和演变的技术，战略性业务方向的改变。</p>
<p>与此相关的反模式与模式如下。</p>
<p>1）反模式：遗漏细节</p>
<p>遗漏细节：描述了发现一个明显的功能特性被遗漏时的尴尬经历。每个人都关注发布的强大新特性，以致忽视了一些用户必不可少的功能。</p>
<p>对这种情况，需要识别关键用户群，和他们一起找出最重要的需求。这意味着要有一位对这些用户群有着深入了解的专题事务专家的参与。要调查的问题包括“哪些产品会建立在这个架构之上？”，“哪些产品是最重要的？”该方法也可以用来指导架构方向的改变。调研的覆盖面很重要，需要让高级经理了解这一过程以使他们在敦促实现其他高级特性和技术的时候，不会在无意中破坏这些基本特性的交付。</p>
<p>2）模式：示范区</p>
<p>示范区模式应用在如何决定哪个产品应该引入一个新架构的情况下。</p>
<p>挑选一个项目初步实现架构。该项目的客户渴望采用新技术，而且也愿意容忍获得该技术时可能存在的不便。当示范区项目投入使用后，架构师将从实际使用中得到关于架构的有价值反馈。在架构大范围应用之前，缺陷将被发现并解决，这也意味着缺陷的修订受后向兼容问题的约束较小。成功的示范区项目可以在建议其他项目时作为参考。</p>
<p>准则2：通过快速复审和开发周期，评估技术和业务上的风险与机会。</p>
<p>1）反模式：品尝未熟的果实</p>
<p>品尝未熟的果实：说明了当架构师没有考虑其用户的客户，而让其用户支持一种未成熟的技术时发生的情况。</p>
<p>在发起人的要求下，架构师采用了一种新技术来建立下一代架构，团队希望通过它胜过最接近的竞争对手。客户对架构糟糕的性能和各种各样的差错感到很失望，客户并不关心底层技术，他们只需要那些能帮助他们实现目标的东西，一些被以前的换代或升级害苦了的客户则对关于未成熟技术的承诺极度不信任。</p>
<p>在这种情况下，要审慎地选择引入新技术的正确场所。在引入后，要为最初用户提供额外的支持。在选择新架构解决方案时，必须愿意修改技术不完善的部分使其适合一个实际可用的解决方案。不要假定一个未经验证的架构能实现所有的承诺，应该分别在开发人员和产品用户的特定环境下测试你的解决方案。即便如此，还必须向采用新技术的用户提供大量的支持，要谨慎地设定用户正确的期望，留意他们可能遇到问题的迹象。</p>
<p>2）模式：架构复审</p>
<p>架构复审模式总结了怎样针对开发中的架构组织执行一次有重点的专家评估，以揭示有重大影响的问题和机遇，例如假设的冲突、可重用的现有方案等。</p>
<p>该模式提出在开发周期的关键时刻成立一个架构复审委员会以检查架构。一旦需求基线初步确定就应该进行首次复审。复审委员会的成员应该包括有经验的架构师、架构小组成员，可能还有客户，人员不要太多，最多七、八个人。在早期复审中，应检测各种假设，看看市场上是否有可购买的解决方案，并进行其他条理性检查。后期的复审应验证假设，确认架构是否满足了需求。注意要让这些复审保持重点。</p>
<p>这种模式可以避免增加成本，因为复审能够在开发过程的早期发现缺陷，这样就可以及时修正。复审能发现可以取代新的开发活动的构件。此外，它还增强了客户对架构提供已承诺能力的信心，从而促进客户使用架构。</p>
<p>准则3：当认识到关键的估计或假设有错时，及时调整功能特性、预算。</p>
<p>1）反模式：创造奇迹</p>
<p>创造奇迹：描绘了当足够的证据显示基础假设和估计已经完全偏离目标时，对架构开发和实现计划不作任何修改将发生的情况。</p>
<p>解决方法分为如下两个部分。</p>
<p>（1）找到架构的基础假设并积极努力测试这些假设。架构复审和示范区模式提供了获取这类信息的手段</p>
<p>（2）一旦发现错误的估计或假设，必须准备好对此采取行动。这可能意味着调整项目进度、功能特性或者启动意外处理计划，此外还包括提醒客户并重新协调进度和发布的内容等。</p>
<p>还应该特别小心那些遏制信息和创意传播、掩盖错误假设的证据的组织文化。无论何种情况，都应该确保把足够的资源编入预算计划，使得当不可避免的意外发生时，有可分配的进度和人员。</p>
<p>2）模式：外包</p>
<p>外包模式展示了怎样适应这种情况，即客户要求的新标准或技术并不属于当前或计划中的核心能力。它提供了指导以说明何时及怎样选择一个已有的第三方构件，或者与供应者合作。</p>
<p>如果存在第三方构件，应考虑采用。如果没有这样的构件，那么组织应该找到合作伙伴来开发和支持该构件。要确定潜在的合作伙伴是否把你需要的构件视为其主营业务的一部分。例如，他们是否能够把它卖给许多其他的客户；评估他们交付和支持该构件所需的特定工作量。把潜在的合作伙伴当作供应商和业务伙伴以评估其能力和信用。基本的规律是，他们必须为你做的专门开发越多，信任程度就要求越高。类似地，信任度越低，你面临的进度和财务风险就越高。如果发现一个非常可靠的潜在供应商，就应该外包构件开发。</p>
<h3 id="协作：建立合作型组织"><a href="#协作：建立合作型组织" class="headerlink" title="协作：建立合作型组织"></a>协作：建立合作型组织</h3><p>协作也是软件架构成功的关键之一，因为不同团体参与者对架构的开发、实现和使用都是很重要的。这些团体跨越了各种各样的组织边界，如团队、地理位置、部门甚至公司。每一个对架构关键的团体必须知道如何使用、努力改进架构从而为自己的利益服务。协作原则解决了如何识别对架构成功起关键作用的团体，以及如何确保这些合作伙伴的支持等问题。</p>
<h4 id="协作定义"><a href="#协作定义" class="headerlink" title="协作定义"></a>协作定义</h4><p>协作是指架构受益人保持明确的、合作的角色并将其所提供和获得的价值最大化的程度。合作是指受益人彼此之间存在一些共享的预期，应该明确表示出达到或未达到预期会有哪些奖励和惩罚。成功协作不仅仅要求架构负责人满足契约条款，合作伙伴还必须采取行动确定和提供预期价值，根据已达成的条款给出特定问题的解决方案。</p>
<h4 id="将协作原则付诸实践：准则、反模式与模式"><a href="#将协作原则付诸实践：准则、反模式与模式" class="headerlink" title="将协作原则付诸实践：准则、反模式与模式"></a>将协作原则付诸实践：准则、反模式与模式</h4><p>协作很容易理解，但将其付诸实践并不简单，当许多团体必须在一个组织内（外）的同一层次上进行合作时尤其如此。正式定义的协作网络与非正式协作网络决定了一个软件架构能否成功。以下准则提供了一种方法用来确定受益人为了使架构与产品服务的价值最大化而进行合作的程度。当出现以下几种情况时，说明协作是有效的。</p>
<p>（1）架构师不断地努力了解谁是最关键的受益人，他们如何贡献价值，以及他们需要什么。</p>
<p>（2）受益人之间达成明确和强制性的契约。</p>
<p>（3）通过社会行为制度和非正式规范强化合作。</p>
<p>表15-4介绍了准则到模式、反模式的映射。</p>
<details><summary>表15-4　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142306.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142306.png';" /></details>

<p>准则1：架构师不断地努力了解谁是最关键的受益人，他们如何贡献价值，以及他们需要什么。</p>
<p>满足受益人的需求说起来很容易，实施起来要困难得多。挑选一批集中的首要客户，找出保证他们参与需要做些什么，然后交付这些内容，这样做可以增大成功的机会。</p>
<p>与准则1相关的反模式和模式如下。</p>
<p>1）反模式：光说不做</p>
<p>光说不做描述了这样一种情况，即架构师知道了用户的需求却遗漏了为了向他们提供有价值的东西所应该做的事情。</p>
<p>架构师忙于其他事务，没有与开发人员进行稳定的交流，各产品团队按照自己的理解开发并升级了产品，放弃了原来同意的清晰的接口。</p>
<p>与许多反模式一样，该反模式中最困难的部分就是，当发生这种情况时如何识别它。当你认为“我们可以以后再补充这些细节”时，应该保证你和你的团队至少理解一些关于开发人员如何从平台获益的明确的例子。模式“了解你的受益人”提供了一种掌握需要哪些措施让受益人参与协作的方法。客户互动模式提供了一些明确、简单和直接的规则与建议，有助于发展有效的协作关系。</p>
<p>2）模式：了解你的受益人</p>
<p>本模式说明了如何利用价值链来识别关键受益人，积极听取他们的意见并获得承诺与支持。</p>
<p>把架构成功的构想与那些最符合合作伙伴能力并积极去做的事情的活动统一起来。阐明设想中架构所能提供的价值，例如架构如何帮助现有产品取得一致的用户界面或者继续保持市场优势，或者是能打开一个针对新产品的全新市场。在初步阐明构想之后，确定潜在的合作伙伴以及他们的能力和利益如何与构想保持一致。</p>
<p>准则2：受益人之间达成明确和强制性的契约。</p>
<p>1）反模式：不记录讨论结果</p>
<p>不记录讨论结果说明了当一个架构团队回避采取必要的行动与其最直接的用户达成明确的契约时会发生什么情况。当用户们失去兴趣时，虽然对话仍在继续，但是讨论已经失去了实质内容，而且通常会浪费所有人的时间。</p>
<p>要确保取得对关键受益人的利益与职责的明确理解。把这些认识记录下来，当互动变得消极或者缺乏建设性时，可以求助于这些文件。这种做法总是很重要，对于那些对别人有强烈影响的参与者而言尤其关键。当状况似乎要失控时，回到当初的约定可以把架构团队从漩涡中解救出来。</p>
<p>2）模式：互惠互利</p>
<p>本模式介绍了一些非常重要的做法，用来建立足够稳固的关系以保障软件架构的共享和成功使用。</p>
<p>互惠互利要求在合作伙伴之间进行公平、主动的价值交换。当共享一个架构的团体之间的关系定义好之后，应该对正式和非正式的契约复审以保证公平的交换。预算中应该包括代码负责人响应其他团体请求所花的时间。要对各个团体支持其他团体的程度进行衡量，而不仅仅评估他们完成自身任务的情况。</p>
<p>准则3：通过社会行为制度和非正式规范强化合作。</p>
<p>协作包括正式和非正式两方面，为了真正巩固协作，需要用社会行为制度和非正式规范来促进合作。</p>
<p>1）反模式：非正式时间做正式工作</p>
<p>非正式时间做正式工作介绍了这样一个情况，即一位工程师申请修改某个构件以便让其他团体使用，却得到一个令人困惑的答复：“你可以做，但是要用你个人的时间。”</p>
<p>让工程师利用业余时间修改，架构师就失去了控制其过程和结果的能力，他可能没有采用组织的文档标准，诸如同级复审等步骤甚至连测试也有可能被删减或完全忽略。如果这种产品加入到其他团队的工件中，这位工程师在需要完成日常任务同时，还接到大量要求提供支持的请求，导致工程师精疲力竭。</p>
<p>对于以上情形，要制定计划奖励工程师花在共享构件上的时间，尽早兑现奖励能减少工作量和大量压力。应仔细考虑如何处理将来这一构件成为多个外部项目的关键的可能性，在权衡利弊时必须根据组织纪律和常理判断，包括企业文化、管理的洞察力、进度压力的程度以及当前状况的细节。很多组织把员工用于开发、维护被团体或项目外部所共享的解决方案的时间编入预算，这样能够预防工程师在利用非正式时间做正式工作开发时对项目的代码偷工减料，并确保你的小组对其他团队或项目的支持能力。</p>
<p>2）模式：杜绝意外</p>
<p>该模式描述了如何在不失去依赖你的构件的其他团体信任的情况下，调整对进度或功能特性的承诺。</p>
<p>要尽早提醒用户注意变更，并及时协商解决方案。在决定变更的内容之前，要确保通知、咨询了构件的用户。让他们了解虽然现在的做法对软件架构能产生直接的影响，但其实它们有着更为广泛的应用。</p>
<p>3）模式：和HR密切合作</p>
<p>和HR密切合作介绍了这样一种做法，即提拔雇员并不仅仅根据个人的技术技能和经验，还要考察其有效地、合乎道德地利用非正式人际网的能力。</p>
<p>软件开发是一种社会活动。可是，很多工程师属于内向型性格，工程师需要与他人交流以获得完成其工作所必需的信息，大部分高级技术岗位要求能迅速获得广泛的潜藏信息。有着广泛非正式人际网的工程师比没有这种网络的工程师能获得质量更好的信息。</p>
<p>在作提拔决定时，要考察一名工程师的非正式人际网的有效性。此时，应找出具体的事例，例如，这位工程师是否通过团队外部的合适人选，获得了曾困扰其同事、阻碍项目进展的问题的答案？如果组织已有晋升的明确标准，那么也可以对此标准做类似的调整。经理们应该避免破坏非正式人际网。</p>
<h3 id="简化：澄清与最小化"><a href="#简化：澄清与最小化" class="headerlink" title="简化：澄清与最小化"></a>简化：澄清与最小化</h3><p>架构师和高级经理必须协力保持架构和组织的平衡。聚焦于客户和业务价值，为架构师提供了方向和指南。确定关键价值是不容易的，尤其是当新客户和新产品的加入使架构偏离原来的方向时，困难会显著增加。构想定义了这种关键价值，而且为实现价值建立了约束。简化则将构想翻译成产品。</p>
<p>简化软件架构的原则概念上看似简单，而实践中它要求对价值非常坚定地专注，以及对架构所生存的组织的理解和支持。架构师必须了解架构最小的基本特征。简化原则还要求通过努力，把这些特征传达给实现架构团队的每一位成员。</p>
<h4 id="简化定义"><a href="#简化定义" class="headerlink" title="简化定义"></a>简化定义</h4><p>简化是指将所作用组织与环境都进行巧妙地理解与最小化，组织形成架构并且思考架构。在决定简化架构时，应当留意组织的结构；否则，你会发现你所做的改变只是暂时的。因此在简化架构之前，必须澄清组织和架构。</p>
<p>澄清组织意味着真实地理解你计划部署架构于其中的组织结构及其影响力（force）。架构对架构团队和客户都必须是清晰的。在简化架构之前，架构师必须精确地知道架构被期望做什么和如何完成这些任务。有时候看似很容易的任务，结果实现起来却很复杂，如果这些复杂性没有被理解清楚，那么建立的架构就可能完全不适合目标任务，而这样的架构会使实现更加复杂。澄清架构就是提供用户所需要的细节。</p>
<p>如果一个组织具备简化、协作和节奏等技能，长期共享架构就能够最小化代码、文档和过程。不必去新发明大量新的代码，却可以开发一种被工程师跨组织共享的公共语言。共享也能促进理解，因为它能最小化用同样术语描述完全不同概念的风险。共享并不能自动产生最小化，在有些不好的组织情况下，共享可能导致架构膨胀。</p>
<h4 id="将简化原则付诸实践：准则、反模式与模式"><a href="#将简化原则付诸实践：准则、反模式与模式" class="headerlink" title="将简化原则付诸实践：准则、反模式与模式"></a>将简化原则付诸实践：准则、反模式与模式</h4><p>当以下准则都满足时，说明简化原则起作用了。</p>
<p>（1）开发人员长期使用架构，减少了总成本和复杂性。</p>
<p>（2）架构小组明确理解关键最小需求，并且将其构造成多应用共享的核心元素。</p>
<p>（3）通过长期的预算和行动确保当相关元素没有被共享、增加了不必要的复杂性时，或者是因为有明确的业务理由时，把相关元素从核心移走。</p>
<p>表15-5介绍了准则到模式、反模式的映射。</p>
<details><summary>表15-5　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142443.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142443.png';" /></details>

<p>准则1：开发人员长期不断地使用架构，减少了总成本和复杂性。</p>
<p>使架构被正确地使用，需要获得并维持经理和实施人员的信任。当存在一个明晰的公共架构构想时，系统可以逐渐变得更加简单。Grady Boody发现，“只有对一个系统的架构有清楚的理解，才能揭示公共的抽象和机制。”利用这种公共性能构造出更简单、更小和更可靠的系统。</p>
<p>与准则1相关的反模式和模式如下。</p>
<p>1）反模式：简单复制并修改</p>
<p>描述了当程序员在学会使用或重视架构之前被强迫迅速完成任务时发生的情况。他们不与构件负责人协商变更就复制并修改架构的部分代码，虽然复制提供了一个快速应付开发新特性的压力的方法，但是它通常会带来深远的后果。例如，如果在原始代码中发现了一个缺陷，组织怎样才能确保修正你和同事复制的所有代码呢？</p>
<p>在一个构件的生命周期中，有几个时机可以避免复制。鼓励工程师在复制构件之前先从构件负责人那里获得变更。可以把避免复制的推测方法加入编程风格指南，以便在代码复制期间识别和去除复制；如果有恰当的理由，这些推测方法可以允许有限的复制。也可以用自动化工具来识别复制代码，特别是在大型遗留系统中。当复制被识别后，可以用一些代码重组技术来去除重复的代码。</p>
<p>2）模式： 由慢而快</p>
<p>描述了当开发人员为了跟上进度而拒绝使用架构结果却更慢时应该怎么做。解决方法是：放宽进度，加强过程。</p>
<p>让开发人员参与架构期望解决的问题的讨论，并通过开发部分解决方案来培训他们，给予过程比进度更高的优先级。指导开发人员逐步采用架构，把以前使用过这种过程有能力修改架构或过程来解决不同问题的专家介绍给开发团队，系统地、认真地遵循验证过程。</p>
<p>准则2：架构小组明确理解关键最小需求，并且将其构造成多应用共享的核心元素。</p>
<p>与准则2相关的反模式与模式如下。</p>
<p>1）反模式：缺乏有效抽象</p>
<p>缺乏有效抽象是直接面对应用编程，虽然开始简洁，但随着应用发展，系统缺乏共享基础。该反模式描述了两种简化的努力走向极端的情况。榕树描述了长期建立单点解决方案的后果。单点解决方案通常是满足一个特定客户需求的最简单方法。根部肥大描述了一个架构或平台小组为平台所支持或可能支持的每个产品开发了专有的特性。</p>
<p>开发小组通过从头开发或者复制一个相关产品，然后根据当前问题进行修改来确保产品尽可能地简单。这样可以很快向客户提供初始产品。然而，这些产品没有共享任何东西。随着每个产品的维护和升级。榕树反模式开始出现，各个产品之间的分离越来越大。由于没有被一个共享平台强力支持，每一个分离产品都要求有自己的支撑结构，很像一棵榕树的分枝被很多枝蔓支撑。</p>
<p>对于这种情况，可以考虑采用类似先复制后合并模式的方法把很多为了适应特定功能特性而被修改的核心架构部分重新并入内核。如果先复制后合并和维护多个产品都不可行，就应考虑通过框架团队来建立一个共享平台。</p>
<p>根部肥大反模式则用枝少干粗的形象描述了这样一种情况，即一个架构或平台小组开发了太多针对单个客户的特性。结果共享了太多的功能，导致平台太大、太慢、推出太迟。根部肥大看起来就像一个倒立的马提尼酒杯，底部很大，杯口太小。</p>
<p>通过其他安排帮助产品小组开发不属于架构的产品特定模块，防止产品专有特性进入平台。把一个最小的共享特性集列入平台计划，并根据优先级以稳定的发布进度交付特性。</p>
<p>2）模式：迁移途径</p>
<p>迁移途径反应了在这样一种情形下的解决方案：架构师打算利用当前架构来支持一个新的有价值的应用领域。但是要在该新应用领域获得成功，需要当前用户所不具备的技能和观念，而拥有这些技能的用户团体却习惯于与当前平台不同的解决问题的方法。</p>
<p>对于这样一种情况，要选择一类最有可能扩大架构价值的采用者，并且努力使架构能被他们很快地理解和采用。考察所有类型的早期采用者，了解他们解决问题的方法和技能。确定哪一种类型最有可能理解或者预见到技术革新的成效，并且严格衡量该类型的用户是否具备解决方案所需的技能和知识。为有目标构想但缺乏重要技能集的专业人员提供迁移途径，提供一个简单的从平台获得基本成果的方法。然后，引导这些用户逐步更具体地使用平台。</p>
<p>准则3：通过长期的预算和行动确保当相关元素没有被共享、增加了不必要的复杂性时，或者是因为有明确的业务理由时，把相关元素从核心移走。</p>
<p>改进一个架构需要时间和经费的稳定投入。稳定性确实很重要，因为当高级经理或主管最不愿意专注于架构时，也是架构最脆弱的时候。他们很容易被诱惑把架构师拉去参加一个紧急的项目以实现一个新特性，而使架构无人照看。</p>
<p>与准则3相关的反模式与模式如下。</p>
<p>1）反模式：编码大于架构</p>
<p>该反模式表明要防止架构师成为实现者。</p>
<p>首席架构师负责调整和维护架构，却被调动了工作要求竭尽全力地实现一个新特性集。这些特性实现了，架构小组却失去了领路人。因为没有时间对架构做出深思熟虑的改变，只好创建了架构的一个特殊版本来解决问题。结果新特性无法适合当前的架构。因为维护一个缺乏概念完整性的产品的工作量太大，结果问题越来越多。</p>
<p>为了防止出现这种情况，应该把首席架构师的时间合理分配给实现新特性和调整架构两个任务，让最能干的工程师来领导实现新特性。在提供时间和资源的同时，允许首席架构师指导实现，以使架构适应新的需求。</p>
<p>2）模式：统计构件变更</p>
<p>统计构件变更是一种通过观察不稳定程度来挑选需要调整的架构构件的方法。</p>
<p>如何才能知道应该重组（Refractor）什么——即从内核去除或简化什么呢？通过长期观测每个构件或子系统的不稳定程度，那些最不稳定的构件就是重组的候选者。因为不稳定表明构件是脆弱和不灵活的，因此应当根本改变该构件。也可以采用其他监控策略，例如监控讨论组以掌握经常被请求的构件。一名经验丰富的实施人员利用该方法可以很快确定哪些构件和子系统是简化的最佳目标，从而节约了时间和精力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch14-%E5%9F%BA%E4%BA%8EODP%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch14-%E5%9F%BA%E4%BA%8EODP%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch14-基于ODP的架构师设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:56:12" itemprop="dateCreated datePublished" datetime="2021-07-19T12:56:12+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 14:04:51" itemprop="dateModified" datetime="2021-09-04T14:04:51+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="基于ODP的架构师设计"><a href="#基于ODP的架构师设计" class="headerlink" title="基于ODP的架构师设计"></a>基于ODP的架构师设计</h2><p>软件系统架构设计方法是一个实践性大于理论性的工作。从软件有模块概念那天起，就有了总体设计，研究模块、构件与它们之间的关系。架构设计虽然可以归集到几种风格，但面对复杂的应用环境，不同应用领域对架构的理解差异非常大，用事实说话是最基本的研究方法。本章在RM-ODP多视点架构模型上，探讨应用于分布式信息系统的软件架构开发，对软件生命周期其他阶段的影响，特别是架构师在开发过程中的任务与作用。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/caolaosanahnu/article/details/10998099">软件体系架构：RM-ODP参考模型简介</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/seacean2000/article/details/102473736">基于ODP的架构师实践问答</a></li>
<li><a target="_blank" rel="noopener" href="http://www.rm-odp.net/">官网</a></li>
</ul>
<h3 id="基于ODP的架构开发过程"><a href="#基于ODP的架构开发过程" class="headerlink" title="基于ODP的架构开发过程"></a>基于ODP的架构开发过程</h3><p>系统架构反映了功能在系统构件中的分布、基础设施相关技术和架构设计模式等，它包含了架构的原则和方法、构件关系与约束，并能支持迭加或增量开发。以软件架构为中心的开发过程是以质量和风险驱动的，最终提供一个稳定、低风险的系统架构，并满足客户的需求（包含潜在需求）。</p>
<p>开放分布进程的参考模型（RM-ODP）是一个ISO标准，它为分布式计算进程提供了一个框架。RM-ODP定义了分布式系统的重要性质：开放性、整体性、灵活性、可塑性、联合性、可操作管理性、优质服务、安全性和透明性，并定义了一组视点。RM-ODP视点定义大体对应于IEEE 1471定义，RM-ODP定义的5个视点如下。</p>
<p>（1）企业视点：在如下因素的环境中分析系统，商业需求和策略、以及系统的范围和目的。RM-ODP处理可能会影响系统中的与企业相关的信息，如组织结构等。</p>
<p>（2）信息视点：指信息的结构，它的变化、流程以及在不同功能间的逻辑划分。</p>
<p>（3）计算视点：重点在于把系统分解为实体和实体间的接口。</p>
<p>（4）工程视点：处理分布式系统对象之间的交互，以及交互是如何得到支持的。</p>
<p>（5）技术视点：定义构成系统的硬件和软件构件。</p>
<p>体系结构视点是把抽象的符号或图表（如UML）运用到具体的体系结构开发任务中。每一个视点有具体的建模目标和系统相关者。例如，环境视图提供了对系统边界及与系统发生交互的外部实体集合的概述。分析视图提供了一个以建模问题而不是答案为中心的实体的抽象集合。</p>
<p>以描述软件设计为目的的视点包括构件、构件交互及构件状态。视图提供了一个对于逻辑运行结构及其功能，以及它们之间通信的映射。子系统接口依赖视图提供了一个子系统依赖关系和接口的图形表示；分层子系统视图提供了一个所有子系统高度抽象的视图；逻辑数据视图提供了构件共有的数据模型描述。</p>
<p>不同视图解决不同方面的问题，这是应对复杂问题的基本研究方法（分治）。采用ODP从5个视点描述信息系统架构，对整个系统开发过程有一定指导意义。除了架构设计阶段，其他阶段对架构师也提出不同的任务与要求。图14-1展示了整个系统及架构开发的10个过程。</p>
<details><summary>图14-1　系统架构开发的10个过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135503.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135503.png';" /></details>

<p>本章按图14-1的次序，探讨架构师的任务与设计工作。</p>
<h3 id="系统构想"><a href="#系统构想" class="headerlink" title="系统构想"></a>系统构想</h3><h4 id="系统构想的定义"><a href="#系统构想的定义" class="headerlink" title="系统构想的定义"></a>系统构想的定义</h4><p>系统构想是指一个系统开发人员与系统用户之间共同的协议。按照该协议，系统开发人员需在特定的时间内完成系统用户的需求。系统构想必须简短而切中要点，给人以清晰的感觉。它不是一成不变的，必须根据系统的不同而不同。</p>
<p>构想描述建立了从需求分析开始的所有项目活动的语境，它高度概括了企业业务架构的核心内容。</p>
<h4 id="架构师的作用"><a href="#架构师的作用" class="headerlink" title="架构师的作用"></a>架构师的作用</h4><p>讨论建模的时候，我们曾提到关键词有目的、关注点、假设和优先级，它们都是系统级的“构想描述（Vision Statement）”的基本元素。如果它们在系统开发过程中改变，项目就有被抛弃的危险。因此，以架构为中心的开发的第一步就是建立一个构想描述，且假定构想描述在系统的各个开发阶段不会改变。所有的改变必须在关键的项目计划中有所反映，特别是在系统架构中。</p>
<p>系统构想包括为客户、为软件系统开发团队等受益人创建的，有助于各方明了系统的目标和范围。对开发者而言，从宏观层面上显示系统架构的需求，为待开发系统提供一个结构清晰的概要，确保系统开发的计划、设计等阶段能依次有序地展开。</p>
<p>系统构想阶段，架构师合理的介入，有以下好处。</p>
<p>（1）有利于使系统架构师本身对系统的看法更加全面、准确。</p>
<p>（2）有利于统一系统开发人员对系统的看法。</p>
<p>（3）有利于正确确定需求的优先次序。</p>
<p>（4）通过系统构想，可以在最大程度上提高客户对设计等过程的参与程度，更好地与客户沟通。</p>
<h4 id="系统构想面临的挑战"><a href="#系统构想面临的挑战" class="headerlink" title="系统构想面临的挑战"></a>系统构想面临的挑战</h4><p>建立和共享架构构想要面临着很多的挑战：架构师对其控制能力之外的因素（例如组织等）通常无能为力；当产品线由一个架构来支撑时，构想就会受更多的因素制约。此外，如果共享的架构构想有问题时，不易马上觉察到。不过，可以通过有效地评估，以及高级经理和架构师之间保持紧密的联系来克服这些困难。</p>
<p>除了以上介绍的挑战外，在系统构想阶段，还必须面对以下几种情况。</p>
<p>（1）很多架构师把架构看成是他们独自的创造，而且只要他们认为合适的就进行修改。</p>
<p>（2）有些人不是拥有产品线构想的高级经理，却总是由这些人来决定雇佣谁来做架构师。由于没有参与架构师的招聘工作，高级经理们将无法评估架构师的能力以及理解并实现其构想。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="架构师的工作"><a href="#架构师的工作" class="headerlink" title="架构师的工作"></a>架构师的工作</h4><p>需求一般定义系统的外部行为和外观及用户信息，而不用设计系统的内部结构。外部行为包括了用来保证外部行为能够完成而所需的内部行为（例如持续性或计算）。外观包括用户界面的布局和导航，用户信息包含用户概念数据结构及关系模型。</p>
<p>架构师对需求分析通常考察以下6个方面的内容。</p>
<p>（1）系统范围对象关系图。主要用于定义系统与系统外部实体间的界限和接口的简单模型，它可以为需求确定一个范围。</p>
<p>（2）用户接口原型。可将其看作为用户操作的一个雏形，通过该接口界面用户能够用一系列的操作完成它想达到的效果。</p>
<p>（3）需求的适用性。即这个需求应该用什么技术解决，它实现后的性能怎么样，是否与其他需求相重合或是矛盾。需求分析应注重需求本身的实用或适用，而不必考虑其实现。</p>
<p>（4）确定需求的优先级。可采用迭代周期来说明何时完成。</p>
<p>（5）为需求建立功能结构模型。可以用UML创建组件图和实体数据对象图，概述系统原型。</p>
<p>（6）使用质量功能分配（Quality Function Deployment, QFD）。根据需求的理解发现隐藏质量需求，建立相关质量场景和易变需求场景，先期预测需求风险。</p>
<p>架构师的一个有效地捕捉行为需求的方法是分析用例（use case）。一个用例包含一个顶层的图和扩展的文字描述。用例符号简单、抽象，非常适合于用来保证在表述顶层需求概念时的简单性和清晰度。</p>
<h4 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h4><h5 id="需求分析的目的"><a href="#需求分析的目的" class="headerlink" title="需求分析的目的"></a>需求分析的目的</h5><p>需求分析的目的是完整、准确地描述用户对系统的需求，跟踪用户需求的变化。将用户的需求准确地反映到系统的架构和设计中，设计和用户的需求保持一致。需求分析具有决策性、方向性和策略性的作用，它在软件开发的过程中具有举足轻重的地位。</p>
<h5 id="需求分析的特点"><a href="#需求分析的特点" class="headerlink" title="需求分析的特点"></a>需求分析的特点</h5><p>一般来说，需求分析特点的共同点都是追求系统需求的完整性、一致性和验证性。</p>
<p>（1）完整性：是准确、全面地描述用户对系统架构的需求。</p>
<p>（2）一致性：是通过分析整理，剔除用户需求矛盾的方面，规范用户需求。</p>
<p>（3）验证性：是需求的一致性表现形式，主要包含以下几个方面的含义。</p>
<p>① 保持和用户要求的同步。</p>
<p>② 保持需求分析各侧面之间的一致。</p>
<p>③ 保持需求和系统设计间的同步。</p>
<p>因此，在对系统架构需求分析之前必须建立需求分析技术层面的基本框架，从技术上保证需求分析的要求，在此基础上进行的架构需求分析才能满足项目对需求分析的要求。</p>
<h4 id="需求文档与架构"><a href="#需求文档与架构" class="headerlink" title="需求文档与架构"></a>需求文档与架构</h4><p>每个用例都有一个相关需求的文字描述。这种方法采用了包含一系列活动的列表形式，用特定领域的平铺直叙的文字来描述。定义用例应该和领域专家一起进行，如果没有领域专家的长期参与，这种活动只能是一种“伪分析”。</p>
<p>用例为定义架构提供了一个系统的领域行为模型。在开发的第7个过程中，用例被特定系统的场景所扩展，最后这些场景会在软件测试中得到运用。</p>
<p>用户界面的外观、功能和导航同用例紧密相联。一个有效定义屏幕的方法叫做低保真度原型（Low-fidelity Prototyping）。在这种方法中，屏幕是用纸和笔先画出来的。同样，最终用户领域专家也始终参与到屏幕定义中去。</p>
<p>有了用例和定义的用户界面以及领域概念模型，我们建立了架构规划的环境。在产生文档之外（包括纸、笔的草图），架构小组得到最终用户领域中需求功能的更深刻理解。需求分析的项目词汇表，也将在架构规划中被扩展。</p>
<h3 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h3><p>系统架构沟通了需求和软件之间巨大的语义上的鸿沟。需求是模糊的、直观的，而软件则具有相反的性质。系统架构的第一个任务就是定义这两个极端之间的映射，架构用一种更为技术性的方式来捕捉直觉的决定，它在设计和编码之前定义了内部的系统结构。架构设计同时为项目计划服务，它允许系统构建用适应变化的方法来控制复杂性，同时指导建立软件项目与架构对应的组织。</p>
<p>开放分布式处理（Open Distributed Processing, ODP）从5个标准的视点组织分析了系统的架构，描述了同一系统的重要方面。如图14-2所示，这些视点包括企业、逻辑信息、计算接口、分布式工程和技术选择。对于每个视点，确认架构需求的一致性是非常重要的。ODP促进了这个过程，因为它内嵌了一个普遍的一致性方法，简单的一致性清单包含识别架构中一致点所需的全部内容。</p>
<details><summary>图14-2　ODP视点</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135801.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135801.png';" /></details>

<h4 id="企业业务架构"><a href="#企业业务架构" class="headerlink" title="企业业务架构"></a>企业业务架构</h4><p>企业业务架构从IT的角度，对企业的业务结构、企业机构与业务的关系、企业内部的关系以及企业与外部机构的关系进行整理定义。企业业务架构包含如下内容。</p>
<p>（1）企业的业务和战略目标。描述企业的目标，包含近期目标、中期目标和长远的战略目标。</p>
<p>（2）企业的组织机构。明确描述企业的组织机构和职能，以及与企业相关的机构和个体，如客户、合作伙伴和供应商等。</p>
<p>（3）业务的分类。对企业的产品、服务和资源体系进行分类。这种分类包含了对相关产品、服务和资源的共性提取和总结。</p>
<p>（4）各类业务之间的关系。对产品、服务和资源的相互关联进行总结。业务之间的关系体现为跨业务的流程及资源共享等。</p>
<p>（5）组织机构与业务的关系。业务的执行是由机构来完成的，但是机构与业务并不一定是一一对应的关系。清楚地找出机构与业务的关系，将为应用与集成架构奠定可靠的基础。</p>
<p>（6）企业与外部机构的关系。对与企业相关的外部机构或个人就其类型、业务类别和业务往来模式等进行分类。</p>
<p>企业业务架构（企业视点）也是用高层企业对象来定义业务目的和系统策略。这些业务对象模型标识出系统的关键性约束，其中包括系统目标和重要的系统策略。</p>
<p>策略包含如下三类明确的表达方式。</p>
<p>●　责任：业务对象必须做什么。</p>
<p>●　许可：业务对象可以做什么。</p>
<p>●　禁止：业务对象不可以作什么。</p>
<p>在对业务问题进行分析时，不仅要考虑企业目前业务的情况，而且要考虑企业业务的发展，如新的服务或产品的推出、考虑组织机构的改变等，企业的业务流程的变化也是要考虑的因素。所有这些可能的变化（易变场景）都应该体现在企业的业务架构中。</p>
<p>企业业务架构在明确了企业的业务和战略目标之后，从业务和机构两个基本点出发进行基础性的分类组织工作，然后根据业务的分工和业务流程与组织机构实现映射，从而形成对企业业务的完整描述。一个典型的企业业务架构包含一系列逻辑对象图（通常用UML表示）和对象语义的平铺直叙的文字描述。</p>
<p>通过对企业业务架构的定义，就可以很清楚地知道由于企业业务特点、业务流程的特点和企业的组织机构等原因对IT系统所带来的自然分块和各个分块之间的边界关系，从而就可以知道怎样从技术架构上来满足和支持企业的业务架构。</p>
<p>企业业务架构的维护也是一个长期而反复的工作。企业业务架构的变化可以通过技术架构反映出来，技术架构的正确与否可以通过业务架构来检验，这样才能通过架构来保证IT服务于企业的业务和战略。</p>
<p>下面以一个测试结果报告系统（Test Results Reporting System, TRRS）为例，介绍一下它的企业业务架构。</p>
<p>TRRS的企业视点由一些UML用例组成，这些用例确定了TRRS社区的参与者以及他们之间策略上的联系。图14-3展示了这些来自应用软件开发者视点的UML用例。这三个在UML图中的用例表明，软件开发者可以通过多种途径使用TRRS，以决定软件产品的兼容性。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135833.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135833.png';" /></details>


<p>重要的企业策略关系到TRRS数据库中产品描述的完整性和责任。在TRRS处理中，可以使用UML对象约束语言（Object Constraint Language, OCL）来定义企业活动者的这些策略（如许可、禁止和义务等）。</p>
<h4 id="逻辑信息架构"><a href="#逻辑信息架构" class="headerlink" title="逻辑信息架构"></a>逻辑信息架构</h4><p>逻辑信息架构（信息视点）标识出系统必须知道什么。这种架构通过一个对象模型来表达，强调定义系统状态的属性。因为开放分布式处理是一种面向对象的方法，模型包含了关键信息的处理，如传统的对象概念。</p>
<p>软件架构对象并不是编程的对象，它表示对系统的约束和依赖。这些约束能够消除在把需求翻译成软件过程中的许多猜测性工作。架构师应该把他们的建模集中于系统中有高风险、高复杂性和模糊性的关键方面，而把直接的细节放在开发的环节中去。</p>
<p>下面以测试结果报告系统为例，介绍一下它的逻辑信息架构。</p>
<details><summary>图14-5　供应商信息的UML表示</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135921.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135921.png';" /></details>

<p>TRRS信息视点是由一组UML类模型组成，该信息视点定义了一些核心的概念，这些概念组成了TRRS系统的持久状态。图14-4是一个UML图，它展示了产品之间的互操作关系。一致性声明（Conformance Statements，如图14-5所示）提供了产品兼容性标准的保证。互操作性声明（Interoperability Statements）是一个类似的概念，和兼容性不同之处在于它不包含供应商对相互之间产品兼容性的保证。互操作性测试报告（Interoperability Test Report）包括了多产品互操作测试所得出的测试结果。互操作性产品（Interoperability Product）是特定的源于多供应商兼容性的解决方案。经验报告（Experience Report）是实例研究的文档，它记载了产品集成的成功经验。合起来，上述各个部分组成了TRRS数据库要储存的关键文档类型。</p>
<h4 id="计算接口架构"><a href="#计算接口架构" class="headerlink" title="计算接口架构"></a>计算接口架构</h4><p>计算接口对系统架构非常有帮助，但是它常常被架构师所忽略。它定义了顶层的应用程序接口，这些是完全工程化的子系统边界的接口。在实现时，开发者将对他们的模型在这些边界上进行编程，以消除多个开发者和小组的主要设计争端。这些接口的架构控制对于一个支持变化和控制复杂性的稳定的系统结构来说，是非常重要的。</p>
<p>开放分布式处理体系结构的一个ISO标准采用的是CORBA接口定义语言（IDL），IDL是一种基本记法，它完全独立于编程语言和操作系统。IDL可以被编译器自动翻译成Java、C++和C#等大多数流行的编程语言。</p>
<h4 id="分布式工程架构"><a href="#分布式工程架构" class="headerlink" title="分布式工程架构"></a>分布式工程架构</h4><p>分布式工程架构定义了底层结构的需求，而独立于所选择的技术。它很好地解决了一些最复杂的系统策略，其中包括物理位置、系统规模可变性和通信服务质量。</p>
<p>ODP的一个最大好处是关注点分离，幸运的是，前面的视点解决了许多其他的复杂问题，那些是分布式很少关注的，如API、系统策略和信息纲要。相反，这些其他的视点能够解决它们各自的设计要点，而独立于分布式的考虑。</p>
<p>在进行分布式工程架构建模时，必须考虑系统的各个方面，如对象复制、多线程和系统拓扑等。</p>
<h4 id="技术选择架构"><a href="#技术选择架构" class="headerlink" title="技术选择架构"></a>技术选择架构</h4><p>技术选择架构（技术视点）确定了实际的技术选择，所有其他视点都独立于这些决定。因为大多数架构设计是独立的，商业技术的发展可以很容易地适应。</p>
<p>一个系统的选择过程包括初始的概念性机制的确认，如持久性或者通信。概念性机制的特定属性可以从其他视点得到。具体的机制被标识出来，如DBMS、OODBMS。这些特定的参选产品是从可得到的技术中选出来的。基于对候选者的初始选择，这个过程根据产品价格、培训要求和维护风险之类的项目因素而反复进行。</p>
<p>架构师选择的原因是非常重要的，因为所有这些观点可以作为以后架构约束的理由。记录可以放在一个由架构小组维护的非正式项目记事本上，可以用于以后进行参考。</p>
<p>以测试结果报告系统为例，介绍一下它的技术选择架构。</p>
<p>TRRS技术视点包括了原型规划的三种方式（如图14-6所示）。我们经常选用这些原型来支持渐进的系统演化和可扩展性。而从一种方式到另一种方式的演化之所以能够发生，是由在实现时选用不同的技术和提供多层结构间互操作机制所造成的。</p>
<details><summary>图14-6　原型规划的三种方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140022.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140022.png';" /></details>

<p>阶段1是一种快速的原型，它由一个独立的Java应用程序以及一个平面文件数据库配置而成。阶段2使用分布式基础设施中的RMI或者IIOP技术，支持局域网上的多客户系统。阶段3支持数据库的可扩展性，这是通过把平面文件替换为JDBC接口及其操作的后端数据库来实现的。</p>
<p>在阶段3之外，TRRS还需要对数据库表项、数据库集成和适应因特网环境下的安全性等功能提供支持。其他的开发挑战包括提供体系结构的设计工具以及利用TRRS数据进行管理等，例如向软件开发者报告相关的TRRS产品表项。这些为软件体系结构引入了一个新的动态层面。</p>
<h3 id="实现模型"><a href="#实现模型" class="headerlink" title="实现模型"></a>实现模型</h3><p>最终用户和架构师应在一起审查并贯穿于用例（业务场景、质量场景、易变场景）始终来证实需求的有效。通常这个交流会出现新的或者需要修改的需求，对于需求的任何修改都要标注并结合到随后的其他架构活动中去。通过模型，管理层能够看到可视化的进展。</p>
<p>大多数系统可以采用快速原型技术生成模型。快速原型技术有利于快速获取产品设计的反馈信息，并对产品设计的可行性做出准确的评估、论证。</p>
<h3 id="架构原型"><a href="#架构原型" class="headerlink" title="架构原型"></a>架构原型</h3><p>在完成上述任务之后，从构建的草图进而发展成产品原型。架构原型是很好的需求验证工具，它能够帮助利益相关人检测系统锲合用户操作的程度。可以使用各种各样的办法构建架构原型，而非编码一种。例如，可以使用故事板来可视化地展现用户使用产品的过程，也可以使用原型工具来模拟过程，以此说明产品是如何运行的。架构原型只是快速构建，作为改进设计的手段，如果在构建架构原型过程中使用了编码，也要尽量避免在最终产品中使用这些代码。</p>
<p>架构框架（Framework）是对系统架构的一种可运行验证工具，通过对系统的API定义的编译以及编写小程序来模拟运行的系统。架构框架用于正式计算和工程体系架构，这包括穿越分布式边界的控制和定时。</p>
<p>使用CORBA技术，一个架构的规范能够被自动地编译成带有分布式stub和框架程序的一系列程序的头文件。通过在框架程序中插入虚拟代码来模拟处理过程，编写简单的客户程序用虚拟的数据来穿越边界发送请求。一些关键的，比如说：高风险的用例被替换的客户程序所模拟。原型的执行被计时以确保与工程约束相一致。</p>
<p>下面是一些架构师可以在架构原型中寻求解答的具体问题。</p>
<p>（1）主要组件的责任是否得到了良好定义？是否适当？</p>
<p>（2）主要组件间的协作是否得到了良好定义？</p>
<p>（3）耦合是否得以最小化？</p>
<p>（4）我们能否确定重用的潜在来源？</p>
<p>（5）接口定义和各项约束是否可接受？</p>
<p>（6）每个模块在执行过程中是否能访问到其所需的数据？是否能在需要时进行访问？</p>
<p>为了构建实际的系统，初始的架构原型需要进行演化。较好的情况是在经过2次或3次迭代之后，架构变得稳定。主要的抽象对象都已被找到；子系统和过程都已经完成；所有的接口都已经明确定义。</p>
<p>在系统架构开发过程中，利用架构原型，至少有下面的几个好处。</p>
<p>（1）在架构落实之前，让团队成员能自由发表他们自己的看法，并进行讨论，提出建议，对在架构原型中存在的问题进行及时改正。</p>
<p>（2）可以在系统的整体性能上，把握得更好。统一团队成员之间的思想看法和提高系统开发的成功率。</p>
<p>（3）它对系统内部的结构分析与设计也有帮助。</p>
<h3 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h3><p>无论什么项目，其最终目标都是要按期、按预算开发出满足用户需求的、高可靠、高性能的产品。在实现这个目标的过程中，项目规划起着至关重要的作用。项目规划是一份已通过批准的正式文档，它根据项目的目标，对项目实施进行的各项活动作出规定，以它为基准跟踪和控制项目，确定未来的行动方案和资源分配，引导项目的实施。项目规划的主要作用是将制定规划的假设和决定以及批准的范围、成本、进度的基线等用正式的文档记录保存。规划的复杂性取决于项目的复杂性，它体现了对客户需求的理解，便于高层管理、项目经理、项目组成员及项目相关人等之间进行交流沟通。</p>
<p>项目规划是基于当前已有的信息，包括过去的经验，当前的目标、范围、组织结构、资源等，工作活动、里程碑、质量目标和风险管理等，其中估算是项目规划的核心。随着项目的进展，信息的增多和理解的深入，估算会不断校正并逐渐地接近实际。项目计划是在规划基础上建立的一组实现任务的活动表，如进度计划、质量活动计划和配置管理计划等。项目管理者通过计划与规划的差异，不断优化和更新计划策略，使项目按规划的要求得以实现，计划的变更是可管理和可受控的。</p>
<p>项目规划是项目工作的纲领，要以此去指导项目的技术和管理活动。项目规划包括如下内容。</p>
<p>（1）项目的目的、范围、目标和对象。</p>
<p>（2）软件生存周期的选择。</p>
<p>（3）精选的供开发和维护软件用的规程、方法和标准。</p>
<p>（4）待开发的软件工作产品。</p>
<p>（5）软件工作产品的规模估计、软件项目的工作量和成本的估计。</p>
<p>（6）关键计算机资源的估计；项目的里程碑。</p>
<p>（7）风险的识别和评估。</p>
<p>（8）工程设施和支持工具计划。</p>
<p>软件项目计划的目标有：软件估计被文档化，以供跟踪软件项目使用。软件项目的活动和约定是有计划的，并形成文档，受影响的组和个人认同与软件项目规划的约定。</p>
<h3 id="并行开发"><a href="#并行开发" class="headerlink" title="并行开发"></a>并行开发</h3><h4 id="软件并行开发的内容及意义"><a href="#软件并行开发的内容及意义" class="headerlink" title="软件并行开发的内容及意义"></a>软件并行开发的内容及意义</h4><p>并行开发的意义在于提高软件生产率和改善软件质量。软件并行开发有效地组织可以重复的资源，并附加额外的控制管理技术，使软件开发尽量并行进行，从而达到加快软件开发速度、提高软件生产率、缩短软件开发周期的目的。同时，软件并行开发通过改善软件过程，达到提高软件质量的目的。软件并行开发以提高软件生产率为目的，对实现软件并行开发的各个方面做了必要的分析，并且给出了可行的解决方案，直接面对软件工程的实施，因此具有重要的应用价值。</p>
<p>软件并行开发研究的内容主要如下。</p>
<p>（1）软件过程及其模型。</p>
<p>（2）并行成分划分。</p>
<p>（3）并行控制。</p>
<p>（4）支持环境。</p>
<p>（5）交互机制与集成技术。</p>
<h4 id="并行开发的过程"><a href="#并行开发的过程" class="headerlink" title="并行开发的过程"></a>并行开发的过程</h4><p>要讨论软件并行开发的软件生存周期模型，需要把视野集中到软件开发过程中。把软件系统的开发过程划分为若干个可以并行的成分，这个成分称之为子开发过程。子开发过程是一个动态概念，和操作系统中的进程概念有类似之处。子开发过程可以定义为：子开发过程＝开发小组＋软件对象＋对软件对象的开发活动。或者说，子开发过程是一个开发小组对一个相对独立的软件对象的动态开发过程。</p>
<p>在此，我们把整个并行开发活动看作是一个并行系统，称为并行开发系统。子开发过程是对并行开发系统的一种动态描述，此系统中的实体是开发小组，实体属性是被开发的软件对象，行为是开发软件对象的活动。每个子开发过程完成一个子系统或一个模块的开发任务，当各个子开发过程都完成之后，进行系统集成和测试，最终完成整个系统的开发，如图14-7所示。</p>
<details><summary>图14-7　并行开发中的生命周期模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140149.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140149.png';" /></details>

<p>并行模块的划分是并行开发中的核心问题，模块独立性是衡量软件设计质量的关键。根据并行开发的特征，一个开发小组负责一个模块的开发，如果各模块之间的耦合度低，那么各并行开发过程之间交互作用将减少，为并行开发控制带来方便。有如下两种系统划分的方法。</p>
<p>（1）基于Petri网系统模型的动态划分方法。</p>
<p>（2）基于脚本的系统划分方法。</p>
<p>在软件并行开发中，软件过程并行控制（以下简称并行控制）是一个非常重要的问题。所谓并行控制，就是要用正确的方式调度并行操作，避免造成不一致性，使一个操作的执行不受其他操作的干扰。为保证开发出的系统内部各成分间的一致性、相容性，保证系统的正确性和可靠性，就要进行并行控制。通常的并行控制手段有加锁、时间戳、管程、Petri网和PV操作等手段。并行控制模型描述被控制对象的并行行为以及它们之间的关系，是并行控制的依据。</p>
<p>当各个产品开发过程分别完成后，应通过集成技术，把各子开发过程所开发的软件对象集成起来，作为一个统一的应用系统。在软件并行开发的软件生存周期模型中，系统集成和系统测试被分为两个阶段，如果不考虑硬件或系统软件的集成，两个阶段并没有明显的界限。所以，就应用软件系统而言，软件集成的主要问题是集成测试技术。通过集成测试技术，在现实可行的时间内，运用工具尽量去发现尽可能多的软件错误，以保证软件的质量。</p>
<h3 id="系统转换"><a href="#系统转换" class="headerlink" title="系统转换"></a>系统转换</h3><p>系统转换是指运用某一种方式由新的系统代替旧的系统的过程，也就是系统设备、系统数据和人员等方面的转换。</p>
<h4 id="系统转换的准备"><a href="#系统转换的准备" class="headerlink" title="系统转换的准备"></a>系统转换的准备</h4><p>在系统转换前，必须认真做好系统设备、数据、人员以及有关文件（如程序说明书、系统操作说明书等）的准备。</p>
<p>除此之外，还需要系统试运行这项准备工作。系统试运行是指在系统没有正式转换之前，选择一些子项目进行的实验运行。需要注意如下两方面的问题。</p>
<p>（1）系统试运行工作的代表性。指在系统试运行工作中所选择的子功能和数据应该尽量接近实际系统运行的需要。</p>
<p>（2）系统试运行中错误的修正。系统试运行过程中用户发现的一些问题，对待这些问题应该以系统分析中确定的系统目标为标准，认真分析产生问题的原因和类型，决定对系统的问题是否修订和如何进行修订。</p>
<h5 id="系统转换的方式"><a href="#系统转换的方式" class="headerlink" title="系统转换的方式"></a>系统转换的方式</h5><p>系统转换可分为直接转换、平行转换、分段转换和分批转换。</p>
<p>（1）直接转换。直接转换是当新系统安装完毕能够进行工作后，立即停止旧系统的运行，让新系统投入运行的转换方式。</p>
<p>（2）平行转换。平行转换是新旧系统共同工作一段时间，当证实新系统有较高的可靠性后，再停止旧系统工作的转换方式。</p>
<p>（3）分段转换。分段转换时一次只用新系统的部分功能去替换旧系统的相应部分，逐步完成新系统替换旧系统的转换方式。</p>
<p>（4）分批转换。分批转换是把新系统在小范围内使用，然后再全部推广的转换方式。</p>
<p>以上几种系统转换方式各有各的特点，应根据系统规模的大小、难易和复杂的程度以及企业的具体情况决定系统转换时采用哪种方式。</p>
<h4 id="系统转换的注意事项"><a href="#系统转换的注意事项" class="headerlink" title="系统转换的注意事项"></a>系统转换的注意事项</h4><p>在系统的转换过程中，无论采取哪种转换方式，都要注意以下问题。</p>
<p>（1）新系统的运行需要大量的基础数据，这些数据的整理与录入工作量很大，应及早准备，尽快完成。</p>
<p>（2）系统的转换不仅仅是机器的转换、程序的转换，更难的是人员的转换，应提前做好人员的培训工作。</p>
<p>（3）系统运行时会出现一些局部性的问题，这是正常现象。系统工作人员对此应有足够的准备，并做好记录。系统只出现局部性问题，说明系统是成功的；反之，如果出现致命问题，说明系统设计质量不好，整个系统甚至要重新设计。</p>
<h3 id="操作与维护"><a href="#操作与维护" class="headerlink" title="操作与维护"></a>操作与维护</h3><h4 id="操作与维护的内容"><a href="#操作与维护的内容" class="headerlink" title="操作与维护的内容"></a>操作与维护的内容</h4><p>一个系统交付使用后，系统的开发就结束了，系统转入正常的运行操作时期。从系统的生命周期看，只有系统投入正常的操作和维护后，才真正实现了系统。因此，可以说操作维护是系统过程的后阶段。</p>
<p>系统操作与维护的内容有数据管理与维护，包括数据收集、数据整理、数据录入以及数据的分发、数据库管理工作；机器设备的管理与维护，包括硬件维护、机器日常行政管理、系统操作记录和用户服务等；系统软件的管理与维护工作，应用软件的管理与维护工作，代码维护。</p>
<h4 id="系统维护与架构"><a href="#系统维护与架构" class="headerlink" title="系统维护与架构"></a>系统维护与架构</h4><p>系统架构的好坏，可维护性是一个重要方面，维护人员应参与架构的评审。系统的可维护性可以定性地定义为：维护人员理解、改正、改动和改进这个软件的难易程度，提高可维护性时开发管理系统所有步骤的关键目的。系统能否被很好地维护，可用系统的可维护性这一指标来衡量。系统的可维护性有如下几个评价指标。</p>
<p>●　可理解性</p>
<p>●　可测试性</p>
<p>●　可修改性</p>
<p>依据信息系统需要维护的原因不同，系统维护工作可以分为以下4种类型。</p>
<p>●　更正性维护</p>
<p>●　适应性维护</p>
<p>●　完善性维护</p>
<p>●　预防性维护</p>
<p>某个维护目标确定以后，维护人员必须先理解要维护的系统，然后建立一个维护方案。由于程序的修改涉及面较广，某处修改很可能会影响其他模块程序，所以建立维护方案后要加以考虑的重要问题是修改的影响范围和波及面的大小。然后按预定维护方案修改程序，若测试发现重大问题，则要重复上述步骤。若通过，则修改相应文档并交付使用，结束本次维护工作。必须强调的是，维护是对整个系统而言的。因此，除了修改程序、数据和代码等部分以外，必须同时修改涉及的所有文档。系统维护的步骤如图14-8所示。</p>
<details><summary>图14-8　系统维护步骤</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140406.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140406.png';" /></details>

<h3 id="系统移植"><a href="#系统移植" class="headerlink" title="系统移植"></a>系统移植</h3><h4 id="系统移植的形式"><a href="#系统移植的形式" class="headerlink" title="系统移植的形式"></a>系统移植的形式</h4><p>系统移植的方法有三种：第一种是不修改已有的软件，可以使用的方法有高位互换、仿真功能和虚拟机（Virtual Machine）功能；第二种是修改软件，就是把已有软件资源，即程序、数据、计算机应用方法及各种说明书转换为与新机器具有匹配性的软件；第三种是重编软件，有从逻辑设计开始、从程序设计开始和从编程开始三种开发方式。</p>
<h4 id="系统移植的工作阶段划分"><a href="#系统移植的工作阶段划分" class="headerlink" title="系统移植的工作阶段划分"></a>系统移植的工作阶段划分</h4><p>移植工作大体上分为计划阶段、准备阶段、转换阶段、测试阶段和验证阶段。为了有效地进行系统移植，就得使系统移植工作标准化；配备软件工具实现自动化；还要简化各阶段的工作。下面简要介绍一下系统移植的各阶段工作。</p>
<p>（1）计划阶段。在计划阶段，要进行现有系统的调查整理，从移植技术、系统内容（是否进行系统提炼等）和系统运行三个方面，探讨如何转换成新系统，决定移植方法，确立移植工作体制及移植日程。</p>
<p>（2）准备阶段。在准备阶段要进行移植方面的研究，准备转换所需的资料。该阶段的作业质量将对以后的生产效率产生很大的影响。</p>
<p>（3）转换阶段。这一阶段是将程序设计和数据转换成新机器能根据需要工作的阶段。提高转换工作的精度，减轻下一阶段的测试负担是提高移植工作效率的基本内容。</p>
<p>（4）测试阶段。这一阶段是进行程序单元、工作单元测试的阶段。在本阶段要核实程序能否在新系统中准确地工作。所以，当有不能准确工作的程序时，就要回到转换阶段重新工作。</p>
<p>（5）验证阶段。这是测试完的程序使新系统工作，最后核实系统，准备正式运行的阶段。</p>
<h4 id="系统移植工具"><a href="#系统移植工具" class="headerlink" title="系统移植工具"></a>系统移植工具</h4><p>数据不能互换的系统移植时，完整的数据转换工具是必需的。主要有以下几种软件工具。</p>
<p>（1）分析工具：是分析现有软件资源，得到探讨移植方法有用信息的工具。</p>
<p>（2）生成工具：是编制作业控制语言、测试数据、转换工作所需文档的工具。</p>
<p>（3）转换工具：包括程序转换、数据转换和作业控制语言转换。</p>
<p>（4）数据应用工具：使用这种工具不用编文件就可以简便地存取磁带上的数据。</p>
<p>（5）测试、验证工具：作为可分类的工具包括静态、动态跟踪。</p>
<p>（6）管理工具：是管理资源及作业的工具。</p>
<p>系统移植工作需要的软件工具有很多种，配备工具最主要的是在决定移植的工作方法之后，配备移植所需的工具并明确工具的界限。即选出移植工作中的作业项目，使项目系列化、标准化。配备、开发移植所需的工具；对于那些用工具转换的项目，采取相应的措施，进行文档化，使任何人都能以相同的顺序开展工作。这样，就不必制作大量的工具，只将有效的工具组合起来，就可以提高效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/index/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/index/">1</a><a class="page-number" href="/index/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/index/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/30/">30</a><a class="extend next" rel="next" href="/index/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">293</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
