<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ednow">
<meta property="og:url" content="http://ednow.github.io/index/page/6/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ednow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ednow.github.io/index/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch17-%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch17-%E4%BC%81%E4%B8%9A%E9%9B%86%E6%88%90%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch17-企业集成架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:57:20" itemprop="dateCreated datePublished" datetime="2021-07-19T12:57:20+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 16:31:26" itemprop="dateModified" datetime="2021-09-26T16:31:26+08:00">2021-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="企业集成架构设计"><a href="#企业集成架构设计" class="headerlink" title="企业集成架构设计"></a>企业集成架构设计</h2><p>企业信息集成是解决“孤岛”问题的需要，技术发展的同时也推动了集成架构等相关的研究。企业集成平台的核心是企业集成架构，包括信息、过程、应用集成的架构。本章从集成平台概念出发，探讨相关的标准、规范、技术及设计模型，包括面向企业整体集成模型和作用。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42801723/article/details/105395540">信息化孤岛问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21516296">OA系统和EIP系统的区别？</a></li>
</ul>
<h3 id="企业集成平台"><a href="#企业集成平台" class="headerlink" title="企业集成平台"></a>企业集成平台</h3><p>信息时代的企业集成需要在一个开放的计算机支撑环境下实现。企业集成平台（Enterprise Integration Platform, EIP）技术是近年来用于企业信息系统集成的一种先进的计算机软件技术，其目的是能够根据业务模型的变化快速地进行信息系统的配置和调整，保证不同系统、应用、服务或操作人员之间顺畅地互操作，进而提高企业适应市场变化的能力，使企业能够在复杂多变的市场环境中生存。</p>
<p>企业集成的水平在很大程度上取决于企业内部各种系统、应用或服务的集成化运行水平，良好的软件支持工具可以帮助企业加快实现企业系统集成。作为支持企业集成化运行的工具，企业集成平台的主要功能是为企业中各种数据、系统和过程等多种对象的协同运行提供各种公共服务及运行时的支撑环境，从而降低实现企业内部的信息孤岛集成的复杂度，提高应用间集成的有效性，将信息系统实施规划中确定的企业中各种应用系统、服务、人员、信息资源及数字化设备的协同关系物化到集成化运行的可执行系统中去。</p>
<h4 id="企业集成平台的概念"><a href="#企业集成平台的概念" class="headerlink" title="企业集成平台的概念"></a>企业集成平台的概念</h4><p>企业集成平台概念的提出和发展来自于企业应用需求和计算机技术发展两方面的驱动。一方面，企业中各种业务信息系统（包含各种遗留信息系统）数量的增加为企业集成平台产生了需求拉动的作用；另一方面，计算机及软件技术的发展是产生企业集成平台的技术推动力。</p>
<p>实现企业集成的技术和手段多种多样，早期比较简单的集成方式是通过在不同的应用之间开发一对一的专用接口来实现应用之间的数据集成，即采用点到点的集成方式。这种点到点的集成方式的优点是比较直观，在企业应用数量少时易实现。但这种方式也存在比较多的问题：工作量大；集成系统的维护费用高，系统升级和扩展困难；不易于标准化，由于接口数量多，给系统管理造成比较大的困难；一般仅能够解决应用系统之间的数据集成问题，难以用来支持过程集成和应用之间的协调。</p>
<p>为了克服点到点集成方式给企业应用系统集成和维护管理带来的困难，人们提出了采用集成平台的方式来实现企业集成。企业集成平台是一个支持复杂信息环境下信息系统开发、集成和协同运行的软件支撑环境。它基于各种企业经营业务的信息特征，在异构分布环境（操作系统、网络、数据库）下为应用提供一致的信息访问和交互手段，对其上运行的应用进行管理，为应用提供服务，并支持企业信息环境下各特定领域的应用系统的集成。</p>
<p>经过多年的发展，集成平台已经成为支持企业集成的先进和有效的方法。基于集成平台，可以使分散的信息系统通过一个单一的接口，以可管理、可重复的方式实现单点集成，使企业内的所有应用都可以通过集成平台进行通信和数据交换，实现广义范围内和深层次上的企业资源共享和集成。图17-1给出了企业集成平台的示意图。</p>
<details><summary>图17-1　企业集成平台的应用架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151753.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151753.png';" /></details>

<p>企业集成平台的产生和发展，使得企业应用软件的开发方式较传统方式发生了很大变化，也使得应用系统维护和扩展的难度及费用大为减少。应用集成平台提供的应用软件集成机制和接口可以实现应用间的透明信息交换，使得在异构分布环境下的应用软件通过该接口集成到平台上，共享平台所拥有的资源。采用集成平台可以大大降低集成的复杂度，提高集成的有效性。</p>
<p>由于其诸多的优点，从20世纪80年代中期以后，集成平台的概念和产品在全世界范围内得到了广泛的推广应用，出现了狭义的集成平台和广义的集成平台两种概念。狭义的集成平台是指一个软件平台，它为企业内多个应用软件系统或组件间的信息共享与互操作提供所需的通用服务，达到降低企业内（间）多个应用软件系统或系统之间的集成复杂性的目的。广义的集成平台则是指由支撑软件系统（狭义集成平台）同其他完成不同业务的逻辑功能的各应用系统一起组成数字化企业的协同运行环境。但无论是广义的集成平台，还是狭义的集成平台，其核心的内容都是为企业提供集成所需要的服务，并对集成系统进行管理。</p>
<p>集成平台是支持企业集成的支撑环境，包括硬件、软件、软件工具和系统，通过集成各种企业应用软件形成企业集成系统。由于硬件环境和应用软件的多样性，企业信息系统的功能和环境都非常复杂，因此，为了能够较好地满足企业的应用需求，作为企业集成系统支持环境的集成平台，其基本功能主要如下。</p>
<p>1） $\color{green}{\text{通信服务}}$ </p>
<p>提供分布环境下透明的同步/异步通信服务功能，使用户和应用程序无需关心具体的操作系统和应用程序所处的网络物理位置，而以透明的函数调用或对象服务方式完成它们所需的通信服务要求。</p>
<p>2） $\color{green}{\text{信息集成服务}}$ </p>
<p>为应用提供透明的信息访问服务，通过实现异种 $\color{green}{\text{数据库系统}}$ 之间数据的交换、互操作、分布数据管理和共享信息模型定义（或共享信息数据库的建立），使集成平台上运行的应用、服务或用户端能够以一致的语义和接口实现对数据（数据库、数据文件、应用交互信息）的访问与控制。</p>
<p>3） $\color{green}{\text{应用集成服务}}$ </p>
<p>通过高层应用编程接口来实现对相应应用程序的访问，这些高层应用编程接口包含在不同的适配器或代理中，被用来连接不同的应用程序。这些接口以函数或对象服务的方式向平台的组件模型提供信息，使用户在无需对原有系统进行修改（不会影响原有系统的功能）的情况下，只要在原有系统的基础上加上相应的访问接口就可以将现有的、用不同的技术实现的系统互联起来，通过为应用提供数据交换和访问操作，使各种不同的系统能够相互协作。</p>
<p>4） $\color{green}{\text{二次开发工具}}$ </p>
<p>是集成平台提供的一组帮助用户开发特定应用程序（如实现数据转换的适配器或应用封装服务等）的支持工具，其目的是简化用户在企业集成平台实施过程中（特定应用程序接口）的开发工作。</p>
<p>5） $\color{green}{\text{平台运行管理工具}}$ </p>
<p>是企业集成平台的运行管理和控制模块，负责企业集成平台系统的静态和动态配置、集成平台应用运行管理和维护、事件管理和出错管理等。通过命名服务、目录服务、平台的动态静态配置，以及其中的关键数据的定期备份等功能来维护整个服务平台的系统配置及稳定运行。</p>
<h4 id="集成平台的标准化"><a href="#集成平台的标准化" class="headerlink" title="集成平台的标准化"></a>集成平台的标准化</h4><p>集成平台上集成的应用软件系统通常都是由不同的软件厂家提供的产品，具有很强的异构性，所以在集成平台中需要广泛采用新的开放性标准。研究和发展系统集成的相关标准，不断地使平台的接口和服务标准化，可以显著提高集成平台系统的适应性和可扩展性，减少异构性给集成带来的障碍。采用标准化的技术也是提高集成平台系统开放性和软件模块可重用性的重要方法。</p>
<p>集成平台的标准化内容涉及通信协议、中间件、企业建模、工作流管理系统、Internet环境下的数据交换、产品数据标准和应用系统集成的标准等。Goldstone技术公司在国际标准化组织定义的开放系统互联（ISO/OSI）的7层网络应用模型的基础上，给出了图17-2所示的集成平台的12层OSI模型。</p>
<details><summary>图17-2　企业集成平台的12层OSI模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151834.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151834.png';" /></details>

<p>在这个12层OSI模型中，下面的7层依然是采用ISO关于网络应用7个层次的定义。第8层为支持应用集成的中间件层，它为集成平台提供商实施企业系统集成提供了可扩展集成的架构。第9层为应用开发商定义的应用间方法（服务）调用、接收/发送消息格式的接口语法层。第10层为应用提供商和集成平台提供商共同提供的用来描述应用软件系统结构和内涵的应用语义层。第11层作为业务语义描述层，供业务操作人员和信息管理人员用来定义基于模型操作的业务对象的数据结构及其语义。第12层为业务过程层，用来为业务操作人员定义企业关键业务流程及流程之间的交互关系。</p>
<h4 id="实现技术的发展趋势"><a href="#实现技术的发展趋势" class="headerlink" title="实现技术的发展趋势"></a>实现技术的发展趋势</h4><p>通过分析国内外集成平台的应用及发展情况，结合企业集成系统对集成平台实施提出的要求和计算机软件技术的发展趋势，企业集成技术有如下的发展趋势。</p>
<h5 id="集成的技术实现从2层到n层过渡"><a href="#集成的技术实现从2层到n层过渡" class="headerlink" title="集成的技术实现从2层到n层过渡"></a>集成的技术实现从2层到n层过渡</h5><p>传统的集成实现一般采用图17-3所示的两层C/S或B/S结构，这样的系统将业务逻辑和应用表示逻辑封装在一起。这个封装在一起的逻辑模块可以安装在客户端应用上，也可以安装在服务器上，但是无论是在服务器端，还是在客户端， 由于业务逻辑和应用表示逻辑的紧密捆绑，对系统的升级和扩展都带来了比较大的困难。</p>
<details><summary>图17-3　集成技术的两层实现</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151917.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151917.png';" /></details>

<p>未来的集成平台将采用图17-4所示的n层系统集成方式，将业务过程逻辑、业务表示逻辑等进行分离，将每层的功能集中在一个特定的角色上，这样可以得到一个非常便于进行系统功能扩展、逻辑修改的应用集成框架，进而提高集成平台和集成系统的柔性。</p>
<details><summary>图17-4　集成技术的n层实现</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904151937.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904151937.png';" /></details>

<h5 id="集成支持的方式从面向信息集成扩充到面向过程集成、服务集成"><a href="#集成支持的方式从面向信息集成扩充到面向过程集成、服务集成" class="headerlink" title="集成支持的方式从面向信息集成扩充到面向过程集成、服务集成"></a>集成支持的方式从面向信息集成扩充到面向过程集成、服务集成</h5><p>面向信息的集成主要是针对设计、制造和管理部门中大量存在的自动化孤岛和信息孤岛而提出来的，其目的是为了解决企业内不同应用和系统间的数据共享和集成。这些应用系统分布在网络环境下的异构计算机系统中，它们所管理和操作的数据格式和存储方式各异，实现信息集成就是要实现数据的转换（不同数据格式和存储方式之间的转换）、数据源的统一（同一个数据仅有一个数据入口）、数据一致性的维护、异构环境下不同的应用系统之间的数据传送。面向信息的集成主要应用于企业内的数据库和数据源上，其具体的实现方法主要有数据复制、数据捆绑和基于接口的信息集成三种方式。</p>
<p>（1）面向过程的集成（这里主要是指技术层面的过程集成）：通过工作流引擎对企业内业务流程模型的执行来实现业务应用数据或信息在不同应用、子过程或执行任务的人员之间流动（如图17-5所示）。采用工作流管理方式可以对业务过程逻辑和应用逻辑进行分离，实现过程建模和数据、功能的分离，从而可以在保持具体功能单元不变的情况下，通过修改过程模型来改变系统功能，进而提高系统的柔性。面向过程集成需要在信息集成的基础上进行，或者说面向过程集成可能会对信息集成提出新的要求，因为在执行过程模型时，过程模型中包含的各种活动之间（特别是自动应用之间）同样需要信息共享与集成。过程集成更重要的是一种策略行为，它还具有过程逻辑可视化、业务执行过程自动化、业务过程执行状态和性能的实时监控等功能。</p>
<details><summary>图17-5　面向过程集成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152003.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152003.png';" /></details>

<p>（2）面向服务的集成（如图17-6所示）：主要是为支持大范围内的公共业务过程集成而提出的一种动态集成方式（如供应链企业群体内），可以较好地实现（企业间）具有松散耦合关系的不同应用间的互操作。在这种集成方式中，服务提供者（平台、企业）将应用作为服务部署在Web上，通过使用Web服务描述语言来描述Web服务提供的功能，并通过统一的服务发布与发现协议（Universal Description, Discovery and Integration, UDDI）将其注册到UDDI中心。服务请求者使用UDDI协议定义的API向UDDI中心提出服务请求，UDDI为其寻求到它所需要的服务，并由UDDI中心返回服务请求，同时与特定服务进行绑定，在此基础上，服务请求者继而通过SOAP协议完成应用服务的调用。基于服务的集成方式对于集成企业原有的系统同样十分方便，在不需要对原有系统进行修改的情况下，只要在原有系统的基础上增加一个对它们进行访问的SOAP接口，就可以完成原有系统到集成平台的集成。面向服务的集成将以前主要在企业内部网络基础上实施的集成扩展到了面向开放网络环境下的集成，从而大大扩展了集成的范围。基于服务的集成方式具有最好的柔性和开放性，然而，这种松散的动态集成方式牺牲了性能和网络流量。</p>
<details><summary>图17-6　面向服务集成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152029.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152029.png';" /></details>

<h5 id="集成规范的标准化程度不断提高"><a href="#集成规范的标准化程度不断提高" class="headerlink" title="集成规范的标准化程度不断提高"></a>集成规范的标准化程度不断提高</h5><p>开放性和标准化在集成的实现技术中的重要性已经得到广泛的认同。从数据描述的角度来看，数据结构的定义已经由原来的各个应用专有数据类型、行业内的标准数据表达（如STEP、EDI等），逐渐过渡到具有自描述功能的基于XML语言的数据表达与存储。从应用间集成接口的实现与接口表现形式来看，已经从最初的自定义应用编程接口、基于IDL接口定义（如CORBA或COM的接口描述语言），发展到更通用的基于XML语言的Web服务接口定义语言（WSDL）的集成接口描述。从业务过程定义方面来看，则由不同产品给出的自定义业务过程描述方式，工作流联盟为实现不同工作流产品间互操作而提出的工作流过程定义语言（WPDL），到近来出现的关于如何利用Web服务集成架构实现过程集成的基于XML语言的商业流程模型描述语言（如WSFL、BPEL等）。标准化技术的采用增强了集成平台的开放性和通用性，从而为企业集成提供了更强有力的技术支持。</p>
<h5 id="所支持的集成耦合度及集成的粒度的变化"><a href="#所支持的集成耦合度及集成的粒度的变化" class="headerlink" title="所支持的集成耦合度及集成的粒度的变化"></a>所支持的集成耦合度及集成的粒度的变化</h5><p>随着编程技术的发展，集成平台所采用的集成实现形式也在不断发展，应用集成的耦合度（松散集成、紧密集成）不断降低，集成范围不断扩大，而集成粒度（对象、组件、服务）也在不断缩小，图17-7给出了集成的范围和集成耦合度的对应关系。</p>
<p>随着集成范围的不断扩大，集成的耦合度不断降低。集成耦合度最高的对象间集成方式比较适合于功能单元之间的集成，集成耦合度最低的服务集成方式则能够比较好地实现企业间的集成，集成耦合度中等的组件集成方式可以较好地完成企业内的集成。对象间集成主要通过程序代码级对象之间的调用来实现。组件之间的集成方式则主要通过构建企业内分布式计算环境、采用远程过程调用来实现跨语言、进程和计算机间的基于组件的集成。基于服务的集成方式包括基于消息中间件服务和基于Web服务两种。基于消息中间件的服务集成通过消息中间件（如MSMQ）来实现应用或系统之间的互操作，基于Web服务的集成通过SOAP消息交换协议（防火墙透明的）来实现Internet环境下的分布式计算。由于Web服务的方式具有良好的松散耦合集成结构，因此它更适合于用来支持企业间应用的集成。</p>
<details><summary>图17-7　集成尺度与范围、耦合度的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152106.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152106.png';" /></details>


<h4 id="集成平台的发展趋势"><a href="#集成平台的发展趋势" class="headerlink" title="集成平台的发展趋势"></a>集成平台的发展趋势</h4><p>企业集成平台技术已经逐步成熟，国外已经出现了许多商用产品。从功能上可以将其划分为企业应用集成和业务到业务的集成（B2B）两种。其中，EAI主要侧重于企业内部的纵向集成，B2B侧重于支持企业间业务往来的横向集成。目前在市场上的产品主要有Active Enterprise 3.0（Tibco公司）、Mercator（Mercator公司）、MQ Series Integrator（IBM公司）、WebMethods Enterprise（WebMethods公司）和Business Ware。</p>
<h5 id="Active-Enterprise-3-0（Tibco公司）"><a href="#Active-Enterprise-3-0（Tibco公司）" class="headerlink" title="Active Enterprise 3.0（Tibco公司）"></a>Active Enterprise 3.0（Tibco公司）</h5><p>Tibco公司主要为具有基本信息技术应用知识的企业用户提供端到端的异构信息系统集成方案。其产品Active Enterprise 3.0采用了模块化的结构，它的每一个组件（如数据仓库、集成服务器、消息代理以及监控工具等）都可以在不同机器上独立运行，组件间的通信通过一个连接所有组件的信息总线实现。信息总线采用其独有的串行UDP技术实现，能够保证在发生系统级事件（包括通信错误）时及时向相关组件发送通知。考虑到在企业有大量的系统需要集成的情况下，对于整个集成系统的管理和监控将会很复杂，Tibco采用一个轻型代理实现对整个平台所有层次上的系统和过程进行全面的监控。轻型代理采用广播的形式向信息总线上的所有组件发送必要的监控和管理消息，采用这种方式可以将监控系统对平台系统性能造成的影响降到最低。通过轻型代理和信息总线的协同作用，可以使Active Enterprise对新接入的应用或服务具有动态发现能力。另外，Active Enterprise利用工作流技术为用户提供了强大的业务过程管理能力，用户可以在简单、直观的过程建模工具的支持下，建立相应的业务过程模型，并通过其工作流引擎同时支持自动化过程和人工型工作流的执行。</p>
<h5 id="Mercator（Mercator公司）"><a href="#Mercator（Mercator公司）" class="headerlink" title="Mercator（Mercator公司）"></a>Mercator（Mercator公司）</h5><p>Mercator由Enterprise Broker、Web Broker和Commerce Broker三个独立的产品构成。其中Enterprise Broker用于企业内应用的集成。Web Broker是B2以外，配合以上产品提供了企业间的流程设计的GUI工具Integration Flow Designer。目前，全世界已经有5000套Mercator投入运行，Mercator在集成SAP R/3用户方面具有很强的优势。</p>
<h5 id="MQ-Series-Integrator（IBM公司）"><a href="#MQ-Series-Integrator（IBM公司）" class="headerlink" title="MQ Series Integrator（IBM公司）"></a>MQ Series Integrator（IBM公司）</h5><p>MQ Series Integrator由消息中间件MQSeries、消息代理Integrator以及实现业务流程自动化的MQSeries Workflow构成。MQSeries是IBM开发和销售的消息中间件产品，是消息中间件事实上的标准，它支持35种以上的协议，可以用统一的API进行异构机种间的连接，主要是进行异步消息处理，但也可以实现实时消息的连接。MQSeries符合JMS标准，可以很容易地与WebLogic和WebSphere等应用服务器实现连接。MQSeries Workflow可以采用图形的方式方便地定义跨不同企业系统间的业务流程，也可以对工作流的实例状态进行控制和调整。特别是MQSeries Workflow可以将规则嵌入到流程节点中来，这点得到了用户广泛的好评。目前IBM已将WebSphere B2B Integrator加到这些产品中，以提供包含企业内和企业间集成的综合解决方案。</p>
<h5 id="WebMethods-Enterprise（WebMethods公司）"><a href="#WebMethods-Enterprise（WebMethods公司）" class="headerlink" title="WebMethods Enterprise（WebMethods公司）"></a>WebMethods Enterprise（WebMethods公司）</h5><p>该产品是WebMethods公司面向技术型用户提供的B2B解决方案，其核心部件是Active Works。Active Works提供了通信协议转换、队列管理和队列分配、60多种适配器、业务流程的控制，XML变换和Web应用接口等EAI的基本功能。需要指出的是，WebMethods Enterprise实现了EAI功能的一体化，即各种EAI功能可以在一个界面上统一进行设计和操作，所以容易进行应用系统开发和实施。特别地，每一次定义的业务流程都可以以模板的方式进行保存。WebMethods Enterprise采用总线型体系结构，利用Java框架来实现客户适配器的开发，因此具有良好的可扩展性和可用性，特别适用于大型企业的系统集成。WebMethods Enterprise消息交换的可靠性也较高，它包含一个异步事务协调引擎，并带有一个可用于MQSeries的适配器。监控代理、适配器及其各自的流程能够在死机的情况下自动恢复，也可以进行事件的自动重送。在对可靠性有更高要求的应用情况下，还可以在系统的外部配置作业控制器的相关服务模块。在收购了Active（EAI）和IntelliFrame（工作流管理系统）后，WebMethods公司具有为企业提供全面的端到端的集成方案的能力，它为许多主流的ERP、CRM、基于消息的中间件系统提供了广泛可用的内置适配器。一旦在技术上实现与这些并购产品的全面集成，WebMethods的领先地位将从目前的B2B领域扩展到EAI领域。</p>
<h5 id="BusinessWare（Vitria-Technology公司）"><a href="#BusinessWare（Vitria-Technology公司）" class="headerlink" title="BusinessWare（Vitria Technology公司）"></a>BusinessWare（Vitria Technology公司）</h5><p>Business Ware产品主要面向技术型用户，它采用以过程为核心的方式实现系统集成。BusinessWare产品具体由业务流程管理工具、可作为系统连接的EAI平台、实时监视工作流状态的实时分析工具、在应用层担当B2B集成的功能模块4个部分构成。它的业务流程管理工具具有友好的用户界面，用户可以在不需要事先编程和配置连接器的条件下，进行业务过程的可视化设计。Business Ware以CORBA技术为核心，采用通道/Hub（集线器）式的系统体系结构，与各系统连接的连接器控制各通道的输入输出，使用连接器开发工具包来支持客户化适配器的开发。BusinessWare中可以用多个类来定义发布/订阅通道的消息，通道采用与域名服务运行方式类似的联邦式分散结构，以实现对不同企业间集成化业务运作提供高性能和高可靠性的服务。在实时分析工具的界面上可以监视所设计流程的运行状态和性能。BusinessWare可以为那些希望自己进行业务过程建模的企业用户提供标准化的集成服务。</p>
<p>集成平台产品的发展具有以下的主要趋势。</p>
<p>（1）与商用工作流产品的融合发展。</p>
<p>集成平台产品通过与商用工作流产品的融合，一方面将基于工作流的业务流程分析、优化及过程管理功能引入到平台中来，并增强支持业务过程的自动执行能力及平台的可实施性；另一方面，利用商用工作流系统与用户的友好交互能力将人的因素集成到自动执行的企业业务操作过程中来，从而提高系统的柔性与可用性。</p>
<p>（2）与底层集成服务器产品的融合发展。</p>
<p>集成平台产品通过与底层集成服务器产品的融合，一方面可以增加集成平台产品内部各组件模块的无缝集成性，进而提高集成到平台上各应用系统间的互操作能力；另一方面，利用商用构件对企业用户提供从底层服务支撑技术到上层应用、过程集成的一体化支持，以保证集成平台的成功实施。</p>
<p>（3）兼容点到点（Point-to-Point）集成和端到端（End-to-End）集成。</p>
<p>集成平台厂商通过将其传统产品支持的点到点集成（主要指同步集成）方式扩展到端到端集成（侧重于异步集成）方式，以分别适用于企业内部集成所需要的大流量数据交换模式和企业间协同所需要的灵活的小流量数据交换模式。</p>
<p>（4）基于模型的集成与协调。</p>
<p>通过采用统一定义和表示的模型（在一些协议或规则的辅助下实现模型的构造和控制）实现不同应用系统之间的协同工作（应用软件通过模型操作接口实现对模型中定义的产品、过程、资源数据的访问，从而实现不同应用软件之间的无缝集成），这样就可以通过模型在整个生命周期的不断演化来实现企业集成信息系统的演化。</p>
<h3 id="企业集成平台的实现"><a href="#企业集成平台的实现" class="headerlink" title="企业集成平台的实现"></a>企业集成平台的实现</h3><h4 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h4><p>构建企业集成平台的首要目的是实现数据集成，即为平台上运行的各种应用、系统或服务，提供具有完整性、一致性和安全性的数据访问、信息查询及决策支持服务。数据集成主要为了解决不同应用和系统间的数据共享和交换需求，具体包括共享信息管理、共享模型管理和数据操作管理三个部分。其中，共享信息管理通过定义统一的集成服务模型和共享信息访问机制，完成对集成平台运行过程中产生数据信息的共享、分发和存储管理；共享模型管理则提供数据资源配置管理、集成资源关系管理、资源运行生命周期管理及相应的业务数据协同监控管理等功能；数据操作管理则为集成平台用户提供数据操作服务，包括多通道的异构模型之间的数据转换、数据映射、数据传递和数据操作等功能服务。</p>
<p>企业运行的业务应用系统采用的体系结构与其实现技术的标准化（规范化）程度，对数据集成的水平有非常大的影响。企业现有各种应用系统的规范化程度不高是影响企业数据集成水平的主要问题，因此，采用先进的软件体系结构和规范化的实现技术是实现良好的数据集成的基础。</p>
<p>企业集成技术架构层次如图17-8所示。</p>
<details><summary>图17-8　企业集成技术架构层次图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152345.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152345.png';" /></details>

<p>数据集成主要有以下三种模式：数据联邦、数据复制和基于接口的数据集成。如图17-9所示，它们分别描述了对多个异构数据源透明、一致访问的三种实现方法。</p>
<details><summary>图17-9　三种典型的数据集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152404.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152404.png';" /></details>


<h5 id="数据联邦"><a href="#数据联邦" class="headerlink" title="数据联邦"></a>数据联邦</h5><p>数据联邦是指不同的应用共同访问一个全局虚拟数据库，通过全局虚拟数据库管理系统为不同的应用提供全局信息服务，实现不同的应用和数据源之间的信息共享和数据交换，其具体实现由客户端应用、全局信息服务和若干个局部数据源三部分组成。</p>
<h5 id="数据复制模式"><a href="#数据复制模式" class="headerlink" title="数据复制模式"></a>数据复制模式</h5><p>在数据复制模式中，通过底层应用数据源之间的一致性复制来实现（访问不同数据库的）不同应用之间的信息共享和互操作，其实现的关键是必须能够提供在两个或多个数据库系统之间实现数据转换和传输的基础结构（以屏蔽不同数据库间数据模型的差异）。</p>
<h5 id="基于接口的数据集成模式"><a href="#基于接口的数据集成模式" class="headerlink" title="基于接口的数据集成模式"></a>基于接口的数据集成模式</h5><p>在基于接口的数据集成模式中，不同的应用系统之间利用适配器（或接口代理）提供的应用编程接口来实现相互调用。应用适配器或接口代理通过其开放或私有接口将业务信息从其所封装的具体应用系统中提取出来，进而实现不同的应用系统之间业务数据的共享与互交换。接口调用的方式可以采用同步调用方法，也可以采用基于消息中间件的异步方法来实现。</p>
<h4 id="应用集成"><a href="#应用集成" class="headerlink" title="应用集成"></a>应用集成</h4><p>应用集成是指两个或多个应用系统根据业务逻辑的需要而进行的功能之间的相互调用和互操作。应用集成需要在数据集成的基础上完成。应用集成在底层的网络集成和数据集成的基础上实现异构应用系统之间语用层次上的互操作。它们共同构成了实现企业集成化运行最顶层会聚集成所需要的，技术层次上的基础支持。</p>
<p>应用集成最初主要采用点对点的紧耦合方式。这种集成方式虽然不需要对应用系统做较大的改动，但用这种方式集成的系统缺乏必要的柔性，不能适应业务系统快速重构的需求。随着应用软件系统设计和实现过程中标准化程度的不断提高，系统的开放性（可配置性、可扩展性）越来越好，组件化的系统实现及松散耦合（它是实现系统柔性的基础）的应用集成方式逐渐成为构建企业业务处理系统的主流。</p>
<p>应用集成模式包括集成适配器、集成信使、集成面板和集成代理4种，每种应用集成模式都是对具有业务功能依赖关系的多个应用之间互操作实现方法的总结。在具体应用中，集成模式可能以某种变形（这是一种扩展集成模式的主要方式）的形式出现，这些变形可能不仅仅只是一种模式的实例化，也可能是一种具有广泛适用性的集成方式。</p>
<h5 id="适配器集成模式"><a href="#适配器集成模式" class="headerlink" title="适配器集成模式"></a>适配器集成模式</h5><p>在EAI技术发展的初期，广泛采用在需要交互的系统之间加入适配器（Adapter）的解决方案来实现企业原有应用系统与新实施系统之间的互操作。在应用系统提供的API的基础上（在应用系统没有提供API的情况下，可以在其数据库表结构已知的条件下直接完成对其数据库的写入与读出），通过适配器完成不同的系统间数据格式及访问方式的转换与映射，进而实现不同的系统之间业务功能及业务数据的集成，如图17-10所示。</p>
<details><summary>图17-10　适配器集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152517.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152517.png';" /></details>

<h5 id="信使集成模式"><a href="#信使集成模式" class="headerlink" title="信使集成模式"></a>信使集成模式</h5><p>随着企业中业务应用系统个数的增多，应用系统间的接口问题变得越来越复杂。为了更灵活地实现应用系统间点对点的集成问题，提出了图17-11所示的基于信使的集成结构。在这种集成结构中，系统之间的通信和数据交换通过信使（消息代理）来实现，每个应用只需要建立与集成信使之间的接口连接，就可实现与所有通过集成信使相联的应用系统间的交互。这种结构大大减少了接口连接数量，同时由于采用了信使（消息代理）作为信息交流的中介，可以将应用之间的交互对通信服务能力的依赖程度降到最低。另外，当某一系统发生改变时、只需要改变信使中相应的部分，从而降低系统维护工作量和系统升级的难度。</p>
<details><summary>图17-11　信使集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152546.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152546.png';" /></details>

<h5 id="面板集成模式"><a href="#面板集成模式" class="headerlink" title="面板集成模式"></a>面板集成模式</h5><p>面板集成模式和面向对象的软件设计方法中的面板模式很相似，它是从应用交互实现的层面来描述客户端应用和服务器端应用集成的一种方法。图17-12给出了面板集成模式框架图。集成面板可以为一对多、多对一、多对多等多种应用提供集成接口，在这种模式中包含有一个或多个客户端应用、一个集成面板、一个或多个服务器端应用。集成面板通过对服务器端应用功能的抽象和简化，为客户端应用访问与调用服务器端应用提供了一种简化的公共接口。集成面板在得到客户端应用服务请求后，将客户端的服务请求转换成服务器端应用能理解的形式，并将该请求提交给服务器端应用。</p>
<details><summary>图17-12　面板集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152613.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152613.png';" /></details>

<h5 id="代理集成模式"><a href="#代理集成模式" class="headerlink" title="代理集成模式"></a>代理集成模式</h5><p>面板集成模式实现了服务器端应用交互逻辑的分离。在代理集成模式中，由于不存在很明显的客户端应用和服务器端应用的划分，它仅需要将待集成的应用间的交互逻辑从应用中分离出来，并对应用间的交互逻辑进行封装，进而由集成代理来引导多个应用之间的交互，如图17-13所示。</p>
<details><summary>图17-13　代理集成模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152642.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152642.png';" /></details>

<h4 id="企业集成"><a href="#企业集成" class="headerlink" title="企业集成"></a>企业集成</h4><p>企业应用软件系统从功能逻辑上可以分为表示、业务逻辑和数据三个层次，其中表示层负责完成系统与用户交互的接口（界面）定义，业务逻辑层主要根据具体业务规则完成相应业务数据的处理，数据层负责存储由业务逻辑层处理或产生的业务数据，它是系统中相对稳定的部分。按照这些逻辑功能层次间是否分离和分离的程度，在软件系统具体实现上可以大致分为如下4类。</p>
<p>（1）单层结构系统。</p>
<p>很多企业遗留应用系统属于这一类，这种应用一般是采用传统的编程方法得到的一个紧密结构应用，三个层次之间没有进行分离，因此某个层次的变化通常需要重新设计与开发其他两个层次的内容。</p>
<p>（2）两层结构系统。</p>
<p>通常是将表示层与业务逻辑层（胖客户）紧密地耦合在一起，或者是将业务逻辑和数据库层紧密地耦合在一起（只将表示层分离出来为瘦客户）。这种结构实现了三个层次间部分的分离，这样在应用的某个部分发生变化时仅需要修改与其紧密耦合的部分，而无需重新开发所有的代码。如将表示层分离出来，可以使同样的业务功能采用不同的图形化用户接口及显示器屏幕模式，改变客户端接口（如增加Web界面）并不需要修改业务的逻辑功能来实现。</p>
<p>（3）三层结构系统。</p>
<p>这是当前比较流行的系统实现方式。它将业务应用系统的表示、业务逻辑和数据三个层次分成独立的模块实现。这样，应用系统的各层可以并行开发，各层也可以选择各自最适合的开发环境和编程语言。这种系统结构不但提高了系统的可维护性，也有利于系统的安全管理。</p>
<p>（4）n层结构系统。</p>
<p>将三层系统结构进一步细化（主要是将业务逻辑及数据库层分成更多、粒度更小的分布式业务对象来分别实现），其目的是提高系统不同业务功能模块的独立性。在提高了系统的可配置能力的同时，可以使系统具有最好的柔性及可扩展能力。</p>
<p>支持企业间应用集成和交互的集成平台在系统结构上通常都采用多层的结构，其目的是在最大程度上提高系统的柔性。在集成平台的具体设计开发中，还需要按照功能的通用性程度（通用功能、面向特定领域的功能、专业化功能）对系统实现模块进行分层（分成不同的中间件）。</p>
<p>根据企业集成平台功能的支持范围，可以将其划分为侧重于支持企业内部集成化运行的EAI和侧重于支持企业间业务集成的B2B。一般来说，EAI是B2B的基础，下面主要讨论EA1的实现模式。</p>
<p>从企业集成运行的实现策略上看，EAI主要有如下三种实现模式。</p>
<p>（1）前端集成模式。</p>
<p>所谓前端集成模式，是指EAI侧重于业务应用系统表示层的集成，它主要通过单一的用户入口实现跨多个应用事务的运作。这种方式适合于用户启动的业务过程会产生多个跨应用的事务，而且这些事务都需要实时响应的情况（主要指B2C的环境）。另外，采用前端集成模式还可以实现对已经运行的核心业务应用系统增加功能或特征的目的。</p>
<p>（2）后端集成模式。</p>
<p>后端集成模式主要侧重于应用系统数据层面的集成。它通过专门的数据维护及转换工具实现不同应用或数据源之间的信息交换，维护企业整体业务数据的完整性和一致性。</p>
<p>后端集成模式就像一个方便多个应用系统之间数据自动交互的数据管道，后端集成模式的实施同样需要得到数据集成及应用集成的支持。后端集成模式实现起来相对比较简单，因为EAI服务器不需要跨应用的事务维护，而只需要维护一些相对简单的业务规则。基于EAI服务器提供的存储——转发机制可以方便地实现对合作伙伴企业之间大量业务数据交换（主要指B2B集成）的支持。</p>
<p>（3）混合集成模式。</p>
<p>混合集成模式是前端集成模式和后端集成模式的组合。客户通过基于Web浏览器的客户端（瘦客户）实现对业务应用或EAI服务器的访问，服务请求可以由前端应用系统执行，也可以通过EAI服务器将服务请求路由到后端，由后端的业务应用来执行。这种模式几乎具有前端集成模式和后端集成模式的所有特征，主要应用于既需要响应大量服务请求、又需要维护多个数据源的完整性和一致性的情况。</p>
<h3 id="企业集成的关键应用技术"><a href="#企业集成的关键应用技术" class="headerlink" title="企业集成的关键应用技术"></a>企业集成的关键应用技术</h3><h4 id="数据交换格式"><a href="#数据交换格式" class="headerlink" title="数据交换格式"></a>数据交换格式</h4><p>企业业务数据可以分为结构化数据（表单）和非结构化数据（文档），它们一般存储在不同的数据库或文档管理系统中。不同的应用系统、数据库所处理的文档和数据格式有很大差别，建立各个应用都可以识别和访问的通用数据模型及表示规范，是实现不同的应用系统之间交互和互操作的最基本方法。企业数据集成中常用的几种数据交换格式如下。</p>
<h5 id="EDI"><a href="#EDI" class="headerlink" title="EDI"></a>EDI</h5><p>EDI（Electronic Data Interchange，电子数据交换）是一种利用计算机进行商务处理的方法，它将贸易、运输、保险、银行和海关等行业的信息，用一种国际公认的标准格式，通过计算机通信网络，供有关部门、公司与企业之间进行数据交换与处理，并完成以贸易为中心的全部业务过程。</p>
<p>EDI格式处理的目的是将在功效上与纸介质文件等同的电子表单用统一的（或标准的）格式进行表示，以保证各个独立开发的计算机应用间能够实现表单数据共享与集成。用于描述电子表单格式的标准称为EDI格式标准或EDI标准，目前广泛使用的EDI格式标准主要有UN/EDIFACT和ANSIX12，分别由联合国欧洲经济委员会（The United Nations Economic Commission for Europe, UN/ECE）和美国国家标准化协会（American National Standard Institute, ANSI）制定。</p>
<p>国际标准化组织采用UN/EDIFACT作为国际标准（IS09735）。按照UN/EDIFACT标准，贸易伙伴之间一次交换的内容称为一个交换，交换由交换头/尾、功能组头/尾、报文头/尾、数据段（或段组）和数据元（简单数据元和复合数据元）等组成。为简化起见，数据段（或段组）、数据元等在本文中都被称为报文项。图17-14给出了EDIFACT报文的数据结构。</p>
<details><summary>图17-14　EDIFACT报文的数据结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152807.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152807.png';" /></details>


<h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>XML是国际组织W3C制定的一个面向各类信息的数据存储工具和可配置载体的开放式标准。提出XML的目的是为了更好地适应Web应用的需求，解决HTML在表达能力、可扩展性和交互性等方面的缺陷。XML是通过对SGML标准进行简化而形成的元标记语言，具有语法清晰简单和结构无歧义等优点。它利用一套定义标记的规则将文件的内容和外观进行分离，实现了XML文档的可延伸性及自我描述特性，从而使各种业务信息可以在全球信息网或企业间的应用系统中传递、处理及储存。这里需要指出的是，虽然XML称为可扩展标记语言，但它本身并不是一种标记语言，而是一种创建、设计和使用标记语言的根规则集，是一种创建标记语言（如HTML）的元语言。图17-15给出了XML相关标准的层次图。</p>
<h5 id="STEP"><a href="#STEP" class="headerlink" title="STEP"></a>STEP</h5><p>STEP标准（Standard for the Exchange of Product Model Data）是一个描述如何表达和交换数字化产品信息的ISO标准（ISO10303），其目的是提供一种不依赖于具体系统的中性模型和机制，并将其用来描述整个生命周期内的产品数据。</p>
<p>图17-16给出了STEP标准的结构，其核心由描述产品数据的形式化语言规范（描述方法）、STEP实现方法、集成资源和一致性测试标准4部分组成，而围绕该核心定义的各种应用协议及抽象测试套件构成了对STEP的外层支持。描述方法用于集成资源的定义，由集成资源模型产生应用协议，应用协议和实现方法相结合产生一种STEP实现，一致性测试则用于测试STEP实现是否与STEP标准相一致。</p>
<details><summary>图17-15　XML标准体系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152849.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152849.png';" /></details>

<details><summary>图17-16　SETP标准的结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152903.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152903.png';" /></details>

<h5 id="PDML"><a href="#PDML" class="headerlink" title="PDML"></a>PDML</h5><p>PDML的技术目标是提供一种灵活的方法，使得不同应用软件系统中的产品数据能够进行交换。它是在STEP和XML基础上实现不同系统间产品数据交换和集成的一种新模式。</p>
<p>PDML中主要应用了STEP的集成资源和EXPRESS数据规范语言两个部分。在PDML中，与特定领域词汇表（或数据字典）相应的组件被称为应用事务集（Application Service Set，ATS），与跨多个应用领域的通用词汇表相应的组件被称为集成方案，集成方案的设计基于STEP的集成资源。</p>
<p>PDML使用XML来描述所有业务应用软件系统中的产品数据，并通过提供一系列的标准DTD来进行产品数据的导入和导出。由于EXPRESS在（产品相关的）语义和约束的表达能力方面要比XML的DTD优越很多，因此EXPRESS被选择作为定义PDML模式的规范。为了充分利用EXPRESS语言在数据建模和XML语言在数据交换方面的优点，PDML定义了一个从EXPRESS模式到XMLDTD的转换机制。</p>
<p>PDML不是单一的产品数据规范，而是一个用来发布和使用集成产品数据的相关标准和工具的集合。PDML由7个应用事务集、一个集成大纲、应用事务集和集成大纲间的映射规范、PDML工具集4部分组成。图17-17给出了应用事务集、集成大纲和映射规范之间的关系。</p>
<details><summary>图17-17　PDML各组成部分之间的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904152930.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904152930.png';" /></details>

<h4 id="分布式应用集成基础框架"><a href="#分布式应用集成基础框架" class="headerlink" title="分布式应用集成基础框架"></a>分布式应用集成基础框架</h4><p>随着计算机网络应用的不断深入和普及，大规模的计算机网络将不断增加，在这种计算机网络中，不仅硬件设备型号、种类、规模相异，而且操作系统平台、程序设计环境及应用也各不相同，这就是大规模计算机网络的重要特征——异构性。人们迫切希望通过在这种计算机网络上建立一套体系结构和一组规范来保证分布式系统的互操作性、可迁移性和可重用性，进而实现分布式环境下的信息共享与应用集成。因此，在面向对象技术和分布式计算基础上产生的分布式对象计算（Distributed Object Computing，DOC），成为20世纪90年代计算机技术发展的一个热点。而在当今众多的分布式对象技术中，比较有影响的分布式软件对象（组件）标准有下面三种。</p>
<h5 id="CORBA"><a href="#CORBA" class="headerlink" title="CORBA"></a>CORBA</h5><p>CORBA（Common Object Request Broker Architecture，公共对象请求代理体系结构）是对象管理组织（OMG）为解决分布式处理环境中硬件和软件系统的互连而提出的一种标准的面向对象应用程序体系规范。</p>
<p>OMG组织给出了分布计算的参考模型，称为对象管理参考模型（Object Management Architecture，OMA）。OMA模型中把软件作为对象，并通过对象请求代理与其他对象进行通信。其体系结构如图17-18所示。</p>
<details><summary>图17-18　对象管理参考模型的体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153004.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153004.png';" /></details>

<p>OMA体系结构的核心是对象请求代理（Object Request Broker，ORB），CORBA规范对ORB的组成和功能进行了定义，它支持对象服务、通用设施、领域接口和应用接口之间的交互和通信。</p>
<p>ORB是CORBA的对象互操作中介，作为应用对象间服务请求响应的中间代理，接收对象请求并把请求转给相应的对象，服务完成后又把执行结果或异常情况返回给请求者。ORB可以使对象以语言、位置和平台独立的方式发出请求和提供服务，相互协同工作，从而建立真正的分布处理，是实现分布对象互操作的核心。COBAR ORB的组成结构如图17-19所示。</p>
<details><summary>图17-19　CORBAORB结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153020.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153020.png';" /></details>

<h5 id="COM＋"><a href="#COM＋" class="headerlink" title="COM＋"></a>COM＋</h5><p>COM+是Microsoft公司基于Windows平台的一个分布式企业应用模型，它与Windows操作系统紧密结合，是沿着DDE-OLE-OLE2-COM-DOOM-COM+的路线发展而来。目前，COM、DCOM和COM+应用比较广泛。</p>
<p>COM是一个开放的组件标准，有很强的扩充和扩展能力。COM组件标准的基础是COM核心，它规定了组件对象与客户通过二进制接口标准进行交互的原则。COM主要由COM接口、COM对象、COM服务器、类工厂和类型库等组成。其中，COM接口是和COM对象之间互相调用相关的一组语义规范，每个接口有一个唯一标识（UUID）；COM对象则为一个或多个COM接口提供具体的服务（功能实现），对COM对象的调用是通过一个指向其接口的指针实现的；COM服务器提供COM运行的环境，完成COM对象的管理，并向COM客户提供服务；类工厂则是用于创建、注册COM对象的特殊对象，它为COM对象的实例化提供一种标准机制；类型库是一个二进制资源文件，包含COM服务器中对象与接口的类型信息。在COM系统中，客户对组件对象功能的调用接口一般采用COM IDL来描述。COM定义了两类服务器，即进程内服务器和进程外服务器。进程内服务器即本地机上的DLL，进程外服务器分为两类：一是本地机上的EXE可执行程序，二是远程机上的DLL或EXE程序。服务器内部包括组件接口的实现和类工厂，类工厂生产组件对象，将对象的接口指针返回给客户。组件服务器的定位由COM库完成并返回对象指针。COM对象位置的透明性处理由COM的服务控制机制保证。进程外的对象必须先调用服务控制机制提供的代理，代理生成服务对象的远程过程调用（Remote Process Call，RPC）。基于COM的系统调用原理如图17-20所示。</p>
<p>另外，COM组件标准还包括结构化存储、统一数据传输和智能命名等。其中结构化存储定义了复合文档的存储格式以及创建文档的接口，统一数据传输约定了组件之间数据交换的标准接口，智能命名则给予对象一个系统可识别的唯一标识。COM组件标准为COM对象之间的相互操作奠定了基础。</p>
<details><summary>图17-20　COM调用原理</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153058.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153058.png';" /></details>

<h5 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h5><p>J2EE（Java 2 Platform Enterprise Edition，Java 2平台企业版）是由Sun公司制定的基于Java技术的分布式组件计算平台规范。</p>
<p>Sun设计J2EE的初衷是为了解决两层模式的弊端，即系统难于升级或改进、可扩展性差，而且经常基于某种专有的协议。它使得重用业务逻辑和界面逻辑非常困难。J2EE将两层化系统模型中的不同层面切分成许多层，从而形成了一个多层的端到端的分布式应用系统架构。在图17-21给出的基于J2EE标准的典型运行结构中，主要包含客户层、Web层、业务逻辑层和数据层（包含遗留系统）4个层次。</p>
<details><summary>图17-21　J2EE运行结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153127.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153127.png';" /></details>

<p>J2EE很好地融合了Internet技术，有利于企业建立基于Web、具有n层结构的分布式应用，同时它也为应用系统集成提供了良好的解决办法。J2EE的应用集成架构如图17-22所示。J2EE的基础是核心Java平台或Java2平台的标准版，J2EE将J2SE集成到自己的体系结构中，不仅巩固了标准版中的许多优点，同时也使J2EE供应商能够独立于操作系统与硬件平台来实现应用程序产品。各种组件可以通过J2EE配置工具将其部署到相应的J2EE容器中，客户端对各种组件的访问及各种组件之间的调用都通过容器及服务器来完成。</p>
<details><summary>图17-22　基于J2EE的应用集成架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153143.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153143.png';" /></details>

<h5 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h5><p>Web Service（Web服务）是指服务提供者将应用作为服务部署在Web上，通过使用Web服务描述语言来描述特定Web服务提供的功能。服务请求者在需要一种Web服务时，可以通过Internet，在Web服务的注册机构中查找分布在Web站点上的Web服务，并自动实现与服务的绑定，完成数据交换，在这个过程中无须人工干预。Web服务的工作原理如图17-23所示。由于Web服务的系统架构和实现技术基本上基于已有的技术，因此，Web服务可以看成是现有应用面向Internet的一个延伸。</p>
<p>实现Web服务需要相关技术标准的支持，目前支持Web服务的技术标准主要有：用于进行数据交换和表达的元语言标准XML，XML用来在Web服务中表示服务请求和应答的内容； $\color{red}{\text{UDDI}}$ （Universal Description，Discovery &amp; Integration），UDDI用于Web $\color{green}{\text{服务注册和服务查找}}$ ；WSDL， $\color{red}{\text{WSDL}}$ 用于 $\color{green}{\text{描述Web服务的接口和操作功能}}$ ； $\color{red}{\text{SOAP}}$ （Simple Object Access Protocol），SOAP为 $\color{green}{\text{建立Web服务和服务请求之间的通信提供支持}}$ 。图17-24给出了支持Web服务实现的体系结构。</p>
<details><summary>图17-23　Web服务的发布、请求和绑定过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153210.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153210.png';" /></details>

<details><summary>图17-24　Web服务的体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153221.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153221.png';" /></details>

<h3 id="面向整体解决方案的企业模型"><a href="#面向整体解决方案的企业模型" class="headerlink" title="面向整体解决方案的企业模型"></a>面向整体解决方案的企业模型</h3><h4 id="企业模型在整体解决方案中的作用"><a href="#企业模型在整体解决方案中的作用" class="headerlink" title="企业模型在整体解决方案中的作用"></a>企业模型在整体解决方案中的作用</h4><p>企业模型是人们了解企业并经过抽象得到的对于企业某个或者某些方面的描述，它是实施企业信息化工程与实现企业集成的基础。企业建模在企业信息化整体解决方案中发挥的作用主要表现在以下几个方面。</p>
<p>（1）企业模型可以为信息化整体解决方案提供对企业公共一致的、规范的表达和描述。</p>
<p>模型为信息化工作中的所有人员提供一个公共的企业表达，所有的规划和决策人员可以站在同一个理解层面上讨论信息化的开展和实施，同时也为信息系统或部件的设计提供一个公共的模型规范，避免在每个信息系统设计时都直接去抽取需要的数据，减少由于这种工作方式带来的不同信息系统反映的企业数据的不一致问题。</p>
<p>（2）建模和基于模型的分析是企业信息化工作的入手点和建立有效的实施途径的基础。</p>
<p>实施企业信息化，首先必须要明确信息化的目的和范围。信息化应该从企业中最迫切需要改革、最影响和制约企业业务目标实现的环节开始，因此企业信息化实施的第一步应该是企业诊断。企业建模是有效并准确地进行企业诊断和分析的必要基础，通过模型来总结概括企业的现状，使信息化工作建立在一个具体、准确的需求的基础上。通过建模过程以及基于模型的诊断来辅助发现企业生产经营中需要解决的企业瓶颈问题和实现企业战略目标的业务需求，指明信息化需要解决的企业实际问题，为企业决策提供科学的支持。</p>
<p>（3）建模可以对信息系统规划方案进行预评价。</p>
<p>信息化工程是一项风险工程，会牵涉到企业的过程、组织、人员和资源等方面。在企业诊断之后，要进行企业信息化规划，对信息系统方案进行选择和论证。企业建模可以用于建立企业的改进模型，并基于对改进模型的分析来评价改进的效果以及对整个企业的影响。信息化过程也是企业的一种改进过程，企业建模可以描述按照某种规划方案布置了信息系统后的企业业务运行模型（模拟企业未来业务运作的模型），通过对该模型的仿真分析，并与企业现状模型进行比较，评价这个信息系统规划方案的效果以及需要付出的代价。通过对多种不同方案的比较分析，可以选择一种相对优异的信息系统规划方案。</p>
<p>（4）基于模型的工作流执行可以导航和监控各信息系统之间及信息系统与外界的交互。</p>
<p>面向工作流执行的企业模型可以准确地描述贯穿企业所有信息系统的业务过程，以及过程执行中传递的信息，并且可以定义信息系统交互过程中出现的异常情况的处理过程。在信息化工程进入实施阶段后，企业模型可以对集成的信息系统运行的导航和监控起到一定的支持作用。</p>
<p>由以上各方面看出，可以把整体解决方案的求解问题转化为更加具体的，基于企业模型的整体解决方案的求解。这样，在企业信息化整体解决方案的每个部分中都会包含企业模型、企业建模、模型管理、模型操作、模型标准、模型评价、模型转换和参考模型等相应的内容及工具。</p>
<h4 id="整体解决方案中的企业模型重"><a href="#整体解决方案中的企业模型重" class="headerlink" title="整体解决方案中的企业模型重"></a>整体解决方案中的企业模型重</h4><p>通过企业模型重用可以提高企业建模的效率与效果，进而更好地支持企业信息化整体解决方案的实施。不同的企业虽然在生产经营诸多方面都有其特殊性，但是它们都是企业系统的实例，都具有企业最本质的行为和特征，如为了完成企业的目标，都要进行一系列活动（或过程）。可以将构成企业的所有要素（无论是物质实体还是抽象过程）分成三类：一类是最通用的，适用于任何企业；第二类是在一定范围内通用，例如在一个行业内；第三类是某个企业专有的。对应这种分类，集成化企业建模体系框架中定义了三个实现企业模型重用的通用性层次：通用层、部分通用层和专用层。</p>
<p>（1）通用层：提供了整个集成化企业建模体系结构的基本构成成分，既包括不同的建模阶段、不同的建模视图的基本模型构件，也包括与建模活动相关的约束、规则、术语、服务和协议等。该层次的内容具有最强的通用性，能够广泛地适用于各类企业。</p>
<p>（2）部分通用层：在通用模型层的基础上，以生产经营方式类似的企业为背景，通过对它们典型业务流程和企业行为特征的分析和提炼，形成一组适合于某一行业的部分通用模型（模板），即行业参考模型。每种行业的部分通用模型拥有该行业中大部分企业共有的典型结构参考模型，它可以适用于这一个行业的所有或大部分企业。</p>
<p>（3）专用层：根据企业实际情况和需求，选择一定的参考模型并进行适当改动，形成适合于一个特定企业的专有模型，该模型仅能够用于所描述的企业。</p>
<p>通用性层次的划分使企业建模活动能够从简单到复杂、从抽象到具体、从一般到特殊逐步进行，形成一个层次化过程。利用模型构件可以组成参考模型，参考模型又可以派生出具体的专用模型，对专用模型再进行抽象后又可以形成新的参考模型。</p>
<p>企业通用模型构件及参考模型是在大量工程应用案例的基础上，对诸多企业的共同特征进行抽取而得到的。模型构件及参考模型库的建立和维护可以为企业信息化工程不同阶段的工作提供有实际应用价值的模型框架基础，并有助于进行企业诊断和模型优化，为提高企业建模质量、缩短企业建模周期、减少企业建模成本提供直接的支持。</p>
<p>企业模型可以采用从零开始的方法来建立，但是这种方法存在建模周期长和建模质量低等问题。因此，基于参考模型建立企业具体的专用模型是较好的方法。其实现过程包括两个阶段：参考模型的选择和参考模型的实例化。其中参考模型的选择具体包括以下几个步骤。</p>
<p>（1）确定企业建模的目标和基本需求。</p>
<p>（2）划定企业建模的范围。企业建模可以覆盖整个企业，也可以覆盖企业的某一部分。</p>
<p>（3）提出候选参考模型。参考模型的选择要依据企业规模相关性、行业相关性、产品相关性、生产经营模式相关性和领域相关性等准则。</p>
<p>（4）确定最终使用的参考模型。在候选参考模型中，经过进一步的分析和评价，最终确定一个或一组参考模型。</p>
<p>参考模型的实例化是在参考模型的基础上完成的，实例化过程在具体操作中可以采用的方法如下。</p>
<p>（1）继承：将参考模型中的模型构件或组件直接继承为企业应用模型的一部分。</p>
<p>（2）剪裁：对选取的参考模型，根据企业建模的目的和范围，进行适当的剪裁，作为企业应用模型的一部分。</p>
<p>（3）细化：在参考模型的基础上，根据企业建模的目的和需求，对模型中的某些部分作进一步的分解、细化和完善。</p>
<p>（4）扩充：按照参考模型的结构，对参考模型没有覆盖的企业建模范围加以扩充，形成企业应用模型。</p>
<p>（5）修改：对参考模型中的某些部分按照企业的实际需要进行修改，或者对参考模型中某些组件进行重组。</p>
<p>在具体的建模过程中，通用层、部分通用层和专用层三个层次又具有相互迭代的关系。当为某个行业里多个具体企业建立起企业模型后，通过抽取模型中共有的行业特性，可以总结出一个适合于这个行业的参考模型。当行业参考模型的内容非常丰富时，可以从中抽取出一些通用的建模构件。反过来，当拥有了足够多且好用的建模构件后，可以通过这些建模构件来搭建新的参考模型。当拥有了足够完善的参考模型后，可以通过实例化参考模型来快速建立起一个具体的企业模型。图17-25给出了这一迭代过程的图示化表示。</p>
<details><summary>图17-25　企业模型中的三个层次间的关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153315.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153315.png';" /></details>

<h4 id="整体解决方案中企业模型演化"><a href="#整体解决方案中企业模型演化" class="headerlink" title="整体解决方案中企业模型演化"></a>整体解决方案中企业模型演化</h4><p>企业信息化整体解决方案实施的不同阶段在一定程度上也反映了企业模型及建模过程的阶段性，在不同的阶段，对模型的广度、深度和粒度要求都是不同的，各阶段需要采用哪些视图、各视图采用什么样的描述方法也都会有所不同。所以，在企业信息化整体解决方案的实施中，企业模型处于不断演化的状态之中。信息系统实施的生命周期可以分成需求分析阶段、系统设计阶段、系统实施阶段和运行维护阶段。下面分别介绍这4个阶段对企业模型的要求和在建模过程中需要完成的工作。</p>
<h5 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h5><p>需求分析阶段主要完成企业业务策略、信息技术/系统策略的确定与分析，并在完成业务调查及建立企业现状模型的基础上，结合用户需求，发现企业现有的优缺点，并针对缺点和瓶颈提出优化需求以及优化目标。在这一阶段通过对用户需求的抽象形成需求分析模型，以作为下一个阶段的输入。所建立的需求分析模型应该包含有较高层次上的企业业务流程、资源分配、组织结构和产品结构等信息。最后还需要确定系统的总体目标和评价标准。</p>
<h5 id="系统设计阶段"><a href="#系统设计阶段" class="headerlink" title="系统设计阶段"></a>系统设计阶段</h5><p>在确定了信息系统的需求之后，系统设计阶段则主要完成企业目标模型的确定和信息系统集成框架的求解，从未来的信息系统相关的业务模型中抽取出功能模型和信息模型，用它们来设计和构造信息系统。功能模型描述系统功能的划分和逐级分解，每一个功能单元对应信息系统的一个功能模块，功能模型是对业务过程模型中过程和活动所实现功能的归纳。信息模型描述信息系统需要使用到的数据结构和数据之间的关系，为建立信息系统数据库进行概念建模和物理建模。信息模型中的内容也来源于需求分析阶段建立的业务核心模型。</p>
<h5 id="系统实施阶段"><a href="#系统实施阶段" class="headerlink" title="系统实施阶段"></a>系统实施阶段</h5><p>系统实施阶段主要完成整体解决方案指导下的信息系统构建，将企业集成框架物化为实现企业集成化运作的协同信息系统。这一阶段实现了企业模型从设计模型向可执行模型的转化。在设计模型的基础上，通过定义具体的操作者、执行器、资源实体、组织单元和应用软件等，形成系统的实施模型。在给定的软硬件和网络环境下，将所得到的实施模型按照系统规划的实施步骤逐步投入运行。具体的工作包括将经过优化后得到的过程模型进行实例化，为业务流程中需要使用的人员、资源和产品指派实际的对象，建立企业信息的物理数据库供实际业务系统使用。</p>
<h5 id="运行维护阶段"><a href="#运行维护阶段" class="headerlink" title="运行维护阶段"></a>运行维护阶段</h5><p>运行维护阶段则主要完成对投入运行的企业集成化系统的运行维护，通过文档管理、版本控制等方法实现对运行系统的有效管理和监控，并通过集成需求管理软件工具来对运行过程中企业不断提出的新的需求进行记录和管理，所积累的需求和文档是下一个生命周期的输入。</p>
<p>企业的优化是一个持续的过程，一个系统实施后在运行维护阶段搜集的问题和需求又会启动一个新的生命周期。所以整个企业模型演化构成一个闭环，每个阶段的结果（输出）是下一个阶段的输入，上一个生命周期的运行维护阶段得到的结果（输出）是下一个生命周期需求分析阶段的输入。这个不断循环的生命周期以螺旋式上升的形式实现企业相关状态及行为的改进与扩展。企业模型演化的生命周期如图17-26所示。</p>
<details><summary>图17-26　企业模型演化的生命周期</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153422.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153422.png';" /></details>

<h4 id="模型驱动的企业集成系统演化"><a href="#模型驱动的企业集成系统演化" class="headerlink" title="模型驱动的企业集成系统演化"></a>模型驱动的企业集成系统演化</h4><p>采用企业信息化整体解决方案的目标是通过系统化的理论与方法来指导企业信息系统的规划与实施，构建一个既能够满足当前企业需求、又具有可持续发展能力的集成化业务计算环境。企业可持续发展必然要求支持企业各种资源（包括数据、应用、业务流程、服务及人员等）协同运作的企业集成系统具有可逐步发展和演化的特性。</p>
<details><summary>图17-27　基于模型的企业集成系统演化模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904153447.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904153447.png';" /></details>

<p>图17-27给出了基于模型的企业集成系统演化模式。首先，经过集成平台实施形成了（根据企业业务模型确定的）企业信息系统集成框架，以及在集成平台支持下的满足企业当前需求的协同信息系统（可能只实现了集成框架下的部分功能）。由于这种实施是根据企业当前的市场策略、业务过程规划和当前的信息技术现状进行的，它只能够在当前的企业和市场状态下，通过信息技术支持企业实现其竞争优势。在这样的集成平台支持下的业务运作，是和企业的业务逻辑（反映市场环境）与业务功能实现技术（反映技术现状）密切相关的。随着市场的变化、技术的进步，企业的核心能力及竞争策略可能要做相应的调整，而这种根据市场、技术的变化调整业务流程或资源配置结构的需求必然要在（在各种信息系统支持下的）业务协同运作过程中得以体现。随着这种需求的不断增加，企业的管理层需要对企业竞争战略或业务流程作必要的调整或改进，从而将这种调整业务模型的需求反馈到（转变为）描述企业业务特征的企业集成化模型中，进而驱动了企业目标模型的演化，企业目标模型的演化又推动了基于模型的企业集成框架和支持业务协同运作的企业集成平台的演化（业务逻辑模型修改或升级信息系统），这个不断循环的过程导致企业信息化工程以螺旋的方式不断上升。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch16-%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch16-%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch16-层次式架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:57:09" itemprop="dateCreated datePublished" datetime="2021-07-19T12:57:09+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 18:56:43" itemprop="dateModified" datetime="2021-09-04T18:56:43+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="层次式架构设计"><a href="#层次式架构设计" class="headerlink" title="层次式架构设计"></a>层次式架构设计</h2><h3 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h3><p>1968年，在Garmish召开的国际软件工程会议上，人们迫切地感到了软件危机给计算机软件产业的发展带来的巨大阻力。软件危机的两个比较大的问题是：软件的规模越来越大，软件复杂度越来越高。伴随着这两个问题的日益突出，整个软件系统结构的设计与规格说明便显得比算法选择和计算问题的数据结构更为重要。因此，代码级别的软件复用已经远远不能满足大型软件开发的需求，由此便引入了“软件体系结构”这一概念。</p>
<p>软件体系结构可定义为：软件体系结构为软件系统提供了结构、行为和属性的高级抽象，由构成系统的元素描述、这些元素的相互作用、指导元素集成的模式以及这些模式的约束组成。软件体系结构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些设计决策的基本原理，是构建于软件系统之上的系统级复用。</p>
<p>软件体系结构贯穿于软件研发的整个生命周期内，具有重要的影响。这主要从以下三个方面来进行考察。</p>
<p>（1）利益相关人员之间的交流。软件体系结构是一种常见的系统抽象，代码级别的系统抽象仅仅可以成为程序员的交流工具，而包括程序员在内的绝大多数系统的利益相关人员都借助软件体系结构来作为相互沟通的基础。</p>
<p>（2）系统设计的前期决策。软件体系结构是我们所开发的软件系统最早期设计决策的体现，而这些早期决策对软件系统的后续开发、部署和维护具有相当重要的影响。这也是能够对系统进行分析的最早时间点。</p>
<p>（3）可传递的系统级抽象。软件体系结构是关于系统构造以及系统各个元素工作机制的相对较小、却又能够突出反映问题的模型。由于软件系统具有的一些共通特性，这种模型可以在多个系统之间传递，特别是可以应用到具有相似质量属性和功能需求的系统中，并能够促进大规模软件的系统级复用。</p>
<p>分层设计是一种最常见的架构设计方法，能有效地使设计简化，使设计的系统机构清晰，便于提高复用能力和产品维护能力。</p>
<h3 id="表现层框架设计"><a href="#表现层框架设计" class="headerlink" title="表现层框架设计"></a>表现层框架设计</h3><h4 id="使用MVC模式设计表现层"><a href="#使用MVC模式设计表现层" class="headerlink" title="使用MVC模式设计表现层"></a>使用MVC模式设计表现层</h4><p>MVC是一种目前广泛流行的软件设计模式。近年来，随着J2EE（Java 2Enterprise Edition）的成熟，MVC成为了J2EE平台上推荐的一种设计模式。MVC强制性地把一个应用的输入、处理、输出流程按照视图、控制、模型的方式进行分离，形成了控制器、模型、视图三个核心模块。</p>
<p>（1）控制器（Controller）：接受用户的输入并调用模型和视图去完成用户的需求。该部分是用户界面与Model的接口。一方面它解释来自于视图的输入，将其解释成为系统能够理解的对象，同时它也识别用户动作，并将其解释为对模型特定方法的调用；另一方面，它处理来自于模型的事件和模型逻辑执行的结果，调用适当的视图为用户提供反馈。</p>
<p>（2）模型（Model）：应用程序的主体部分。模型表示业务数据和业务逻辑。一个模型能为多个视图提供数据。由于同一个模型可以被多个视图重用，所以提高了应用的可重用性。</p>
<p>（3）视图（View）：用户看到并与之交互的界面。视图向用户显示相关的数据，并能接收用户输入的数据，但是它并不进行任何实际的业务处理。视图可以向模型查询业务状态，但不能改变模型。视图还能接受模型发出的数据更新事件，从而对用户界面进行同步更新。</p>
<p>三者的协作关系如图16-1所示。</p>
<details><summary>图16-1　MVC设计模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142745.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142745.png';" /></details>


<p>从图16-1中可以看到，首先，控制器接收用户的请求，并决定应该调用哪个模型来处理；然后，模型根据用户请求进行相应的业务逻辑处理，并返回数据；最后，控制器调用相应的视图来格式化模型返回的数据，并通过视图呈现给用户。</p>
<p>使用MVC模式来设计表现层，可以有以下的优点。</p>
<p>1）允许多种用户界面的扩展。在MVC模式中，视图与模型没有必然的联系，都是通过控制器发生关系，这样如果要增加新类型的用户界面，只需要改动相应的视图和控制器即可，而模型则无需发生改动。</p>
<p>（2）易于维护。控制器和视图可以随着模型的扩展而进行相应的扩展，只要保持一种公共的接口，控制器和视图的旧版本也可以继续使用。</p>
<p>（3）功能强大的用户界面。用户界面与模型方法调用组合起来，使程序的使用更清晰，可将友好的界面发布给用户。</p>
<p>MVC是构建应用框架的一个较好的设计模式，可以将业务处理与显示分离，将应用分为控制器、模型和视图，增加了应用的可拓展性、强壮性及灵活性。基于MVC的优点，目前比较先进的Web应用框架都是基于MVC设计模式的。</p>
<h4 id="使用XML设计表现层，统一Web-Form与Windows-Form的外观"><a href="#使用XML设计表现层，统一Web-Form与Windows-Form的外观" class="headerlink" title="使用XML设计表现层，统一Web Form与Windows Form的外观"></a>使用XML设计表现层，统一Web Form与Windows Form的外观</h4><p>XML（可扩展标记语言）与HTML类似，是一种标记语言。与主要用于控制数据的显示和外观的HTML标记不同，XML标记用于定义数据本身的结构和数据类型。XML已被公认为是优秀的数据描述语言，并且成为了业内广泛采用的数据描述标准。</p>
<p>由于XML的设计目标是描述数据并集中于数据的内容，所以虽然XML和HTML类似，但是业内很少采用XML作为表现层技术，表现层技术仍然是HTML唱主角。但是，由于Web应用程序对特定浏览器的局限以及性能问题，基于窗体表现形式的胖客户端应用程序又开始有了卷土重来的趋势。这两种应用程序各有优势，在未来很长一段时间这两种技术架构都会并存。因此，许多开发厂商在开发新产品时提出了既要支持胖客户端的表现形式，又要支持Web的表现形式。于是，有人提出将GUI用一个标准的形式描述，对于不同的表现形式，提供特定形式的转换器，根据GUI的描述转换成相应的表现形式。这就要求描述语言有非常好的通用性和扩展性，XML恰恰是这种描述语言理想的载体。</p>
<p>对于大多数应用系统，GUI主要是由GUI控件组成。控件可以看成是一个数据对象，其包含位置信息、类型和绑定的事件等。这些信息在XML中都可以作为数据结点保存下来，每一个控件都可以被描述成一个XML结点，而控件的那些相关属性都可以描述成这个XML结点的Attribute。由于XML本身就是一种树型结构描述语言，所以可以很好地支持控件之间的层次结构。同时，XML标记由架构或文档的作者定义，并且是无限制的，所以架构开发人员可以随意约定控件的属性，例如可以约定type=”button”是一个按钮，type=”panel”是一个控件容器，type=”Constraint”是位置等。这样，整个GUI就可以完整而且简单地通过XML来描述。例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142823.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142823.png';" /></details>

<p>这么一段XML很清晰地表示一个控件容器位置是（16,22,78,200），包含了一个不可视按钮。用上述的XML形式将GUI按照数据描述的形式保存下来代替原先特有的表现形式所需要的GUI描述载体。然后，对于特定的表现技术，实现不同的解析器解析XML配置文件。根据XML中的标签，按照特有的表现技术实例化的GUI控件实例对象。例如，解析器遇到button，JFC解析器会给予JLabel对象，XSLT解析器会给予<code>&lt;button id=… &gt;</code>这样一个HTML字符串，再调用特定表现技术的API将实例化出来的组件对象添加到GUI上显示。</p>
<p>从设计模式的角度来说，整个XML表现层解析的机制是一种策略模式。在调用显示GUI时，不是直接的调用特定的表现技术的API，而是装载GUI对应的XML配置文件，然后根据特定的表现技术的解析器解析XML，得到GUI视图实例对象。这样，对于GUI开发人员来说，GUI视图只需要维护一套XML文件即可。</p>
<h4 id="表现层中UIP设计思想"><a href="#表现层中UIP设计思想" class="headerlink" title="表现层中UIP设计思想"></a>表现层中UIP设计思想</h4><p>应用程序通常要用代码来管理用户界面，例如一个窗体可以决定下一个要呈现给用户的窗体。开发人员可以把这些代码写在UI代码中间，但是会使得代码复杂，不易复用、维护和扩展。另一方面，应用程序要运行在其他的平台也变得相当困难，因为它进行控制的逻辑和状态都不能被复用。</p>
<p>在大多数情况下，应用程序需要维护一个状态，如状态存储在窗体中，代码需要访问这个窗体以重新恢复状态。这样做会比较困难并且代码也会变得不雅，同时也会对用户接口的重用性和可扩展性产生影响。</p>
<p>用户应用系统的时候，他可能会先启动一个任务，离开一段时间后再回来继续。如果在中间用户关闭了应用程序，它将失去当前的状态，要想继续任务的话必须一切从头开始。因此设计程序的时候，必须分开来考虑工作流、导航、与商业服务的交互等各个组成部分，以获取数据并呈现给用户。</p>
<p>UIP (User Interface Process Application Block) 是微软社区开发的众多Application Block中的其中之一，它是开源的。UIP提供了一个扩展的框架，用于简化用户界面与商业逻辑代码的分离的方法，可以用它来写复杂的用户界面导航和工作流处理，并且它能够复用在不同的场景、并可以随着应用的增加而进行扩展。</p>
<p>使用UIP框架的应用程序把表现层分为了以下几层。</p>
<p>●　User Interface Components：这个组件就是原来的表现层，用户看到的和进行交互都是这个组件，它负责获取用户的数据并且返回结果。</p>
<p>●　User Interface Process Components：这个组件用于协调用户界面的各部分，使其配合后台的活动，例如导航和工作流控制，以及状态和视图的管理。用户看不到这一组件，但是这些组件为User Interface Components提供了重要的支持功能。</p>
<p>图16-2展示了这两层在基于.Net的分布式应用程序中的位置。</p>
<details><summary>图16-2　UI Components和UIP Components</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143122.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143122.png';" /></details>

<p>UIP的组件主要负责的功能是：管理经过User Interface Components的信息流；管理UIP中各个事件之间的事务；修改用户过程的流程以响应异常；将概念上的用户交互流程从实现或者涉及的设备上分离出来；保持内部的事务关联状态，通常是持有一个或者多个的与用户交互的事务实体。因此，这些组件也能进行从UI组件收集数据以执行服务器的成组的升级或是跟踪UIP中的任务过程的管理。</p>
<h4 id="表现层动态生成设计思想"><a href="#表现层动态生成设计思想" class="headerlink" title="表现层动态生成设计思想"></a>表现层动态生成设计思想</h4><p>基于XML的界面管理技术可实现灵活的界面配置、界面动态生成和界面定制。其思路是用XML生成配置文件及界面所需的元数据，按不同需求生成界面元素及软件界面。</p>
<p>基于XML界面管理技术，包括界面配置、界面动态生成和界面定制三部分，如图16-3所示。</p>
<details><summary>图16-3　基于XML的界面管理技术框图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143152.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143152.png';" /></details>

<p>界面配置是对用户界面的静态定义，通过读取配置文件的初始值对界面配置。由界面配置对软件功能进行裁剪、重组和扩充，以实现特殊需求。</p>
<p>界面定制是对用户界面的动态修改过程，在软件运行过程中，用户可按需求和使用习惯，对界面元素（如菜单、工具栏、键盘命令）的属性（如文字、图标、大小和位置等）进行修改。软件运行结束，界面定制的结果被保存。</p>
<p>系统通过DOM API读取XML配置文件的表示层信息（初始界面大小、位置等），通过数据存取类读取数据库中的数据层信息，运行时由界面元素动态生成界面。界面配置和定制模块在软件运行前后修改配置文件、更改界面内容。</p>
<p>基于XML的界面管理技术实现的管理信息系统实现了用户界面描述信息与功能实现代码的分离，可针对不同用户需求进行界面配置和定制，能适应一定程度内的数据库结构改动。只需对XML文件稍加修改，即可实现系统的移植。</p>
<h3 id="中间层架构设计"><a href="#中间层架构设计" class="headerlink" title="中间层架构设计"></a>中间层架构设计</h3><h4 id="业务逻辑层组件设计"><a href="#业务逻辑层组件设计" class="headerlink" title="业务逻辑层组件设计"></a>业务逻辑层组件设计</h4><p>业务逻辑组件分为接口和实现类两个部分。</p>
<p>接口用于定义业务逻辑组件，定义业务逻辑组件必须实现的方法是整个系统运行的核心。通常按模块来设计业务逻辑组件，每个模块设计一个业务逻辑组件，并且每个业务逻辑组件以多个DAO组件作为基础，从而实现对外提供系统的业务逻辑服务。增加业务逻辑组件的接口，是为了提供更好的解耦，控制器无须与具体的业务逻辑组件耦合，而是面向接口编程。</p>
<h5 id="业务逻辑组件的实现类"><a href="#业务逻辑组件的实现类" class="headerlink" title="业务逻辑组件的实现类"></a>业务逻辑组件的实现类</h5><p>业务逻辑组件以DAO组件为基础，必须接收Spring容器注入的DAO组件，因此必须为业务逻辑组件的实现类提供对应的setter方法。业务逻辑组件的实现类将DAO组件接口实例作为属性（面向接口编程），而对于复杂的业务逻辑，可能需要访问多个对象的数据，那么只需在这个方法里调用多个DAO接口，将具体实现委派给DAO完成。</p>
<h5 id="业务逻辑组件的配置"><a href="#业务逻辑组件的配置" class="headerlink" title="业务逻辑组件的配置"></a>业务逻辑组件的配置</h5><p>由于业务逻辑组件的DAO组件从未被初始化过，那么业务方法如何完成？DAO组件初始化是由Spring的反向控制（Inverse of Control, IoC）或者称为依赖注入（Dependency Injection, DI）机制完成的。为此，还需要在applicationContext.xml里面配置FacadeManager组件。</p>
<p>定义FacadeManager组件时必须为其配置所需要的DAO组件，配置信息表示BaseManager继承刚才配置的事务代理模板。并且由容器给BaseManager注入dao的组件，即BaseDAOHibernate。而target则是TransactionProxy FactoryBean需要指定的属性，TransactionProxyFactoryBean负责为某个bean实例生成代理，代理必须有个目标，target属性则用于指定目标。</p>
<p>当然，也可以不使用事务代理模板及嵌套bean，而是为组件指定单独的事务代理属性，让事务代理的目标引用容器中已经存在的bean。</p>
<p>applicationContext.xml文件的源代码配置了应用的数据源和SessionFactory等bean，而业务逻辑组件也被部署在该文件中。</p>
<p>在配置文件中，采用继承业务逻辑组件的事务代理，将原有的业务逻辑组件作为嵌套bean配置，避免了直接调用没有事务特性的业务逻辑组件。</p>
<p>系统实现了所有的后台业务逻辑，并且向外提供了统一的Facade接口，前台Web层仅仅依赖这个Facade接口。这样，Web层与后台业务层的耦合已经非常松散，系统可以在不同的Web框架中方便切换，即使将整个Web层替换掉也非常容易。</p>
<h4 id="业务逻辑层工作流设计"><a href="#业务逻辑层工作流设计" class="headerlink" title="业务逻辑层工作流设计"></a>业务逻辑层工作流设计</h4><p>工作流管理联盟（Workflow Management Coalition）将工作流定义为：业务流程的全部或部分自动化，在此过程中，文档、信息或任务按照一定的过程规则流转，实现组织成员间的协调工作以达到业务的整体目标。</p>
<p>工作流管理一直是企业界和学术界关注的热点领域。1993年，国际上专门成立了工作流管理联盟（Workflow Management Coalition, WFMC），以便对工作流实现标准化管理。它是一种反映业务流程的计算机化的模型，是为了在先进计算机环境支持下实现经营过程集成与经营过程自动化而建立的可由工作流管理系统执行的业务模型。它解决的主要问题是：使在多个参与者之间按照某种预定义的规则传递文档、信息或任务的过程自动进行，从而实现某个预期的业务目标，或者是促使此目标的实现。</p>
<details><summary>图16-4　工作流参考模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143343.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143343.png';" /></details>

<p>（1）interface 1：过程定义导入/导出接口。这个接口的特点是：转换格式和API调用，从而支持过程定义信息间的互相转换。这个接口也支持已完成的过程定义或过程定义的一部分之间的互相转换。早期标准是WPDL，后来发展为XPDL。</p>
<p>（2）interface 2：客户端应用程序接口。通过这个接口工作流机可以与任务表处理器交互，代表用户资源来组织任务。然后由任务表处理器负责，从任务表中选择、推进任务项。由任务表处理器或者终端用户来控制应用工具的活动。</p>
<p>（3）interface 3：应用程序调用接口。允许工作流机直接激活一个应用工具，来执行一个活动。典型的是调用以后台服务为主的应用程序，没有用户接口。当执行活动要用到的工具，需要与终端用户交互，通常是使用客户端应用程序接口来调用那个工具，这样可以为用户安排任务时间表提供更多的灵活性。</p>
<p>（4）interface 4：工作流机协作接口。其目标是定义相关标准，以使不同开发商的工作流系统产品相互间能够进行无缝的任务项传递。WFMC定义了4个协同工作模型，包含多种协同工作能力级别。</p>
<p>（5）interface 5：管理和监视接口。提供的功能包括用户管理、角色管理、审查管理、资源控制、过程管理和过程状态处理器等。</p>
<p>用工作流的思想组织业务逻辑，优点是：将应用逻辑与过程逻辑分离，在不修改具体功能的情况下，通过修改过程模型改变系统功能，完成对生产经营部分过程或全过程的集成管理，可有效地把人、信息和应用工具合理地组织在一起，发挥系统的最大效能。</p>
<h4 id="业务逻辑层实体设计"><a href="#业务逻辑层实体设计" class="headerlink" title="业务逻辑层实体设计"></a>业务逻辑层实体设计</h4><p>业务逻辑层实体具有以下特点：业务逻辑层实体提供对业务数据及相关功能（在某些设计中）的状态编程访问。业务逻辑层实体可以使用具有复杂架构的数据来构建，这种数据通常来自数据库中的多个相关表。业务逻辑层实体数据可以作为业务过程的部分I/O参数传递。业务逻辑层实体可以是可序列化的，以保持它们的当前状态。例如，应用程序可能需要在本地磁盘、桌面数据库（如果应用程序脱机工作）或消息队列消息中存储实体数据。业务逻辑层实体不直接访问数据库，全部数据库访问都是由相关联的数据访问逻辑组件提供的。业务逻辑层实体不启动任何类型的事务处理，事务处理由使用业务逻辑层实体的应用程序或业务过程来启动。</p>
<p>在应用程序中表示业务逻辑层实体的方法有很多（从以数据为中心的模型到更加面向对象的表示法），如XML、通用DataSet、有类型的DataSet等。</p>
<p>以下示例显示了如何将一个简单的业务逻辑层实体表示为XML。该业务逻辑层实体包含一个产品。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143420.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143420.png';" /></details>

<p>将业务逻辑层实体表示为XML的优点如下。</p>
<p>（1）标准支持。XML是World Wide Web Consortium (W3C)的标准数据表示格式。</p>
<p>（2）灵活性。XML能够表示信息的层次结构和集合。</p>
<p>（3）互操作性。在所有平台上，XML都是与外部各方及贸易伙伴交换信息的理想选择。</p>
<p>如果XML数据将由ASP.NET应用程序或Windows窗体应用程序使用，则还可以把这些XML数据装载到一个DataSet中，以利用DataSet提供的数据绑定支持。</p>
<p>将业务逻辑层实体表示为通用DataSet。通用DataSet是DataSet类的实例，它是在ADO.NET的System.Data命名空间中定义的。DataSet对象包含一个或多个DataTable对象，用于表示数据访问逻辑组件从数据库检索到的信息。</p>
<p>图16-5所示为用于Product业务逻辑层实体的通用DataSet对象。该DataSet对象具有一个DataTable，用于保存产品信息。该DataTable具有一个UniqueConstraint对象，用于将ProductID列标记为主键。DataTable和UniqueConstraint对象是在数据访问逻辑组件中创建该DataSet时创建的。</p>
<details><summary>图16-5　用于Product业务逻辑层实体的通用DataSet</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143433.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143433.png';" /></details>

<p>图16-6所示为用于Order业务逻辑层实体的通用DataSet对象。此DataSet对象具有两个DataTable对象，分别保存订单信息和订单详细信息。每个DataTable具有一个对应的UniqueConstraint对象，用于标识表中的主键。此外，该DataSet还有一个Relation对象，用于将订单详细信息与订单相关联。</p>
<details><summary>图16-6　用于Order业务逻辑层实体的通用DataSet</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143453.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143453.png';" /></details>

<p>将业务逻辑层实体表示为通用DataSet的优点如下。</p>
<p>（1）灵活性。DataSet可以包含数据的集合，能够表示复杂的数据关系。</p>
<p>（2）序列化。在层间传递时，DataSet本身支持序列化。</p>
<p>（3）数据绑定。可以把DataSet绑定到ASP.NET应用程序和Windows窗体应用程序的任意用户界面控件。</p>
<p>（4）排序与过滤。可以使用DataView对象排序和过滤DataSet。应用程序可以为同一个DataSet创建多个DataView对象，以便用不同方式查看数据。</p>
<p>（5）与XML的互换性。可以用XML格式读写DataSet。</p>
<p>（6）开放式并发。在更新数据时，可以配合使用数据适配器与DataSet方便地执行开放式并发检查。</p>
<p>（7）可扩展性。如果修改了数据库架构，则适当情况下数据访问逻辑组件中的方法可以创建包含修改后的DataTable和DataRelation对象的DataSet。</p>
<p>将业务逻辑层实体表示为有类型的DataSet。有类型的DataSet是包含具有严格类型的方法、属性和类型定义以公开DataSet中的数据和元数据的类。</p>
<p>将业务逻辑层实体表示为有类型的DataSet的优点如下。</p>
<p>（1）代码易读。要访问有类型的DataSet中的表和列，可以使用有类型的方法和属性。</p>
<p>（2）有类型的方法和属性的提供使得使用有类型的DataSet比使用通用DataSet更方便。使用有类型的DataSet时，IntelliSense将可用。</p>
<p>（3）编译时类型检查，无效的表名称和列名称将在编译时而不是在运行时检测。</p>
<h4 id="业务逻辑层框架"><a href="#业务逻辑层框架" class="headerlink" title="业务逻辑层框架"></a>业务逻辑层框架</h4><p>业务框架位于系统架构的中间层，是实现系统功能的核心组件。采用容器的形式，便于系统功能的开发、代码重用和管理。图16-7便是在吸收了SOA思想之后的一个三层体系结构的简图。</p>
<details><summary>图16-7　业务框架在整个系统架构中的位置</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143533.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143533.png';" /></details>

<p>从图16-7中可以看到，业务层采用业务容器（Business Container）的方式存在于整个系统当中，采用此方式可以大大降低业务层和相邻各层的耦合，表示层代码只需要将业务参数传递给业务容器，便不需要业务层多余的干预。如此一来，可以有效地防止业务层代码渗透到表示层。</p>
<p>在业务容器中，业务逻辑是按照Domain Model—Service—Control思想来实现的。</p>
<p>（1）Domain Model是领域层业务对象，它仅仅包含业务相关的属性。</p>
<p>（2）Service是业务过程实现的组成部分，是应用程序的不同功能单元，通过在这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。这种具有中立的接口定义（没有强制绑定到特定的实现上）的特征称为服务之间的松耦合。松耦合系统的好处有两点，一是它的灵活性，二是当组成整个应用程序的每个服务的内部结构和实现逐渐地发生改变时，它能够继续存在。</p>
<p>（3）Control服务控制器，是服务之间的纽带，不同服务之间的切换就是通过它来实现的。通过服务控制器控制服务切换可以将服务的实现和服务的转向控制分离，提高了服务实现的灵活性和重用性。</p>
<p>以下是Domain Model-Service-Control三者的互动关系。</p>
<p>（1）Service的运行会依赖于Domain Model的状态，反之，Service也会根据业务规则改变Domain Model的状态。</p>
<p>（2）Control作为服务控制器，根据Domain Model的状态和相关参数决定Service之间的执行顺序及相互关系。</p>
<p>Domain Model—Service—Control的互动关系，是吸取了Model—View—Control的优点，在“控制和显示的分离”的基础之上演变而来的，通过将服务和服务控制隔离，使程序具备高度的可重用性和灵活性。</p>
<h3 id="数据访问层设计（持久层架构设计）"><a href="#数据访问层设计（持久层架构设计）" class="headerlink" title="数据访问层设计（持久层架构设计）"></a>数据访问层设计（持久层架构设计）</h3><h4 id="5种数据访问模式"><a href="#5种数据访问模式" class="headerlink" title="5种数据访问模式"></a>5种数据访问模式</h4><h5 id="在线访问"><a href="#在线访问" class="headerlink" title="在线访问"></a>在线访问</h5><p>在线访问是最基本的数据访问模式，也是在实际开发过程中最常采用的。</p>
<p>如图16-8所示，这种数据访问模式会占用一个数据库连接，读取数据，每个数据库操作都会通过这个连接不断地与后台的数据源进行交互。</p>
<details><summary>图16-8　在线访问模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143641.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143641.png';" /></details>


<h5 id="Data-Access-Object"><a href="#Data-Access-Object" class="headerlink" title="Data Access Object"></a>Data Access Object</h5><p>如图16-9所示，DAO模式是标准J2EE设计模式之一，开发人员常常用这种模式将底层数据访问操作与高层业务逻辑分离开。</p>
<details><summary>图16-9　DAO模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143708.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143708.png';" /></details>

<p>一个典型的DAO实现通常有以下组件。</p>
<p>（1）一个DAO工厂类。</p>
<p>（2）一个DAO接口。</p>
<p>（3）一个实现了DAO接口的具体类。</p>
<p>（4）数据传输对象。</p>
<p>这当中具体的DAO类包含访问特定数据源的数据的逻辑。</p>
<h5 id="Data-Transfer-Object"><a href="#Data-Transfer-Object" class="headerlink" title="Data Transfer Object"></a>Data Transfer Object</h5><p>如图16-10所示，Data Transfer Object是经典EJB设计模式之一。DTO本身是这样一组对象或是数据的容器，它需要跨不同的进程或是网络的边界来传输数据。这类对象本身应该不包含具体的业务逻辑，并且通常这些对象内部只能进行一些诸如内部一致性检查和基本验证之类的方法，而且这些方法最好不要再调用其他的对象行为。</p>
<details><summary>图16-10　DTO模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143734.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143734.png';" /></details>

<p>在具体设计这类对象（DTO）时，通常可以有如下两种选择。</p>
<p>（1）使用编程语言内置的集合对象，它通常只需要一个类，就可以在整个应用程序中满足任何数据传输目的；而且几乎所有的编程语言都内置了集合类型，不需要再另外编写实现代码。同时，使用内置的集合对象来实现DTO对象的时候，客户端必须按位置序号（在简单数组的情况下）或元素名称（在键控集合的情况下）访问集合内的字段。不过，集合存储的是同一类型（通常是最基本的Object类型）的对象，这有时会导致在编译时碰到一些无法检测到的编码错误。</p>
<p>（2）通过创建自定义类来实现DTO对象，通过定义显示的get或是set方法来访问数据。这种方式能够提供与任何其他对象完全一样的、客户端应用程序可访问的强类型对象。这种对象可以提供编译时的类型检查，但是增加了编码的工作量，若应用程序发出许多远程调用的话，需要编写大量的调用代码。</p>
<p>具体实现中有许多方法试图将上述这两种方法的优点结合在一起。第一种方法是代码生成技术，该技术可以生成脱离现有元数据（如可扩展标记语言XML架构）的自定义DTO类的源代码；第二种方法是提供更强大的集合，尽管它也是平台内置的一般的集合，但它将关系和数据类型信息与原始数据存储在一起，例如IBM提出的SDO技术或是微软ADO.NET中的DataSet就支持这类方法。</p>
<h5 id="离线数据模式"><a href="#离线数据模式" class="headerlink" title="离线数据模式"></a>离线数据模式</h5><p>离线数据模式是以数据为中心，数据从数据源获取之后，将按照某种预定义的结构（这种结构可以是SDO中的Data图表结构，也同样可以是ADO.NET中的关系结构）存放在系统中，成为应用的中心。离线，对数据的各种操作独立于各种与后台数据源之间的连接或是事务；与XML集成，数据可以方便地与XML格式的文档之间互相转换；独立于数据源，离线数据模式的不同实现定义了数据的各异的存放结构和规则，这些都是独立于具体的某种数据源的。</p>
<h5 id="对象-关系映射（Object-Relation-Mapping-O-R-Mapping）"><a href="#对象-关系映射（Object-Relation-Mapping-O-R-Mapping）" class="headerlink" title="对象/关系映射（Object/Relation Mapping, O/R Mapping）"></a>对象/关系映射（Object/Relation Mapping, O/R Mapping）</h5><p>在最近几年，采用OR映射的指导思想来进行数据持久层的设计似乎已经成了一种潮流。对象/关系映射的基本思想来源于这样一种现实：大多数应用中的数据都是依据关系模型存储在关系型数据库中；而很多应用程序中的数据在开发或是运行时则是以对象的形式组织起来的。那么，对象/关系映射就提供了这样一种工具或是平台，能够帮助将应用程序中的数据转换成关系型数据库中的记录；或是将关系数据库中的记录转换成应用程序中代码便于操作的对象。</p>
<h4 id="工厂模式在数据访问层应用"><a href="#工厂模式在数据访问层应用" class="headerlink" title="工厂模式在数据访问层应用"></a>工厂模式在数据访问层应用</h4><p>在应用程序的设计中，数据库的访问是非常重要的，数据库的访问需要良好的封装性和可维护性。在.Net中，数据库的访问，对于微软自家的SqlServer和其他数据库（支持OleDb），采用不同的访问方法，这些类分别分布于System.Data.SqlClient和System.Data.OleDb名称空间中。微软后来又推出了专门用于访问Oracle数据库的类库。我们希望在编写应用系统的时候，不因这么多类的不同而受到影响，尽量做到数据库无关。</p>
<p>这就需要在实际开发过程中将这些数据库访问类再作一次封装。经过这样的封装，不仅可以达到上述的目标，还可以减少操作数据库的步骤，减少代码编写量。工厂设计模式是使用的主要方法。</p>
<p>工厂模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。这里可能会处理对多种数据库的操作，因此，需要首先定义一个操纵数据库的接口，然后根据数据库的不同，由类工厂决定实例化哪个类。</p>
<p>下面首先来定义这个访问接口。为了方便说明问题，在这里只列出了比较少的方法，其他的方法是很容易参照添加的。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904143944.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904143944.png';" /></details>

<p>因为DataAccess的具体实现类有一些共同的方法，所以先从DataAccess实现一个抽象的AbstractDataAccess类，包含一些公用方法。然后，分别为Sql Server、Oracle和OleDb数据库编写三个数据访问的具体实现类。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144006.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144006.png';" /></details>

<p>现在已经完成了所要的功能，下面需要创建一个Factory类，来实现自动数据库切换的管理。这个类很简单，主要的功能就是根据数据库类型，返回适当的数据库操纵类。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144029.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144029.png';" /></details>

<p>现在一切都完成了，客户端在代码调用的时候，可能就是采用如下形式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144047.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144047.png';" /></details>

<p>或者，如果事先设定了DataAccessFactory的DefaultPersistenceProperty属性，可以直接使用DataAccess db= DataAccessFactory.CreateDataAccess()方法创建DataAccess实例。</p>
<p>当数据库发生变化时，只需要修改PersistenceProperty的值，客户端不会感觉到变化，也不用去关心。这样，实现了良好的封装性。当然，前提是你在编写程序时，没有用到特定数据库的特性，例如，Sql Server的专用函数。</p>
<h4 id="ORM、Hibernate与CMP2-0设计思想"><a href="#ORM、Hibernate与CMP2-0设计思想" class="headerlink" title="ORM、Hibernate与CMP2.0设计思想"></a>ORM、Hibernate与CMP2.0设计思想</h4><p>ORM（Object-Relation Mapping）在关系型数据库和对象之间作一个映射，这样，在具体操作数据库时，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作即可。</p>
<p>当你开发一个应用程序的时候（不使用OR Mapping），可能会涉及许多数据访问层的代码，用来从数据库保存、删除和读取对象信息等，然而这些代码写起来总是重复的。</p>
<p>一个更好的办法就是引入OR Mapping。实质上，一个OR Mapping会为你生成DAL。与其自己写DAL代码，不如用OR Mapping，你只需要关心对象就好。</p>
<p>使用ORM可以大大降低学习和开发成本。而在实际的开发中，真正对客户有价值的是其独特的业务功能，而不应该把大量时间花费在编写数据访问、CRUD方法、后期的Bug查找和维护上。在使用ORM之后，ORM框架已经把数据库转变成了我们熟悉的对象，我们只需要了解面向对象开发就可以实现数据库应用程序的开发，不需要浪费时间在SQL上。同时也可减少代码量，减少数据层出错机会。</p>
<p>通过Cache的实现，能够对性能进行调优，实现了ORM区隔了实际数据存储和业务层之间的关系，能够对每一层进行单独跟踪，增加了性能优化的可能。</p>
<p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了轻量级的对象封装，使Java程序员可以随心所欲地使用对象编程思维来操纵数据库。它不仅提供了从Java类到数据表之间的映射，还提供了数据查询和恢复机制。相对于使用JDBC和SQL来手工操作数据库，Hibernate可以大大减少操作数据库的工作量。另外，Hibernate可以利用代理模式来简化载入类的过程，这将大大减少利用Hibernate QL从数据库提取数据的代码的编写量。Hibernate可以和多种Web服务器或者应用服务器良好集成，如今已经支持几乎所有流行的数据库服务器。</p>
<p>Hibernate技术本质上是一个提供数据库服务的中间件，它的架构如图16-11所示。</p>
<details><summary>图16-11　Hibernate架构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144125.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144125.png';" /></details>

<p>图16-11显示了Hibernate件（如hibernate.properties）的工作原理，它是利用数据库以及其他一些配置XML Mapping等来为应用程序提供数据持久化服务的。</p>
<p>Hibernate具有很大的灵活性，但同时它的体系结构比较复杂，提供了好几种不同的运行方式。在轻型体系中，应用程序提供JDBC连接，并且自行管理事务，这种方式使用了Hibernate的一个最小子集。在全面解决体系中，对于应用程序来说，所有底层的JDBC/JTA API都被抽象了，Hibernate会替你照管所有的细节。</p>
<p>Hibernate是一个功能强大，可以有效地进行数据库数据到业务对象的0/R映射方案。Hibernate推动了基于普通Java对象模型，用于映射底层数据结构的持久对象的开发。通过将持久层的生成自动扩展到一个更大的范围，Hibernate使开发人员专心实现业务逻辑而不用分心于繁琐的数据库方面的逻辑，同时提供了更加合理的模块划分的方法。</p>
<h4 id="灵活运用Xml-Schema"><a href="#灵活运用Xml-Schema" class="headerlink" title="灵活运用Xml Schema"></a>灵活运用Xml Schema</h4><p>XML Schema用来描述XML文档合法结构、内容和限制。XML Schema由XML 1.0自描述，并且使用了命名空间，有丰富的内嵌数据类型及其强大的数据结构定义功能，充分地改造了并且极大地扩展了DTDs（传统描述XML文档结构和内容限制的机制）的能力，将逐步替代DTDs，成为XML体系中正式的类型语言，同XML规范、Namespace规范一起成为XML体系的坚实基础。</p>
<p>XML Schema由诸如类型定义和元素声明的组件组成，可以用来评估一个格式良好元素和属性信息的有效性。XML Schema是Schema组件的集合，这些组件分为三组：基本组件、组件和帮助组件。其中基本组件包括简单类型定义、复杂类型定义、属性声明和元素声明；组件包括属性组、完整性约束定义、模型组和符号声明；帮助组件包括注释、模型组、小品词、通配符和属性使用。Schema组件详细说明了抽象数据模型的每个组件的严格语义，每个组件在XML中的表示，一个XML Schema文档类型的DTD和XML Schema引用。</p>
<p>XML Schema提供了创建XML文档必要的框架，详细说明了一个XML文档的不同元素和属性的有效结构、限制和数据类型。XML Schema规范由如下三部分组成。</p>
<p>（1）XML Schema PartO: Primer。一个非标准化的文档，提供了XML Schema的一个简单可读的描述，目的是快速地理解如何利用XML Schema语言创建一个Schema（框架）。</p>
<p>（2）XML Schema Part1: Structures。这一部分详细说明了XML Schema定义语言，这个语言为描述XML 1.0文档的结构和内容限制提供了便利，包括开发了XMLNamespace（命名空间）的使用。</p>
<p>（3）XML Schema Part2: Datatypes。这一部分定义了可用于XML Schema和其他XML规范中的定义数据类型的方法。这个数据类型语言，本身由XML 1.0自描述，提供了说明元素和属性数据类型的XML 1.0文档类型定义（DTDs）的一个超集。这部分提出了标准的数据类型内容集合，其中讲述了目的、需求、范围和术语。XML Schema与DTD相比，有其独特的特点，提供了丰富的数据类型，实现了继承和复用，与命名空间紧密联系，易于使用。</p>
<p>与DTD不同，XML Schema规范提供了丰富的数据类型。其中不仅包括一些内嵌的数据类型，如string、integer、Boolean、time和date等，还提供了定义新类型的能力，如complexType和simpleType。开发者可以利用内嵌的数据类型和用户定义的数据类型，有效地定义和限制XML文档的属性和元素值。</p>
<p>XML Schema支持继承是它的另一特点。可以利用从已经存在的schema中获得某些类型而构造新的schema，也可以在不需要时使获得的类型无效。同时，XML Schema能将一个schema分成单独的组件，这样，在写Schema时，就可以正确地引用已经定义的组件。继承性使得软件复用更加有效，帮助开发者避免了每一次创建都要从零开始，极大地提高了软件开发和维护的效率。</p>
<p>XML Schema与XML Namespace紧密联系，使得在一个命名空间中创建元素和属性非常容易。这种联系简化了使用多个命名空间定义多个schema的XML文档的创建和验证文档有效性。</p>
<h4 id="事务处理设计"><a href="#事务处理设计" class="headerlink" title="事务处理设计"></a>事务处理设计</h4><p>事务是现代数据库理论中的核心概念之一。如果一组处理步骤或者全部发生或者一步也不执行，我们称该组处理步骤为一个事务。当所有的步骤像一个操作一样被完整地执行，我们称该事务被提交。由于其中的一部分或多步执行失败，导致没有步骤被提交，则事务必须回滚（回到最初的系统状态）。事务必须服从ISO/IEC所制定的ACID原则。ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）的缩写。事务的原子性表示事务执行过程中的任何失败都将导致事务所做的任何修改失效。一致性表示当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态。隔离性表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见。持久性表示已提交的数据在事务执行失败时，数据的状态都应该正确。</p>
<p>一般情况下，J2EE应用服务器支持JDBC事务、JTA （Java Transaction API）事务和容器管理事务。一般情况下，最好不要在程序中同时使用上述三种事务类型，例如在JTA事务中嵌套JDBC事务。另外，事务要在尽可能短的时间内完成，不要在不同方法中实现事务的使用。下面举列说明两种事务处理方式。</p>
<h5 id="JavaBean中使用JDBC方式进行事务处理"><a href="#JavaBean中使用JDBC方式进行事务处理" class="headerlink" title="JavaBean中使用JDBC方式进行事务处理"></a>JavaBean中使用JDBC方式进行事务处理</h5><p>在JDBC中怎样将多个SQL语句组合成一个事务呢？在JDBC中，打开一个连接对象Connection时，默认是auto-commit模式，每个SQL语句都被当作一个事务，即每次执行一个语句，都会自动地得到事务确认。为了能将多个SQL语句组合成一个事务，要将auto-commit模式屏蔽掉。在auto-commit模式屏蔽掉之后，如果不调用commit()方法，SQL语句不会得到事务确认。在最近一次commit()方法调用之后的所有SQL会在方法commit()调用时得到确认。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144235.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144235.png';" /></details>

<h5 id="SessionBean中的JTA事务"><a href="#SessionBean中的JTA事务" class="headerlink" title="SessionBean中的JTA事务"></a>SessionBean中的JTA事务</h5><p>JTA是事务服务的J2EE解决方案。本质上，它是描述事务接口（例如UserTransaction接口，开发人员直接使用该接口或者通过J2EE容器使用该接口来确保业务逻辑能够可靠地运行）的J2EE模型的一部分。JTA具有的三个主要的接口，分别是UserTransaction接口、TransactionManager接口和Transaction接口。这些接口共享公共的事务操作，例如commit()和rollback()；但是也包含特殊的事务操作，例如suspend()、resume()和enlist()，它们只出现在特定的接口上，以便在实现中允许一定程度的访问控制。例如，UserTransaction能够执行事务划分和基本的事务操作，而TransactionManager能够执行上下文管理。</p>
<p>应用程序可以调用UserTransaction.begin()方法开始一个事务，该事务与应用程序正在其中运行的当前线程相关联。底层的事务管理器实际处理线程与事务之间的关联。UserTransaction.commit()方法终止与当前线程关联的事务。UserTransaction.rollback()方法将放弃与当前线程关联的当前事务。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144309.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144309.png';" /></details>

<h4 id="连接对象管理设计"><a href="#连接对象管理设计" class="headerlink" title="连接对象管理设计"></a>连接对象管理设计</h4><p>在基于JDBC的数据库应用开发中，数据库连接的管理是一个难点，因为它是决定该应用性能的一个重要因素。</p>
<p>对于共享资源，有一个很著名的设计模式——资源池。该模式正是为了解决资源频繁分配、释放所造成的问题。把该模式应用到数据库连接管理领域，就是建立一个数据库连接池，提供一套高效的连接分配、使用策略。</p>
<p>建立连接池的第一步，就是要建立一个静态的连接池。所谓静态，是指池中的连接是在系统初始化时就分配好的，并且不能够随意关闭。Java中给我们提供了很多容器类，可以方便地用来构建连接池，如Vector、Stack等。在系统初始化时，根据配置创建连接并放置在连接池中，以后所使用的连接都是从该连接池中获取的，这样就可以避免连接随意建立、关闭造成的开销（当然，我们没有办法避免Java的Garbage Collection带来的开销）。</p>
<p>有了这个连接池，下面就可以提供一套自定义的分配、释放策略。当客户请求数据库连接时，首先看连接池中是否有未分配出去的连接。如果存在空闲连接则把连接分配给客户，并作相应处理。具体处理策略，在关键议题中会详述，主要的处理策略就是标记该连接为已分配。若连接池中没有空闲连接，就在已经分配出去的连接中，寻找一个合适的连接给客户，此时该连接在多个客户间复用。</p>
<p>当客户释放数据库连接时，可以根据该连接是否被复用，进行不同的处理。如果连接没有使用者，就放入到连接池中，而不是被关闭。可以看出，正是这套策略保证了数据库连接的有效复用。</p>
<h3 id="数据架构规划与设计"><a href="#数据架构规划与设计" class="headerlink" title="数据架构规划与设计"></a>数据架构规划与设计</h3><h4 id="数据库设计与类的设计融合"><a href="#数据库设计与类的设计融合" class="headerlink" title="数据库设计与类的设计融合"></a>数据库设计与类的设计融合</h4><p>对类和类之间关系的正确识别是数据模型的关键所在。本节将讨论如何发现、识别以及描述类。要想将建模过程缩减为一个简单的、逐步进行的过程是不太可能的。从本质上讲，建模是一项艺术。对一个给定的复杂情况而言，不存在唯一正确的数据模型，然而却存在好的数据模型。一个企业或机构的某个数据模型可能会优于另一个数据模型，但就如何为一个特定的系统建立数据模型，却没有唯一的解决方案。</p>
<p>好模型的目标是将工程项目整个生存期内的花费减至最小，同时也会考虑到随时间的推移系统将可能发生的变化，因而设计时也要很容易地能适应这些变化。因此，将目光集中在最大限度地降低开发费用上是一个错误。</p>
<h4 id="数据库设计与XML设计融合"><a href="#数据库设计与XML设计融合" class="headerlink" title="数据库设计与XML设计融合"></a>数据库设计与XML设计融合</h4><p>WWW的迅速发展，使其成为全球信息传递和共享日益重要和最具潜力的资源，电子商务、电子图书和远程教育等全新领域的需求和发展，使Web数据变得更加复杂和多样化，利用传统数据库技术很难存储和管理所有不同的Web数据。</p>
<p>目前，XML正在成为Internet上数据描述和交换的标准，并且将来会代替HTML而成为Web上保存数据的主要格式。</p>
<p>XML文档分为两类：一类是以数据为中心的文档，这种文档在结构上是规则的，在内容上是同构的，具有较少的混合内容和嵌套层次，人们只关心文档中的数据而并不关心数据元素的存放顺序，这种文档简称为数据文档，它常用来存储和传输Web数据。另一类是以文档为中心的文档，这种文档的结构不规则，内容比较零散，具有较多的混合内容，并且元素之间的顺序是有关的，这种文档常用来在网页上发布描述性信息、产品性能介绍和E-mail信息等。</p>
<p>Web上存有大量的XML文档，并需要持久保存，这一需求引发了人们对XML文档的存储技术研究。已经提出的XML文档的存储方式有两种：基于文件的存储方式和数据库存储方式。</p>
<p>（1）基于文件的存储方式。基于文件的存储方式是指将XML文档按其原始文本形式存储，主要存储技术包括操作系统文件库、通用文档管理系统和传统数据库的列（作为二进制大对象BLOB或字符大对象CLOB）。这种存储方式需维护某种类型的附加索引，以建立文件之间的层次结构。基于文件的存储方式的特点：无法获取XML文档中的结构化数据；通过附加索引可以定位具有某些关键字的XML文档，一旦关键字不确定，将很难定位；查询时，只能以原始文档的形式返回，即不能获取文档内部信息；文件管理存在容量大、管理难的缺点。</p>
<p>（2）数据库存储方式。数据库在数据管理方面具有管理方便、存储占用空间小、检索速度快、修改效率高和安全性好等优点。一种比较自然的想法是采用数据库对XML文档进行存取和操作，这样可以利用相对成熟的数据库技术处理XML文档内部的数据。数据库存储方式的特点：能够管理结构化和半结构化数据；具有管理和控制整个文档集合本身的能力；可以对文档内部的数据进行操作；具有数据库技术的特性，如多用户、并发控制和一致性约束等；管理方便，易于操作。</p>
<p>在某种程度上，XML及其一系列相关技术就是一个数据库系统。它提供了传统数据库所具有的特点，如存储（以XML文档形式）、数据库的模式（DTD或XMLSchema）、查询语言（XQuery、XPath、XQL和XML-QL等）和编程接口（如SAX、DOM）等。但与传统数据库相比，它在存储、索引、安全、多用户访问和事务管理等方面还存在不足之处。在一定的环境下，例如当数据量和操作用户较少并且性能要求不高的情况下，XML文档能够作为数据库在应用程序中使用。如果应用程序有许多操作用户，并且要求严格的数据完整性和性能要求，则不宜采用XML文档。</p>
<p>XML数据库是一组XML文档的集合，并且是持久的和可操作的；有专门的DBMS管理（不是XML文件系统）；文档都是有效的（即符合某一模式）；文档的集合可能基于多个模式文件（即文件扩展名为.xsd），多个模式文件之间可能有语法和语义上的相互联系。</p>
<h3 id="实战案例——电子商务网站（网上商店PetShop）"><a href="#实战案例——电子商务网站（网上商店PetShop）" class="headerlink" title="实战案例——电子商务网站（网上商店PetShop）"></a>实战案例——电子商务网站（网上商店PetShop）</h3><p>PetShop是一个范例，微软用它来展示.Net企业系统开发的能力。PetShop随着版本的不断更新，至现在基于.Net 2.0的PetShop4.0为止，整个设计逐渐变得成熟而优雅，有很多可以借鉴之处。PetShop是一个小型的项目，系统架构与代码都比较简单，却也凸现了许多颇有价值的设计与开发理念。</p>
<h4 id="PetShop的系统架构设计"><a href="#PetShop的系统架构设计" class="headerlink" title="PetShop的系统架构设计"></a>PetShop的系统架构设计</h4><p>PetShop的表示层是用ASP.Net设计的，也就是说，它应是一个BS系统。在.Net中，标准的BS分层式结构如图16-12所示。</p>
<details><summary>图16-12　Net中标准的BS分层式结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144722.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144722.png';" /></details>

<p>随着PetShop版本的更新，其分层式结构也在不断的完善，例如PetShop 2.0，就没有采用标准的三层式结构，如图16-13所示。</p>
<details><summary>图16-13　PetShop 2.0的体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144739.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144739.png';" /></details>

<p>从图16-13中可以看到，并没有明显的数据访问层设计。这样的设计虽然提高了数据访问的性能，但也同时导致了业务逻辑层与数据访问的职责混乱。一旦要求支持的数据库发生变化，或者需要修改数据访问的逻辑，由于没有清晰的分层，会导致项目做大的修改。而随着硬件系统性能的提高，以及充分利用缓存、异步处理等机制，分层式结构所带来的性能影响几乎可以忽略不计。</p>
<p>PetShop 3.0纠正了此前层次不明的问题，将数据访问逻辑作为单独的一层独立出来。PetShop 3.0的体系架构如图16-14所示。</p>
<details><summary>图16-14　PetShop 3.0的体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144756.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144756.png';" /></details>

<p>PetShop 4.0基本上延续了3.0的结构，但在性能上作了一定的改进，引入了缓存和异步处理机制，同时又充分利用了ASP.Net 2.0的新功能MemberShip。因此，PetShop 4.0的系统架构如图16-15所示。</p>
<details><summary>图16-15　PetShop 4.0的体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144820.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144820.png';" /></details>

<p>比较3.0和4.0的系统架构图，其核心的内容并没有发生变化。在数据访问层（DAL）中，仍然采用DAL Interface抽象出数据访问逻辑，并以DAL Factory作为数据访问层对象的工厂模块。对于DAL Interface而言，分别有支持MS-SQL的SQL Server DAL和支持Oracle的Oracle DAL具体实现，而Model模块则包含了数据实体对象，其详细的模块结构如图16-16所示。</p>
<p>可以看到，在数据访问层中，完全采用了“面向接口编程”思想。抽象出来的IDAL模块，脱离了与具体数据库的依赖，从而使得整个数据访问层有利于数据库迁移。DALFactory模块专门管理DAL对象的创建，便于业务逻辑层访问。SQLServerDAL和OracleDAL模块均实现IDAL模块的接口，其中包含的逻辑就是对数据库的Select、Insert、Update和Delete操作。因为数据库类型的不同，对数据库的操作也有所不同，代码也会因此有所区别。</p>
<p>此外，抽象出来的IDAL模块，除了解除了向下的依赖之外，对于其上的业务逻辑层同样仅存在弱依赖关系，如图16-17所示。</p>
<details><summary>图16-17　业务逻辑层的模块结构图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144850.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144850.png';" /></details>

<p>图16-17中，BLL是业务逻辑层的核心模块，它包含了整个系统的核心业务。在业务逻辑层中，不能直接访问数据库，而必须通过数据访问层。注意，图16-17中对数据访问业务的调用，是通过接口模块IDAL来完成的。既然与具体的数据访问逻辑无关，则层与层之间的关系就是松散耦合的。如果此时需要修改数据访问层的具体实现，只要不涉及到IDAL的接口定义，那么业务逻辑层就不会受到任何影响。毕竟，具体实现的SQLServerDAL和OracalDAL根本就与业务逻辑层没有半点关系。</p>
<p>因为在PetShop 4.0中引入了异步处理机制，插入订单的策略可以分为同步和异步，两者的插入策略明显不同。但对于调用者而言，插入订单的接口是完全一样的，所以PetShop 4.0中设计了IBLLStrategy模块。虽然在IBLLStrategy模块中，仅仅是简单的IOrderStategy，但同时也给出了一个范例和信息，那就是在业务逻辑的处理中，如果存在业务操作的多样化或者是今后可能的变化，均应利用抽象的原理、或者使用接口、或者使用抽象类，从而脱离对具体业务的依赖。不过在PetShop中，由于业务逻辑相对简单，这种思想体现得不够明显。也正因为此，PetShop将核心的业务逻辑都放到了一个模块BLL中，并没有将具体的实现和抽象严格地按照模块分开。所以表示层和业务逻辑层之间的调用关系，其耦合度相对较高。</p>
<p>图16-18表示层的模块结构图中，各个层次中还引入了辅助的模块，如数据访问层的Messaging模块，是为异步插入订单的功能提供，采用了MSMQ（Microsoft Messaging Queue）技术，而表示层的CacheDependency则提供缓存功能。</p>
<details><summary>图16-18　表示层的模块结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904144906.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904144906.png';" /></details>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch15-%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E7%AE%A1%E7%90%86%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch15-%E6%9E%B6%E6%9E%84%E5%B8%88%E7%9A%84%E7%AE%A1%E7%90%86%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch15-架构师的管理实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:56:44" itemprop="dateCreated datePublished" datetime="2021-07-19T12:56:44+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 19:22:39" itemprop="dateModified" datetime="2021-09-26T19:22:39+08:00">2021-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="架构师的管理实践"><a href="#架构师的管理实践" class="headerlink" title="架构师的管理实践"></a>架构师的管理实践</h2><p>在实践过程中，软件架构的主要障碍往往在于组织方面而非技术。创造切实可行的软件架构需要对技术的深入把握、良好的认知能力和沟通技巧以及大量艰苦的工作。技术上出色的架构往往由于没有全面地处理好组织管理因素而失败。架构师利用自己的知识影响团队，常被大家认为是无冕之王，因此架构师需要管理技巧。本章介绍了架构师的VRAPS实践。</p>
<h3 id="VRAPS组织管理原则"><a href="#VRAPS组织管理原则" class="headerlink" title="VRAPS组织管理原则"></a>VRAPS组织管理原则</h3><p>VRAPS是为实践软件架构的组织管理原则提出的，包括构想、节奏、预见、协作和简化5个相关联的原则。每项原则都是实际可操作的，原则的提出都来源于构建软件架构的直接经验，并且都可以用来解释实践。VRAPS模型的焦点在开发和使用软件架构过程的组织管理方面，其应用环境不仅包括建立和部署架构的团队，还包括利用架构开发和利用产品线的团队和使用这些产品的客户。</p>
<p>受益人是指建立并长期保持架构的价值有重要影响的人或组织。受益人一般包括发起人、应用开发人员和应用客户，还可能包括其他重要的参与者，如技术供应方。</p>
<p>（1）构想原则：说明了如何向架构的受益人描述一幅一致的、有约束力和灵活的未来图景。</p>
<p>（2）节奏原则：刻画了一种在整个组织范围内的协调程度，即定期地根据可预测的速度、内容和质量对制品生产进行检查与规划。</p>
<p>（3）预见原则：要在预测未来与检查并适应现状之间做出平衡。</p>
<p>（4）协作原则：解决了如何识别对架构成功关键的团体，以及如何确保这些合作伙伴的有效支持。</p>
<p>（5）简化原则：要求理解组织的结构，了解架构最小的基本特征并最小化架构。</p>
<p>各个原则之间不是相互孤立的，图15-1解释了构想原则如何与其他原则交互。构想原则确立了总体方向，使得节奏原则所要求的协调工作能够进行。而一个好的节奏又可以使组织朝着构想原则制定的目标不断提供递增的进展。构想原则中的假设根据预见原则进行测试和验证。在架构演化中，应注意环境的变化，并把这些变化加入到构想中。构想帮助建立准则，以挑选合作伙伴和理解他人给架构带来的价值。这些合作伙伴的约束是一个好的构想的关键要素。构想对简化原则也起到了作用。预期的价值经过解释被运用到架构的决策中，而反过来又帮助完善构想。</p>
<details><summary>图15-1　构想与其他原则之间的交互关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140553.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140553.png';" /></details>

<p>所有其他的原则也是彼此之间相互影响的。例如，节奏原则中的协调组活动如果没有了协作是不可能完成的。通过在每个开发周期中关注最小的关键需求，节奏原则又帮助了简化原则的进行。</p>
<h3 id="概念框架"><a href="#概念框架" class="headerlink" title="概念框架"></a>概念框架</h3><p>为了更好地使用VRAPS原则，我们用准则、模式和反模式来对各项原则进行补充。准则用于判断每项原则的实施效果如何。模式描述了开发和使用软件架构时可能遇到的常见问题和解决方法，能够帮助组织改进原则。反模式则描述了组织在实践中可能遇到的陷阱。</p>
<h4 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h4><p>为了把原则运用到实践中，需要可操作的实施细节。准则把广泛的原则翻译成是否和如何执行原则的细节。</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>第一项原则都附有一组模式，它描述了开发或者使用软件架构时可能遇到的常见问题的解决方法。模式更注重于解决特定情况下的问题，传达了在给定背景和多方竞争因素下针对常见问题的解决方案。</p>
<h4 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h4><p>反模式描述了组织在实践中可能遇到的陷阱，描述了不该做的事情，或者用在错误背景下的解决方案，可以帮助更深入地理解原则。</p>
<h3 id="形成并统一构想"><a href="#形成并统一构想" class="headerlink" title="形成并统一构想"></a>形成并统一构想</h3><p>构想描述了架构的未来，提供了架构使用的环境和动机。构想是未来价值到架构约束的映射，构想要成功，则必须把它所能提供的价值与客户的约束相对应。构想也必须是明晰的、有约束力的、一致的和灵活的，从而能够被其受益人理解并有效地运用。</p>
<p>例如，在大型组织中，管理层可能把项目架构师与维护产品构想的高级经理分隔开来。这种距离会维持构想一致性，导致架构难以满足维护要求，引发后期运行成本问题。为了应对类似组织结构产生的复杂性，高级经理和架构师之间建立稳固的、积极的关系以及共享统一的构想至关重要。</p>
<p>把价值映射为架构约束，要求开发人员把约束诸如接口、开发语言和模块边界等映射到特定的客户价值上。促使受益人把约束与客户价值捆绑需要高超的技艺，用例建模是把架构的预期使用与能够被满足的切实的用户目标连接起来的一种方法。例如，识别并表达出似乎无关的用例之间的实质性联系是建立构想的一个重要内容。</p>
<h4 id="形成构想"><a href="#形成构想" class="headerlink" title="形成构想"></a>形成构想</h4><p>构想需要维持一致性与协调性。一致性是指受益人的各种期望之间妥协，以及它们与现在和将来的架构之间的需求满足程度。灵活性是指受益人在不破坏架构的情况下，在现有架构之上完成事先没有预料到的需求的容易程度。</p>
<p>一致性并不意味着所有受益人之间拥有一张完全一致的构想视图，而是指各受益人共享的视图根据他们不同的视角保持一致。RUP的“4＋1架构视图”体现了获得这种一致性的方法。RUP通过逻辑视图（Logic View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）和用例视图（Use case View）建立了架构视图。这些架构视图的不同点在于，它们根据不同目的表示系统（例如，用例视图表示了系统的最终用户功能）。</p>
<p>架构师常负有将现实引入业务构想和将构想变成现实的责任。架构师可以推荐技术，包括如何以及何时采用这些技术， 由此来帮助确定业务构想的哪些部分可以在短期内实现，以及各部分实现的次序。</p>
<p>架构师更像管理者而并非实施者，Dean Thompson说：“作为架构师更多地意味着权衡业务、组织运作和使用技术，而不仅仅是技术细节。”例如，架构师应该全面研究整个组织，找出各利益方关注的重点，然后妥善平衡，建立符合主要关注问题的架构描述。</p>
<p>多方整合能促进构想的形成。多方整合是组织各利益方的机制，用于确保获得构想并使其稳定；是指在一个公共的组织层次上对信息、决策和资源进行协调。多方整合能使从事硬件设计的基层经理理解软件设计和开发人员，以及市场营销、客户支持和市场营销的同事的期望，包括增强组织与客户和外部供应者沟通的能力。</p>
<p>Thompson归纳了形成架构构想的三步方法：清楚明确地阐述一条迫切的客户价值；将客户价值映射为少数特定的能解决的问题；将以上问题转译成一组特定的约束条件。</p>
<p>成功的架构师用明确的客户价值映射规划未来，以使用户及它们的客户能将其与约束联系起来。架构师必须格外关注产品开发人员和最终的客户，而且为了成功，还要发动所有其他人做类似的事情。</p>
<h4 id="将构想原则付诸实践"><a href="#将构想原则付诸实践" class="headerlink" title="将构想原则付诸实践"></a>将构想原则付诸实践</h4><p>下面的准则、反模式和模式能帮助建立、形成、维护一个被共享的构想，将构想原则付诸实践。</p>
<p>用于检验构想原则是否起作用的准则如下。</p>
<p>（1）架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>（2）实施人员是否信任并使用架构。</p>
<p>（3）关于架构和构件的潜藏知识对其用户（开发团队）是否是可见的、可获得的。</p>
<p>构想原则中准则到模式、反模式的映射如表15-1所示。</p>
<details><summary>表15-1　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140731.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140731.png';" /></details>

<p>下面详细介绍与各准则相关的反模式和模式。</p>
<p>准则1：架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>为了获得一致、迫切和灵活的架构，需要产品线经理、架构师和实施经理等达成共识。而如果没有阐明用户价值，则会导致构想脱离了重点。</p>
<p>与准则1相关的反模式与模式如下。</p>
<p>1）反模式：风险后置</p>
<p>形容这样统一受益人的构想：用最小的妥协、最大的优化规划出一个构件以满足所有冲突利益的需要。这种统一方法的问题是，设计出来的构件往往在理论上可行，但实际运行中出现风险。</p>
<p>一条新产品线的架构师或经理，需要开发看似很棒但实现有风险的构件。这些要完成构件可能需要打破“物理定律”才能完成，这些风险可能在制品交付的最后才能显现。可是有一批工程师仍然坚持开发这些构件。风险构件被安排到最后完成，以为这样可以有时间消除风险。可是，当计划好的完成日期临近时，依然无法交付。尽管架构在演示的幻灯片上运转良好，实际上却无法正常工作。</p>
<p>面对这种情况，需要分析并阐明风险， 向高级经理提供一个选择，要么承认风险，要么调整任务。</p>
<p>2）模式：前后一致</p>
<p>要求推动架构投资的高级经理积极地维护构想，并防止构想受到短期压力的影响。</p>
<p>一个公共的架构被几个产品共享，它已经变得比预期要复杂得多。而客户们针对每件产品又提出了以前没有预计到的功能特性。如果加入这些功能特性，则不能保证进度，但如果不开发这个特性则可能失去一位重要客户。</p>
<p>这样的情况下，需要评估架构构想的质量和稳定性。只有当两者都正常时，才能采取进一步行动。如果该新特性不属于原来的产品构想支持的代价范围，那就应该放弃开发这个新特性。如果构想不明确，在短期内就交付很可能导致大量缺陷。此时应与客户、架构师和销售、产品、支持人员以及开发经理一起加强产品的构想。如果这个特性确实属于一个稳定的产品构想，那么应该在开发组织内核实这种一致性。</p>
<p>准则2：实施人员信任并使用架构。</p>
<p>只有使用架构，才能从中获得价值。然而，要让开发人员对架构构想充分信任需要做更多的工作，仅仅靠不断兑现承诺是不够的。开发人员需要把他们对构想的了解与他们认为对下一步行动有用的东西联系起来。开发人员在利用架构的过程中，可能会使架构向许多不同的方向发展。一个良好架构应与构想保持一致，同时又能满足用户的需求。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：墙头草</p>
<p>描述了这样一种情况：因为没有良好的构想，导致架构方向在竞争和客户压力的影响下经常改变。这种构想永远不能达到稳定以便有效地被共享。</p>
<p>在开发过程中，经常会出现这样一种情况：来自客户、竞争对手和高级经理的压力使得需要在一次发布的中途加入一些代价高昂的功能，高级经理甚至可能在没有咨询架构师的情况下决定提供这些功能。可是一旦交付了某个激进的功能，组织马上就会陷入对该功能的支持工作中。以后的发布会因需要提供向后兼容而变得更为复杂。</p>
<p>在这种情况下，要做的是理解并阐明构想。方便变更需求是成功构想的一部分，要对其进行规划。高级主管要与架构师一起紧密地工作，理解变更的后果并做出正确的权衡。在建立了构想之后，可以用前后一致模式来评估特定的变更建议。在把功能特性加入到发布之前，要坚持达成一致意见。这需要一种固定的机制，以使达成一致成为正常业务的一部分。如果架构满足了高层的约束条件，那么在细节的实施方面可以允许更多的灵活性。在最极端的情况下，解决墙头草问题可能需要寻找新的、期望更为接近的受益人。</p>
<p>2）模式：三个臭皮匠</p>
<p>三个臭皮匠：反映了这样一种认识，即架构师并非总是架构构想的来源，架构师和客户一起充实、完善构想。</p>
<p>一个共同的架构或平台是产品线战略的关键，架构发起人希望产品团体能开发出“杀手解决方案”，而同时又能避免追随新的标准、潮流带来的困扰。</p>
<p>在这种情况下，需要抵制创建一个无所不能的架构的诱惑，建立一种能让架构师及其用户都能丰富、实现功能特性的构想。高级经理只提供构想、目标和原则，把架构和平台留给架构师，把实现细节留给合适的团队或层次。一个成功的产品线架构必须能为适应市场变化，能适应和采用新技术，能解决在概念阶段还不知道的但变化场景可预见的问题。</p>
<p>这是一项很少有架构师能独立完成的任务，然而，通过高级经理建立正确的顶层业务构想，架构师采取实现构想的正确行动就能取得成功。</p>
<p>准则3：关于架构和构件的潜藏知识对其用户是可见的、可获得的。</p>
<p>1）反模式：一叶障目</p>
<p>一叶障目：发生在这种情况下：开发人员过分专注于应用，以致不知道其他架构解决同类问题的通用的解决方案。</p>
<p>在一个组织中，工程团队正在实践代码所有制模式，工程师们都把精力集中在自己眼前的任务和职责上，没有把自己当作一个共享资源的看护者。陷入本反模式的工程师的视野很窄，面对其他开发同事的请求往往只求解决问题，不愿意多加考虑。这样导致的工作结果可能变得非常复杂、脆弱而且容易出错，这是由一名工程师所无法预见的情况造成的。</p>
<p>要解决上面的问题，需创造一种分享知识的愿望。例如，工程师培训等方式就可以起到一些作用，整个组织的人员启用知识管理平台也能促进产生这种愿望。</p>
<p>2）模式：轮流工作</p>
<p>轮流工作：要求参与架构的工作人员轮流在架构的不同部分上工作。这样能使他们对架构有更多的了解，并有机会发展非正式的人际网络。</p>
<p>当一个产品线的销售增长到一定程度，一个单一的、聚集的团队已无法支撑架构和实现，人员被重新组织到地理上分布不同的团队中。已有的沟通管道与新的形势已经不相适应。</p>
<p>通过帮教制（Apprenticeship）模式阶段性地轮流交换构件的所有权可以解决上面的问题。组织和鼓励构件的前任负责人抽出时间帮助新的负责人，轮转周期应该尽可能地与发布进度保持同步。该方法能使开发人员更容易地发现如何找到有关构件的知识，团队成员掌握某个构件或者在出现问题时知道应该问谁的可能性也大大增加了。因此，意外发生的次数减少了。</p>
<h3 id="节奏：保证节拍、过程和进展"><a href="#节奏：保证节拍、过程和进展" class="headerlink" title="节奏：保证节拍、过程和进展"></a>节奏：保证节拍、过程和进展</h3><p>节奏原则使得软件架构在跨越组织边界的情况下开发和使用成为可能。由于许多参与开发和使用架构的团体是自治性的，不可能自上而下地协调这些团体，节奏原则提供了一个随时间变化的框架，可使团体同步各自的活动与期望。有了节奏，参与者就能知道何时关心和应该关心哪些活动。不仅计划中的活动可以被协调管理，节奏原则也可以协调那些非正式的但很关键的活动，例如团体间的交流，这样参与者就可以知道何时应该或不应该提出对于信息或支持的要求。</p>
<h4 id="节奏定义"><a href="#节奏定义" class="headerlink" title="节奏定义"></a>节奏定义</h4><p>节奏是一个架构团体内部及它与客户和供应者之间反复出现的、可预测的工件交换活动。节奏有三个元素：速度、内容和质量。速度是指一个团体与另一个团体之间同类型交接发生的频率，例如架构团队与产品开发工程师之间。如果交接的时间是可预测的，移交则容易管理。稳定的发布计划是速度的一个例子。内容是指一个团体向另一个团体提供的价值。例如，一个团体开发一种新的或者要修改的特性被另一个团体用于满足某种需要。质量的含义是遵循开发过程确保架构没有缺陷。组织可以通过省略非增值的步骤来加快速度，但是如果重要的流程被截掉了，节奏就会遭到破坏。</p>
<p>节奏在团体和组织之间与内部提供一种协调活动的稳定力量，帮助移交管理。当节奏很强时，受益人能培养很强的预见、实施移交和交接的技能。节奏还能驱动活动完结，拥有良好节奏的组织通过建立有规律的阶段间隙来推动评估、再评估和其他工作的进展。</p>
<h4 id="将节奏原则付诸实践"><a href="#将节奏原则付诸实践" class="headerlink" title="将节奏原则付诸实践"></a>将节奏原则付诸实践</h4><p>没有建立节奏会导致客户不满意、不期望的错误发生和工件无法一起工作。只有当以下准则出现时，才说明节奏原则起了作用。</p>
<p>（1）经理们定期地再评估、同步和调整架构。</p>
<p>（2）架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>（3）通过节奏协调明确的活动。</p>
<p>节奏原则中，准则到模式、反模式的映射如表15-2所示。</p>
<details><summary>表15-2　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904141235.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904141235.png';" /></details>

<p>准则1：经理们定期地再评估、同步和调整架构。</p>
<p>好的节奏需要有规律的节拍。对于架构组织的管理者，这意味着他们必须在稳定的间隙上再评估、同步和调整他们的架构计划。节奏的节拍还能提供一个计划过程的框架。具有良好节奏的一个组织用节拍而不是时间来衡量进度。</p>
<p>相关的反模式和模式如下。</p>
<p>1）反模式：一步成功</p>
<p>一步成功：是指当组织变得过于专注地向市场推出某项功能特性而导致内部节奏遭到破坏时发生的情形。组织被竞争所蒙蔽，全身心地专注于向市场提供该特性，却削减了质量，甚至可能破坏本来的节奏。</p>
<p>相关的解决办法有：把关键的功能特性作为团队节奏的一个组成部分来实现。围绕一个特定的主题来进行一次特定的发布，利用主题帮助抓住市场上的机会。如果关键特性特别复杂，则采用几次迭代来实现。但如果在实现关键特性的时候难以保持节奏，说明该特性的风险和复杂度比预计的要大，需要重新规划。</p>
<p>2）模式：发布委员会</p>
<p>发布委员会：描述了一种协调参与发布新架构的相关各方的方法。该模式向经理们介绍了一种在架构发布的最后阶段再评估、同步和调整架构的方法。</p>
<p>定期举办由组织中每个关键受益人参加的正式会议以引导发布的进程。在会议中，要复审产品功能特性和优先级的变更，从而使产品文档、市场承诺、公共关系、测试和开发保持一致。在适合的地方采用测量指标度量发布的进展，分享责任和依赖，做出如何前进的决定，并记录和传达会议的决定。参加委员会的成员应该保持稳定，会议成员的组成应保持一致，与会人员也应该有足够的决定权。</p>
<p>准则2：架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>如果架构用户不信任架构发布的进度和内容，那么用户就可能不采用新的架构发布，或者可能选择另一个架构。用户对架构发布的进度和内容缺乏信心是一个警告信号，说明没有建立一个良好的节奏。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：超敏捷</p>
<p>超敏捷：发生在组织试图在开发过程中抄近路以维持稳定的发布节拍的时候。该反模式对用户所期望的架构质量和内容进行了妥协。</p>
<p>过程执行的合适方法取决于组织文化。在有些组织中，阶段性的软件审计可以用于保证过程被遵守。然而，在许多组织中，审计并不是一种改变或约束行为的有效方法，高层管理的行动能更直接地改变组织行为。是否已经分配了足够的资源来执行计划中的步骤，经理们是否创建明确的目标来保证对节奏的维持都有非常重要的影响。</p>
<p>2）模式：舍兵保帅</p>
<p>舍兵保帅：探讨了组织如何通过把不太重要的特性移到后面的发布周期以保持一个节拍。通过保持节奏，该模式可以使用户获得对架构发布进度更多的信心。</p>
<p>如果对构件的修订看上去无法及时完成时，而且该修订并不非常重要，应该尽快向受益人说明。在不对延误构件做变更的情况下，继续发布架构。为了避免因用户没有阅读或看见特性变更说明而造成的问题，应该确保从预发布开始就放弃该特性，这样用户就能在α或β测试中体验到变化，而不是在正式的产品发布中。可以在以后的发布中再把该构件的变更加进来。通过上面的方法可以保持发布的速度，使架构发布后的活动计划能按进度进行。该方法还能推动构件负责人按时完成他们的修订工作。因为架构的发布实现了承诺，开发人员增强了信任感，他们对下一次如期发布也有了更多的信心。</p>
<p>准则3：通过节奏协调明确的活动。</p>
<p>软件架构的受益人分布在许多不同的组织中。一个共享的架构节奏能帮助这些自治团体跨越组织边界协同工作，因为它能帮助建立关于关键事件何时发生以及如何发生的共同假定。例如，如果一位产品开发员知道每年有一个架构主发布和若干季节性的维护发布，他就可以根据预期的架构发布安排产品发布时间，更好地利用新的架构特性。</p>
<p>与准则3相关的反模式与模式如下。</p>
<p>1）反模式：销售未检验的产品</p>
<p>销售未检验的产品在此情况下发生：一个组织试图实现定期的建立，但这些建立经常编译失第15章　架构师的管理实践</p>
<p>在实践过程中，软件架构的主要障碍往往在于组织方面而非技术。创造切实可行的软件架构需要对技术的深入把握、良好的认知能力和沟通技巧以及大量艰苦的工作。技术上出色的架构往往由于没有全面地处理好组织管理因素而失败。架构师利用自己的知识影响团队，常被大家认为是无冕之王，因此架构师需要管理技巧。本章介绍了架构师的VRAPS实践。</p>
<p>15.1　VRAPS组织管理原则</p>
<p>VRAPS是为实践软件架构的组织管理原则提出的，包括构想、节奏、预见、协作和简化5个相关联的原则。每项原则都是实际可操作的，原则的提出都来源于构建软件架构的直接经验，并且都可以用来解释实践。VRAPS模型的焦点在开发和使用软件架构过程的组织管理方面，其应用环境不仅包括建立和部署架构的团队，还包括利用架构开发和利用产品线的团队和使用这些产品的客户。</p>
<p>受益人是指建立并长期保持架构的价值有重要影响的人或组织。受益人一般包括发起人、应用开发人员和应用客户，还可能包括其他重要的参与者，如技术供应方。</p>
<p>（1）构想原则：说明了如何向架构的受益人描述一幅一致的、有约束力和灵活的未来图景。</p>
<p>（2）节奏原则：刻画了一种在整个组织范围内的协调程度，即定期地根据可预测的速度、内容和质量对制品生产进行检查与规划。</p>
<p>（3）预见原则：要在预测未来与检查并适应现状之间做出平衡。</p>
<p>（4）协作原则：解决了如何识别对架构成功关键的团体，以及如何确保这些合作伙伴的有效支持。</p>
<p>（5）简化原则：要求理解组织的结构，了解架构最小的基本特征并最小化架构。</p>
<p>各个原则之间不是相互孤立的，图15-1解释了构想原则如何与其他原则交互。构想原则确立了总体方向，使得节奏原则所要求的协调工作能够进行。而一个好的节奏又可以使组织朝着构想原则制定的目标不断提供递增的进展。构想原则中的假设根据预见原则进行测试和验证。在架构演化中，应注意环境的变化，并把这些变化加入到构想中。构想帮助建立准则，以挑选合作伙伴和理解他人给架构带来的价值。这些合作伙伴的约束是一个好的构想的关键要素。构想对简化原则也起到了作用。预期的价值经过解释被运用到架构的决策中，而反过来又帮助完善构想。</p>
<p>alt</p>
<p>图15-1　构想与其他原则之间的交互关系</p>
<p>所有其他的原则也是彼此之间相互影响的。例如，节奏原则中的协调组活动如果没有了协作是不可能完成的。通过在每个开发周期中关注最小的关键需求，节奏原则又帮助了简化原则的进行。</p>
<p>15.2　概念框架</p>
<p>为了更好地使用VRAPS原则，我们用准则、模式和反模式来对各项原则进行补充。准则用于判断每项原则的实施效果如何。模式描述了开发和使用软件架构时可能遇到的常见问题和解决方法，能够帮助组织改进原则。反模式则描述了组织在实践中可能遇到的陷阱。</p>
<p>1．准则</p>
<p>为了把原则运用到实践中，需要可操作的实施细节。准则把广泛的原则翻译成是否和如何执行原则的细节。</p>
<p>2．模式</p>
<p>第一项原则都附有一组模式，它描述了开发或者使用软件架构时可能遇到的常见问题的解决方法。模式更注重于解决特定情况下的问题，传达了在给定背景和多方竞争因素下针对常见问题的解决方案。</p>
<p>3．反模式</p>
<p>反模式描述了组织在实践中可能遇到的陷阱，描述了不该做的事情，或者用在错误背景下的解决方案，可以帮助更深入地理解原则。</p>
<p>15.3　形成并统一构想</p>
<p>构想描述了架构的未来，提供了架构使用的环境和动机。构想是未来价值到架构约束的映射，构想要成功，则必须把它所能提供的价值与客户的约束相对应。构想也必须是明晰的、有约束力的、一致的和灵活的，从而能够被其受益人理解并有效地运用。</p>
<p>例如，在大型组织中，管理层可能把项目架构师与维护产品构想的高级经理分隔开来。这种距离会维持构想一致性，导致架构难以满足维护要求，引发后期运行成本问题。为了应对类似组织结构产生的复杂性，高级经理和架构师之间建立稳固的、积极的关系以及共享统一的构想至关重要。</p>
<p>把价值映射为架构约束，要求开发人员把约束诸如接口、开发语言和模块边界等映射到特定的客户价值上。促使受益人把约束与客户价值捆绑需要高超的技艺，用例建模是把架构的预期使用与能够被满足的切实的用户目标连接起来的一种方法。例如，识别并表达出似乎无关的用例之间的实质性联系是建立构想的一个重要内容。</p>
<p>15.3.1　形成构想</p>
<p>构想需要维持一致性与协调性。一致性是指受益人的各种期望之间妥协，以及它们与现在和将来的架构之间的需求满足程度。灵活性是指受益人在不破坏架构的情况下，在现有架构之上完成事先没有预料到的需求的容易程度。</p>
<p>一致性并不意味着所有受益人之间拥有一张完全一致的构想视图，而是指各受益人共享的视图根据他们不同的视角保持一致。RUP的“4＋1架构视图”体现了获得这种一致性的方法。RUP通过逻辑视图（Logic View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）和用例视图（Use case View）建立了架构视图。这些架构视图的不同点在于，它们根据不同目的表示系统（例如，用例视图表示了系统的最终用户功能）。</p>
<p>架构师常负有将现实引入业务构想和将构想变成现实的责任。架构师可以推荐技术，包括如何以及何时采用这些技术， 由此来帮助确定业务构想的哪些部分可以在短期内实现，以及各部分实现的次序。</p>
<p>架构师更像管理者而并非实施者，Dean Thompson说：“作为架构师更多地意味着权衡业务、组织运作和使用技术，而不仅仅是技术细节。”例如，架构师应该全面研究整个组织，找出各利益方关注的重点，然后妥善平衡，建立符合主要关注问题的架构描述。</p>
<p>多方整合能促进构想的形成。多方整合是组织各利益方的机制，用于确保获得构想并使其稳定；是指在一个公共的组织层次上对信息、决策和资源进行协调。多方整合能使从事硬件设计的基层经理理解软件设计和开发人员，以及市场营销、客户支持和市场营销的同事的期望，包括增强组织与客户和外部供应者沟通的能力。</p>
<p>Thompson归纳了形成架构构想的三步方法：清楚明确地阐述一条迫切的客户价值；将客户价值映射为少数特定的能解决的问题；将以上问题转译成一组特定的约束条件。</p>
<p>成功的架构师用明确的客户价值映射规划未来，以使用户及它们的客户能将其与约束联系起来。架构师必须格外关注产品开发人员和最终的客户，而且为了成功，还要发动所有其他人做类似的事情。</p>
<p>15.3.2　将构想原则付诸实践</p>
<p>下面的准则、反模式和模式能帮助建立、形成、维护一个被共享的构想，将构想原则付诸实践。</p>
<p>用于检验构想原则是否起作用的准则如下。</p>
<p>（1）架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>（2）实施人员是否信任并使用架构。</p>
<p>（3）关于架构和构件的潜藏知识对其用户（开发团队）是否是可见的、可获得的。</p>
<p>构想原则中准则到模式、反模式的映射如表15-1所示。</p>
<p>表15-1　准则到模式、反模式的映射</p>
<p>alt</p>
<p>下面详细介绍与各准则相关的反模式和模式。</p>
<p>准则1：架构师的构想与发起人、用户、最终客户期望实现的目标是否保持一致。</p>
<p>为了获得一致、迫切和灵活的架构，需要产品线经理、架构师和实施经理等达成共识。而如果没有阐明用户价值，则会导致构想脱离了重点。</p>
<p>与准则1相关的反模式与模式如下。</p>
<p>1）反模式：风险后置</p>
<p>形容这样统一受益人的构想：用最小的妥协、最大的优化规划出一个构件以满足所有冲突利益的需要。这种统一方法的问题是，设计出来的构件往往在理论上可行，但实际运行中出现风险。</p>
<p>一条新产品线的架构师或经理，需要开发看似很棒但实现有风险的构件。这些要完成构件可能需要打破“物理定律”才能完成，这些风险可能在制品交付的最后才能显现。可是有一批工程师仍然坚持开发这些构件。风险构件被安排到最后完成，以为这样可以有时间消除风险。可是，当计划好的完成日期临近时，依然无法交付。尽管架构在演示的幻灯片上运转良好，实际上却无法正常工作。</p>
<p>面对这种情况，需要分析并阐明风险， 向高级经理提供一个选择，要么承认风险，要么调整任务。</p>
<p>2）模式：前后一致</p>
<p>要求推动架构投资的高级经理积极地维护构想，并防止构想受到短期压力的影响。</p>
<p>一个公共的架构被几个产品共享，它已经变得比预期要复杂得多。而客户们针对每件产品又提出了以前没有预计到的功能特性。如果加入这些功能特性，则不能保证进度，但如果不开发这个特性则可能失去一位重要客户。</p>
<p>这样的情况下，需要评估架构构想的质量和稳定性。只有当两者都正常时，才能采取进一步行动。如果该新特性不属于原来的产品构想支持的代价范围，那就应该放弃开发这个新特性。如果构想不明确，在短期内就交付很可能导致大量缺陷。此时应与客户、架构师和销售、产品、支持人员以及开发经理一起加强产品的构想。如果这个特性确实属于一个稳定的产品构想，那么应该在开发组织内核实这种一致性。</p>
<p>准则2：实施人员信任并使用架构。</p>
<p>只有使用架构，才能从中获得价值。然而，要让开发人员对架构构想充分信任需要做更多的工作，仅仅靠不断兑现承诺是不够的。开发人员需要把他们对构想的了解与他们认为对下一步行动有用的东西联系起来。开发人员在利用架构的过程中，可能会使架构向许多不同的方向发展。一个良好架构应与构想保持一致，同时又能满足用户的需求。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：墙头草</p>
<p>描述了这样一种情况：因为没有良好的构想，导致架构方向在竞争和客户压力的影响下经常改变。这种构想永远不能达到稳定以便有效地被共享。</p>
<p>在开发过程中，经常会出现这样一种情况：来自客户、竞争对手和高级经理的压力使得需要在一次发布的中途加入一些代价高昂的功能，高级经理甚至可能在没有咨询架构师的情况下决定提供这些功能。可是一旦交付了某个激进的功能，组织马上就会陷入对该功能的支持工作中。以后的发布会因需要提供向后兼容而变得更为复杂。</p>
<p>在这种情况下，要做的是理解并阐明构想。方便变更需求是成功构想的一部分，要对其进行规划。高级主管要与架构师一起紧密地工作，理解变更的后果并做出正确的权衡。在建立了构想之后，可以用前后一致模式来评估特定的变更建议。在把功能特性加入到发布之前，要坚持达成一致意见。这需要一种固定的机制，以使达成一致成为正常业务的一部分。如果架构满足了高层的约束条件，那么在细节的实施方面可以允许更多的灵活性。在最极端的情况下，解决墙头草问题可能需要寻找新的、期望更为接近的受益人。</p>
<p>2）模式：三个臭皮匠</p>
<p>三个臭皮匠：反映了这样一种认识，即架构师并非总是架构构想的来源，架构师和客户一起充实、完善构想。</p>
<p>一个共同的架构或平台是产品线战略的关键，架构发起人希望产品团体能开发出“杀手解决方案”，而同时又能避免追随新的标准、潮流带来的困扰。</p>
<p>在这种情况下，需要抵制创建一个无所不能的架构的诱惑，建立一种能让架构师及其用户都能丰富、实现功能特性的构想。高级经理只提供构想、目标和原则，把架构和平台留给架构师，把实现细节留给合适的团队或层次。一个成功的产品线架构必须能为适应市场变化，能适应和采用新技术，能解决在概念阶段还不知道的但变化场景可预见的问题。</p>
<p>这是一项很少有架构师能独立完成的任务，然而，通过高级经理建立正确的顶层业务构想，架构师采取实现构想的正确行动就能取得成功。</p>
<p>准则3：关于架构和构件的潜藏知识对其用户是可见的、可获得的。</p>
<p>1）反模式：一叶障目</p>
<p>一叶障目：发生在这种情况下：开发人员过分专注于应用，以致不知道其他架构解决同类问题的通用的解决方案。</p>
<p>在一个组织中，工程团队正在实践代码所有制模式，工程师们都把精力集中在自己眼前的任务和职责上，没有把自己当作一个共享资源的看护者。陷入本反模式的工程师的视野很窄，面对其他开发同事的请求往往只求解决问题，不愿意多加考虑。这样导致的工作结果可能变得非常复杂、脆弱而且容易出错，这是由一名工程师所无法预见的情况造成的。</p>
<p>要解决上面的问题，需创造一种分享知识的愿望。例如，工程师培训等方式就可以起到一些作用，整个组织的人员启用知识管理平台也能促进产生这种愿望。</p>
<p>2）模式：轮流工作</p>
<p>轮流工作：要求参与架构的工作人员轮流在架构的不同部分上工作。这样能使他们对架构有更多的了解，并有机会发展非正式的人际网络。</p>
<p>当一个产品线的销售增长到一定程度，一个单一的、聚集的团队已无法支撑架构和实现，人员被重新组织到地理上分布不同的团队中。已有的沟通管道与新的形势已经不相适应。</p>
<p>通过帮教制（Apprenticeship）模式阶段性地轮流交换构件的所有权可以解决上面的问题。组织和鼓励构件的前任负责人抽出时间帮助新的负责人，轮转周期应该尽可能地与发布进度保持同步。该方法能使开发人员更容易地发现如何找到有关构件的知识，团队成员掌握某个构件或者在出现问题时知道应该问谁的可能性也大大增加了。因此，意外发生的次数减少了。</p>
<p>15.4　节奏：保证节拍、过程和进展</p>
<p>节奏原则使得软件架构在跨越组织边界的情况下开发和使用成为可能。由于许多参与开发和使用架构的团体是自治性的，不可能自上而下地协调这些团体，节奏原则提供了一个随时间变化的框架，可使团体同步各自的活动与期望。有了节奏，参与者就能知道何时关心和应该关心哪些活动。不仅计划中的活动可以被协调管理，节奏原则也可以协调那些非正式的但很关键的活动，例如团体间的交流，这样参与者就可以知道何时应该或不应该提出对于信息或支持的要求。</p>
<p>15.4.1　节奏定义</p>
<p>节奏是一个架构团体内部及它与客户和供应者之间反复出现的、可预测的工件交换活动。节奏有三个元素：速度、内容和质量。速度是指一个团体与另一个团体之间同类型交接发生的频率，例如架构团队与产品开发工程师之间。如果交接的时间是可预测的，移交则容易管理。稳定的发布计划是速度的一个例子。内容是指一个团体向另一个团体提供的价值。例如，一个团体开发一种新的或者要修改的特性被另一个团体用于满足某种需要。质量的含义是遵循开发过程确保架构没有缺陷。组织可以通过省略非增值的步骤来加快速度，但是如果重要的流程被截掉了，节奏就会遭到破坏。</p>
<p>节奏在团体和组织之间与内部提供一种协调活动的稳定力量，帮助移交管理。当节奏很强时，受益人能培养很强的预见、实施移交和交接的技能。节奏还能驱动活动完结，拥有良好节奏的组织通过建立有规律的阶段间隙来推动评估、再评估和其他工作的进展。</p>
<p>15.4.2　将节奏原则付诸实践</p>
<p>没有建立节奏会导致客户不满意、不期望的错误发生和工件无法一起工作。只有当以下准则出现时，才说明节奏原则起了作用。</p>
<p>（1）经理们定期地再评估、同步和调整架构。</p>
<p>（2）架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>（3）通过节奏协调明确的活动。</p>
<p>节奏原则中，准则到模式、反模式的映射如表15-2所示。</p>
<p>表15-2　准则到模式、反模式的映射</p>
<p>alt</p>
<p>准则1：经理们定期地再评估、同步和调整架构。</p>
<p>好的节奏需要有规律的节拍。对于架构组织的管理者，这意味着他们必须在稳定的间隙上再评估、同步和调整他们的架构计划。节奏的节拍还能提供一个计划过程的框架。具有良好节奏的一个组织用节拍而不是时间来衡量进度。</p>
<p>相关的反模式和模式如下。</p>
<p>1）反模式：一步成功</p>
<p>一步成功：是指当组织变得过于专注地向市场推出某项功能特性而导致内部节奏遭到破坏时发生的情形。组织被竞争所蒙蔽，全身心地专注于向市场提供该特性，却削减了质量，甚至可能破坏本来的节奏。</p>
<p>相关的解决办法有：把关键的功能特性作为团队节奏的一个组成部分来实现。围绕一个特定的主题来进行一次特定的发布，利用主题帮助抓住市场上的机会。如果关键特性特别复杂，则采用几次迭代来实现。但如果在实现关键特性的时候难以保持节奏，说明该特性的风险和复杂度比预计的要大，需要重新规划。</p>
<p>2）模式：发布委员会</p>
<p>发布委员会：描述了一种协调参与发布新架构的相关各方的方法。该模式向经理们介绍了一种在架构发布的最后阶段再评估、同步和调整架构的方法。</p>
<p>定期举办由组织中每个关键受益人参加的正式会议以引导发布的进程。在会议中，要复审产品功能特性和优先级的变更，从而使产品文档、市场承诺、公共关系、测试和开发保持一致。在适合的地方采用测量指标度量发布的进展，分享责任和依赖，做出如何前进的决定，并记录和传达会议的决定。参加委员会的成员应该保持稳定，会议成员的组成应保持一致，与会人员也应该有足够的决定权。</p>
<p>准则2：架构用户对架构发布的进度和内容具有高度的信心。</p>
<p>如果架构用户不信任架构发布的进度和内容，那么用户就可能不采用新的架构发布，或者可能选择另一个架构。用户对架构发布的进度和内容缺乏信心是一个警告信号，说明没有建立一个良好的节奏。</p>
<p>与准则2相关的反模式和模式如下。</p>
<p>1）反模式：超敏捷</p>
<p>超敏捷：发生在组织试图在开发过程中抄近路以维持稳定的发布节拍的时候。该反模式对用户所期望的架构质量和内容进行了妥协。</p>
<p>过程执行的合适方法取决于组织文化。在有些组织中，阶段性的软件审计可以用于保证过程被遵守。然而，在许多组织中，审计并不是一种改变或约束行为的有效方法，高层管理的行动能更直接地改变组织行为。是否已经分配了足够的资源来执行计划中的步骤，经理们是否创建明确的目标来保证对节奏的维持都有非常重要的影响。</p>
<p>2）模式：舍兵保帅</p>
<p>舍兵保帅：探讨了组织如何通过把不太重要的特性移到后面的发布周期以保持一个节拍。通过保持节奏，该模式可以使用户获得对架构发布进度更多的信心。</p>
<p>如果对构件的修订看上去无法及时完成时，而且该修订并不非常重要，应该尽快向受益人说明。在不对延误构件做变更的情况下，继续发布架构。为了避免因用户没有阅读或看见特性变更说明而造成的问题，应该确保从预发布开始就放弃该特性，这样用户就能在α或β测试中体验到变化，而不是在正式的产品发布中。可以在以后的发布中再把该构件的变更加进来。通过上面的方法可以保持发布的速度，使架构发布后的活动计划能按进度进行。该方法还能推动构件负责人按时完成他们的修订工作。因为架构的发布实现了承诺，开发人员增强了信任感，他们对下一次如期发布也有了更多的信心。</p>
<p>准则3：通过节奏协调明确的活动。</p>
<p>软件架构的受益人分布在许多不同的组织中。一个共享的架构节奏能帮助这些自治团体跨越组织边界协同工作，因为它能帮助建立关于关键事件何时发生以及如何发生的共同假定。例如，如果一位产品开发员知道每年有一个架构主发布和若干季节性的维护发布，他就可以根据预期的架构发布安排产品发布时间，更好地利用新的架构特性。</p>
<p>与准则3相关的反模式与模式如下。</p>
<p>1）反模式：销售未检验的产品</p>
<p>销售未检验的产品在此情况下发生：一个组织试图实现定期的建立，但这些建立经常编译失败或无法通过自动测试。这表明协作的失效。</p>
<p>由于团队不把编译和测试用例的失败当回事，认为在以后的开发过程中能消除这些不一致的情况，导致积累下来的问题越来越多，无法按时发布。</p>
<p>在这样的情况下，要确保对定期建立的承诺。管理层必须明确无误地告诉开发人员，定期建立应该成功。软件建立不仅应该包括编译产品，还应该包括某种形式的自动测试。对定期建立的流程进行修改，防止在修正失败的建立之前开展新的工作。同样地，以前曾经通过的失败测试用例应该马上处理。</p>
<p>2）模式：同步发布</p>
<p>同步发布是一种把节奏理念扩展到组织边界以外的技术。该模式提供了一种同步架构团队及其用户的活动的方法。</p>
<p>和你的合作伙伴一起确定交付架构特性的先后顺序，以便他们利用架构开发产品。应尽可能在架构的早期发布中包括这些特性。如果架构中的一些变化需要互补产品做出重大变更，那么应让这些变化出现在最早的预发布中。应该告知合作伙伴何时能够获得哪些特性。作为调整早期发布方式的回报，应与合作伙伴签订协议让他们把包含或需要你的架构的产品迅速推向市场。</p>
<h3 id="预测、验证和调整"><a href="#预测、验证和调整" class="headerlink" title="预测、验证和调整"></a>预测、验证和调整</h3><p>为了使对软件产品线的长期投资能产生回报，组织必须确保架构满足许多应用的需求。组织应能够预见变化并对变化做出反应，包括那些在设计架构时还没想到的需求。架构必须能够适应新的技术、标准、市场和竞争对手。刚开始设计架构时正确的假设几年以后可能就失效了，这就要求组织必须能够对架构进行预测和演化。</p>
<h4 id="预测、验证和调整的定义"><a href="#预测、验证和调整的定义" class="headerlink" title="预测、验证和调整的定义"></a>预测、验证和调整的定义</h4><p>预见是指建立和实现架构的人员根据变化的技术、竞争和客户需求预测、验证和调整架构的程度。</p>
<p>软件架构师不可能总能预测到未来。但是，既然一个成功的架构将被持续使用很长时间，架构师至少要对未来将发生什么做出合理的猜测。架构师必须考虑架构用户可能怎么变化，竞争形势将如何改变，未来的运行环境是怎样的。架构必须能够适应新的组织结构，特别是在一些像银行业这样合并和接管司空见惯的领域中。许多计划建立在对未来的假定上，但是预测意味着这些假定是作为架构描述的一部分而明确表述的。例如，有关的假定可能基于这样一种未来的情况：处理器速度依然遵循摩尔定律，在以后的10年里每18个月翻一番。当然，除非架构师有预知未来的超自然能力，否则这些预测不可能总是正确，所以需要验证。</p>
<p>验证不仅局限于传统软件工程的测试和检查技术，也包括对架构的基础假定的测试。例如，用户真的想要计划好的东西吗？现有的技术能实现用户的需求吗？分析这些假定的重要原因是，架构师及其发起人做出了许多关于架构的艰难决策。在架构成型前要对这些假定进行检查和确认，否则会导致代价高昂的错误。</p>
<p>软件架构的长期成功依赖于对假定的变更和通过预测及验证所获信息的适应程度。调整就是对架构计划及架构本身修正以加入新特性，从而能参与新兴市场的竞争或者在新的环境中生存。因此，调整要求组织具有敏捷性。调整可能不仅包含架构本身，还包括计划，甚至整个架构构想。</p>
<h4 id="将预见原则付诸实践：准则、反模式与模式"><a href="#将预见原则付诸实践：准则、反模式与模式" class="headerlink" title="将预见原则付诸实践：准则、反模式与模式"></a>将预见原则付诸实践：准则、反模式与模式</h4><p>下面的准则、反模式和模式为帮助判定组织在预见验证、调整架构方面提供了指导。当以下情况发生时，说明预见原则发生了作用。</p>
<p>（1）不断增强架构的响应能力：预见到的风险和架构客户及其客户的需求；市场驱动的标准和演变的技术；战略性业务方向的改变。</p>
<p>（2）通过快速复审和开发周期，评估技术和业务上的风险与机会。</p>
<p>（3）当认识到关键的估计或假设有错时，及时调整功能特性、预算。</p>
<details><summary>表15-3　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142106.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142106.png';" /></details>

<details><summary>表15-3　准则到模式、反模式的映射-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142120.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142120.png';" /></details>

<p>准则1：不断增强架构的能力以响应预见到的风险和架构客户及其客户的需求，市场驱动的标准和演变的技术，战略性业务方向的改变。</p>
<p>与此相关的反模式与模式如下。</p>
<p>1）反模式：遗漏细节</p>
<p>遗漏细节：描述了发现一个明显的功能特性被遗漏时的尴尬经历。每个人都关注发布的强大新特性，以致忽视了一些用户必不可少的功能。</p>
<p>对这种情况，需要识别关键用户群，和他们一起找出最重要的需求。这意味着要有一位对这些用户群有着深入了解的专题事务专家的参与。要调查的问题包括“哪些产品会建立在这个架构之上？”，“哪些产品是最重要的？”该方法也可以用来指导架构方向的改变。调研的覆盖面很重要，需要让高级经理了解这一过程以使他们在敦促实现其他高级特性和技术的时候，不会在无意中破坏这些基本特性的交付。</p>
<p>2）模式：示范区</p>
<p>示范区模式应用在如何决定哪个产品应该引入一个新架构的情况下。</p>
<p>挑选一个项目初步实现架构。该项目的客户渴望采用新技术，而且也愿意容忍获得该技术时可能存在的不便。当示范区项目投入使用后，架构师将从实际使用中得到关于架构的有价值反馈。在架构大范围应用之前，缺陷将被发现并解决，这也意味着缺陷的修订受后向兼容问题的约束较小。成功的示范区项目可以在建议其他项目时作为参考。</p>
<p>准则2：通过快速复审和开发周期，评估技术和业务上的风险与机会。</p>
<p>1）反模式：品尝未熟的果实</p>
<p>品尝未熟的果实：说明了当架构师没有考虑其用户的客户，而让其用户支持一种未成熟的技术时发生的情况。</p>
<p>在发起人的要求下，架构师采用了一种新技术来建立下一代架构，团队希望通过它胜过最接近的竞争对手。客户对架构糟糕的性能和各种各样的差错感到很失望，客户并不关心底层技术，他们只需要那些能帮助他们实现目标的东西，一些被以前的换代或升级害苦了的客户则对关于未成熟技术的承诺极度不信任。</p>
<p>在这种情况下，要审慎地选择引入新技术的正确场所。在引入后，要为最初用户提供额外的支持。在选择新架构解决方案时，必须愿意修改技术不完善的部分使其适合一个实际可用的解决方案。不要假定一个未经验证的架构能实现所有的承诺，应该分别在开发人员和产品用户的特定环境下测试你的解决方案。即便如此，还必须向采用新技术的用户提供大量的支持，要谨慎地设定用户正确的期望，留意他们可能遇到问题的迹象。</p>
<p>2）模式： $\color{green}{\text{架构复审}}$ </p>
<p>架构复审模式总结了怎样针对开发中的架构组织执行一次有重点的专家评估，以揭示有重大影响的问题和机遇，例如假设的冲突、可重用的现有方案等。</p>
<p>该模式提出在开发周期的关键时刻成立一个架构复审委员会以检查架构。一旦需求基线初步确定就应该进行首次复审。复审委员会的成员应该包括有经验的架构师、架构小组成员，可能还有客户，人员不要太多，最多七、八个人。在早期复审中，应检测各种假设，看看市场上是否有可购买的解决方案，并进行其他条理性检查。后期的复审应验证假设，确认架构是否满足了需求。注意要让这些复审保持重点。</p>
<p>这种模式可以避免增加成本，因为复审能够在开发过程的早期发现缺陷，这样就可以及时修正。复审能发现可以取代新的开发活动的构件。此外，它还增强了客户对架构提供已承诺能力的信心，从而促进客户使用架构。</p>
<p>准则3：当认识到关键的估计或假设有错时，及时调整功能特性、预算。</p>
<p>1）反模式：创造奇迹</p>
<p>创造奇迹：描绘了当足够的证据显示基础假设和估计已经完全偏离目标时，对架构开发和实现计划不作任何修改将发生的情况。</p>
<p>解决方法分为如下两个部分。</p>
<p>（1）找到架构的基础假设并积极努力测试这些假设。架构复审和示范区模式提供了获取这类信息的手段</p>
<p>（2）一旦发现错误的估计或假设，必须准备好对此采取行动。这可能意味着调整项目进度、功能特性或者启动意外处理计划，此外还包括提醒客户并重新协调进度和发布的内容等。</p>
<p>还应该特别小心那些遏制信息和创意传播、掩盖错误假设的证据的组织文化。无论何种情况，都应该确保把足够的资源编入预算计划，使得当不可避免的意外发生时，有可分配的进度和人员。</p>
<p>2）模式：外包</p>
<p>外包模式展示了怎样适应这种情况，即客户要求的新标准或技术并不属于当前或计划中的核心能力。它提供了指导以说明何时及怎样选择一个已有的第三方构件，或者与供应者合作。</p>
<p>如果存在第三方构件，应考虑采用。如果没有这样的构件，那么组织应该找到合作伙伴来开发和支持该构件。要确定潜在的合作伙伴是否把你需要的构件视为其主营业务的一部分。例如，他们是否能够把它卖给许多其他的客户；评估他们交付和支持该构件所需的特定工作量。把潜在的合作伙伴当作供应商和业务伙伴以评估其能力和信用。基本的规律是，他们必须为你做的专门开发越多，信任程度就要求越高。类似地，信任度越低，你面临的进度和财务风险就越高。如果发现一个非常可靠的潜在供应商，就应该外包构件开发。</p>
<h3 id="协作：建立合作型组织"><a href="#协作：建立合作型组织" class="headerlink" title="协作：建立合作型组织"></a>协作：建立合作型组织</h3><p>协作也是软件架构成功的关键之一，因为不同团体参与者对架构的开发、实现和使用都是很重要的。这些团体跨越了各种各样的组织边界，如团队、地理位置、部门甚至公司。每一个对架构关键的团体必须知道如何使用、努力改进架构从而为自己的利益服务。协作原则解决了如何识别对架构成功起关键作用的团体，以及如何确保这些合作伙伴的支持等问题。</p>
<h4 id="协作定义"><a href="#协作定义" class="headerlink" title="协作定义"></a>协作定义</h4><p>协作是指架构受益人保持明确的、合作的角色并将其所提供和获得的价值最大化的程度。合作是指受益人彼此之间存在一些共享的预期，应该明确表示出达到或未达到预期会有哪些奖励和惩罚。成功协作不仅仅要求架构负责人满足契约条款，合作伙伴还必须采取行动确定和提供预期价值，根据已达成的条款给出特定问题的解决方案。</p>
<h4 id="将协作原则付诸实践：准则、反模式与模式"><a href="#将协作原则付诸实践：准则、反模式与模式" class="headerlink" title="将协作原则付诸实践：准则、反模式与模式"></a>将协作原则付诸实践：准则、反模式与模式</h4><p>协作很容易理解，但将其付诸实践并不简单，当许多团体必须在一个组织内（外）的同一层次上进行合作时尤其如此。正式定义的协作网络与非正式协作网络决定了一个软件架构能否成功。以下准则提供了一种方法用来确定受益人为了使架构与产品服务的价值最大化而进行合作的程度。当出现以下几种情况时，说明协作是有效的。</p>
<p>（1）架构师不断地努力了解谁是最关键的受益人，他们如何贡献价值，以及他们需要什么。</p>
<p>（2）受益人之间达成明确和强制性的契约。</p>
<p>（3）通过社会行为制度和非正式规范强化合作。</p>
<p>表15-4介绍了准则到模式、反模式的映射。</p>
<details><summary>表15-4　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142306.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142306.png';" /></details>

<p>准则1：架构师不断地努力了解谁是最关键的受益人，他们如何贡献价值，以及他们需要什么。</p>
<p>满足受益人的需求说起来很容易，实施起来要困难得多。挑选一批集中的首要客户，找出保证他们参与需要做些什么，然后交付这些内容，这样做可以增大成功的机会。</p>
<p>与准则1相关的反模式和模式如下。</p>
<p>1）反模式：光说不做</p>
<p>光说不做描述了这样一种情况，即架构师知道了用户的需求却遗漏了为了向他们提供有价值的东西所应该做的事情。</p>
<p>架构师忙于其他事务，没有与开发人员进行稳定的交流，各产品团队按照自己的理解开发并升级了产品，放弃了原来同意的清晰的接口。</p>
<p>与许多反模式一样，该反模式中最困难的部分就是，当发生这种情况时如何识别它。当你认为“我们可以以后再补充这些细节”时，应该保证你和你的团队至少理解一些关于开发人员如何从平台获益的明确的例子。模式“了解你的受益人”提供了一种掌握需要哪些措施让受益人参与协作的方法。客户互动模式提供了一些明确、简单和直接的规则与建议，有助于发展有效的协作关系。</p>
<p>2）模式：了解你的受益人</p>
<p>本模式说明了如何利用价值链来识别关键受益人，积极听取他们的意见并获得承诺与支持。</p>
<p>把架构成功的构想与那些最符合合作伙伴能力并积极去做的事情的活动统一起来。阐明设想中架构所能提供的价值，例如架构如何帮助现有产品取得一致的用户界面或者继续保持市场优势，或者是能打开一个针对新产品的全新市场。在初步阐明构想之后，确定潜在的合作伙伴以及他们的能力和利益如何与构想保持一致。</p>
<p>准则2：受益人之间达成明确和强制性的契约。</p>
<p>1）反模式：不记录讨论结果</p>
<p>不记录讨论结果说明了当一个架构团队回避采取必要的行动与其最直接的用户达成明确的契约时会发生什么情况。当用户们失去兴趣时，虽然对话仍在继续，但是讨论已经失去了实质内容，而且通常会浪费所有人的时间。</p>
<p>要确保取得对关键受益人的利益与职责的明确理解。把这些认识记录下来，当互动变得消极或者缺乏建设性时，可以求助于这些文件。这种做法总是很重要，对于那些对别人有强烈影响的参与者而言尤其关键。当状况似乎要失控时，回到当初的约定可以把架构团队从漩涡中解救出来。</p>
<p>2）模式：互惠互利</p>
<p>本模式介绍了一些非常重要的做法，用来建立足够稳固的关系以保障软件架构的共享和成功使用。</p>
<p>互惠互利要求在合作伙伴之间进行公平、主动的价值交换。当共享一个架构的团体之间的关系定义好之后，应该对正式和非正式的契约复审以保证公平的交换。预算中应该包括代码负责人响应其他团体请求所花的时间。要对各个团体支持其他团体的程度进行衡量，而不仅仅评估他们完成自身任务的情况。</p>
<p>准则3：通过社会行为制度和非正式规范强化合作。</p>
<p>协作包括正式和非正式两方面，为了真正巩固协作，需要用社会行为制度和非正式规范来促进合作。</p>
<p>1）反模式：非正式时间做正式工作</p>
<p>非正式时间做正式工作介绍了这样一个情况，即一位工程师申请修改某个构件以便让其他团体使用，却得到一个令人困惑的答复：“你可以做，但是要用你个人的时间。”</p>
<p>让工程师利用业余时间修改，架构师就失去了控制其过程和结果的能力，他可能没有采用组织的文档标准，诸如同级复审等步骤甚至连测试也有可能被删减或完全忽略。如果这种产品加入到其他团队的工件中，这位工程师在需要完成日常任务同时，还接到大量要求提供支持的请求，导致工程师精疲力竭。</p>
<p>对于以上情形，要制定计划奖励工程师花在共享构件上的时间，尽早兑现奖励能减少工作量和大量压力。应仔细考虑如何处理将来这一构件成为多个外部项目的关键的可能性，在权衡利弊时必须根据组织纪律和常理判断，包括企业文化、管理的洞察力、进度压力的程度以及当前状况的细节。很多组织把员工用于开发、维护被团体或项目外部所共享的解决方案的时间编入预算，这样能够预防工程师在利用非正式时间做正式工作开发时对项目的代码偷工减料，并确保你的小组对其他团队或项目的支持能力。</p>
<p>2）模式：杜绝意外</p>
<p>该模式描述了如何在不失去依赖你的构件的其他团体信任的情况下，调整对进度或功能特性的承诺。</p>
<p>要尽早提醒用户注意变更，并及时协商解决方案。在决定变更的内容之前，要确保通知、咨询了构件的用户。让他们了解虽然现在的做法对软件架构能产生直接的影响，但其实它们有着更为广泛的应用。</p>
<p>3）模式：和HR密切合作</p>
<p>和HR密切合作介绍了这样一种做法，即提拔雇员并不仅仅根据个人的技术技能和经验，还要考察其有效地、合乎道德地利用非正式人际网的能力。</p>
<p>软件开发是一种社会活动。可是，很多工程师属于内向型性格，工程师需要与他人交流以获得完成其工作所必需的信息，大部分高级技术岗位要求能迅速获得广泛的潜藏信息。有着广泛非正式人际网的工程师比没有这种网络的工程师能获得质量更好的信息。</p>
<p>在作提拔决定时，要考察一名工程师的非正式人际网的有效性。此时，应找出具体的事例，例如，这位工程师是否通过团队外部的合适人选，获得了曾困扰其同事、阻碍项目进展的问题的答案？如果组织已有晋升的明确标准，那么也可以对此标准做类似的调整。经理们应该避免破坏非正式人际网。</p>
<h3 id="简化：澄清与最小化"><a href="#简化：澄清与最小化" class="headerlink" title="简化：澄清与最小化"></a>简化：澄清与最小化</h3><p>架构师和高级经理必须协力保持架构和组织的平衡。聚焦于客户和业务价值，为架构师提供了方向和指南。确定关键价值是不容易的，尤其是当新客户和新产品的加入使架构偏离原来的方向时，困难会显著增加。构想定义了这种关键价值，而且为实现价值建立了约束。简化则将构想翻译成产品。</p>
<p>简化软件架构的原则概念上看似简单，而实践中它要求对价值非常坚定地专注，以及对架构所生存的组织的理解和支持。架构师必须了解架构最小的基本特征。简化原则还要求通过努力，把这些特征传达给实现架构团队的每一位成员。</p>
<h4 id="简化定义"><a href="#简化定义" class="headerlink" title="简化定义"></a>简化定义</h4><p>简化是指将所作用组织与环境都进行巧妙地理解与最小化，组织形成架构并且思考架构。在决定简化架构时，应当留意组织的结构；否则，你会发现你所做的改变只是暂时的。因此在简化架构之前，必须澄清组织和架构。</p>
<p>澄清组织意味着真实地理解你计划部署架构于其中的组织结构及其影响力（force）。架构对架构团队和客户都必须是清晰的。在简化架构之前，架构师必须精确地知道架构被期望做什么和如何完成这些任务。有时候看似很容易的任务，结果实现起来却很复杂，如果这些复杂性没有被理解清楚，那么建立的架构就可能完全不适合目标任务，而这样的架构会使实现更加复杂。澄清架构就是提供用户所需要的细节。</p>
<p>如果一个组织具备简化、协作和节奏等技能，长期共享架构就能够最小化代码、文档和过程。不必去新发明大量新的代码，却可以开发一种被工程师跨组织共享的公共语言。共享也能促进理解，因为它能最小化用同样术语描述完全不同概念的风险。共享并不能自动产生最小化，在有些不好的组织情况下，共享可能导致架构膨胀。</p>
<h4 id="将简化原则付诸实践：准则、反模式与模式"><a href="#将简化原则付诸实践：准则、反模式与模式" class="headerlink" title="将简化原则付诸实践：准则、反模式与模式"></a>将简化原则付诸实践：准则、反模式与模式</h4><p>当以下准则都满足时，说明简化原则起作用了。</p>
<p>（1）开发人员长期使用架构，减少了总成本和复杂性。</p>
<p>（2）架构小组明确理解关键最小需求，并且将其构造成多应用共享的核心元素。</p>
<p>（3）通过长期的预算和行动确保当相关元素没有被共享、增加了不必要的复杂性时，或者是因为有明确的业务理由时，把相关元素从核心移走。</p>
<p>表15-5介绍了准则到模式、反模式的映射。</p>
<details><summary>表15-5　准则到模式、反模式的映射</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904142443.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904142443.png';" /></details>

<p>准则1：开发人员长期不断地使用架构，减少了总成本和复杂性。</p>
<p>使架构被正确地使用，需要获得并维持经理和实施人员的信任。当存在一个明晰的公共架构构想时，系统可以逐渐变得更加简单。Grady Boody发现，“只有对一个系统的架构有清楚的理解，才能揭示公共的抽象和机制。”利用这种公共性能构造出更简单、更小和更可靠的系统。</p>
<p>与准则1相关的反模式和模式如下。</p>
<p>1）反模式：简单复制并修改</p>
<p>描述了当程序员在学会使用或重视架构之前被强迫迅速完成任务时发生的情况。他们不与构件负责人协商变更就复制并修改架构的部分代码，虽然复制提供了一个快速应付开发新特性的压力的方法，但是它通常会带来深远的后果。例如，如果在原始代码中发现了一个缺陷，组织怎样才能确保修正你和同事复制的所有代码呢？</p>
<p>在一个构件的生命周期中，有几个时机可以避免复制。鼓励工程师在复制构件之前先从构件负责人那里获得变更。可以把避免复制的推测方法加入编程风格指南，以便在代码复制期间识别和去除复制；如果有恰当的理由，这些推测方法可以允许有限的复制。也可以用自动化工具来识别复制代码，特别是在大型遗留系统中。当复制被识别后，可以用一些代码重组技术来去除重复的代码。</p>
<p>2）模式： 由慢而快</p>
<p>描述了当开发人员为了跟上进度而拒绝使用架构结果却更慢时应该怎么做。解决方法是：放宽进度，加强过程。</p>
<p>让开发人员参与架构期望解决的问题的讨论，并通过开发部分解决方案来培训他们，给予过程比进度更高的优先级。指导开发人员逐步采用架构，把以前使用过这种过程有能力修改架构或过程来解决不同问题的专家介绍给开发团队，系统地、认真地遵循验证过程。</p>
<p>准则2：架构小组明确理解关键最小需求，并且将其构造成多应用共享的核心元素。</p>
<p>与准则2相关的反模式与模式如下。</p>
<p>1）反模式：缺乏有效抽象</p>
<p>缺乏有效抽象是直接面对应用编程，虽然开始简洁，但随着应用发展，系统缺乏共享基础。该反模式描述了两种简化的努力走向极端的情况。榕树描述了长期建立单点解决方案的后果。单点解决方案通常是满足一个特定客户需求的最简单方法。根部肥大描述了一个架构或平台小组为平台所支持或可能支持的每个产品开发了专有的特性。</p>
<p>开发小组通过从头开发或者复制一个相关产品，然后根据当前问题进行修改来确保产品尽可能地简单。这样可以很快向客户提供初始产品。然而，这些产品没有共享任何东西。随着每个产品的维护和升级。榕树反模式开始出现，各个产品之间的分离越来越大。由于没有被一个共享平台强力支持，每一个分离产品都要求有自己的支撑结构，很像一棵榕树的分枝被很多枝蔓支撑。</p>
<p>对于这种情况，可以考虑采用类似先复制后合并模式的方法把很多为了适应特定功能特性而被修改的核心架构部分重新并入内核。如果先复制后合并和维护多个产品都不可行，就应考虑通过框架团队来建立一个共享平台。</p>
<p>根部肥大反模式则用枝少干粗的形象描述了这样一种情况，即一个架构或平台小组开发了太多针对单个客户的特性。结果共享了太多的功能，导致平台太大、太慢、推出太迟。根部肥大看起来就像一个倒立的马提尼酒杯，底部很大，杯口太小。</p>
<p>通过其他安排帮助产品小组开发不属于架构的产品特定模块，防止产品专有特性进入平台。把一个最小的共享特性集列入平台计划，并根据优先级以稳定的发布进度交付特性。</p>
<p>2）模式：迁移途径</p>
<p>迁移途径反应了在这样一种情形下的解决方案：架构师打算利用当前架构来支持一个新的有价值的应用领域。但是要在该新应用领域获得成功，需要当前用户所不具备的技能和观念，而拥有这些技能的用户团体却习惯于与当前平台不同的解决问题的方法。</p>
<p>对于这样一种情况，要选择一类最有可能扩大架构价值的采用者，并且努力使架构能被他们很快地理解和采用。考察所有类型的早期采用者，了解他们解决问题的方法和技能。确定哪一种类型最有可能理解或者预见到技术革新的成效，并且严格衡量该类型的用户是否具备解决方案所需的技能和知识。为有目标构想但缺乏重要技能集的专业人员提供迁移途径，提供一个简单的从平台获得基本成果的方法。然后，引导这些用户逐步更具体地使用平台。</p>
<p>准则3：通过长期的预算和行动确保当相关元素没有被共享、增加了不必要的复杂性时，或者是因为有明确的业务理由时，把相关元素从核心移走。</p>
<p>改进一个架构需要时间和经费的稳定投入。稳定性确实很重要，因为当高级经理或主管最不愿意专注于架构时，也是架构最脆弱的时候。他们很容易被诱惑把架构师拉去参加一个紧急的项目以实现一个新特性，而使架构无人照看。</p>
<p>与准则3相关的反模式与模式如下。</p>
<p>1）反模式：编码大于架构</p>
<p>该反模式表明要防止架构师成为实现者。</p>
<p>首席架构师负责调整和维护架构，却被调动了工作要求竭尽全力地实现一个新特性集。这些特性实现了，架构小组却失去了领路人。因为没有时间对架构做出深思熟虑的改变，只好创建了架构的一个特殊版本来解决问题。结果新特性无法适合当前的架构。因为维护一个缺乏概念完整性的产品的工作量太大，结果问题越来越多。</p>
<p>为了防止出现这种情况，应该把首席架构师的时间合理分配给实现新特性和调整架构两个任务，让最能干的工程师来领导实现新特性。在提供时间和资源的同时，允许首席架构师指导实现，以使架构适应新的需求。</p>
<p>2）模式：统计构件变更</p>
<p>统计构件变更是一种通过观察不稳定程度来挑选需要调整的架构构件的方法。</p>
<p>如何才能知道应该重组（Refractor）什么——即从内核去除或简化什么呢？通过长期观测每个构件或子系统的不稳定程度，那些最不稳定的构件就是重组的候选者。因为不稳定表明构件是脆弱和不灵活的，因此应当根本改变该构件。也可以采用其他监控策略，例如监控讨论组以掌握经常被请求的构件。一名经验丰富的实施人员利用该方法可以很快确定哪些构件和子系统是简化的最佳目标，从而节约了时间和精力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch14-%E5%9F%BA%E4%BA%8EODP%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch14-%E5%9F%BA%E4%BA%8EODP%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch14-基于ODP的架构师设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:56:12" itemprop="dateCreated datePublished" datetime="2021-07-19T12:56:12+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 16:57:13" itemprop="dateModified" datetime="2021-09-26T16:57:13+08:00">2021-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="基于ODP的架构师设计"><a href="#基于ODP的架构师设计" class="headerlink" title="基于ODP的架构师设计"></a>基于ODP的架构师设计</h2><p>软件系统架构设计方法是一个实践性大于理论性的工作。从软件有模块概念那天起，就有了总体设计，研究模块、构件与它们之间的关系。架构设计虽然可以归集到几种风格，但面对复杂的应用环境，不同应用领域对架构的理解差异非常大，用事实说话是最基本的研究方法。本章在RM-ODP多视点架构模型上，探讨应用于分布式信息系统的软件架构开发，对软件生命周期其他阶段的影响，特别是架构师在开发过程中的任务与作用。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/caolaosanahnu/article/details/10998099">软件体系架构：RM-ODP参考模型简介</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/seacean2000/article/details/102473736">基于ODP的架构师实践问答</a></li>
<li><a target="_blank" rel="noopener" href="http://www.rm-odp.net/">官网</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ODP/68318?fr=aladdin">Open Distributed Processing</a></li>
</ul>
<h3 id="基于ODP的架构开发过程"><a href="#基于ODP的架构开发过程" class="headerlink" title="基于ODP的架构开发过程"></a>基于ODP的架构开发过程</h3><p>系统架构反映了功能在系统构件中的分布、基础设施相关技术和架构设计模式等，它包含了架构的原则和方法、构件关系与约束，并能支持迭加或增量开发。以软件架构为中心的开发过程是以质量和风险驱动的，最终提供一个稳定、低风险的系统架构，并满足客户的需求（包含潜在需求）。</p>
<p>开放分布进程的参考模型（RM-ODP）是一个ISO标准，它为分布式计算进程提供了一个框架。RM-ODP定义了分布式系统的重要性质：开放性、整体性、灵活性、可塑性、联合性、可操作管理性、优质服务、安全性和透明性，并定义了一组视点。RM-ODP视点定义大体对应于IEEE 1471定义，RM-ODP定义的5个视点如下。</p>
<p>（1）企业视点：在如下因素的环境中分析系统，商业需求和策略、以及系统的范围和目的。RM-ODP处理可能会影响系统中的与企业相关的信息，如组织结构等。</p>
<p>（2）信息视点：指信息的结构，它的变化、流程以及在不同功能间的逻辑划分。</p>
<p>（3）计算视点：重点在于把系统分解为实体和实体间的接口。</p>
<p>（4）工程视点：处理分布式系统对象之间的交互，以及交互是如何得到支持的。</p>
<p>（5）技术视点：定义构成系统的硬件和软件构件。</p>
<p>体系结构视点是把抽象的符号或图表（如UML）运用到具体的体系结构开发任务中。每一个视点有具体的建模目标和系统相关者。例如，环境视图提供了对系统边界及与系统发生交互的外部实体集合的概述。分析视图提供了一个以建模问题而不是答案为中心的实体的抽象集合。</p>
<p>以描述软件设计为目的的视点包括构件、构件交互及构件状态。视图提供了一个对于逻辑运行结构及其功能，以及它们之间通信的映射。子系统接口依赖视图提供了一个子系统依赖关系和接口的图形表示；分层子系统视图提供了一个所有子系统高度抽象的视图；逻辑数据视图提供了构件共有的数据模型描述。</p>
<p>不同视图解决不同方面的问题，这是应对复杂问题的基本研究方法（分治）。采用ODP从5个视点描述信息系统架构，对整个系统开发过程有一定指导意义。除了架构设计阶段，其他阶段对架构师也提出不同的任务与要求。图14-1展示了整个系统及架构开发的10个过程。</p>
<details><summary>图14-1　系统架构开发的10个过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135503.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135503.png';" /></details>

<p>本章按图14-1的次序，探讨架构师的任务与设计工作。</p>
<h3 id="系统构想"><a href="#系统构想" class="headerlink" title="系统构想"></a>系统构想</h3><h4 id="系统构想的定义"><a href="#系统构想的定义" class="headerlink" title="系统构想的定义"></a>系统构想的定义</h4><p>系统构想是指一个系统开发人员与系统用户之间共同的协议。按照该协议，系统开发人员需在特定的时间内完成系统用户的需求。系统构想必须简短而切中要点，给人以清晰的感觉。它不是一成不变的，必须根据系统的不同而不同。</p>
<p>构想描述建立了从需求分析开始的所有项目活动的语境，它高度概括了企业业务架构的核心内容。</p>
<h4 id="架构师的作用"><a href="#架构师的作用" class="headerlink" title="架构师的作用"></a>架构师的作用</h4><p>讨论建模的时候，我们曾提到关键词有目的、关注点、假设和优先级，它们都是系统级的“构想描述（Vision Statement）”的基本元素。如果它们在系统开发过程中改变，项目就有被抛弃的危险。因此，以架构为中心的开发的第一步就是建立一个构想描述，且假定构想描述在系统的各个开发阶段不会改变。所有的改变必须在关键的项目计划中有所反映，特别是在系统架构中。</p>
<p>系统构想包括为客户、为软件系统开发团队等受益人创建的，有助于各方明了系统的目标和范围。对开发者而言，从宏观层面上显示系统架构的需求，为待开发系统提供一个结构清晰的概要，确保系统开发的计划、设计等阶段能依次有序地展开。</p>
<p>系统构想阶段，架构师合理的介入，有以下好处。</p>
<p>（1）有利于使系统架构师本身对系统的看法更加全面、准确。</p>
<p>（2）有利于统一系统开发人员对系统的看法。</p>
<p>（3）有利于正确确定需求的优先次序。</p>
<p>（4）通过系统构想，可以在最大程度上提高客户对设计等过程的参与程度，更好地与客户沟通。</p>
<h4 id="系统构想面临的挑战"><a href="#系统构想面临的挑战" class="headerlink" title="系统构想面临的挑战"></a>系统构想面临的挑战</h4><p>建立和共享架构构想要面临着很多的挑战：架构师对其控制能力之外的因素（例如组织等）通常无能为力；当产品线由一个架构来支撑时，构想就会受更多的因素制约。此外，如果共享的架构构想有问题时，不易马上觉察到。不过，可以通过有效地评估，以及高级经理和架构师之间保持紧密的联系来克服这些困难。</p>
<p>除了以上介绍的挑战外，在系统构想阶段，还必须面对以下几种情况。</p>
<p>（1）很多架构师把架构看成是他们独自的创造，而且只要他们认为合适的就进行修改。</p>
<p>（2）有些人不是拥有产品线构想的高级经理，却总是由这些人来决定雇佣谁来做架构师。由于没有参与架构师的招聘工作，高级经理们将无法评估架构师的能力以及理解并实现其构想。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="架构师的工作"><a href="#架构师的工作" class="headerlink" title="架构师的工作"></a>架构师的工作</h4><p>需求一般定义系统的外部行为和外观及用户信息，而不用设计系统的内部结构。外部行为包括了用来保证外部行为能够完成而所需的内部行为（例如持续性或计算）。外观包括用户界面的布局和导航，用户信息包含用户概念数据结构及关系模型。</p>
<p>架构师对需求分析通常考察以下6个方面的内容。</p>
<p>（1）系统范围对象关系图。主要用于定义系统与系统外部实体间的界限和接口的简单模型，它可以为需求确定一个范围。</p>
<p>（2）用户接口原型。可将其看作为用户操作的一个雏形，通过该接口界面用户能够用一系列的操作完成它想达到的效果。</p>
<p>（3）需求的适用性。即这个需求应该用什么技术解决，它实现后的性能怎么样，是否与其他需求相重合或是矛盾。需求分析应注重需求本身的实用或适用，而不必考虑其实现。</p>
<p>（4）确定需求的优先级。可采用迭代周期来说明何时完成。</p>
<p>（5）为需求建立功能结构模型。可以用UML创建组件图和实体数据对象图，概述系统原型。</p>
<p>（6）使用质量功能分配（Quality Function Deployment, QFD）。根据需求的理解发现隐藏质量需求，建立相关质量场景和易变需求场景，先期预测需求风险。</p>
<p>架构师的一个有效地捕捉行为需求的方法是分析用例（use case）。一个用例包含一个顶层的图和扩展的文字描述。用例符号简单、抽象，非常适合于用来保证在表述顶层需求概念时的简单性和清晰度。</p>
<h4 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h4><h5 id="需求分析的目的"><a href="#需求分析的目的" class="headerlink" title="需求分析的目的"></a>需求分析的目的</h5><p>需求分析的目的是完整、准确地描述用户对系统的需求，跟踪用户需求的变化。将用户的需求准确地反映到系统的架构和设计中，设计和用户的需求保持一致。需求分析具有决策性、方向性和策略性的作用，它在软件开发的过程中具有举足轻重的地位。</p>
<h5 id="需求分析的特点"><a href="#需求分析的特点" class="headerlink" title="需求分析的特点"></a>需求分析的特点</h5><p>一般来说，需求分析特点的共同点都是追求系统需求的完整性、一致性和验证性。</p>
<p>（1）完整性：是准确、全面地描述用户对系统架构的需求。</p>
<p>（2）一致性：是通过分析整理，剔除用户需求矛盾的方面，规范用户需求。</p>
<p>（3）验证性：是需求的一致性表现形式，主要包含以下几个方面的含义。</p>
<p>① 保持和用户要求的同步。</p>
<p>② 保持需求分析各侧面之间的一致。</p>
<p>③ 保持需求和系统设计间的同步。</p>
<p>因此，在对系统架构需求分析之前必须建立需求分析技术层面的基本框架，从技术上保证需求分析的要求，在此基础上进行的架构需求分析才能满足项目对需求分析的要求。</p>
<h4 id="需求文档与架构"><a href="#需求文档与架构" class="headerlink" title="需求文档与架构"></a>需求文档与架构</h4><p>每个用例都有一个相关需求的文字描述。这种方法采用了包含一系列活动的列表形式，用特定领域的平铺直叙的文字来描述。定义用例应该和领域专家一起进行，如果没有领域专家的长期参与，这种活动只能是一种“伪分析”。</p>
<p>用例为定义架构提供了一个系统的领域行为模型。在开发的第7个过程中，用例被特定系统的场景所扩展，最后这些场景会在软件测试中得到运用。</p>
<p>用户界面的外观、功能和导航同用例紧密相联。一个有效定义屏幕的方法叫做低保真度原型（Low-fidelity Prototyping）。在这种方法中，屏幕是用纸和笔先画出来的。同样，最终用户领域专家也始终参与到屏幕定义中去。</p>
<p>有了用例和定义的用户界面以及领域概念模型，我们建立了架构规划的环境。在产生文档之外（包括纸、笔的草图），架构小组得到最终用户领域中需求功能的更深刻理解。需求分析的项目词汇表，也将在架构规划中被扩展。</p>
<h3 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h3><p>系统架构沟通了需求和软件之间巨大的语义上的鸿沟。需求是模糊的、直观的，而软件则具有相反的性质。系统架构的第一个任务就是定义这两个极端之间的映射，架构用一种更为技术性的方式来捕捉直觉的决定，它在设计和编码之前定义了内部的系统结构。架构设计同时为项目计划服务，它允许系统构建用适应变化的方法来控制复杂性，同时指导建立软件项目与架构对应的组织。</p>
<p>开放分布式处理（Open Distributed Processing, ODP）从5个标准的视点组织分析了系统的架构，描述了同一系统的重要方面。如图14-2所示，这些视点包括企业、逻辑信息、计算接口、分布式工程和技术选择。对于每个视点，确认架构需求的一致性是非常重要的。ODP促进了这个过程，因为它内嵌了一个普遍的一致性方法，简单的一致性清单包含识别架构中一致点所需的全部内容。</p>
<details><summary>图14-2　ODP视点</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135801.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135801.png';" /></details>

<h4 id="企业业务架构"><a href="#企业业务架构" class="headerlink" title="企业业务架构"></a>企业业务架构</h4><p>企业业务架构从IT的角度，对企业的业务结构、企业机构与业务的关系、企业内部的关系以及企业与外部机构的关系进行整理定义。企业业务架构包含如下内容。</p>
<p>（1）企业的业务和战略目标。描述企业的目标，包含近期目标、中期目标和长远的战略目标。</p>
<p>（2）企业的组织机构。明确描述企业的组织机构和职能，以及与企业相关的机构和个体，如客户、合作伙伴和供应商等。</p>
<p>（3）业务的分类。对企业的产品、服务和资源体系进行分类。这种分类包含了对相关产品、服务和资源的共性提取和总结。</p>
<p>（4）各类业务之间的关系。对产品、服务和资源的相互关联进行总结。业务之间的关系体现为跨业务的流程及资源共享等。</p>
<p>（5）组织机构与业务的关系。业务的执行是由机构来完成的，但是机构与业务并不一定是一一对应的关系。清楚地找出机构与业务的关系，将为应用与集成架构奠定可靠的基础。</p>
<p>（6）企业与外部机构的关系。对与企业相关的外部机构或个人就其类型、业务类别和业务往来模式等进行分类。</p>
<p>企业业务架构（企业视点）也是用高层企业对象来定义业务目的和系统策略。这些业务对象模型标识出系统的关键性约束，其中包括系统目标和重要的系统策略。</p>
<p>策略包含如下三类明确的表达方式。</p>
<p>●　责任：业务对象必须做什么。</p>
<p>●　许可：业务对象可以做什么。</p>
<p>●　禁止：业务对象不可以作什么。</p>
<p>在对业务问题进行分析时，不仅要考虑企业目前业务的情况，而且要考虑企业业务的发展，如新的服务或产品的推出、考虑组织机构的改变等，企业的业务流程的变化也是要考虑的因素。所有这些可能的变化（易变场景）都应该体现在企业的业务架构中。</p>
<p>企业业务架构在明确了企业的业务和战略目标之后，从业务和机构两个基本点出发进行基础性的分类组织工作，然后根据业务的分工和业务流程与组织机构实现映射，从而形成对企业业务的完整描述。一个典型的企业业务架构包含一系列逻辑对象图（通常用UML表示）和对象语义的平铺直叙的文字描述。</p>
<p>通过对企业业务架构的定义，就可以很清楚地知道由于企业业务特点、业务流程的特点和企业的组织机构等原因对IT系统所带来的自然分块和各个分块之间的边界关系，从而就可以知道怎样从技术架构上来满足和支持企业的业务架构。</p>
<p>企业业务架构的维护也是一个长期而反复的工作。企业业务架构的变化可以通过技术架构反映出来，技术架构的正确与否可以通过业务架构来检验，这样才能通过架构来保证IT服务于企业的业务和战略。</p>
<p>下面以一个测试结果报告系统（Test Results Reporting System, TRRS）为例，介绍一下它的企业业务架构。</p>
<p>TRRS的企业视点由一些UML用例组成，这些用例确定了TRRS社区的参与者以及他们之间策略上的联系。图14-3展示了这些来自应用软件开发者视点的UML用例。这三个在UML图中的用例表明，软件开发者可以通过多种途径使用TRRS，以决定软件产品的兼容性。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135833.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135833.png';" /></details>


<p>重要的企业策略关系到TRRS数据库中产品描述的完整性和责任。在TRRS处理中，可以使用UML对象约束语言（Object Constraint Language, OCL）来定义企业活动者的这些策略（如许可、禁止和义务等）。</p>
<h4 id="逻辑信息架构"><a href="#逻辑信息架构" class="headerlink" title="逻辑信息架构"></a>逻辑信息架构</h4><p>逻辑信息架构（信息视点）标识出系统必须知道什么。这种架构通过一个对象模型来表达，强调定义系统状态的属性。因为开放分布式处理是一种面向对象的方法，模型包含了关键信息的处理，如传统的对象概念。</p>
<p>软件架构对象并不是编程的对象，它表示对系统的约束和依赖。这些约束能够消除在把需求翻译成软件过程中的许多猜测性工作。架构师应该把他们的建模集中于系统中有高风险、高复杂性和模糊性的关键方面，而把直接的细节放在开发的环节中去。</p>
<p>下面以测试结果报告系统为例，介绍一下它的逻辑信息架构。</p>
<details><summary>图14-5　供应商信息的UML表示</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135921.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135921.png';" /></details>

<p>TRRS信息视点是由一组UML类模型组成，该信息视点定义了一些核心的概念，这些概念组成了TRRS系统的持久状态。图14-4是一个UML图，它展示了产品之间的互操作关系。一致性声明（Conformance Statements，如图14-5所示）提供了产品兼容性标准的保证。互操作性声明（Interoperability Statements）是一个类似的概念，和兼容性不同之处在于它不包含供应商对相互之间产品兼容性的保证。互操作性测试报告（Interoperability Test Report）包括了多产品互操作测试所得出的测试结果。互操作性产品（Interoperability Product）是特定的源于多供应商兼容性的解决方案。经验报告（Experience Report）是实例研究的文档，它记载了产品集成的成功经验。合起来，上述各个部分组成了TRRS数据库要储存的关键文档类型。</p>
<h4 id="计算接口架构"><a href="#计算接口架构" class="headerlink" title="计算接口架构"></a>计算接口架构</h4><p>计算接口对系统架构非常有帮助，但是它常常被架构师所忽略。它定义了顶层的应用程序接口，这些是完全工程化的子系统边界的接口。在实现时，开发者将对他们的模型在这些边界上进行编程，以消除多个开发者和小组的主要设计争端。这些接口的架构控制对于一个支持变化和控制复杂性的稳定的系统结构来说，是非常重要的。</p>
<p>开放分布式处理体系结构的一个ISO标准采用的是CORBA接口定义语言（IDL），IDL是一种基本记法，它完全独立于编程语言和操作系统。IDL可以被编译器自动翻译成Java、C++和C#等大多数流行的编程语言。</p>
<h4 id="分布式工程架构"><a href="#分布式工程架构" class="headerlink" title="分布式工程架构"></a>分布式工程架构</h4><p>分布式工程架构定义了底层结构的需求，而独立于所选择的技术。它很好地解决了一些最复杂的系统策略，其中包括物理位置、系统规模可变性和通信服务质量。</p>
<p>ODP的一个最大好处是关注点分离，幸运的是，前面的视点解决了许多其他的复杂问题，那些是分布式很少关注的，如API、系统策略和信息纲要。相反，这些其他的视点能够解决它们各自的设计要点，而独立于分布式的考虑。</p>
<p>在进行分布式工程架构建模时，必须考虑系统的各个方面，如对象复制、多线程和系统拓扑等。</p>
<h4 id="技术选择架构"><a href="#技术选择架构" class="headerlink" title="技术选择架构"></a>技术选择架构</h4><p>技术选择架构（技术视点）确定了实际的技术选择，所有其他视点都独立于这些决定。因为大多数架构设计是独立的，商业技术的发展可以很容易地适应。</p>
<p>一个系统的选择过程包括初始的概念性机制的确认，如持久性或者通信。概念性机制的特定属性可以从其他视点得到。具体的机制被标识出来，如DBMS、OODBMS。这些特定的参选产品是从可得到的技术中选出来的。基于对候选者的初始选择，这个过程根据产品价格、培训要求和维护风险之类的项目因素而反复进行。</p>
<p>架构师选择的原因是非常重要的，因为所有这些观点可以作为以后架构约束的理由。记录可以放在一个由架构小组维护的非正式项目记事本上，可以用于以后进行参考。</p>
<p>以测试结果报告系统为例，介绍一下它的技术选择架构。</p>
<p>TRRS技术视点包括了原型规划的三种方式（如图14-6所示）。我们经常选用这些原型来支持渐进的系统演化和可扩展性。而从一种方式到另一种方式的演化之所以能够发生，是由在实现时选用不同的技术和提供多层结构间互操作机制所造成的。</p>
<details><summary>图14-6　原型规划的三种方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140022.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140022.png';" /></details>

<p>阶段1是一种快速的原型，它由一个独立的Java应用程序以及一个平面文件数据库配置而成。阶段2使用分布式基础设施中的RMI或者IIOP技术，支持局域网上的多客户系统。阶段3支持数据库的可扩展性，这是通过把平面文件替换为JDBC接口及其操作的后端数据库来实现的。</p>
<p>在阶段3之外，TRRS还需要对数据库表项、数据库集成和适应因特网环境下的安全性等功能提供支持。其他的开发挑战包括提供体系结构的设计工具以及利用TRRS数据进行管理等，例如向软件开发者报告相关的TRRS产品表项。这些为软件体系结构引入了一个新的动态层面。</p>
<h3 id="实现模型"><a href="#实现模型" class="headerlink" title="实现模型"></a>实现模型</h3><p>最终用户和架构师应在一起审查并贯穿于用例（业务场景、质量场景、易变场景）始终来证实需求的有效。通常这个交流会出现新的或者需要修改的需求，对于需求的任何修改都要标注并结合到随后的其他架构活动中去。通过模型，管理层能够看到可视化的进展。</p>
<p>大多数系统可以采用快速原型技术生成模型。快速原型技术有利于快速获取产品设计的反馈信息，并对产品设计的可行性做出准确的评估、论证。</p>
<h3 id="架构原型"><a href="#架构原型" class="headerlink" title="架构原型"></a>架构原型</h3><p>在完成上述任务之后，从构建的草图进而发展成产品原型。架构原型是很好的需求验证工具，它能够帮助利益相关人检测系统锲合用户操作的程度。可以使用各种各样的办法构建架构原型，而非编码一种。例如，可以使用故事板来可视化地展现用户使用产品的过程，也可以使用原型工具来模拟过程，以此说明产品是如何运行的。架构原型只是快速构建，作为改进设计的手段，如果在构建架构原型过程中使用了编码，也要尽量避免在最终产品中使用这些代码。</p>
<p>架构框架（Framework）是对系统架构的一种可运行验证工具，通过对系统的API定义的编译以及编写小程序来模拟运行的系统。架构框架用于正式计算和工程体系架构，这包括穿越分布式边界的控制和定时。</p>
<p>使用CORBA技术，一个架构的规范能够被自动地编译成带有分布式stub和框架程序的一系列程序的头文件。通过在框架程序中插入虚拟代码来模拟处理过程，编写简单的客户程序用虚拟的数据来穿越边界发送请求。一些关键的，比如说：高风险的用例被替换的客户程序所模拟。原型的执行被计时以确保与工程约束相一致。</p>
<p>下面是一些架构师可以在架构原型中寻求解答的具体问题。</p>
<p>（1）主要组件的责任是否得到了良好定义？是否适当？</p>
<p>（2）主要组件间的协作是否得到了良好定义？</p>
<p>（3）耦合是否得以最小化？</p>
<p>（4）我们能否确定重用的潜在来源？</p>
<p>（5）接口定义和各项约束是否可接受？</p>
<p>（6）每个模块在执行过程中是否能访问到其所需的数据？是否能在需要时进行访问？</p>
<p>为了构建实际的系统，初始的架构原型需要进行演化。较好的情况是在经过2次或3次迭代之后，架构变得稳定。主要的抽象对象都已被找到；子系统和过程都已经完成；所有的接口都已经明确定义。</p>
<p>在系统架构开发过程中，利用架构原型，至少有下面的几个好处。</p>
<p>（1）在架构落实之前，让团队成员能自由发表他们自己的看法，并进行讨论，提出建议，对在架构原型中存在的问题进行及时改正。</p>
<p>（2）可以在系统的整体性能上，把握得更好。统一团队成员之间的思想看法和提高系统开发的成功率。</p>
<p>（3）它对系统内部的结构分析与设计也有帮助。</p>
<h3 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h3><p>无论什么项目，其最终目标都是要按期、按预算开发出满足用户需求的、高可靠、高性能的产品。在实现这个目标的过程中，项目规划起着至关重要的作用。项目规划是一份已通过批准的正式文档，它根据项目的目标，对项目实施进行的各项活动作出规定，以它为基准跟踪和控制项目，确定未来的行动方案和资源分配，引导项目的实施。项目规划的主要作用是将制定规划的假设和决定以及批准的范围、成本、进度的基线等用正式的文档记录保存。规划的复杂性取决于项目的复杂性，它体现了对客户需求的理解，便于高层管理、项目经理、项目组成员及项目相关人等之间进行交流沟通。</p>
<p>项目规划是基于当前已有的信息，包括过去的经验，当前的目标、范围、组织结构、资源等，工作活动、里程碑、质量目标和风险管理等，其中估算是项目规划的核心。随着项目的进展，信息的增多和理解的深入，估算会不断校正并逐渐地接近实际。项目计划是在规划基础上建立的一组实现任务的活动表，如进度计划、质量活动计划和配置管理计划等。项目管理者通过计划与规划的差异，不断优化和更新计划策略，使项目按规划的要求得以实现，计划的变更是可管理和可受控的。</p>
<p>项目规划是项目工作的纲领，要以此去指导项目的技术和管理活动。项目规划包括如下内容。</p>
<p>（1）项目的目的、范围、目标和对象。</p>
<p>（2）软件生存周期的选择。</p>
<p>（3）精选的供开发和维护软件用的规程、方法和标准。</p>
<p>（4）待开发的软件工作产品。</p>
<p>（5）软件工作产品的规模估计、软件项目的工作量和成本的估计。</p>
<p>（6）关键计算机资源的估计；项目的里程碑。</p>
<p>（7）风险的识别和评估。</p>
<p>（8）工程设施和支持工具计划。</p>
<p>软件项目计划的目标有：软件估计被文档化，以供跟踪软件项目使用。软件项目的活动和约定是有计划的，并形成文档，受影响的组和个人认同与软件项目规划的约定。</p>
<h3 id="并行开发"><a href="#并行开发" class="headerlink" title="并行开发"></a>并行开发</h3><h4 id="软件并行开发的内容及意义"><a href="#软件并行开发的内容及意义" class="headerlink" title="软件并行开发的内容及意义"></a>软件并行开发的内容及意义</h4><p>并行开发的意义在于提高软件生产率和改善软件质量。软件并行开发有效地组织可以重复的资源，并附加额外的控制管理技术，使软件开发尽量并行进行，从而达到加快软件开发速度、提高软件生产率、缩短软件开发周期的目的。同时，软件并行开发通过改善软件过程，达到提高软件质量的目的。软件并行开发以提高软件生产率为目的，对实现软件并行开发的各个方面做了必要的分析，并且给出了可行的解决方案，直接面对软件工程的实施，因此具有重要的应用价值。</p>
<p>软件并行开发研究的内容主要如下。</p>
<p>（1）软件过程及其模型。</p>
<p>（2）并行成分划分。</p>
<p>（3）并行控制。</p>
<p>（4）支持环境。</p>
<p>（5）交互机制与集成技术。</p>
<h4 id="并行开发的过程"><a href="#并行开发的过程" class="headerlink" title="并行开发的过程"></a>并行开发的过程</h4><p>要讨论软件并行开发的软件生存周期模型，需要把视野集中到软件开发过程中。把软件系统的开发过程划分为若干个可以并行的成分，这个成分称之为子开发过程。子开发过程是一个动态概念，和操作系统中的进程概念有类似之处。子开发过程可以定义为：子开发过程＝开发小组＋软件对象＋对软件对象的开发活动。或者说，子开发过程是一个开发小组对一个相对独立的软件对象的动态开发过程。</p>
<p>在此，我们把整个并行开发活动看作是一个并行系统，称为并行开发系统。子开发过程是对并行开发系统的一种动态描述，此系统中的实体是开发小组，实体属性是被开发的软件对象，行为是开发软件对象的活动。每个子开发过程完成一个子系统或一个模块的开发任务，当各个子开发过程都完成之后，进行系统集成和测试，最终完成整个系统的开发，如图14-7所示。</p>
<details><summary>图14-7　并行开发中的生命周期模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140149.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140149.png';" /></details>

<p>并行模块的划分是并行开发中的核心问题，模块独立性是衡量软件设计质量的关键。根据并行开发的特征，一个开发小组负责一个模块的开发，如果各模块之间的耦合度低，那么各并行开发过程之间交互作用将减少，为并行开发控制带来方便。有如下两种系统划分的方法。</p>
<p>（1）基于Petri网系统模型的动态划分方法。</p>
<p>（2）基于脚本的系统划分方法。</p>
<p>在软件并行开发中，软件过程并行控制（以下简称并行控制）是一个非常重要的问题。所谓并行控制，就是要用正确的方式调度并行操作，避免造成不一致性，使一个操作的执行不受其他操作的干扰。为保证开发出的系统内部各成分间的一致性、相容性，保证系统的正确性和可靠性，就要进行并行控制。通常的并行控制手段有加锁、时间戳、管程、Petri网和PV操作等手段。并行控制模型描述被控制对象的并行行为以及它们之间的关系，是并行控制的依据。</p>
<p>当各个产品开发过程分别完成后，应通过集成技术，把各子开发过程所开发的软件对象集成起来，作为一个统一的应用系统。在软件并行开发的软件生存周期模型中，系统集成和系统测试被分为两个阶段，如果不考虑硬件或系统软件的集成，两个阶段并没有明显的界限。所以，就应用软件系统而言，软件集成的主要问题是集成测试技术。通过集成测试技术，在现实可行的时间内，运用工具尽量去发现尽可能多的软件错误，以保证软件的质量。</p>
<h3 id="系统转换"><a href="#系统转换" class="headerlink" title="系统转换"></a>系统转换</h3><p>系统转换是指运用某一种方式由新的系统代替旧的系统的过程，也就是系统设备、系统数据和人员等方面的转换。</p>
<h4 id="系统转换的准备"><a href="#系统转换的准备" class="headerlink" title="系统转换的准备"></a>系统转换的准备</h4><p>在系统转换前，必须认真做好系统设备、数据、人员以及有关文件（如程序说明书、系统操作说明书等）的准备。</p>
<p>除此之外，还需要系统试运行这项准备工作。系统试运行是指在系统没有正式转换之前，选择一些子项目进行的实验运行。需要注意如下两方面的问题。</p>
<p>（1）系统试运行工作的代表性。指在系统试运行工作中所选择的子功能和数据应该尽量接近实际系统运行的需要。</p>
<p>（2）系统试运行中错误的修正。系统试运行过程中用户发现的一些问题，对待这些问题应该以系统分析中确定的系统目标为标准，认真分析产生问题的原因和类型，决定对系统的问题是否修订和如何进行修订。</p>
<h5 id="系统转换的方式"><a href="#系统转换的方式" class="headerlink" title="系统转换的方式"></a>系统转换的方式</h5><p>系统转换可分为直接转换、平行转换、分段转换和分批转换。</p>
<p>（1）直接转换。直接转换是当新系统安装完毕能够进行工作后，立即停止旧系统的运行，让新系统投入运行的转换方式。</p>
<p>（2）平行转换。平行转换是新旧系统共同工作一段时间，当证实新系统有较高的可靠性后，再停止旧系统工作的转换方式。</p>
<p>（3）分段转换。分段转换时一次只用新系统的部分功能去替换旧系统的相应部分，逐步完成新系统替换旧系统的转换方式。</p>
<p>（4）分批转换。分批转换是把新系统在小范围内使用，然后再全部推广的转换方式。</p>
<p>以上几种系统转换方式各有各的特点，应根据系统规模的大小、难易和复杂的程度以及企业的具体情况决定系统转换时采用哪种方式。</p>
<h4 id="系统转换的注意事项"><a href="#系统转换的注意事项" class="headerlink" title="系统转换的注意事项"></a>系统转换的注意事项</h4><p>在系统的转换过程中，无论采取哪种转换方式，都要注意以下问题。</p>
<p>（1）新系统的运行需要大量的基础数据，这些数据的整理与录入工作量很大，应及早准备，尽快完成。</p>
<p>（2）系统的转换不仅仅是机器的转换、程序的转换，更难的是人员的转换，应提前做好人员的培训工作。</p>
<p>（3）系统运行时会出现一些局部性的问题，这是正常现象。系统工作人员对此应有足够的准备，并做好记录。系统只出现局部性问题，说明系统是成功的；反之，如果出现致命问题，说明系统设计质量不好，整个系统甚至要重新设计。</p>
<h3 id="操作与维护"><a href="#操作与维护" class="headerlink" title="操作与维护"></a>操作与维护</h3><h4 id="操作与维护的内容"><a href="#操作与维护的内容" class="headerlink" title="操作与维护的内容"></a>操作与维护的内容</h4><p>一个系统交付使用后，系统的开发就结束了，系统转入正常的运行操作时期。从系统的生命周期看，只有系统投入正常的操作和维护后，才真正实现了系统。因此，可以说操作维护是系统过程的后阶段。</p>
<p>系统操作与维护的内容有数据管理与维护，包括数据收集、数据整理、数据录入以及数据的分发、数据库管理工作；机器设备的管理与维护，包括硬件维护、机器日常行政管理、系统操作记录和用户服务等；系统软件的管理与维护工作，应用软件的管理与维护工作，代码维护。</p>
<h4 id="系统维护与架构"><a href="#系统维护与架构" class="headerlink" title="系统维护与架构"></a>系统维护与架构</h4><p>系统架构的好坏，可维护性是一个重要方面，维护人员应参与架构的评审。系统的可维护性可以定性地定义为：维护人员理解、改正、改动和改进这个软件的难易程度，提高可维护性时开发管理系统所有步骤的关键目的。系统能否被很好地维护，可用系统的可维护性这一指标来衡量。系统的可维护性有如下几个评价指标。</p>
<p>●　可理解性</p>
<p>●　可测试性</p>
<p>●　可修改性</p>
<p>依据信息系统需要维护的原因不同，系统维护工作可以分为以下4种类型。</p>
<p>●　 $\color{green}{\text{更正性维护}}$ </p>
<p>●　 $\color{green}{\text{适应性维护}}$ </p>
<p>●　 $\color{green}{\text{完善性维护}}$ </p>
<p>●　 $\color{green}{\text{预防性维护}}$ </p>
<p>某个维护目标确定以后，维护人员必须先理解要维护的系统，然后建立一个维护方案。由于程序的修改涉及面较广，某处修改很可能会影响其他模块程序，所以建立维护方案后要加以考虑的重要问题是修改的影响范围和波及面的大小。然后按预定维护方案修改程序，若测试发现重大问题，则要重复上述步骤。若通过，则修改相应文档并交付使用，结束本次维护工作。必须强调的是，维护是对整个系统而言的。因此，除了修改程序、数据和代码等部分以外，必须同时修改涉及的所有文档。系统维护的步骤如图14-8所示。</p>
<details><summary>图14-8　系统维护步骤</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140406.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140406.png';" /></details>

<h3 id="系统移植"><a href="#系统移植" class="headerlink" title="系统移植"></a>系统移植</h3><h4 id="系统移植的形式"><a href="#系统移植的形式" class="headerlink" title="系统移植的形式"></a>系统移植的形式</h4><p>系统移植的方法有三种：第一种是不修改已有的软件，可以使用的方法有高位互换、仿真功能和虚拟机（Virtual Machine）功能；第二种是修改软件，就是把已有软件资源，即程序、数据、计算机应用方法及各种说明书转换为与新机器具有匹配性的软件；第三种是重编软件，有从逻辑设计开始、从程序设计开始和从编程开始三种开发方式。</p>
<h4 id="color-red-text-系统移植的工作阶段划分"><a href="#color-red-text-系统移植的工作阶段划分" class="headerlink" title="$\color{red}{\text{系统移植的工作阶段划分}}$"></a>$\color{red}{\text{系统移植的工作阶段划分}}$</h4><p>移植工作大体上分为计划阶段、准备阶段、转换阶段、测试阶段和验证阶段。为了有效地进行系统移植，就得使系统移植工作标准化；配备软件工具实现自动化；还要简化各阶段的工作。下面简要介绍一下系统移植的各阶段工作。</p>
<p>（1） $\color{green}{\text{计划阶段}}$ 。在计划阶段，要进行现有系统的调查整理，从移植技术、系统内容（是否进行系统提炼等）和系统运行三个方面，探讨如何转换成新系统，决定移植方法，确立移植工作体制及移植日程。</p>
<p>（2） $\color{green}{\text{准备阶段}}$ 。在准备阶段要进行移植方面的研究，准备转换所需的资料。该阶段的作业质量将对以后的生产效率产生很大的影响。</p>
<p>（3） $\color{green}{\text{转换阶段}}$ 。这一阶段是将程序设计和数据转换成新机器能根据需要工作的阶段。提高转换工作的精度，减轻下一阶段的测试负担是提高移植工作效率的基本内容。</p>
<p>（4） $\color{green}{\text{测试阶段}}$ 。这一阶段是进行程序单元、工作单元测试的阶段。在本阶段要核实程序能否在新系统中准确地工作。所以，当有不能准确工作的程序时，就要回到转换阶段重新工作。</p>
<p>（5） $\color{green}{\text{验证阶段}}$ 。这是测试完的程序使新系统工作，最后核实系统，准备正式运行的阶段。</p>
<h4 id="系统移植工具"><a href="#系统移植工具" class="headerlink" title="系统移植工具"></a>系统移植工具</h4><p>数据不能互换的系统移植时，完整的数据转换工具是必需的。主要有以下几种软件工具。</p>
<p>（1）分析工具：是分析现有软件资源，得到探讨移植方法有用信息的工具。</p>
<p>（2）生成工具：是编制作业控制语言、测试数据、转换工作所需文档的工具。</p>
<p>（3）转换工具：包括程序转换、数据转换和作业控制语言转换。</p>
<p>（4）数据应用工具：使用这种工具不用编文件就可以简便地存取磁带上的数据。</p>
<p>（5）测试、验证工具：作为可分类的工具包括静态、动态跟踪。</p>
<p>（6）管理工具：是管理资源及作业的工具。</p>
<p>系统移植工作需要的软件工具有很多种，配备工具最主要的是在决定移植的工作方法之后，配备移植所需的工具并明确工具的界限。即选出移植工作中的作业项目，使项目系列化、标准化。配备、开发移植所需的工具；对于那些用工具转换的项目，采取相应的措施，进行文档化，使任何人都能以相同的顺序开展工作。这样，就不必制作大量的工具，只将有效的工具组合起来，就可以提高效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch13-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch13-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch13-系统的可靠性设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:54" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:54+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 14:58:22" itemprop="dateModified" datetime="2021-10-21T14:58:22+08:00">2021-10-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="系统的可靠性设计"><a href="#系统的可靠性设计" class="headerlink" title="系统的可靠性设计"></a>系统的可靠性设计</h2><p>随着软件复杂度的增加，软件设计的正确性验证成本也越来越高。可靠和可信的计算模型首先在军事和高要求的商业系统中开始研究，可靠性和其他质量属性一样是衡量软件架构的重要指标。实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制。本章探讨软件可靠性的概念、建模与管理方法。</p>
<h3 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h3><h4 id="软件可靠性概述"><a href="#软件可靠性概述" class="headerlink" title="软件可靠性概述"></a>软件可靠性概述</h4><p>在现代军事和商用系统中，以软件为核心的产品得到了广泛的应用。随着系统中软件成分的不断增加，使得系统对软件的依赖性越来越强，对软件可靠性的要求也越来越高。目前，硬件可靠性测试技术和评估手段日趋成熟，硬件可靠性评估模型经过长期的实践积累，已经得到了业界的认可。但是，由于软件和硬件存在着巨大的差异性，硬件的可靠性测试和评估技术，并不能完全应用于对软件的可靠性的测试和评估中。因此，软件可靠性技术研究成为当今可靠性工程研究领域中一个重要领域。</p>
<p>国外从20世纪60年代后期开始加强对软件可靠性的研究工作，经过40多年的研究，推出了各种可靠性模型和预测方法，于1990年前后形成了较为系统的软件可靠性工程体系。同时，从20世纪80年代中期开始，西方各主要工业强国均确立了专门的研究计划和课题，如英国的AIVEY（软件可靠性和度量标准）计划、欧洲的ESPRIT（欧洲信息技术研究与发展战略）计划、SPMMS（软件生产和维护管理保障）课题和Eureka（尤里卡）计划等。每年，都有大量的人力物力投入到软件可靠性研究项目中，并取得了一定的成果。</p>
<p>国内对于软件可靠性的研究工作起步较晚，在软件可靠性量化理论、度量标准（指标体系）、建模技术、设计方法和测试技术等方面与国外差距较大。</p>
<p>目前，软件可靠性管理方面还没有建立起具有权威性的管理体系和规范。例如，如何描述软件可靠性，如何测试、评估、设计和提高等。由于目前国内外对于软件可靠性模型的研究多集中在软件的开发阶段及测试与评估阶段的可靠性模型，而且现有的模型也多来源于硬件可靠性评估，与软件可靠性评估存在较大的差距，所以从事软件可靠性测试与评估研究是一个有理论价值和实际意义的工作。总的来说，软件可靠性工程研究虽然得到了普遍的重视，但仍然不是很成熟，还处于发展阶段。</p>
<h4 id="软件可靠性的定义"><a href="#软件可靠性的定义" class="headerlink" title="软件可靠性的定义"></a>软件可靠性的定义</h4><p>可靠性（Reliability）是指产品在规定的条件下和规定的时间内完成规定功能的能力。</p>
<p>按照产品可靠性的形成，可靠性可分为固有可靠性和使用可靠性。固有可靠性是通过设计、制造赋予产品的可靠性；使用可靠性既受设计、制造的影响，又受使用条件的影响。一般使用可靠性总低于固有可靠性。</p>
<p>软件与硬件有很多不同点，但从可靠性的角度来看，它们主要有如下4个不同点。</p>
<p>（1）复杂性。软件内部逻辑高度复杂，硬件则相对简单，这就在很大程度上决定了设计错误是导致软件失效的主要原因，而导致硬件失效的可能性则很小。</p>
<p>（2）物理退化。软件不存在物理退化现象，硬件失效则主要是由于物理退化所致。这就决定了软件正确性与软件可靠性密切相关，一个正确的软件任何时刻均可靠。然而，一个正确的硬件元器件或系统，则可能在某个时刻失效。</p>
<p>（3）唯一性。软件是唯一的，软件复制不改变软件本身，而任何两个硬件不可能绝对相同。这就是为什么概率方法在硬件可靠性领域取得巨大成功，而在软件可靠性领域不令人满意的原因。</p>
<p>（4）版本更新较快。硬件的更新周期通常较慢，硬件产品一旦定型一般就不会更改，而软件产品通常受需求变更、软件缺陷修复的需要，造成软件版本更新较快，这也给软件可靠性评估带来较大的难度。</p>
<p>尽管这样，软件仍然是一种具有特殊属性的产品，因此，也可以按照上面的产品可靠性定义来框架性地描述软件的可靠性。</p>
<p>1983年，美国IEEE计算机学会对“软件可靠性”做出了更为明确的定义，随后，此定义经美国标准化研究所批准为美国的国家标准。在1989年，我国国家标准GB/T-11457也采用了这个定义。这个定义就是：在规定的条件下，在规定的时间内，软件不引起系统失效的概率，该概率是系统输入和系统使用的函数，也是软件中存在的缺陷函数；系统输入将确定是否会遇到已存在的缺陷（如果缺陷存在的话）。</p>
<p>简言之，就是在规定的时间周期内，在所述条件下程序执行所要求的功能的能力。显而易见，美国IEEE计算机学会关于“软件可靠性”的定义仍然沿用了“产品可靠性”的定义，但有了更具体的定位和更深入的描述。</p>
<p>下面来分析一下软件可靠性的框架性定义。</p>
<p>（1）规定的时间。</p>
<p>软件可靠性只是体现在其运行阶段，所以将“运行时间”作为“规定的时间”的度量。“运行时间”包括软件系统运行后工作与挂起（开启但空闲）的累计时间。由于软件运行的环境与程序路径选取的随机性，软件的失效为随机事件，所以运行时间属于随机变量。</p>
<p>（2）规定的条件。</p>
<p>规定的条件主要指软件的运行环境。它涉及软件系统运行时所需的各种支持要素，如支持硬件平台（服务器、台式机和网络平台等）、操作系统、数据库管理系统、中间件，以及其他支持软件、输入数据格式和范围及操作规程等。不同的环境条件下软件的可靠性是不同的，具体地说，规定的环境条件主要是描述软件系统运行时计算机的配置情况及对输入数据的要求，并假定其他一切因素都是理想的。有了明确规定的环境条件，还可以有效地判断软件失效的责任在用户方还是开发方。</p>
<p>（3）所要求的功能。</p>
<p>软件可靠性还与规定的任务和功能有关。由于要完成的任务不同，软件的运行情况会有所区别，则调用的子模块就不同（包括程序选择路径不同），其可靠性也就可能不同。所以，要准确度量软件系统的可靠性，必须先明确它的任务和功能。</p>
<p>（4）“软件可靠性”定义具有以下特点。</p>
<p>① 用内在的“缺陷”和外在的“失效”关系来描述可靠性，更能深刻地体现软件的本质特点。</p>
<p>② 定义使人们对软件可靠性进行量化评估成为可能。对于软件的可靠性这样一个质量特性，很难用一个明确直观的数值去体现。而依据这个定义，我们有可能通过分析影响可靠性的因素，用函数的形式，按照不同的目的建立各种数学模型去分析软件可靠性。</p>
<p>③ 用概率的方法去描述可靠性是比较科学的。前面讲到，软件失效是随机的外部表现，完全是一个随机事件，而软件缺陷是软件固有的没有损耗的内在特点。定义用规定时间内其操作不出现软件失效的概率，也就是输入未碰到软件缺陷的概率来描述可靠性，这种方法就是用概率来描述纯粹的随机事件，是比较合理的，也是可行的。</p>
<h4 id="软件可靠性的定量描述"><a href="#软件可靠性的定量描述" class="headerlink" title="软件可靠性的定量描述"></a>软件可靠性的定量描述</h4><p>从软件可靠性的定义可以看到，软件的可靠性可以基于使用条件、规定时间、系统输入、系统使用和软件缺陷等变量构建的数学表达式。下面从可靠性定义中的术语“规定时间”、“失效概率”开始，探讨软件可靠性的定量描述，并相应地引入一些概念。</p>
<h5 id="规定时间"><a href="#规定时间" class="headerlink" title="规定时间"></a>规定时间</h5><p>对于“规定时间”有三种概念：一种是自然时间，也就是日历时间，指我们日常计时用的年、月、周、日等自然流逝的时间段；一种是运行时间，指软件从启动开始，到运行结束的时间段；最后一种是执行时间，指软件运行过程中，中央处理器（CPU）执行程序指令所用的时间总和。</p>
<p>例如，某单位有一套供会计人员使用的财务软件，我们来关注一整天的时间，上午9:00上班开机运行，下午5:00下班退出程序。在这里，自然时间是一天，也就是24小时，运行时间是8个小时，而CPU处理程序的执行时间可能不到2小时，这要视会计的业务繁忙状况、使用软件的频度和软件本身的设计而定。</p>
<p>很明显，在这三种时间中，我们使用执行时间来度量软件的可靠性最为准确，效果也最好。如果运行的软件系统处于一种相对稳定的工作状态，可以根据一定的经验值，按一定的换算比例，对这三种时间进行折算。</p>
<h5 id="失效概率"><a href="#失效概率" class="headerlink" title="失效概率"></a>失效概率</h5><p>我们把软件从运行开始，到某一时刻t为止，出现失效的概率看作关于软件运行时间的一个随机函数，用F（t）表示。根据我们对软件可靠性的分析，函数F（t）有如下特征。</p>
<p>（1）F（0）＝0，即软件运行初始时刻失效概率为0。</p>
<p>（2）F（t）在时间域（0，+∞）上是单调递增的。</p>
<p>（3）F（+∞）＝1，即失效概率在运行时间不断增长时趋向于1，这也和“任何软件都存在缺陷”的思想相吻合。</p>
<p>为了简化分析，把F（t）看作关于时间t的一个连续函数，并且可导。</p>
<p>3．可靠度</p>
<p>我们用来表示可靠性最为直接的方式就是可靠度，根据可靠性的定义，可靠度就是软件系统在规定的条件下、规定的时间内不发生失效的概率。如果用F（t）来表示到t时刻止，软件不出现失效的概率，则可靠度的公式为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093411.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093411.png';" /></details>

<p>同样，我们知道R（0）＝1，R（+∞）＝0。</p>
<h5 id="失效强度"><a href="#失效强度" class="headerlink" title="失效强度"></a>失效强度</h5><p>失效强度（Failure Intensity）的物理解释就是单位时间软件系统出现失效的概率。在t时刻到t＋Δt时刻之间软件系统出现失效的平均概率为（F（t＋Δt）－F（t））/Δt，当Δt趋于很小时，就表现为t时刻的失效强度。用f（t）表示失效强度函数，则</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093437.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093437.png';" /></details>

<h5 id="失效率"><a href="#失效率" class="headerlink" title="失效率"></a>失效率</h5><p>失效率（Failure Rate）又称风险函数（Hazard Function），也可以称为条件失效强度，物理解释就是在运行至此软件系统未出现失效的情况下，单位时间软件系统出现失效的概率。具体用数学用语来描述，就是当软件在0～t时刻内没有发生失效的条件下，t时刻软件系统的失效强度。用λ（t）表示失效率，则</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093509.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093509.png';" /></details>

<h5 id="失效率-1"><a href="#失效率-1" class="headerlink" title="失效率"></a>失效率</h5><p>失效率（Failure Rate）又称风险函数（Hazard Function），也可以称为条件失效强度，物理解释就是在运行至此软件系统未出现失效的情况下，单位时间软件系统出现失效的概率。具体用数学用语来描述，就是当软件在0～t时刻内没有发生失效的条件下，t时刻软件系统的失效强度。用λ（t）表示失效率，则</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093530.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093530.png';" /></details>

<p>代入公式（13-1）可得从可靠度到失效率的转换表达式</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093547.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093547.png';" /></details>

<h5 id="可靠度与失效率之间的换算"><a href="#可靠度与失效率之间的换算" class="headerlink" title="可靠度与失效率之间的换算"></a>可靠度与失效率之间的换算</h5><p>我们知道，在0时刻，可靠度R（0）为1，对公式（13-4）一阶常微分方程求解可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093617.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093617.png';" /></details>

<p>假设软件系统的失效率为常数时，由公式13-5可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093632.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093632.png';" /></details>

<p>当失效率λ（t）与时间t之积，也就是tλ（t）＜0.05时，公式（13-6）可简化为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093702.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093702.png';" /></details>

<p>这样计算，误差在2.5％之内。</p>
<p>由公式（13-6）可得，从可靠度到失效强度的转换公式</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093747.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093747.png';" /></details>

<p>当可靠度R（t）＞0.95时，公式（13-6）可简化为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093808.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093808.png';" /></details>

<p>这样计算，误差在2.5％之内。</p>
<h5 id="平均无失效时间"><a href="#平均无失效时间" class="headerlink" title="平均无失效时间"></a>平均无失效时间</h5><p>平均无失效时间（Mean Time to Failure, MTTF）就是软件运行后，到下一次出现失效的平均时间。通常平均无失效时间更能直观地表明一个软件的可靠程度。用θ表示平均无失效时间MTTF，则可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093919.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093919.png';" /></details>

<p>代入关于失效率的换算公式，可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093934.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093934.png';" /></details>

<p>当失效率为一个常数时，可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093946.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093946.png';" /></details>

<p>当讨论完对软件可靠性的定量描述问题之后，需要对软件可靠度这个直接反映软件可靠性的度量指标作下列补充说明。</p>
<p>（1）描述的软件对象必须明确，即需指明它与其他软件的界限。</p>
<p>（2）软件失效必须明确定义。</p>
<p>（3）必须假设硬件无故障（失效）和软件有关变量的输入值正确。</p>
<p>（4）运行环境包括硬件环境、软件支持环境和确定的软件输入域。</p>
<p>（5）规定的时间必须指明时间基准，可以是自然时间（日历时间）、运行时间、执行时间（CPU时间）或其他时间基准。</p>
<p>（6）软件无失效运行的机会通常以概率度量，但也可以模糊数学中的可能性加以度量。</p>
<p>（7）上述定义是在时间域上进行的，这时软件可靠度是一种动态度量。也可以是在数据域上将软件可靠度定义为一种表态度量，表示软件成功执行一个回合的概率。软件回合（Run）是指软件在规定环境下的一个基本执行过程，如给定一组输入数据，到软件给定相应的输出数据这一过程。软件回合是软件运行最小的、不可分的执行单位，软件的运行过程由一系列软件回合组成。</p>
<p>（8）有时将软件运行环境简单地理解为软件运行剖面（Operational Profile）。欧空局（ESA）标准PSS-01-21（1991）“ESA软件产品保证要求”中，定义“软件运行剖面”为：“对系统使用条件的定义。系统的输入值都用其按时间的分布或按它们在可能输入范围内的出现概率的分布来定义”。简单来说，运行剖面定义了关于软件可靠性描述中的“规定条件”，也就是相当于可靠性测试中需要考虑的测试环境、测试数据等一系列问题。</p>
<h4 id="可靠性目标"><a href="#可靠性目标" class="headerlink" title="可靠性目标"></a>可靠性目标</h4><p>前面定量分析软件的可靠性时，使用失效强度来表示软件缺陷对软件运行的影响程度。然而在实际情况中，对软件运行的影响程度不仅取决于软件失效发生的概率，还和软件失效的严重程度有很大关系。这里引出另外一个概念——失效严重程度类（Failure Severity Class）。</p>
<p>失效严重程度类就是对用户具有相同程度影响的失效集合。</p>
<p>对失效严重程度的分级可以按照不同的标准进行，最为常见的是按对成本影响、对系统能力的影响等标准划分软件失效的严重程度类。</p>
<p>对成本的影响可能包括失效引起的额外运行成本、修复和恢复成本、现有或潜在的业务机会的损失等。由于失效严重程度类的影响分布很广泛，为了按照一定数量的等级去定义失效严重程度类，通常用数量级去划分等级。</p>
<p>表13-1给出了一个按照对成本的影响划分失效严重程度类的例子，这个例子涉及到的软件系统是某电子商务运营系统。</p>
<details><summary>表13-1　按照对成本的影响划分失效严重程度类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094025.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094025.png';" /></details>

<p>对系统能力的影响常常表现为关键数据的损失、系统异常退出、系统崩溃、导致用户操作无效等。对于不同性质的软件系统，相同的表现可能造成的失效严重程度是不同的，例如对可用性要求较高的系统，导致长时间停机的失效常常会划分到较高的严重级别中去。</p>
<p>表13-2给出了一个按照对系统能力的影响划分失效严重程度类的例子，这个例子涉及到的软件系统是某电信实时计费系统。</p>
<details><summary>表13-2　按照对系统能力的影响划分失效严重程度类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094046.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094046.png';" /></details>

<p>有了失效严重程度的划分，现在可以结合失效强度来定量地表示一个软件系统的可靠性目标了。</p>
<p>可靠性目标是指客户对软件性能满意程度的期望。通常用可靠度、故障强度和平均失效时间（MTTF）等指标来描述，根据不同项目的不同需要而定。建立定量的可靠性指标需要对可靠性、交付时间和成本进行平衡。为了定义系统的可靠性指标，必须确定系统的运行模式，定义故障的严重性等级，确定故障强度目标。</p>
<p>例如，对于表13-2的例子，可以根据经验和用户的需求确定软件系统需要达到的可靠程度，按照前面的公式，换算成失效强度和平均无失效时间，如表13-3所示。</p>
<details><summary>表13-3　可靠性目标参考表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094121.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094121.png';" /></details>

<h4 id="可靠性测试的意义"><a href="#可靠性测试的意义" class="headerlink" title="可靠性测试的意义"></a>可靠性测试的意义</h4><p>软件可靠性问题已被越来越多的软件工程专家所重视，人们已开始投入大量的人力、物力去研究软件可靠性的设计、评估和测试等课题。以下多个方面可以反映出软件可靠性问题对软件工程实践、乃至对生产活动和社会活动产生的深远影响。</p>
<p>（1）软件失效可能造成灾难性的后果。一个最显著的例子就是由于控制系统的Fortran程序中少了个逗点，致使控制系统未能发出正确的指令，最终使美国的一次宇宙飞行失败。而目前由于计算机和软件在各行各业中应用的日益广泛和深入，例如军用作战系统、民航指挥系统、银行支付系统和交通调控系统等，一旦发生严重级别的软件失效，轻则造成经济损失，重则危及人们的生命安全，危害国家安全。</p>
<p>（2）软件的失效在整个计算机系统失效中的比例较高。某研究机构曾经作过统计，在计算机系统的失效中，有80％和软件有关。原因是软件系统的内容结构太复杂了，一个较简单的程序，其所有的路径数就可能是一个天文数字。在软件开发的过程中，很难用全路径覆盖方式的测试去发现软件系统中隐藏的所有缺陷，也就是说，很难完全排除软件缺陷。</p>
<p>（3）相比硬件可靠性技术，软件可靠性技术很不成熟，这就加剧了软件可靠性问题的重要性。例如在硬件可靠性领域，故障树分析（Fault Tree Analysis, FTA）、失效模式与效应分析（Failure Made And Effect Analysis, FMEA）技术等比较成熟，容错技术也有广泛应用，但在软件可靠性领域，这些技术似乎尚未定型。</p>
<p>（4）与硬件元器件成本急剧下降形成鲜明对比的是，软件费用呈有增无减的势头，而软件可靠性问题是造成费用增长的主要原因之一。</p>
<p>（5）计算机技术获得日益广泛的应用，随着计算机应用系统中软件成分的不断增加，使得系统对于软件的依赖性越来越强，软件对生产活动和社会生活的影响越来越大，从而增加了软件可靠性问题在软件工程领域乃至整个计算机工程领域的重要性。</p>
<p>软件可靠性问题的重要性凸显了发展以发现软件可靠性缺陷为目的的可靠性设计与测试技术的迫切性。</p>
<h4 id="广义的可靠性测试与狭义的可靠性测试"><a href="#广义的可靠性测试与狭义的可靠性测试" class="headerlink" title="广义的可靠性测试与狭义的可靠性测试"></a>广义的可靠性测试与狭义的可靠性测试</h4><p>广义的软件可靠性测试是指为了最终评价软件系统的可靠性而运用建模、统计、试验、分析和评价等一系列手段对软件系统实施的一种测试。一个完整的软件可靠性测试包括图13-1所示的过程。</p>
<details><summary>图13-1　广义的软件可靠性测试</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094355.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094355.png';" /></details>

<p>狭义的软件可靠性测试是指为了获取可靠性数据，按预先确定的测试用例，在软件的预期使用环境中，对软件实施的一种测试。狭义的软件可靠性测试也叫“软件可靠性试验（Software Reliability Test）”，它是面向缺陷的测试，以用户将要使用的方式来测试软件，每一次测试代表用户将要完成的一组操作，使测试成为最终产品使用的预演。这就使得所获得的测试数据与软件的实际运行数据比较接近，可用于软件可靠性评价。</p>
<p>其实，软件可靠性测试是软件测试的一种形式，和易用性测试、性能测试、标准符合性测试等前面介绍的测试类型一样，是针对软件的某个重要质量特性，使用一定的测试用例对软件进行测试的过程。</p>
<p>可靠性测试是对软件产品的可靠性进行调查、分析和评价的一种手段。它不仅仅是为了用测试数据确定软件产品是否达到可靠性目标，还要对检测出的失效的分布、原因及后果进行分析，并给出纠正建议。总的来说，可靠性测试的目的可归纳为以下三个方面。</p>
<p>（1）发现软件系统在需求、设计、编码、测试和实施等方面的各种缺陷。</p>
<p>（2）为软件的使用和维护提供可靠性数据。</p>
<p>（3）确认软件是否达到可靠性的定量要求。</p>
<h3 id="软件可靠性建模"><a href="#软件可靠性建模" class="headerlink" title="软件可靠性建模"></a>软件可靠性建模</h3><h4 id="影响软件可靠性的因素"><a href="#影响软件可靠性的因素" class="headerlink" title="影响软件可靠性的因素"></a>影响软件可靠性的因素</h4><p>在讲到软件可靠性评估的时候，我们不得不提到软件可靠性模型。软件可靠性模型（Software Reliability Model）是指为预计或估算软件的可靠性所建立的可靠性框图和数学模型。建立可靠性模型是为了将复杂系统的可靠性逐级分解为简单系统的可靠性，以便于定量预计、分配、估算和评价复杂系统的可靠性。</p>
<p>为了构建软件的可靠性模型，首先要来分析一下影响软件可靠性的因素。影响软件可靠性的因素是纷杂而众多的，甚至包括技术以外的许多因素。首先必须考虑影响软件可靠性的主要因素：缺陷的引入、发现和清除。缺陷的引入主要取决于软件产品的特性和软件的开发过程特性。软件产品的特性指软件本身的性质，开发过程特性包括开发技术、开发工具、开发人员的水平、需求的变化频度等。缺陷的发现依靠用户对软件的操作方式、运行环境等，也就是运行剖面。缺陷的清除依赖于失效的发现和修复活动及可靠性方面的投入。</p>
<p>从技术的角度来看，影响软件可靠性的主要因素如下。</p>
<p>（1）运行剖面（环境）。软件可靠性的定义是相对运行环境而言的，一样的软件在不同的运行剖面下，其可靠性的表现是不一样的。</p>
<p>（2）软件规模。也就是软件的大小，一个只有数十行代码的软件和几千万行代码的软件是不能相提并论的。</p>
<p>（3）软件内部结构。结构对软件可靠性的影响主要取决于软件结构的复杂程度，一般来说，内部结构越复杂的软件，所包含的软件缺陷数就可能越多。</p>
<p>（4）软件的开发方法和开发环境。软件工程表明，软件的开发方法对软件的可靠性有显著影响。例如，与非结构方法相比，结构化方法可以明显减少软件的缺陷数。</p>
<p>（5）软件的可靠性投入。软件在生命周期中可靠性的投入包括开发者在可靠性设计、可靠性管理、可靠性测试和可靠性评价等方面投入的人力、资金、资源和时间等。经验表明，在早期重视软件可靠性并采取措施开发出来的软件，可靠性有明显的提高。</p>
<p>总之，有许许多多的因素影响着软件的可靠性，有些至今也无法确定它们与软件可靠性之间的定量关系，甚至定性关系也不甚清楚。</p>
<h4 id="软件可靠性建模方法"><a href="#软件可靠性建模方法" class="headerlink" title="软件可靠性建模方法"></a>软件可靠性建模方法</h4><p>一个软件可靠性模型通常（但不是绝对）由以下几部分组成。</p>
<p>（1）模型假设。模型是实际情况的简化或规范化，总要包含若干假设，例如测试的选取代表实际运行剖面，不同软件失效独立发生等。</p>
<p>（2）性能度量。软件可靠性模型的输出量就是性能度量，如失效强度、残留缺陷数等。在软件可靠性模型中性能度量通常以数学表达式给出。</p>
<p>（3）参数估计方法。某些可靠性度量的实际值无法直接获得，例如残留缺陷数，这时需通过一定的方法估计参数的值，从而间接确定可靠性度量的值。当然，对于可直接获得实际值的可靠性度量，就无需参数估计了。</p>
<p>（4）数据要求。一个软件可靠性模型要求一定的输入数据，即软件可靠性数据。不同类型的软件可靠性模型可能要求不同类型的软件可靠性数据。</p>
<p>绝大多数的模型包含三个共同假设。这些假设至今主宰着软件可靠性建模的研究发展，人们尚未找到克服这些假设局限性的有效方法。</p>
<p>（1）代表性假设。此假设认为软件测试用例的选取代表软件实际的运行剖面，甚至认为测试用例是独立随机地选取。此假设实质上是指可以用测试产生的软件可靠性数据预测运行阶段的软件可靠性行为。</p>
<p>（2）独立性假设。此假设认为软件失效是独立发生于不同时刻，一个软件失效的发生不影响另一个软件失效的发生。例如在概率范畴，假设相邻软件失效间隔构成一组独立随机变量，或假设一定时间内软件失效次数构成一个独立增量过程。在模糊数学范畴，则相邻软件失效间隔构成一组不相关的模糊变量。</p>
<p>（3）相同性假设。此假设认为所有软件失效的后果（等级）相同，即建模过程只考虑软件失效的具体发生时刻，不区分软件的失效严重等级。</p>
<p>软件可靠性模型要描述失效过程对上一节所分析的因素的一般依赖形式。由于这些因素大多数在本质上是概率性的，并且表现与时间相关联，所以通过失效数据的概率分布和随机过程随时间的变化的特性来整体区分软件可靠性模型。</p>
<p>我们常常通过下面估计或预测的方法来确定模型的参数。估计是通过收集到的失效数据进行统计分析，利用一定的推导过程归纳出模型的参数；预测则是使用软件产品自身的属性和开发过程来确定模型的参数，这种方法可以在开始执行程序前完成。</p>
<p>确定了模型的参数后，就可以来表示失效过程的很多不同的特性。例如，大多数模型都会对如下的内容进行解析表达。</p>
<p>（1）任何时间点所经历的平均失效数。</p>
<p>（2）一段时间间隔内的平均失效数。</p>
<p>（3）任何时间点的失效强度。</p>
<p>（4）失效区间的概率分布。</p>
<p>在对将来的故障行为进行预测时，应保证模型参数的值不发生变化。如果在进行预测时发现引入了新的错误，或修复行为使新的故障不断发生，就应停止预测，并等足够多的故障出现后，再重新进行模型参数的估计。否则，这样的变化会因为增加问题的复杂程度而使模型的实用性降低。</p>
<p>一般来说，软件可靠性模型是以在固定不变的运行环境中运行的不变的程序作为估测实体的。这也就是说，程序的代码和运行剖面都不发生变化，但它们往往总要发生变化的，于是在这种情况之下，就应采取分段处理的方式来进行工作。因此，模型主要集中注意力于排错。但是，也有的模型具有能处理缓慢地引进错误情况的能力。</p>
<p>对于一个已发行并正在运行的程序，应暂缓安装新的功能和对下一次发行的版本的修复。如果能保持一个不变的运行剖面，则程序的故障密度将显示为一个常数。</p>
<p>一般来说，一个好的软件可靠性模型增加了关于开发项目的交流，并对了解软件开发过程提供了一个共同的工作基础。它也增加了管理的透明度和其他令人感兴趣的东西。即使在特殊的情况之下，通过模型做出的预测并不是很精确的话，上面的这些优点也仍然是明显而有价值的。</p>
<p>要建立一个有用的软件可靠性模型必须有坚实的理论研究工作、有关工具的建造和实际工作经验的积累。通常这些工作要许多人一年的工作量。相反，要应用一个好的软件可靠性模型，则要求以极少的项目资源就可以在实际工作中产生好的效益。</p>
<p>一个好的软件可靠性模型应该具有如下重要特性。</p>
<p>（1）基于可靠的假设。</p>
<p>（2）简单。</p>
<p>（3）计算一些有用的量。</p>
<p>（4）给出未来失效行为的好的映射。</p>
<p>（5）可广泛应用。</p>
<h4 id="软件的可靠性模型分类"><a href="#软件的可靠性模型分类" class="headerlink" title="软件的可靠性模型分类"></a>软件的可靠性模型分类</h4><p>一个有效的软件可靠性模型应尽可能地将上面所述的因素在软件可靠性建模时加以考虑，尽可能简明地反映出来。自1972年第一个软件可靠性分析模型发表的30多年来，见之于文献的软件可靠性统计分析模型将近百种。这些可靠性模型大致可分为如下10类。</p>
<p>●　种子法模型。</p>
<p>●　失效率类模型。</p>
<p>●　曲线拟合类模型。</p>
<p>●　可靠性增长模型。</p>
<p>●　程序结构分析模型。</p>
<p>●　输入域分类模型。</p>
<p>●　执行路径分析方法模型。</p>
<p>●　非齐次泊松过程模型。</p>
<p>●　马尔可夫过程模型。</p>
<p>●　贝叶斯分析模型。</p>
<p>下面分别对这些模型进行简单介绍。</p>
<h5 id="种子法模型"><a href="#种子法模型" class="headerlink" title="种子法模型"></a>种子法模型</h5><p>这类模型利用捕获一再捕获抽样技术估计程序中的错误数，在程序中预先有意“播种”一些设定的错误“种子”，然后根据测试出的原始错误数和发现的诱导错误的比例，来估计程序中残留的错误数。其优点是简便易行，缺点是诱导错误的“种子”与实际的原始错误之间的类比性估量困难。</p>
<h5 id="失效率类模型"><a href="#失效率类模型" class="headerlink" title="失效率类模型"></a>失效率类模型</h5><p>这类模型用来研究程序的失效率，主要有下列内容。</p>
<p>●　Jelinski-Moranda的De-eutrophication模型。</p>
<p>●　Jelinski-Moranda的几何De-eutrophication模型。</p>
<p>●　Schick-Wolverton模型。</p>
<p>●　改进的Schick-Wolverton模型。</p>
<p>●　Moranda的几何泊松模型。</p>
<p>●　Goal和Okumoto不完全排错模型。</p>
<h5 id="曲线拟合类模型"><a href="#曲线拟合类模型" class="headerlink" title="曲线拟合类模型"></a>曲线拟合类模型</h5><p>这类模型用回归分析的方法研究软件复杂性、程序中的缺陷数、失效率、失效间隔时间，包括参数方法和非参数方法两种。</p>
<h5 id="可靠性增长模型"><a href="#可靠性增长模型" class="headerlink" title="可靠性增长模型"></a>可靠性增长模型</h5><p>这类模型预测软件在检错过程中的可靠性改进，用增长函数来描述软件的改进过程。这类模型如下。</p>
<p>●　Duane模型。</p>
<p>●　Weibull模型。</p>
<p>●　Wagoner的Weibull改进模型。</p>
<p>●　Yamada和Osaki的逻辑增长曲线。</p>
<p>●　Gompertz的增长曲线。</p>
<h5 id="程序结构分析模型"><a href="#程序结构分析模型" class="headerlink" title="程序结构分析模型"></a>程序结构分析模型</h5><p>程序结构模型是根据程序、子程序及其相互间的调用关系，形成一个可靠性分析网络。网络中的每一结点代表一个子程序或一个模块，网络中的每一有向弧代表模块间的程序执行顺序。假定各结点的可靠性是相互独立的，通过对每一个结点可靠性、结点间转换的可靠性和网络在结点间的转换概率，得出该持续程序的整体可靠性。这类模型如下。</p>
<p>●　Littewood马尔可夫结构模型。</p>
<p>●　Cheung的面向用户的马尔可夫模型。</p>
<h5 id="输入域分类模型"><a href="#输入域分类模型" class="headerlink" title="输入域分类模型"></a>输入域分类模型</h5><p>这类模型选取软件输入域中的某些样本“点”运行程序，根据这些样本点在“实际”使用环境中的使用概率的测试运行时的成功/失效率，推断软件的使用可靠性。这类模型的重点（亦是难点）是输入域的概率分布的确定及对软件运行剖面的正确描述。这类模型如下。</p>
<p>●　Nelson模型。</p>
<p>●　Bastani的基于输入域的随机过程模型。</p>
<h5 id="执行路径分析方法模型"><a href="#执行路径分析方法模型" class="headerlink" title="执行路径分析方法模型"></a>执行路径分析方法模型</h5><p>这类模型的分析方法与上面的模型相似，先计算程序各逻辑路径的执行概率和程序中错误路径的执行概率，再综合出该软件的使用可靠性。Shooman分解模型属于此类。</p>
<h5 id="非齐次泊松过程模型"><a href="#非齐次泊松过程模型" class="headerlink" title="非齐次泊松过程模型"></a>非齐次泊松过程模型</h5><p>非齐次泊松过程模型，即NHPP，是以软件测试过程中单位时间的失效次数为独立泊松随机变量，来预测在今后软件的某使用时间点的累计失效数。这类模型如下。</p>
<p>●　Musa的指数模型。</p>
<p>●　Goel和Okumoto的NHPP模型。</p>
<p>●　S型可靠性增长模型。</p>
<p>●　超指数增长模型。</p>
<p>●　Pham改进的NHPP模型。</p>
<h5 id="马尔可夫过程模型"><a href="#马尔可夫过程模型" class="headerlink" title="马尔可夫过程模型"></a>马尔可夫过程模型</h5><p>这类模型如下。</p>
<p>●　完全改错的线性死亡模型。</p>
<p>●　不完全改错的线性死亡模型。</p>
<p>●　完全改错的非静态线性死亡模型。</p>
<h5 id="贝叶斯模型"><a href="#贝叶斯模型" class="headerlink" title="贝叶斯模型"></a>贝叶斯模型</h5><p>这是利用失效率的试验前分布和当前的测试失效信息，来评估软件的可靠性。这是一类当软件可靠性工程师对软件的开发过程有充分的了解，软件的继承性比较好时具有良好效果的可靠性分析模型。这类模型如下。</p>
<p>●　连续时间的离散型马尔可夫链。</p>
<p>●　Shock模型。</p>
<p>另外，Musa和Okumoto依据模型的不同属性对可靠性模型进行以下分类。</p>
<p>●　时间域：有两种，自然或日历时间与执行（CPU）时间。</p>
<p>●　失效数类：取决于无限时间内发生的失效数是有限的还是无限的。</p>
<p>●　失效数分布：相对于时间系统失效数的统计分布形式，主要的两类是泊松分布型和二项分布型。</p>
<p>●　有限类：对有限失效数的类别适用，用时间表示的失效强度的函数形式。</p>
<p>●　无限类：对无限失效数的类别适用，用经验期望失效数表示的失效强度的函数形式。</p>
<h4 id="软件可靠性模型举例"><a href="#软件可靠性模型举例" class="headerlink" title="软件可靠性模型举例"></a>软件可靠性模型举例</h4><p>迄今已有数十种模型是根据上一小节中关于模型的分类方法进行的分类，下面将介绍Jelinski-Moranda模型的基本思想及其相关的历史背景。</p>
<p>Jelinski-Moranda模型（JM模型）是Z.Jelinski和P.Moranda于1972年提出的软件可靠性数学模型，是最具代表性的早期软件可靠性马尔可夫过程的数学模型。随后的许多工作都是在它的基础上对其中与软件开发实际不相适合的地方进行改进而提出来的，所以，JM模型是具有广泛影响的模型之一。</p>
<h5 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h5><p>M模型的基本假设如下。</p>
<p>（1）软件系统中的初始错误个数为一个未知的常数，用N0表示。</p>
<p>（2）可靠性测试中发现的错误立即被完全排除，并且排除过程不引入新的错误，排除时间忽略不计。因此，每次排错之后，N0就要减去1。</p>
<p>（3）在任何一个失效间隔区间，软件系统的失效率与系统中剩余的错误个数成正比，比例常数用φ表示。</p>
<p>其实，最初Jehnski和Moranda提出的模型假设只有最后一条，前面两个假设是后人根据使用过程中出现的问题归纳总结而来的。</p>
<h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><p>根据假设，每发生1次失效，错误数都要减去1，如果用t1，t2，…，ti表示从0时刻开始的每次失效间隔时间，那第i-1次失效到第i次失效之间的失效率为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134009.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134009.png';" /></details>

<p>根据在可靠性定量描述一节的讨论，知道失效强度函数为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134022.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134022.png';" /></details>

<p>可靠度函数为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134043.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134043.png';" /></details>

<p>失效概率分布函数为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134106.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134106.png';" /></details>

<h5 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h5><p>在可靠度函数表达式中含有两个未知参数φ和N0，下面运用统计学中的最大似然法来对参数φ和N0进行估算。</p>
<p>由公式（13-15）可得似然函数</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134146.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134146.png';" /></details>

<p>对公式（13-17）取对数，得到对数似然函数</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134202.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134202.png';" /></details>

<p>对公式（13-18）中的N0和φ求偏导，并令结果为0</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134228.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134228.png';" /></details>

<p>公式（13-19）可以写成</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134249.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134249.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134325.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134325.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134334.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134334.png';" /></details>

<p>再来解出另一个参数φ的估计值，令</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134348.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134348.png';" /></details>

<p>则从（13-20）中可解出</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134404.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134404.png';" /></details>

<p>代入N0的估计值，可解出φ的估计值</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134417.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134417.png';" /></details>

<p>需要说明的是，软件可靠性是一门正在发展中的分支学科，许多来源于硬件可靠性的理论在软件可靠性研究中并不适用，有关软件可靠性的模型并不成熟，并且应用范围也非常有限，软件可靠性的定量分析方法和数学模型要在实践中不断加以验证和修正，对于不同类型的软件，模型的假设、表示公式及应用方式也有很大的区别。</p>
<h4 id="软件可靠性测试概述"><a href="#软件可靠性测试概述" class="headerlink" title="软件可靠性测试概述"></a>软件可靠性测试概述</h4><p>软件测试者可以使用很多方法进行软件测试，如按行为或结构来划分输入域的划分测试，纯粹随机选择输入的随机测试，基于功能、路径、数据流或控制流的覆盖测试等。对于给定的软件，每种测试方法都局限于暴露一定数量和一些类别的缺陷。通过这些测试能够查找、定位、改正和消除某些缺陷，实现一定意义上的软件可靠性增长。但是，由于它们都是面向错误的测试，测试所得的结果数据不能直接用于软件可靠性评价，必须经过一定的分析处理后方可使用可靠性模型进行可靠性评价。</p>
<p>软件可靠性测试由可靠性目标的确定、运行剖面的开发、测试用例的设计、测试实施、测试结果的分析等主要活动组成。</p>
<p>软件可靠性测试还必须考虑对软件开发进度和成本的影响，最好是在受控的自动测试环境下，由专业测试机构完成。</p>
<p>软件可靠性测试是一种有效的软件测试和软件可靠性评价技术。尽管软件可靠性测试也不能保证软件中残存的缺陷数最少，但经过软件可靠性测试可以保证软件的可靠性达到较高的要求，对于开发高可靠性与高安全性软件系统很有帮助。</p>
<p>软件可靠性测试要在工程上获得广泛应用，还有许多实际问题需要解决。</p>
<h4 id="定义软件运行剖面"><a href="#定义软件运行剖面" class="headerlink" title="定义软件运行剖面"></a>定义软件运行剖面</h4><p>定义运行剖面首先需要为软件的使用行为建模，建模可以采用马尔可夫链来完成。用马尔可夫链将输入域编码为一个代表用户观点的软件使用的状态集。弧用来连接状态并表示由各种激励导致的转换，这些激励可能由硬件、人机接口或其他软件等产生。将转换概率分配给每个弧，用来代表一个典型用户最有可能施加给系统的激励。这种类型的马尔可夫链是一个离散的有限状态集，这类模型可以用有向图或转换矩阵表示。</p>
<p>定义运行剖面的下一步是开发使用模型，明确需要测试的内容。软件系统可能会有许多用户和用户类别，每类用户都可能以不同的方式使用系统。开发使用模型涉及到将输入域分层，有两种类型的分层形式：用户级分层和用法级分层。用户级分层依赖于谁或什么能激励系统；用法级分层依赖于在测试状态下系统能做什么。换句话说，用户级分层考虑各种类型的用户以及他们如何使用系统；用法级分层则要求考虑系统能够提供的所有功能。一旦用户和用法模型被开发出来，弧上的概率将被分配。这些概率估计主要是基于如下几个方面。</p>
<p>（1）从现有系统收集到的数据。</p>
<p>（2）与用户的交谈或对用户进行观察获得的信息。</p>
<p>（3）原型使用与测试分析的结果。</p>
<p>（4）相关领域专家的意见。</p>
<p>定义使用概率的最佳方法是使用实际的用户数据，如来自系统原型、前一版本的使用数据；其次是由该软件应用领域的用户和专家提供的预期使用数据；在没有任何数据可用的情况下，只能是将每个状态现有的弧分配相同的概率，这是最差的一种方法。</p>
<p>由于软件可靠性行为是相对于软件实际的运行剖面而言的，同一软件在不同运行剖面下其可靠性表现可能大不相同，所以用于可靠性测试准备的运行剖面的开发与定义必须充分分析和考虑软件的实际运行情况。</p>
<p>软件可靠性测试假设每个操作的数据输入都有同样的发生错误的概率，这样最频繁出现的操作和输入将表现出最高的故障率。对于特定的操作环境这是正确的，但无法贯穿系统的全部操作集合。典型的例子是飞机的飞行控制软件，在正常飞行、起飞、降落、地面运动和地面等待这5个状态中，尽管起飞和降落在运行剖面上只占有很小的百分比，但是它们却占有很大的故障比例。对于高安全性要求的软件，一个看起来很少使用的代码路径也可能带来灾难性的后果。因此，对于边界、跃迁情况和关键功能不应该用简单的运行剖面来对待，应该构造专门的运行剖面，补充统计模型之外的测试用例。在覆盖率水平不够时，可根据具体空白，进行适当的补充测试。如果补充测试发现了错误，就可分析这些错误，估计其对可靠性产生的影响。</p>
<p>一个产品有可能需要开发多个运行剖面，这取决于它所包含的运行模式和关键操作，通常需要为关键操作单独定义运行剖面。</p>
<h4 id="可靠性测试用例设计"><a href="#可靠性测试用例设计" class="headerlink" title="可靠性测试用例设计"></a>可靠性测试用例设计</h4><p>为了对软件可靠性进行良好的预计，必须在软件的运行域上对其进行测试。首先定义一个相应的剖面来镜像运行域，然后使用这个剖面驱动测试，这样可以使测试真实地反映软件的使用情况。</p>
<p>由于可能的输入几乎是无限的，测试必须从中选择出一些样本，即测试用例。测试用例要能够反映实际的使用情况，反映系统的运行剖面。将统计方法运用到运行剖面开发和测试用例生成中去，并为在运行剖面中的每个元素都定量地赋予一个发生概率值和关键因子，然后根据这些因素分配测试资源，挑选和生成测试用例。</p>
<p>在这种测试中，优先测试那些最重要或最频繁使用的功能，释放和缓解最高级别的风险，有助于尽早发现那些对可靠性有最大影响的故障，以保证软件的按期交付。</p>
<p>设计测试用例就是针对特定功能或组合功能设计测试方案，并编写成文档。测试用例的选择既要有一般情况，也应有极限情况以及最大和最小的边界值情况。因为测试的目的是暴露应用软件中隐藏的缺陷，所以在设计选取测试用例和数据时要考虑那些易于发现缺陷的测试用例和数据，结合复杂的运行环境，在所有可能的输入条件和输出条件中确定测试数据，来检查应用软件是否都能产生正确的输出。</p>
<p>一个典型的测试用例应该包括下列组成部分。</p>
<p>（1）测试用例标识。</p>
<p>（2）被测对象。</p>
<p>（3）测试环境及条件。</p>
<p>（4）测试输入。</p>
<p>（5）操作步骤。</p>
<p>（6）预期输出。</p>
<p>（7）判断输出结果是否符合标准。</p>
<p>（8）测试对象的特殊需求。</p>
<p>由于可靠性测试的主要目的是评估软件系统的可靠性，因此，除了常规的测试用例集仍然适用外，还要着重考虑和可靠性密切相关的一些特殊情况。在测试中，可以考虑进行“强化输入”，即比正常输入更恶劣（合理程度的恶劣）的输入。</p>
<p>表13-4给出了一些参考例子。</p>
<details><summary>表13-4　可靠性测试用例设计时重点考虑的一些特殊情况</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134610.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134610.png';" /></details>

<h4 id="可靠性测试的实施"><a href="#可靠性测试的实施" class="headerlink" title="可靠性测试的实施"></a>可靠性测试的实施</h4><p>在进行应用软件的可靠性测试前有必要检查软件需求与设计文档是否一致，检查软件开发过程中形成的文档的准确性、完整性以及与程序的一致性，检查所交付程序和数据以及相应的软件支持环境是否符合要求。</p>
<p>这些检查虽然增加了工作量，但对于在测试早期发现错误和提高软件的质量是非常必要的。</p>
<p>软件可靠性测试必须是受控测试，在运行此类测试时，为了保证统计数据的有效性，测试过程中的每个测试用例必须用相同的软件版本，新的软件版本意味着新测试的开始。</p>
<p>在有些情况下，不能进行纯粹的可靠性测试。因为客户的要求、合同的规定或者标准的约束，需要补充其他形式的非统计测试。这时的最佳选择是既执行可靠性测试，也执行非统计测试（如覆盖测试）。如果非统计测试在可靠性测试之前完成，由统计测试产生的统计数据仍然有效。但是在可靠性测试之后执行非统计测试，可能会影响软件可靠性评估的准确性。</p>
<p>软件可靠性测试同样依赖于软件的可测试性。可靠性测试的难点就在于判断测试用例的运行是成功还是失败。在控制系统及类似的软件中，失效由详细说明、时间（通常是CPU时间或时钟时间）来客观地定义。而在一般应用系统中，失效的定义更主观些，它不仅依赖于程序是否符合规格说明的要求，也取决于指定的性能是否能够达到用户的期望，但是否达到期望没有确定的标准。在一些科学计算中，计算结果只能由计算机给出，在这种情况下，如果软件只是输出了错误的结果而不是整个系统发生失效，错误就不可能被发现。此时可以将测试分成两个阶段进行。第一阶段运行较少量的测试用例，并对照规范进行仔细检查。第二阶段再运行大量测试用例。第二阶段不用人工检查输出的每项内容，而是找失效现象，包括错误信息、断电、崩溃和死机。也可把输出记录到文件中，采用搜索或过滤方法进行处理。如果软件有足够的可测试性，这种方法不会漏掉很多的严重失效。如果计算的正确性无法验证，就需要对软件进行一些形式化的证明。</p>
<p>开发方交付的任何软件文档中与可靠性质量特性有关的部分、程序以及数据都应当按照需求说明和质量需求进行测试。在项目合同、需求说明书和用户文档中规定的所有配置情况下，程序和数据都必须进行测试。</p>
<p>软件可靠性数据是可靠性评价的基础。为了获得更多的可靠性数据，应该使用多台计算机同时运行软件，以增加累计运行时间。应该建立软件错误报告、分析与纠正措施系统。按照相关标准的要求，制定和实施软件错误报告和可靠性数据收集、保存、分析和处理的规程，完整、准确地记录软件测试阶段的软件错误报告和收集可靠性数据。</p>
<p>用时间定义的软件可靠性数据可以分为4类，具体内容如下。</p>
<p>（1）失效时间数据。记录发生一次失效所累积经历的时间。</p>
<p>（2）失效间隔时间数据。记录本次失效与上一次失效间的间隔时间。</p>
<p>（3）分组时间内的失效数。记录某个时间区内发生了多少次失效。</p>
<p>（4）分组时间的累积失效数。记录到某个区间的累积失效数。</p>
<p>这4类数据可以互相转化。</p>
<p>在测试过程中必须真实地进行记录，每个测试记录必须包含如下信息。</p>
<p>（1）测试时间。</p>
<p>（2）含有测试用例的测试说明或标识。</p>
<p>（3）所有与测试有关的测试结果，包括失效数据。</p>
<p>（4）测试人员。</p>
<p>测试活动结束后要编写《软件可靠性测试报告》，对测试用例及测试结果在测试报告中加以总结归纳。编写时可以参考GJB 438A-97中提供的《软件测试报告》格式，并应根据情况进行剪裁。测试报告应具备如下内容。</p>
<p>（1）软件产品标识。</p>
<p>（2）测试环境配置（硬件和软件）。</p>
<p>（3）测试依据。</p>
<p>（4）测试结果。</p>
<p>（5）测试问题。</p>
<p>（6）测试时间。</p>
<p>把可靠性测试过程进行规范化，有利于获得真实有效的数据，为最终得到客观的可靠性评价结果奠定基础。</p>
<h3 id="软件可靠性评价"><a href="#软件可靠性评价" class="headerlink" title="软件可靠性评价"></a>软件可靠性评价</h3><h4 id="软件可靠性评价概述"><a href="#软件可靠性评价概述" class="headerlink" title="软件可靠性评价概述"></a>软件可靠性评价概述</h4><p>软件可靠性评价是软件可靠性活动的重要组成部分，既适用于软件开发过程，也可针对最终软件系统。在软件开发过程中使用软件可靠性评价，可以使用软件可靠性模型，估计软件当前的可靠性，以确认是否可以终止测试并发布软件，同时还可以预计软件要达到相应的可靠性水平所需要的时间和工作量，评价提交软件时的软件可靠性水平。对于最终软件产品，软件可靠性评价结合可靠性验证测试，确认软件的执行与需求的一致性，确定最终软件产品所达到的可靠性水平。</p>
<p>这一节阐述的软件可靠性评价工作是指选用或建立合适的可靠性数学模型，运用统计技术和其他手段，对软件可靠性测试和系统运行期间收集的软件失效数据进行处理，并评估和预测软件可靠性的过程。这个过程包含如下三个方面。</p>
<p>（1）选择可靠性模型。</p>
<p>（2）收集可靠性数据。</p>
<p>（3）可靠性评估和预测。</p>
<h4 id="怎样选择可靠性模型"><a href="#怎样选择可靠性模型" class="headerlink" title="怎样选择可靠性模型"></a>怎样选择可靠性模型</h4><p>在前面讨论了软件的可靠性模型以及一个举例，一些可靠性研究者试图寻找一个最好的模型，能适用于所有的软件系统，但这样的工作是徒劳的。因为对于不同的软件系统，出于不同的可靠性分析目的，模型的适用性是不一样的。但究竟怎样来为可靠性评价选用不同的模型，却又是一个不小的难题。</p>
<p>针对可靠性模型的构成以及使用模型来进行可靠性评价的目的，可以从以下几个方面进行比较和选择。</p>
<h5 id="模型假设的适用性"><a href="#模型假设的适用性" class="headerlink" title="模型假设的适用性"></a>模型假设的适用性</h5><p>模型假设是可靠性模型的基础，模型假设要符合软件系统的现有状况，或与假设冲突的因素在软件系统中应该是可忽略的。例如，有的模型假定检测或发现的软件缺陷是立即排除掉的，而且排除时间忽略不计，如果现有的软件系统对于严重程度类较低的软件缺陷不进行立即排错，那么这个模型显然是不适用的。</p>
<p>往往一个模型的假设有许多条，我们需要在选用模型的时候对每一条假设进行细致的分析，评估现有的软件系统中不符合假设的因素对可靠性评价的影响如何，以确定模型是否适合软件系统的可靠性评价工作。</p>
<h5 id="预测的能力与质量"><a href="#预测的能力与质量" class="headerlink" title="预测的能力与质量"></a>预测的能力与质量</h5><p>预测的能力与质量是指模型根据现在和历史的可靠性数据，预测将来的可靠性和失效概率的能力，以及预测结果的准确程度。显然，模型预测的能力与质量是比较难于评价的，但任何一个模型只有在实践中加以实验和不断改善，才能得到认可。所以，在满足其他条件的前提下，应尽量选用比较成熟、应用较广的模型作为分析模型。</p>
<h5 id="模型输出值能否满足可靠性评价需求"><a href="#模型输出值能否满足可靠性评价需求" class="headerlink" title="模型输出值能否满足可靠性评价需求"></a>模型输出值能否满足可靠性评价需求</h5><p>使用模型进行可靠性评价的最终目的，是想得到软件系统当前的可靠性定量数据，以及预测一定时间后的可靠性数据，可以根据可靠性测试目的来确定哪些模型的输出值满足可靠性评价需求。一般来说，最重要的几个需要精确估计的可靠性定量指标包括如下内容。</p>
<p>（1）当前的可靠度。</p>
<p>（2）平均无失效时间。</p>
<p>（3）故障密度。</p>
<p>（4）期望达到规定可靠性目标的日期。</p>
<p>（5）达到规定的可靠性目标的成本要求。</p>
<h5 id="模型使用的简便性"><a href="#模型使用的简便性" class="headerlink" title="模型使用的简便性"></a>模型使用的简便性</h5><p>模型使用的简便性一般包含如下三层含义。</p>
<p>（1）模型需要的数据在软件系统中应该易于收集，而且收集需要投入的成本不能超过可靠性计划的预算。</p>
<p>（2）模型应该简单易懂，进行可靠性分析的软件测试人员不会花费太多的时间去研究专业的数学理论，他们只需要知道哪些假设适用，需要收集哪些数据，能够得到哪些分析结果就可以了。</p>
<p>（3）模型应该便于使用，最好能用工具实现数据的输入。也就是说，测试人员除了输入可靠性数据外，不需要深入模型内部进行一些额外的工作。</p>
<p>尽管这样，由于可靠性研究理论在软件工程领域发展的限制，可供选择的可靠性模型极其有限，这已在相当大的程度上制约了可靠性测试的开展。</p>
<h4 id="可靠性数据的收集"><a href="#可靠性数据的收集" class="headerlink" title="可靠性数据的收集"></a>可靠性数据的收集</h4><p>面向缺陷的可靠性测试产生的测试数据经过分析后，可以得到非常有价值的可靠性数据，是可靠性评价所用数据的一个重要来源，这部分数据取决于定义的运行剖面和选取的测试用例集。可靠性数据主要是指软件失效数据，是软件可靠性评价的基础，主要是在软件测试、实施阶段收集的。在软件工程的需求、设计和开发阶段的可靠性活动，也会产生影响较大的其他可靠性数据。因此，可靠性数据的收集工作是贯穿于整个软件生命周期的。</p>
<p>由于软件开发过程中的特殊复杂性及许多潜在因素的影响，可靠性数据收集工作会极为困难。目前，关于数据的收集工作，存在许多有待解决的问题。</p>
<p>（1）可靠性数据的规范不统一，对软件进行度量的定义混乱不清。例如，时间、缺陷、失效和模型结构等的定义，就相当含糊，缺乏统一的标准。这样就使得在进行软件可靠性数据的收集时，目标不明确，甚至无从下手。</p>
<p>（2）数据收集工作的连续性不能保证。可靠性数据的收集是连续的、长期的过程，而且需要投入一定的资金、人力、时间，往往这些投入会在软件的开发计划中被忽略，以至于不能保证可靠性数据收集工作的正常进行。</p>
<p>（3）缺乏有效的数据收集手段。进行数据收集同样需要方便实用的工具，然而除了在可靠性测试方面有了一些可用的数据收集工具外，其他方面的工具还十分缺乏。</p>
<p>（4）数据的完整性不能保证。即使可靠性活动计划做得再周密，收集到的数据仍有可能是不完全的，而且遗漏的数据往往会影响到可靠性评价的结果。</p>
<p>（5）数据质量和准确性不能保证。不完全的排错及诊断，使收集的数据中含有不少虚假的成分，它们不能正确反映软件的真实状况。使用不准确的可靠性数据进行的可靠性评价，误差有可能会比利用可靠性模型进行预测产生的误差大一个数量级，这说明数据质量的重要性。</p>
<p>为了给软件可靠性评价提供一套准确、有效的可靠性数据，有必要在软件工程中重视软件可靠性数据的收集工作，采取一些措施尽量解决上述问题。在现有条件下，可行的一些办法如下。</p>
<p>（1）及早确定所采用的可靠性模型，以确定需要收集的可靠性数据，并明确定义可靠性数据规范中的一些术语和记录方法，如时间、失效、失效严重程度类的定义，制定标准的可靠性数据记录和统计表格等。</p>
<p>（2）制定可实施性较强的可靠性数据收集计划，指定专人负责，抽取部分开发人员、质量保证人员、测试人员、用户业务人员参加，按照统一的规范收集记录可靠性数据。</p>
<p>（3）重视软件测试特别是可靠性测试产生的测试数据的整理和分析，因为这部分数据是用模拟软件实际运行环境的方法、模拟用户实际操作的测试用例测试软件系统产生的数据，对软件可靠性评价和预测有较高的实用价值。</p>
<p>（4）充分利用数据库来完成可靠性数据的存储和统计分析。一方面减少数据管理的混乱，一方面提高数据处理的效率。</p>
<h4 id="软件可靠性的评估和预测"><a href="#软件可靠性的评估和预测" class="headerlink" title="软件可靠性的评估和预测"></a>软件可靠性的评估和预测</h4><p>软件可靠性的评估和预测的主要目的，是为了评估软件系统的可靠性状况和预测将来一段时间的可靠性水平。下面是一些常见的需要利用软件可靠性评价进行解答的问题。</p>
<p>（1）判断是否达到了可靠性目标，是否达到了软件付诸使用的条件，是否达到了中止测试的条件。</p>
<p>（2）如未能达到，要再投入多少时间、多少人力和多少资金，才能达到可靠性目标或投入使用。</p>
<p>（3）在软件系统投入实际运行一年或若干时间后，经过维护、升级、修改，软件能否达到交付或部分交付用户使用的可靠性水平。</p>
<p>目前有不少支持软件可靠性估计的软件工具，只要将收集的失效数据分类并录入，选择合适的可靠性模型就可以获得软件可靠性的评价结果。</p>
<p>然而，对于那些可靠性要求很高的系统，必须进行很多测试才能预计出高置信度的可靠性结果。即便如此，仍然可能没有任何失效发生。没有失效就无法估计可靠性，不能认为程序的可靠度是1.0。除非已经进行了完全的测试，否则程序不失效就无法做出估计，而完全的测试几乎总是不可能的。如果在测试期间没有失效发生，可以简单地假设测试是基于二项式分布的，这样就可以对可靠性作保守估计。也可以凭经验，根据无故障运行的测试用例的数量，在一定的置信度水平上，估计可靠性的等级。</p>
<p>软件可靠性评价技术和方法主要依据选用的软件可靠性模型，其来源于统计理论。软件可靠性评估和预测以软件可靠性模型分析为主，但也要在模型之外运用一些统计技术和手段对可靠性数据进行分析，作为可靠性模型的补充、完善和修正。这些辅助方法如下。</p>
<p>（1）失效数据的图形分析法。运行图形处理软件失效数据，可以直观地帮助我们进行分析。图形指标如下。</p>
<p>①累积失效个数图形。</p>
<p>②单位时间段内的失效数的图形。</p>
<p>③失效间隔时间图形。</p>
<p>（2）试探性数据分析技术（Exploratory Data Analysis, EDA）。对于失效数据图形进行一定的数字化分析，能发现和揭示出数据中的异常。对可靠性分析有用的信息如下。</p>
<p>①循环相关。</p>
<p>②短期内失效数的急剧上升。</p>
<p>③失效数集中的时间段。</p>
<p>这种分析方法常可以发现因排错引入新的缺陷、数据收集的质量问题及时间域的错误定义等问题。</p>
<p>还有其他一些分析方法，这里就不一一赘述了。</p>
<h3 id="软件的可靠性设计与管理"><a href="#软件的可靠性设计与管理" class="headerlink" title="软件的可靠性设计与管理"></a>软件的可靠性设计与管理</h3><h4 id="软件可靠性设计"><a href="#软件可靠性设计" class="headerlink" title="软件可靠性设计"></a>软件可靠性设计</h4><p>在测试阶段，利用测试手段收集测试数据，并利用软件可靠性模型，可以评估或预测软件的可靠性。这些软件可靠性测试活动虽然能通过查错—排错活动有限地改善软件可靠性，但不能从根本上提高软件的可靠性，也难以保证软件可靠性，并且修改由于设计导致的软件缺陷，有可能付出比较昂贵的代价。实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制。为了从根本上提高软件的可靠性，降低软件后期修改的成本和难度，人们提出了可靠性设计的概念。</p>
<p>可靠性设计其实就是在常规的软件设计中，应用各种方法和技术，使程序设计在兼顾用户的功能和性能需求的同时，全面满足软件的可靠性要求，即采用一些技术手段，把可靠性“设计”到软件中去。软件可靠性设计技术就是以提高和保障软件的可靠性为目的，在软件设计阶段运用的一种特殊的设计技术。</p>
<p>在软件工程中已有很多比较成熟的设计技术，如结构化设计、模块化设计、自顶向下设计及自底向上设计等，这些技术是为了保障软件的整体质量而采用的。在此基础上，为了进一步提高软件的可靠性，通常会采用一些特殊设计技术。虽然软件可靠性设计技术与普通的软件设计技术没有明显的界限，但软件可靠性设计仍要遵循一些自己的原则。</p>
<p>（1）软件可靠性设计是软件设计的一部分，必须在软件的总体设计框架中使用，并且不能与其他设计原则相冲突。</p>
<p>（2）软件可靠性设计在满足提高软件质量要求的前提下，以提高和保障软件可靠性为最终目标。</p>
<p>（3）软件可靠性设计应确定软件的可靠性目标，不能无限扩大化，并且排在功能度、用户需求和开发费用之后考虑。</p>
<p>可靠性设计概念被广为引用，但并没有多少人能提出非常实用并且广泛运用的可靠性设计技术。一般来说，被认可的且具有应用前景的软件可靠性设计技术主要有容错设计、检错设计和降低复杂度设计等技术。</p>
<h5 id="容错设计技术"><a href="#容错设计技术" class="headerlink" title="容错设计技术"></a>容错设计技术</h5><p>对于软件失效后果特别严重的场合，如飞机的飞行控制系统、空中交通管制系统及核反应堆安全控制系统等，可采用容错设计方法。常用的软件容错技术主要有恢复块设计、N版本程序设计和冗余设计三种方法。</p>
<p>（1） $\color{green}{\text{恢复块设计}}$ 。</p>
<p>程序的执行过程可以看成是由一系列操作构成的，这些操作又可由更小的操作构成。恢复块设计就是选择一组操作作为容错设计单元，从而把普通的程序块变成恢复块。被选择用来构造恢复块的程序块可以是模块、过程、子程序和程序段等。</p>
<p>一个恢复块包含有若干个功能相同、设计差异的程序块文本，每一时刻有一个文本处于运行状态。一旦该文本出现故障，则用备份文本加以替换，从而构成“动态冗余”。软件容错的恢复块方法就是使软件包含有一系列恢复块。</p>
<p>（2） $\color{green}{\text{N版本程序设计}}$ 。</p>
<p>N版本程序的核心是通过设计出多个模块或不同版本，对于相同初始条件和相同输入的操作结果，实行多数表决，防止其中某一软件模块/版本的故障提供错误的服务，以实现软件容错。为使此种容错技术具有良好的结果，必须注意以下两个方面。</p>
<p>①使软件的需求说明具有完全性和精确性。这是保证软件设计错误不相关的前提，因为软件的需求说明是不同设计组织和人员的唯一共同出发点。</p>
<p>②设计全过程的不相关性。它要求各个不同的软件设计人员彼此不交流，程序设计使用不同的算法、不同的编程语言、不同的编译程序、不同的设计工具、不同的实现方法和不同的测试方法。为了彻底保证软件设计的不相关性，甚至提出设计人员应具有不同的受教育背景，来自不同的地域、不同的国家。</p>
<p>（3） $\color{green}{\text{冗余设计}}$ 。</p>
<p>改善软件可靠性的一个重要技术是冗余设计。在硬件系统中，在主运行的系统之外备用额外的元件或系统，如果出现一个元件故障或系统故障，则立即更换冗余的元件或切换到冗余的系统，则该硬件系统仍可以维持运行。在软件系统中，冗余技术的运用有所区别。如果采用相同两套软件系统作为互为备份，其意义不大，因为在相同的运行环境中，一套软件出故障的地方，另外一套也一定会出现故障。软件的冗余设计技术实现的原理是在一套完整的软件系统之外，设计一种不同路径、不同算法或不同实现方法的模块或系统作为备份，在出现故障时可以使用冗余的部分进行替换，从而维持软件系统的正常运行。</p>
<p>从表面上看，设计开发完成同样功能但实现方法完全不同的两套软件系统，需要的费用可能接近于单个版本软件开发费用的两倍，但采用冗余技术设计软件所增加的额外费用肯定远低于重新设计一个版本软件的费用。这是因为大多数设计花费，例如文档、测试以及人力都是有可能复用的。冗余设计还有可能导致软件运行时所花费的存储空间、内存消耗以及运行时间有所增加，这就需要在可靠性要求和额外付出代价之间作出折衷。</p>
<h5 id="检错技术"><a href="#检错技术" class="headerlink" title="检错技术"></a>检错技术</h5><p>在软件系统中，对无需在线容错的地方、或不能采用冗余设计技术的部分，如果对可靠性要求较高，故障有可能导致严重的后果。一般采用检错技术，在软件出现故障后能及时发现并报警，提醒维护人员进行处理。检错技术实现的代价一般低于容错技术和冗余技术，但它有一个明显的缺点，就是不能自动解决故障，出现故障后如果不进行人工干预，将最终导致软件系统不能正常运行。</p>
<p>采用检错设计技术要着重考虑几个要素：检测对象、检测延时、实现方式和处理方式。</p>
<p>（1）检测对象：包含两个层次的含义，即检测点和检测内容。在设计时应考虑把检测点放在容易出错的地方和出错对软件系统影响较大的地方；检测内容选取那些有代表性的、易于判断的指标。</p>
<p>（2）检测延时：从软件发生故障到被自检出来是有一定延时的，这段延时的长短对故障的处理是非常重要的。因此，在软件检错设计时要充分考虑到检测延时。如果延时长到影响故障的及时报警，则需要更换检测对象或检测方式。</p>
<p>（3）实现方式：最直接的一种实现方式是判断返回结果，如果返回结果超出正常范围，则进行异常处理。计算运行时间也是一种常用的技术，如果某个模块或函数运行超过预期的时间，可以判断出现故障。另外，还有置状态标志位等多种方法，自检的实现方式要根据实际情况来选用。</p>
<p>（4）处理方式：大多数检错采用“查出故障—停止软件系统运行—报警”的处理方式，但也有采用不停止或部分停止软件系统运行的情况，这一般由故障是否需要实时处理来决定。</p>
<h5 id="降低复杂度设计"><a href="#降低复杂度设计" class="headerlink" title="降低复杂度设计"></a>降低复杂度设计</h5><p>前面讲到，软件和硬件最大的区别之一就是软件的内部结构比硬件复杂得多，我们用软件复杂度来定量描述软件的复杂程度。软件复杂性常分为模块复杂性和结构复杂性。模块复杂性主要包含模块内部数据流向和程序长度两个方面，结构复杂性用不同模块之间的关联程度来表示。软件复杂度可用涉及到模块复杂性和结构复杂性的一些统计指标来进行定量描述，在这里就不进行详细叙述了。</p>
<p>软件的复杂性与软件可靠性有着密切的关系，软件复杂性是产生软件缺陷的重要根源。有研究表明，当软件的复杂度超过一定界限时，软件缺陷数会急剧上升，软件的可靠性急剧下降。因此，在设计时就应考虑降低软件的复杂性，使之处于一个合理的阀值之内，这是提高软件可靠性的有效方法。</p>
<p>降低复杂度设计的思想就是在保证实现软件功能的基础上，简化软件结构，缩短程序代码长度，优化软件数据流向，降低软件复杂度，从而提高软件可靠性。</p>
<p>除了容错设计、检错设计和降低复杂度设计技术外，人们尝试着把硬件可靠性设计中比较成熟的技术，如故障树分析（FTA）、失效模式与效应分析（FMEA）等运用到软件可靠性设计领域，这些技术大多是运用一些分析、预测技术，在软件设计时就充分考虑影响软件可靠性的因素，并采取一些措施进行优化。由于软件与硬件内部性质的巨大差异，这些技术在软件可靠性设计领域的应用效果和范围极其有限。</p>
<h4 id="软件可靠性管理"><a href="#软件可靠性管理" class="headerlink" title="软件可靠性管理"></a>软件可靠性管理</h4><p>为了进一步提高软件可靠性，人们又提出了软件可靠性管理的概念，把软件可靠性活动贯穿于软件开发的全过程。</p>
<p>软件可靠性管理是软件工程管理的一部分，它以全面提高和保证软件可靠性为目标，以软件可靠性活动为主要对象，是把现代管理理论用于软件生命周期中的可靠性保障活动的一种管理形式。</p>
<p>软件可靠性管理的内容包括软件工程各个阶段的可靠性活动的目标、计划、进度、任务和修正措施等。</p>
<p>软件工程各个阶段可能进行的主要的软件可靠性活动如下所述。由于软件之间的差异较大，并且人们对可靠性的期望不同，对可靠性的投入不同，所以下面的每项活动并不是每一个软件系统的可靠性管理的必须内容，也不是软件可靠性管理的全部内容。</p>
<h5 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h5><p>（1）确定软件的可靠性目标。</p>
<p>（2）分析可能影响可靠性的因素。</p>
<p>（3）确定可靠性的验收标准。</p>
<p>（4）制定可靠性管理框架。</p>
<p>（5）制定可靠性文档编写规范。</p>
<p>（6）制定可靠性活动初步计划。</p>
<p>（7）确定可靠性数据收集规范。</p>
<h5 id="概要设计阶段"><a href="#概要设计阶段" class="headerlink" title="概要设计阶段"></a>概要设计阶段</h5><p>（1）确定可靠性度量。</p>
<p>（2）制定详细的可靠性验收方案。</p>
<p>（3）可靠性设计。</p>
<p>（4）收集可靠性数据。</p>
<p>（5）调整可靠性活动计划。</p>
<p>（6）明确后续阶段的可靠性活动的详细计划。</p>
<p>（7）编制可靠性文档。</p>
<h5 id="详细设计阶段"><a href="#详细设计阶段" class="headerlink" title="详细设计阶段"></a>详细设计阶段</h5><p>（1）可靠性设计。</p>
<p>（2）可靠性预测（确定可靠性度量估计值）。</p>
<p>（3）调整可靠性活动计划。</p>
<p>（4）收集可靠性数据。</p>
<p>（5）明确后续阶段的可靠性活动的详细计划。</p>
<p>（6）编制可靠性文档。</p>
<h5 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h5><p>（1）可靠性测试（含于单元测试）。</p>
<p>（2）排错。</p>
<p>（3）调整可靠性活动计划。</p>
<p>（4）收集可靠性数据。</p>
<p>（5）明确后续阶段的可靠性活动的详细计划。</p>
<p>（6）编制可靠性文档。</p>
<h5 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h5><p>（1）可靠性测试〔含于集成测试、系统测试〕。</p>
<p>（2）排错。</p>
<p>（3）可靠性建模。</p>
<p>（4）可靠性评价。</p>
<p>（5）调整可靠性活动计划。</p>
<p>（6）收集可靠性数据。</p>
<p>（7）明确后续阶段的可靠性活动的详细计划。</p>
<p>（8）编制可靠性文档。</p>
<h5 id="实施阶段"><a href="#实施阶段" class="headerlink" title="实施阶段"></a>实施阶段</h5><p>（1）可靠性测试（含于验收测试）。</p>
<p>（2）排错。</p>
<p>（3）收集可靠性数据。</p>
<p>（4）调整可靠性模型。</p>
<p>（5）可靠性评价。</p>
<p>（6）编制可靠性文档。</p>
<p>可靠性管理目前还停留在定性描述的水平上，很难用量化的指标来进行可靠性管理。可靠性管理规范的制定水平和实施效果也有待提高。怎样利用有限的可靠性投入，达到预期的可靠性目标是软件项目管理者常常要面对的难题。因此，可靠性管理研究是一个长期的课题。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><h4 id="系统故障模型"><a href="#系统故障模型" class="headerlink" title="系统故障模型"></a>系统故障模型</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090958.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090958.png';" /></details>


<h4 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907091247.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907091247.png';" /></details>

<h5 id="可靠性vs可用性"><a href="#可靠性vs可用性" class="headerlink" title="可靠性vs可用性"></a>可靠性vs可用性</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907091440.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907091440.png';" /></details>

<h4 id="串联系统与并联系统可靠度计算"><a href="#串联系统与并联系统可靠度计算" class="headerlink" title="串联系统与并联系统可靠度计算"></a>串联系统与并联系统可靠度计算</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142225.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142225.png';" /></details>

<p>可靠度：是相乘的可靠度</p>
<h5 id="模冗余系统与混合系统"><a href="#模冗余系统与混合系统" class="headerlink" title="模冗余系统与混合系统"></a>模冗余系统与混合系统</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142301.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142301.png';" /></details>


<h4 id="系统容错技术"><a href="#系统容错技术" class="headerlink" title="系统容错技术"></a>系统容错技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142422.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142422.png';" /></details>

<p>架构来说可靠性是很重要的</p>
<h5 id="容错系统"><a href="#容错系统" class="headerlink" title="容错系统"></a>容错系统</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142738.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142738.png';" /></details>

<h4 id="N版本程序设计-恢复块方法-防卫式程序设计"><a href="#N版本程序设计-恢复块方法-防卫式程序设计" class="headerlink" title="N版本程序设计_恢复块方法_防卫式程序设计"></a>N版本程序设计_恢复块方法_防卫式程序设计</h4><h5 id="N版本程序设计"><a href="#N版本程序设计" class="headerlink" title="N版本程序设计"></a>N版本程序设计</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142829.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142829.png';" /></details>

<ul>
<li>与通常软件开发过程不同的是，N版本程序设计增加了三个新的阶段:相异成份规范评审、相异性确认、背对背测试</li>
<li>N版本程序的同步、N版本程序之间的通信、表决算法(全等表决、非精确表决、Cosmetie表决)、一致比较问题、数据相异性</li>
<li>各版本的需求说明说不一致</li>
</ul>
<h5 id="恢复块方法"><a href="#恢复块方法" class="headerlink" title="恢复块方法"></a>恢复块方法</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142912.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142912.png';" /></details>

<ul>
<li>设计时应保证实现主块和后备块之间的独立性,避免相关错误的产生,使主块和备份块之间的共性错误降到最低程度。</li>
<li>必须保证验证测试程序的正确性。</li>
</ul>
<h5 id="防卫式程序设计"><a href="#防卫式程序设计" class="headerlink" title="防卫式程序设计"></a>防卫式程序设计</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142954.png';" /></details>
try-catch

<ul>
<li>对于程序中存在的错误和不一致性，通过在程序中包含错误检查代码和错误恢复代码，使得一旦错误发生，程序能撤消错误状态,恢复到一个已知的正确状态中去</li>
<li>实现策略:错误检测、破坏估计、错误恢复</li>
</ul>
<h4 id="双机容错与集群技术"><a href="#双机容错与集群技术" class="headerlink" title="双机容错与集群技术"></a>双机容错与集群技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143115.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143115.png';" /></details>


<p>互备：出现故障接管另一台服务器的业务</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143322.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143322.png';" /></details>



<h4 id="集群技术"><a href="#集群技术" class="headerlink" title="集群技术"></a>集群技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143447.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143447.png';" /></details>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch12-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch12-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch12-系统安全架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:37" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:37+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 09:29:38" itemprop="dateModified" datetime="2021-09-04T09:29:38+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="系统安全架构设计"><a href="#系统安全架构设计" class="headerlink" title="系统安全架构设计"></a>系统安全架构设计</h2><h3 id="信息系统安全架构的简单描述"><a href="#信息系统安全架构的简单描述" class="headerlink" title="信息系统安全架构的简单描述"></a>信息系统安全架构的简单描述</h3><p>信息安全的特征是为了保证信息的机密性、完整性、可用性、可控性和不可抵赖性。信息系统的安全保障是以风险和策略为基础，在信息系统的整个生命周期中提供包括技术、管理、人员和工程过程的整体安全，在信息系统中保障信息的这些安全特征，并实现组织机构的使命。许多信息系统的用户需要提供一种方法和内容对信息系统的技术框架、工程过程能力和管理能力提出安全性要求，并进行可比性的评估、设计和实施。</p>
<h4 id="信息安全的现状及其威胁"><a href="#信息安全的现状及其威胁" class="headerlink" title="信息安全的现状及其威胁"></a>信息安全的现状及其威胁</h4><p>随着社会信息化进程的加快，计算机及网络已经在各行各业中得到了广泛的应用，同时一些重要单位如政府机关、部队、企业财务和人事部门已经越来越依赖于计算机。毫无疑问，在不远的将来，计算机和网络的普及程度会比现在有更大的提高，这种普及将会产生两方面的效应：其一，各行各业的业务运转几乎完全依赖于计算机和网络，各种重要数据如政府文件、工资档案、财务账目和人事资料等将全部依托计算机和网络存储、传输；其二，大多数人对计算机的了解更加全面，有更多的计算机技术水平较高的人可以采用种种手段对信息资源进行攻击。目前，信息安全主要可能会受到的威胁可以总结为以下几个方面，如图12-1所示。</p>
<details><summary>图12-1　网络与信息安全风险</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085527.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085527.png';" /></details>

<p>对于信息系统来说，威胁可以是针对物理环境、通信链路、网络系统、操作系统、应用系统以及管理系统等方面。物理安全威胁，是指对系统所用设备的威胁，自然灾害、电源故障、操作系统引导失败或数据库信息丢失、设备被盗/被毁造成数据丢失或信息泄露。通信链路安全威胁，是指在传输线路上安装窃听装置或对通信链路进行干扰。网络安全威胁，互联网的开放性、国际性与无安全管理性，对内部网络形成严重的安全威胁。操作系统安全威胁，对系统平台最危险的威胁是在系统软件或硬件芯片中植入威胁，如“木马”和“陷阱门”、BIOS有万能密码。应用系统安全威胁，是指对于网络服务或用户业务系统安全的威胁，也受到“木马”和“陷阱门”的威胁。管理系统安全威胁，必须从人员管理上杜绝安全漏洞。</p>
<p>具体来讲，常见的安全威胁有如下几种。</p>
<p>（1）信息泄露：信息被泄露或透露给某个非授权的实体。</p>
<p>（2）破坏信息的完整性：数据被非授权地进行增删、修改或破坏而受到损失。</p>
<p>（3）拒绝服务：对信息或其他资源的合法访问被无条件地阻止。</p>
<p>（4）非法使用（非授权访问）：某一资源被某个非授权的人、或以非授权的方式使用。</p>
<p>（5）窃听：用各种可能的合法或非法的手段窃取系统中的信息资源和敏感信息。例如对通信线路中传输的信号进行搭线监听，或者利用通信设备在工作过程中产生的电磁泄露截取有用信息等。</p>
<p>（6）业务流分析：通过对系统进行长期监听，利用统计分析方法对诸如通信频度、通信的信息流向、通信总量的变化等参数进行研究，从而发现有价值的信息和规律。</p>
<p>（7）假冒：通过欺骗通信系统（或用户）达到非法用户冒充成为合法用户，或者特权小的用户冒充成为特权大的用户的目的。黑客大多是采用假冒进行攻击。</p>
<p>（8）旁路控制：攻击者利用系统的安全缺陷或安全性上的脆弱之处获得非授权的权利或特权。例如，攻击者通过各种攻击手段发现原本应保密，但是却又暴露出来的一些系统“特性”。利用这些“特性”，攻击者可以绕过防线守卫者侵入系统的内部。</p>
<p>（9）授权侵犯：被授权以某一目的使用某一系统或资源的某个人，却将此权限用于其他非授权的目的，也称作“内部攻击”。</p>
<p>（10）特洛伊木马：软件中含有一个察觉不出的或者无害的程序段，当它被执行时，会破坏用户的安全。这种应用程序称为特洛伊木马（Trojan Horse）。</p>
<p>（11）陷阱门：在某个系统或某个部件中设置了“机关”，使得当提供特定的输入数据时，允许违反安全策略。</p>
<p>（12）抵赖：这是一种来自用户的攻击，例如，否认自己曾经发布过的某条消息、伪造一份对方来信等。</p>
<p>（13）重放：所截获的某次合法的通信数据备份，出于非法的目的而被重新发送。</p>
<p>（14）计算机病毒：所谓计算机病毒，是一种在计算机系统运行过程中能够实现传染和侵害的功能程序。一种病毒通常含有两个功能：一种功能是对其他程序产生“感染”；另外一种或者是引发损坏功能、或者是一种植入攻击的能力。</p>
<p>（15）人员不慎：一个授权的人为了钱或利益、或由于粗心，将信息泄露给一个非授权的人。</p>
<p>（16）媒体废弃：信息被从废弃的磁盘或打印过的存储介质中获得。</p>
<p>（17）物理侵入：侵入者通过绕过物理控制而获得对系统的访问。</p>
<p>（18）窃取：重要的安全物品，如令牌或身份卡被盗。</p>
<p>（19）业务欺骗：某一伪系统或系统部件欺骗合法的用户或系统自愿地放弃敏感信息。</p>
<p>通过对网络面临的安全风险威胁和实施相应控制措施的支出进行合理的评价，提出有效合理的安全技术，形成提升网络信息的安全性质的安全方案，是安全架构设计的根本目标。在实际应用中，可以从安全技术的角度提取出5个方面的内容：认证鉴别、访问控制、内容安全、冗余恢复和审计响应。</p>
<h4 id="国内外影响较大的标准和组织"><a href="#国内外影响较大的标准和组织" class="headerlink" title="国内外影响较大的标准和组织"></a>国内外影响较大的标准和组织</h4><h5 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h5><p>有如下标准。</p>
<p>（1）可信计算机标准评估规则橘皮书（TCSEC，美国）</p>
<p>（2）欧洲ITSEC标准</p>
<p>（3）加拿大CTCPEC标准</p>
<p>（4）美国联邦准则（FC）</p>
<p>（5）美国信息技术安全评价通用准则（CC）</p>
<p>（6）ISO安全体系结构标准（IS07498-2-1989）〈信息处理系统开放系统互连基本参考模型第二部分安全体系结构〉</p>
<p>（7）美国国家安全局：信息保障技术框架（IATF）</p>
<p>2）我国的标准</p>
<p>（1）主管部门：公安部、信息产业部和国家技术标准局等</p>
<p>（2）主要技术标准如下。</p>
<p>●　GA163-1997（计算机信息系统安全专用产品分类原则）</p>
<p>●　GB17895-1999（计算机信息系统安全保护等级划分准则）</p>
<p>●　GB/T9387.2-1995（信息处理系统开放系统互连基本参考模型第二部分安全体系结构）</p>
<p>●　GB 15834.1-1995（信息处理数据加密实体鉴别机制第一部分：一般模型）</p>
<p>●　GB 4943-1995（信息技术设备的安全）</p>
<h5 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h5><p>1）国际标准化组织（ISO）</p>
<p>ISO的信息技术标准化委员会TC97在1984年1月，专门组织了一个分技术委员会SC20，负责制定数据加密技术的国际标准；之后在1987年，ISO的TC97和IEC的TCs47B/83合并成为ISO/IEC联合技术委员会（JTC1）；1990年4月，ISO将原来的数据加密分技术委员会SC20，更名为安全技术分技术委员会SC27，专门从事信息技术安全一般方法和技术的标准化工作。而ISO/TC68负责银行业务应用范围内有关信息安全标准的制定，它主要制定行业应用标准，在组织上和标准之间与SC27有着密切的联系。</p>
<p>由于信息技术的发展，开放系统互连的网络体系结构的广泛应用，信息技术安全标准化越来越受到人们的重视。在信息技术安全分委会的成立会上，研究了信息技术安全标准化的发展规划，明确了指导思想，确定了工作目标，制定了实施计划，提出了具体的措施，正在为建立完整的信息技术安全标准体系而积极组织开展研究工作和标准制定工作。</p>
<p>2）信息技术安全分技术委员会</p>
<p>1984年7月，在我国的全国计算机与信息处理标准化技术委员会下，建立了相应的数据加密分技术委员会，在国家技术监督局和原电子工业部的领导下，归口国内外的信息技术数据加密的标准化工作。随着信息技术的发展和工作范围的扩大，在原数据加密分委员会的基础上，于1997年8月改组成了信息技术安全分技术委员会（与ISO/IECJTC1/SC27信息技术的安全技术分委会对应）。它是一个具有广泛代表性、权威性和军民结合的信息安全标准化组织。其工作范围是负责信息和通信安全的通用框架、方法、技术和机制的标准化，归口管理国内外对应的标准化工作。其技术安全包括开放式安全体系结构、各种安全信息交换的语义规则、在有关的应用程序接口和协议引用安全功能接口等。</p>
<h3 id="系统安全体系架构规划框架及其方法"><a href="#系统安全体系架构规划框架及其方法" class="headerlink" title="系统安全体系架构规划框架及其方法"></a>系统安全体系架构规划框架及其方法</h3><p>安全技术体系架构是对组织机构信息技术系统的安全体系结构的整体描述。安全技术体系架构能力是拥有信息技术系统的组织机构根据其策略的要求和风险评估的结果，参考相关技术体系构架的标准和最佳实践，结合组织机构信息技术系统的具体现状和需求，建立的符合组织机构信息技术系统战略发展规划的信息技术系统整体体系框架；它是组织机构信息技术系统战略管理的具体体现。技术体系架构能力是组织机构执行安全技术整体能力的体现，它反映了组织机构在执行信息安全技术体系框架管理达到预定的成本、功能和质量目标上的度量。</p>
<p>安全技术体系架构过程的目标是建立可持续改进的安全技术体系架构的能力，信息技术系统千变万化，有各种各样的分类方式，为从技术角度建立一个通用的对象分析模型，在本书中将信息系统抽象成一个基本完备的信息系统分析模型，如图12-2所示。从信息技术系统分析模型出发，建立整个信息技术系统的安全架构。</p>
<details><summary>图12-2　信息技术系统分析模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085724.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085724.png';" /></details>

<p>一般来说，OSI参考模型将网络划分为物理、数据链路、网络、传输、会话、表示和应用7层，Andrew S.Tanenbau综合OSI参考模型和TCP/IP参考模型将网络划分为物理、数据链路、网络、传输、应用5层。在本模型中，首先需要做的就是对网络结构层次进行划分，考虑到安全评估是以安全风险威胁分析入手的，而且在实际的网络安全评估中会发现，主机和存储系统占据了大量的评估考察工作，虽然主机和存储系统都属于应用层，但本模型由于其重要性，特将其单列为一个层次，因此根据网络中风险威胁的存在实体划分出5个层次的实体对象：应用、存储、主机、网络和物理。</p>
<p>信息系统安全规划是一个非常细致和非常重要的工作，首先需要对企业信息化发展的历史情况进行深入和全面的调研，知道家底、掌握情况，针对信息系统安全的主要内容进行整体的发展规划工作。下面用图12-3表示信息系统安全体系的框架。</p>
<p>从图12-3可以看出，信息系统安全体系主要是由技术体系、组织机构体系和管理体系三部分共同构成的。技术体系是全面提供信息系统安全保护的技术保障系统，该体系由物理安全技术和系统安全技术两大类构成。组织体系是信息系统的组织保障系统，由机构、岗位和人事三个模块构成。机构分为领导决策层、日常管理层和具体执行层；岗位是信息系统安全管理部门根据系统安全需要设定的负责某一个或某几个安全事务的职位；人事是根据管理机构设定的岗位，对岗位上在职、待职和离职的员工进行素质教育、业绩考核和安全监管的机构。管理体系由法律管理、制度管理和培训管理三部分组成。</p>
<details><summary>图12-3　信息系统安全体系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085744.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085744.png';" /></details>

<p>信息系统安全体系清楚了之后，就可以针对以上描述的内容进行全面的规划。信息系统安全规划的层次方法与步骤可以有不同，但是规划内容与层次应该是相同。规划的具体环节、相互之间的关系和具体方法如图12-4所示。</p>
<details><summary>图12-4　信息系统安全规划框架图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085800.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085800.png';" /></details>


<h5 id="信息系统安全规划依托企业信息化战略规划"><a href="#信息系统安全规划依托企业信息化战略规划" class="headerlink" title="信息系统安全规划依托企业信息化战略规划"></a>信息系统安全规划依托企业信息化战略规划</h5><p>信息化战略规划是以整个企业的发展目标、发展战略和企业各部门的业务需求为基础，结合行业信息化方面的需求分析、环境分析和对信息技术发展趋势的掌握，定义出企业信息化建设的远景、使命、目标和战略，规划出企业信息化建设的未来架构，为信息化建设的实施提供一副完整的蓝图，全面系统地指导企业信息化建设的进程。信息系统安全规划依托企业信息化战略规划，对信息化战略的实施起到保驾护航的作用。信息系统安全规划的目标应该与企业信息化的目标是一致的，而且应该比企业信息化的目标更具体明确、更贴近安全。信息系统安全规划的一切论述都要围绕着这个目标展开和部署。</p>
<h5 id="信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑"><a href="#信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑" class="headerlink" title="信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑"></a>信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑</h5><p>信息系统安全规划的方法可以不同、侧重点可以不同，但都需要围绕技术安全、管理安全、组织安全进行全面的考虑。规划的内容基本上应该涵盖：确定信息系统安全的任务、目标、战略以及战略部门和战略人员，并在此基础上制定出物理安全、网络安全、系统安全、运营安全、人员安全的信息系统安全的总体规划。物理安全包括环境设备安全、信息设备安全、网络设备安全、信息资产设备的物理分布安全等。网络安全包括网络拓扑结构安全、网络的物理线路安全、网络访问安全（防火墙、入侵检测系统和VPN等）等。系统安全包括操作系统安全、应用软件安全和应用策略安全等。运营安全应在控制层面和管理层面保障，包括备份与恢复系统安全、入侵检测功能、加密认证功能、漏洞检查及系统补丁功能、口令管理等。人员安全包括安全管理的组织机构、人员安全教育与意识机制、人员招聘及离职管理、第三方人员安全管理等。</p>
<h5 id="信息系统安全规划以信息系统与信息资源的安全保护为核心"><a href="#信息系统安全规划以信息系统与信息资源的安全保护为核心" class="headerlink" title="信息系统安全规划以信息系统与信息资源的安全保护为核心"></a>信息系统安全规划以信息系统与信息资源的安全保护为核心</h5><p>信息系统安全规划的最终效果应该体现在对信息系统与信息资源的安全保护上，因此规划工作需要围绕着信息系统与信息资源的开发、利用和保护工作进行，要包括蓝图、现状、需求和措施4个方面。</p>
<p>（1）对信息系统与信息资源的规划需要从信息化建设的蓝图入手，知道企业信息化发展策略的总体目标和各阶段的实施目标，制定出信息系统安全的发展目标。</p>
<p>（2）对企业的信息化工作现状进行整体的、综合、全面的分析，找出过去工作中的优势与不足。</p>
<p>（3）根据信息化建设的目标提出未来几年的需求，这个需求最好可以分解成若干个小的方面，以便于今后的落实与实施。</p>
<p>（4）要写明在实施工作阶段的具体措施与办法，提高规划工作的执行力度。信息系统安全规划服务于企业信息化战略目标，信息系统安全规划做得好，企业信息化工作的实现就有了保障。信息系统安全规划是企业信息化发展战略的基础性工作，不是可有可无而是非常重要。由于企业信息化的任务与目标不同，所以信息系统安全规划包括的内容就不同，建设的规模就有很大的差异，因此信息系统安全规划无法从专业书籍或研究资料中找到非常有针对性的、有帮助的适用法则，也不可能给出一个规范化的信息系统安全规划的模板。在这里提出信息系统安全规划框架与方法，给出了信息系统安全规划工作的一种建设原则、建设内容、建设思路，具体规划还需要深入细致地进行本地化的调查与研究。</p>
<h3 id="网络安全体系架构设计"><a href="#网络安全体系架构设计" class="headerlink" title="网络安全体系架构设计"></a>网络安全体系架构设计</h3><p>介绍信息系统安全体系的目的，就是将普遍性安全原理与信息系统的实际相结合，形成满足信息系统安全需求的安全体系结构。</p>
<h4 id="OSI的安全体系架构概述"><a href="#OSI的安全体系架构概述" class="headerlink" title="OSI的安全体系架构概述"></a>OSI的安全体系架构概述</h4><p>国家标准《信息处理系统工程开放系统互联基本参考模型—第二部分：安全体系结构》（GB/T 9387.2-1995）（等同于ISO 7498-2），以及互联网安全体系结构（RFC 2401），是两个普遍适用的安全体系结构，目的在于保证开放系统进程与进程之间远距离安全交换信息。这些标准在参考模型的框架内，建立起一些指导原则与约束条件，从而提供了解决开放互联系统中安全问题的一致性方法。</p>
<p>OSI安全体系结构提供以下内容。</p>
<p>（1）提供安全服务与有关安全机制在体系结构下的一般描述，这些服务和机制必须是为体系结构所配备的。</p>
<p>（2）确定体系结构内部可以提供这些服务的位置。</p>
<p>（3）保证安全服务完全准确地得以配置，并且在信息系统的安全周期中一直维持，安全功能务必达到一定强度的要求。</p>
<p>国家标准《信息处理系统工程开放系统互联基本参考模型—第二部分：安全体系结构》（GB/T 9387.2-1995）（等同于ISO 7498-2），给出了基于OSI参考模型的7层协议之上的信息安全体系结构。其核心内容是：为了保证异构计算机进程与进程之间远距离交换信息的安全，它定义了该系统5大类安全服务，以及提供这些服务的8类安全机制及相应的OSI安全管理，并可根据具体系统适当地配置于OSI模型的7层协议中。图12-5所示的三维安全空间解释了这一体系结构。</p>
<p>在OSI 7层协议中除第5层（会话层）外，每一层均能提供相应的安全服务。实际上，最适合配置安全服务的是在物理层、网络层、运输层及应用层上，其他层都不宜配置安全服务。</p>
<p>ISO开放系统互联安全体系的5类安全服务包括鉴别、访问控制、数据机密性、数据完整性和抗抵赖性。</p>
<p>分层多点安全技术体系架构，也称为深度防御安全技术体系架构，它通过以下方式将防御能力分布至整个信息系统中。</p>
<details><summary>图12-5　信息安全体系结构示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085956.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085956.png';" /></details>

<p>（1）多点技术防御。在对手可以从内部或外部多点攻击一个目标的前提下，多点技术防御通过对以下多个防御核心区域的防御达到抵御所有方式的攻击的目的。</p>
<p>①网络和基础设施。为了确保可用性，局域网和广域网需要进行保护以抵抗各种攻击，如拒绝服务攻击等。为了确保机密性和完整性，需要保护在这些网络上传送的信息以及流量的特征以防止非故意的泄露。</p>
<p>②边界。为了抵御主动的网络攻击，边界需要提供更强的边界防御，例如流量过滤和控制以及入侵检测。</p>
<p>③计算环境。为了抵御内部、近距离的分布攻击，主机和工作站需要提供足够的访问控制。</p>
<p>（2）分层技术防御。即使最好的可得到的信息保障产品也有弱点，其最终结果将使对手能找到一个可探查的脆弱性，一个有效的措施是在对手和目标间使用多个防御机制。为了减少这些攻击成功的可能性和对成功攻击的可承担性，每种机制应代表一种唯一的障碍并同时包括保护和检测方法。例如，在外部和内部边界同时使用嵌套的防火墙并配合以入侵检测就是分层技术防御的一个实例。</p>
<p>支撑性基础设施为网络、边界和计算环境中信息保障机制运行基础的支撑性基础设施，包括公钥基础设施以及检测和响应基础设施。</p>
<p>（1）公钥基础设施。提供一种通用的联合处理方式，以便安全地创建、分发和管理公钥证书和传统的对称密钥，使它们能够为网络、边界和计算环境提供安全服务。这些服务能够对发送者和接收者的完整性进行可靠验证，并可以避免在未获授权的情况下泄露和更改信息。公钥基础设施必须支持受控的互操作性，并与各用户团体所建立的安全策略保持一致。</p>
<p>（2）检测和响应基础设施。检测和响应基础设施能够迅速检测并响应入侵行为。它也提供便于结合其他相关事件观察某个事件的“汇总”性能。另外，它也允许分析员识别潜在的行为模式或新的发展趋势。</p>
<p>必须提醒的是，信息系统的安全保障不仅仅依赖于技术，还需要集成的技术和非技术防御手段。一个可接受级别的信息保障依赖于人员、管理、技术和过程的综合。</p>
<p>图12-6描述了分层多点安全技术体系架构。</p>
<details><summary>图12-6　分层多点安全技术体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090039.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090039.png';" /></details>

<p>分层多点安全技术体系架构为信息系统安全保障提供了框架和进一步分析所需的重点区域划分。在具体的技术方案实践中，应从使命和需求的实际情况出发制定适合组织机构要求的技术体系和方案。</p>
<h4 id="鉴别框架"><a href="#鉴别框架" class="headerlink" title="鉴别框架"></a>鉴别框架</h4><p>鉴别（Authentication）的基本目的，就是防止其他实体占用和独立操作被鉴别实体的身份。鉴别提供了实体声称其身份的保证，只有在主体和验证者的关系背景下，鉴别才是有意义的。鉴别有两种重要的关系背景：一是实体由申请者来代表，申请者与验证者之间存在着特定的通信关系（如实体鉴别）；二是实体为验证者提供数据项来源。</p>
<p>鉴别的方式主要基于以下5种。</p>
<p>（1）已知的，如一个秘密的口令。</p>
<p>（2）拥有的，如IC卡、令牌等。</p>
<p>（3）不改变的特性，如生物特征。</p>
<p>（4）相信可靠的第三方建立的鉴别（递推）。</p>
<p>（5）环境（如主机地址等）。</p>
<p>鉴别信息（Artificial Intelligence, AI）是指申请者要求鉴别到鉴别过程结束所生成、使用和交换的信息。鉴别信息的类型有交换鉴别信息（交换AI）、申请鉴别信息（申请AI）和验证鉴别信息（验证AI）。</p>
<details><summary>图12-7　申请者、验证者、可信第三方之间的关系及三种鉴别信息类型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090111.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090111.png';" /></details>


<p>注意：在某些特定的情况下，可以不涉及可信任的第三方。</p>
<p>验证AI可以是主体的，也可以是可信任第三方的。</p>
<p>在某些情况下，为了产生交换AI，申请者需要与可信第三方进行交互。类似的，为了验证交换AI，验证者也需要同可信第三方进行交互。在这种情况下，可信第三方持有相关实体的验证AI，也可能使用可信第三方来传递交换AI。实体也可能需要持有鉴别可信第三方中所使用的鉴别信息。</p>
<p>鉴别服务分为以下阶段：安装阶段；修改鉴别信息阶段；分发阶段；获取阶段；传送阶段；验证阶段；停活阶段；重新激活阶段；取消安装阶段。</p>
<p>在安装阶段，定义申请AI和验证AI。修改鉴别信息阶段，实体或管理者申请AI和验证AI变更（如修改口令）。在分发阶段，为了验证交换AI，把验证AI分发到各实体（如申请者或验证者）以供使用。在获取阶段，申请者或验证者可得到为鉴别实例生成特定交换AI所需的信息，通过与可信第三方进行交互或鉴别实体间的信息交换可得到交换AI。例如，当使用联机密钥分配中心时，申请者或验证者可从密钥分配中心得到一些信息，如鉴别证书。在传送阶段，在申请者与验证者之间传送交换AI。在验证阶段，用验证AI核对交换AI。在停活阶段，将建立一种状态，使得以前能被鉴别的实体暂时不能被鉴别。在重新激活阶段，使在停活阶段建立的状态将被终止。在取消安装阶段，实体从实体集合中被拆除。</p>
<h4 id="访问控制框架"><a href="#访问控制框架" class="headerlink" title="访问控制框架"></a>访问控制框架</h4><p>访问控制（Access Control）决定开放系统环境中允许使用哪些资源、在什么地方适合阻止未授权访问的过程。在访问控制实例中，访问可以是对一个系统（即对一个系统通信部分的一个实体）或对一个系统内部进行的。</p>
<p>图12-8和图12-9说明了访问控制的基础性功能。</p>
<details><summary>图12-9　ADF示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090214.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090214.png';" /></details>

<p>ACI（访问控制信息）是用于访问控制目的的任何信息，其中包括上下文信息。ADI（访问控制判决信息）是在做出一个特定的访问控制判决时可供ADF使用的部分（或全部）ACI。ADF（访问控制判决功能）是一种特定功能，它通过对访问请求、ADI以及该访问请求的上下文使用访问控制策略规则而做出访问控制判决。AEF（访问控制实施功能）确保只有对目标允许的访问才由发起者执行。</p>
<p>涉及访问控制的有发起者、AEF、ADF和目标。发起者代表访问或试图访问目标的人和基于计算机的实体。目标代表被试图访问或由发起者访问的，基于计算机或通信的实体。例如，目标可能是OSI实体、文件或者系统。访问请求代表构成试图访问部分的操作和操作数。</p>
<p>当发起者请求对目标进行特殊访问时，AEF就通知ADF需要一个判决来做出决定。为了作出判决，给ADF提供了访问请求（作为判决请求的一部分）和下列几种访问控制判决信息（ADI）。</p>
<p>（1）发起者ADI（ADI由绑定到发起者的ACI导出）。</p>
<p>（2）目标ADI（ADI由绑定到目标的ACI导出）。</p>
<p>（3）访问请求ADI（ADI由绑定到访问请求的ACI导出）。</p>
<p>ADF的其他输入是访问控制策略规则（来自ADF的安全域权威机构）和用于解释ADI或策略的必要上下文信息。上下文信息包括发起者的位置、访问时间或使用中的特殊通信路径。基于这些输入，以及可能还有以前判决中保留下来的ADI信息，ADF可以做出允许或禁止发起者试图对目标进行访问的判决。该判决传递给AEF，然后AEF允许将访问请求传给目标或采取其他合适的行动。</p>
<p>在许多情况下，由发起者对目标的逐次访问请求是相关的。应用中的一个典型例子是在打开与同层目标的连接应用进程后，试图用相同（保留）的ADI执行几个访问。对一些随后通过连接进行通信的访问请求，可能需要给ADF提供附加的ADI以允许访问请求。在另一些情况中，安全策略可能要求对一个或多个发起者与一个或多个目标之间的某种相关访问请求进行限制。这时，ADF可能使用与多个发起者和目标有关的先前判决中所保留的ADI来对特殊访问请求作出判决。</p>
<p>如果得到AEF的允许，访问请求只涉及发起者与目标的单一交互。尽管发起者和目标之间的一些访问请求是完全与其他访问请求无关的，但常常是两个实体进入一个相关的访问请求集合中，如质询应答模式。在这种情况下，实体根据需要同时或交替地变更发起者和目标角色，可以由分离的AEF组件、ADF组件和访问控制策略对每一个访问请求执行访问控制功能。</p>
<h4 id="机密性框架"><a href="#机密性框架" class="headerlink" title="机密性框架"></a>机密性框架</h4><p>机密性（Confidentiality）服务的目的是确保信息仅仅是对被授权者可用。由于信息是通过数据表示的，而且数据可能导致关系的变化（如文件操作可能导致目录改变或可用存储区域的改变），因此信息能通过许多不同的方式从数据中导出。例如，通过理解数据的含义（如数据的值）导出；通过使用数据相关的属性（如存在性、创建的数据、数据大小、最后一次更新的日期等）进行推导；通过研究数据的上下文关系，即那些与之相关的其他数据实体导出；通过观察数据表达式的动态变化导出。</p>
<p>信息的保护通过确保数据被限制于授权者获得，或通过特定方式表示数据来获得，这种保护方式的语义是，数据只对那些拥有某种关键信息的人才是可访问的。有效的机密性保护要求必要的控制信息（如密钥和RCI等）是受到保护的，这种保护机制和用来保护数据的机制是不同的（如密钥可以通过物理手段保护等）。</p>
<p>在机密性框架中用到被保护的环境和被交叠保护的环境两个概念。在被保护环境中的数据，通过使用特别的安全机制（或多个机制）保护。在一个被保护环境中的所有数据以类似方法受到保护。当两个或更多的环境交叠的时候，交叠中的数据能被多重保护。可以推断，从一个环境移到另一个环境的数据的连续保护必然涉及到交叠保护环境。</p>
<p>机密性机制</p>
<p>数据的机密性可以依赖于所驻留和传输的媒体。因此，存储数据的机密性能通过使用隐藏数据语义（如加密）或将数据分片的机制来保证。数据在传输中的机密性能通过禁止访问的机制、通过隐藏数据语义的机制或通过分散数据的机制得以保证（如跳频等）。这些机制类型能被单独使用或者组合使用。</p>
<p>1）通过禁止访问提供机密性</p>
<p>通过禁止访问的机密性能通过在ITU-T Rec. 812或ISO/IEC 10181-3中描述的访问控制获得，以及通过物理媒体保护和路由选择控制获得。通过物理媒体保护的机密性保护可以采取物理方法保证媒体中的数据只能通过特殊的有限设备才能检测到。数据机密性通过确保只有授权的实体才能使这些机制本身有效的方式来实现。通过路由选择控制的机密性保护机制的目的，是防止被传输数据项表示的信息未授权泄露。在这一机制下只有可信和安全的设施才能路由数据，以达到支持机密性服务的目的。</p>
<p>2）通过加密提供机密性</p>
<p>这些机制的目的是防止数据泄露在传输或存储中。加密机制分为基于对称的加密机制和基于非对称加密的机密机制。</p>
<p>除了以下两种机密性机制外，还可以通过数据填充、通过虚假事件（如把在不可信链路上交换的信息流总量隐藏起来）、通过保护PDU头和通过时间可变域提供机密性。</p>
<h4 id="完整性框架"><a href="#完整性框架" class="headerlink" title="完整性框架"></a>完整性框架</h4><p>完整性（Integrity）框架的目的是通过阻止威胁或探测威胁，保护可能遭到不同方式危害的数据完整性和数据相关属性完整性。所谓完整性，就是数据不以未经授权方式进行改变或损毁的特征。</p>
<p>完整性服务有几种分类方式：根据防范的违规分类违规操作分为未授权的数据修改、未授权的数据创建、未授权的数据删除、未授权的数据插入和未授权的数据重放。依据提供的保护方法分为阻止完整性损坏和检测完整性损坏。依据是否包括恢复机制分为具有恢复机制的和不具有恢复机制的。</p>
<p>完整性机制的类型</p>
<p>由于保护数据的能力与正在使用的媒体有关。完整性机制是有区别的，包括如下类型。</p>
<p>（1）阻止对媒体访问的机制。包括物理隔离的、不受干扰的信道；路由控制；访问控制。</p>
<p>（2）用以探测对数据或数据项序列的非授权修改的机制。未授权修改包括未授权数据创建、数据删除以及数据重复。而相应的完整性机制包括密封、数字签名、数据重复（作为对抗其他类型违规的手段）、与密码变换相结合的数字指纹和消息序列号。</p>
<p>按照保护强度，完整性机制可分为不作保护；对修改和创建的探测；对修改、创建、删除和重复的探测；对修改和创建的探测并带恢复功能；对修改、创建、删除和重复的探测并带恢复功能。</p>
<h4 id="抗抵赖框架"><a href="#抗抵赖框架" class="headerlink" title="抗抵赖框架"></a>抗抵赖框架</h4><p>抗抵赖（Non-repudiation）服务包括证据的生成、验证和记录，以及在解决纠纷时随即进行的证据恢复和再次验证。</p>
<p>框架所描述的抗抵赖服务的目的是提供有关特定事件或行为的证据。事件或行为本身以外的其他实体可以请求抗抵赖服务。抗抵赖服务可以保护的行为实例有发送X.400消息；在数据库中插入记录、请求远程操作等。</p>
<p>当涉及消息内容的抗抵赖服务时，为提供原发证明，必须确认数据原发者身份和数据完整性。为提供递交证明，必须确认接收者身份和数据完整性。在某些情况下，还可能需要涉及上下文关系（如日期、时间、原发者/接收者的地点等）的证据。</p>
<p>抗抵赖服务提供下列可在试图抵赖的事件中使用的设备：证据生成、证据记录、验证生成的证据、证据的恢复和重验。</p>
<p>纠纷可以在纠纷两方之间直接通过检查证据解决。但是，纠纷也可能不得不通过仲裁者解决，该仲裁者评估并确定是否发生过有纠纷的行为或事件。</p>
<p>抗抵赖由4个独立的阶段组成：证据生成；证据传输、存储和恢复；证据验证；解决纠纷，如图12-10所示。</p>
<p>1）证据生成</p>
<p>在这个阶段中，证据生成请求者请求证据生成者为事件或行为生成证据。卷入事件或行为中的实体，称为证据实体，其卷入关系由证据建立。根据抗抵赖服务的类型，证据可由证据实体、或可能与可信第三方的服务一起生成、或者单独由可信第三方生成。</p>
<p>2）证据传输、存储和恢复</p>
<p>在这个阶段，证据在实体间传输或从存储器取出来或传到存储器。</p>
<details><summary>图12-10　参与生成、传输、存储/恢复和证实阶段的实体(注：本图是示意图，并非定义)</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090400.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090400.png';" /></details>

<p>3）证据验证</p>
<p>在这个阶段，证据在证据使用者的请求下被证据验证者验证。本阶段的目的是在出现纠纷的事件中，让证据使用者确信被提供的证据确实是充分的。可信第三方服务也可参与，以提供验证该证据的信息。</p>
<p>4）解决纠纷</p>
<p>在解决纠纷阶段，仲裁者有解决双方纠纷的责任。图12-11描述了纠纷解决阶段。</p>
<details><summary>图12-11　抗抵赖过程的纠纷解决阶段</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904092122.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904092122.png';" /></details>

<h3 id="数据库系统的安全设计"><a href="#数据库系统的安全设计" class="headerlink" title="数据库系统的安全设计"></a>数据库系统的安全设计</h3><p>在数据库系统中， 由于数据的集中管理，随之而来的是多用户存取，以及近年来跨网络的分布系统的急速发展。数据库的安全问题可以说已经构成信息系统最为关键的环节，而电子政务中所涉及的数据库密级更高、实时性更强。因此，有必要根据其特殊性完善安全策略，这些安全策略应该能保证数据库中的数据不会被有意地攻击或无意地破坏。不会发生数据的外泄、丢失和毁损，即实现了数据库系统安全的完整性、保密性和可用性。从数据库管理系统的角度而言，要采取的安全策略一般为用户管理、存取控制、数据加密、审计跟踪和攻击检测，从而解决数据库系统的运行安全和信息安全。</p>
<p>下面分别从数据库安全设计的评估标准和完整性设计两方面进行讨论。</p>
<h4 id="数据库安全设计的评估标准"><a href="#数据库安全设计的评估标准" class="headerlink" title="数据库安全设计的评估标准"></a>数据库安全设计的评估标准</h4><p>随着人们对安全问题的认识和对安全产品的要求不断提高，在计算机安全技术方面逐步建立了一套安全评估标准，以规范和指导安全信息的建立、安全产品的生产，并能较准确地评测产品的安全性能指标。在当前各国制定和采用的标准中，最重要的是1985年美国国防部颁布的“可信计算机系统评估标准（Trusted Computer System Evaluation Criteria, TCSEC）”桔皮书（简称为DoD85）。1991年，美国国家计算机安全中心（The National Computer Seaurity Center, NCSC）又颁布了“可信计算机评估标准关于可信数据库管理系统的解释（Trusted Database Interpretation, TDI）”。我国也于1994年2月发布了“中华人民共和国计算机信息系统安全保护条例”。在TCSEC中，将安全系统分为4大类7个等级。</p>
<p>TDI是TCSEC在数据库管理系统方面的扩充和解释，并从安全策略、责任、保护和文档4个方面进一步描述了每级的安全标准。按照TCSEC标准，D类产品是基本没有安全保护措施的产品，C类产品只提供了安全保护措施，一般不称为安全产品。B类以上产品是实行强制存取控制的产品，也是真正意义上的安全产品。所谓安全产品均是指安全级别在B1以上的产品，而安全数据库研究原型一般是指安全级别在B1级以上的以科研为目的，尚未产品化的数据库管理系统原型。</p>
<h4 id="数据库的完整性设计"><a href="#数据库的完整性设计" class="headerlink" title="数据库的完整性设计"></a>数据库的完整性设计</h4><p>数据库完整性是指数据库中数据的正确性和相容性。数据库完整性由各种各样的完整性约束来保证，因此可以说数据库完整性设计就是数据库完整性约束的设计。数据库完整性约束可以通过DBMS或应用程序来实现，基于DBMS的完整性约束作为模式的一部分存入数据库中。通过DBMS实现的数据库完整性按照数据库设计步骤进行设计，而由应用软件实现的数据库完整性则纳入应用软件设计。</p>
<h5 id="数据库完整性设计原则"><a href="#数据库完整性设计原则" class="headerlink" title="数据库完整性设计原则"></a>数据库完整性设计原则</h5><p>在实施数据库完整性设计时，需要把握以下基本原则。</p>
<p>（1）根据数据库完整性约束的类型确定其实现的系统层次和方式，并提前考虑对系统性能的影响。一般情况下，静态约束应尽量包含在数据库模式中，而动态约束由应用程序实现。</p>
<p>（2）实体完整性约束、参照完整性约束是关系数据库最重要的完整性约束，在不影响系统关键性能的前提下需尽量应用。用一定的时间和空间来换取系统的易用性是值得的。</p>
<p>（3）要慎用目前主流DBMS都支持的触发器功能，一方面由于触发器的性能开销较大；另一方面，触发器的多级触发不好控制，容易发生错误，非用不可时，最好使用Before型语句级触发器。</p>
<p>（4）在需求分析阶段就必须制定完整性约束的命名规范，尽量使用有意义的英文单词、缩写词、表名、列名及下划线等组合，使其易于识别和记忆，如CKC EMP REAL INCOME EMPLOYEE、PK EMPLOYEE、CKT EMPLOYEE。如果使用CASE工具，一般有默认的规则，可在此基础上修改使用。</p>
<p>（5）要根据业务规则对数据库完整性进行细致的测试，以尽早排除隐含的完整性约束间的冲突和对性能的影响。</p>
<p>（6）要有专职的数据库设计小组，自始至终负责数据库的分析、设计、测试、实施及早期维护。数据库设计人员不仅负责基于DBMS的数据库完整性约束的设计实现，还要负责对应用软件实现的数据库完整性约束进行审核。</p>
<p>（7）应采用合适的CASE工具来降低数据库设计各阶段的工作量。好的CASE工具能够支持整个数据库的生命周期，这将使数据库设计人员的工作效率得到很大提高，同时也容易与用户沟通。</p>
<h5 id="数据库完整性的作用"><a href="#数据库完整性的作用" class="headerlink" title="数据库完整性的作用"></a>数据库完整性的作用</h5><p>数据库完整性对于数据库应用系统非常关键，其作用主要体现在以下几个方面。</p>
<p>（1）数据库完整性约束能够防止合法用户使用数据库时向数据库中添加不合语义的数据。</p>
<p>（2）利用基于DBMS的完整性控制机制来实现业务规则，易于定义，容易理解，而且可以降低应用程序的复杂性，提高应用程序的运行效率。同时，基于DBMS的完整性控制机制是集中管理的，因此比应用程序更容易实现数据库的完整性。</p>
<p>（3）合理的数据库完整性设计，能够同时兼顾数据库的完整性和系统的效能。例如装载大量数据时，只要在装载之前临时使基于DBMS的数据库完整性约束失效，此后再使其生效，就能保证既不影响数据装载的效率又能保证数据库的完整性。</p>
<p>（4）在应用软件的功能测试中，完善的数据库完整性有助于尽早发现应用软件的错误。</p>
<p>（5）数据库完整性约束可分为6类：列级静态约束、元组级静态约束、关系级静态约束、列级动态约束、元组级动态约束和关系级动态约束。动态约束通常由应用软件来实现。不同DBMS支持的数据库完整性基本相同，Oracle支持的基于DBMS的完整性约束如表12-1所示。</p>
<details><summary>表12-1　Oracle支持的基于DBMS的完整性约束</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904092311.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904092311.png';" /></details>

<h5 id="数据库完整性设计示例"><a href="#数据库完整性设计示例" class="headerlink" title="数据库完整性设计示例"></a>数据库完整性设计示例</h5><p>一个好的数据库完整性设计，首先需要在需求分析阶段确定要通过数据库完整性约束实现的业务规则。然后在充分了解特定DBMS提供的完整性控制机制的基础上，依据整个系统的体系结构和性能要求，遵照数据库设计方法和应用软件设计方法，合理选择每个业务规则的实现方式。最后，认真测试，排除隐含的约束冲突和性能问题。基于DBMS的数据库完整性设计大体分为以下几个阶段。</p>
<p>1）需求分析阶段</p>
<p>经过系统分析员、数据库分析员和用户的共同努力，确定系统模型中应该包含的对象，如人事及工资管理系统中的部门、员工和经理等，以及各种业务规则。</p>
<p>在完成寻找业务规则的工作之后，确定要作为数据库完整性的业务规则，并对业务规则进行分类。其中作为数据库模式一部分的完整性设计按下面的过程进行，而由应用软件来实现的数据库完整性设计将按照软件工程的方法进行。</p>
<p>2）概念结构设计阶段</p>
<p>概念结构设计阶段是将依据需求分析的结果转换成一个独立于具体DBMS的概念模型，即实体关系图（Entity-Relationship Diagram, ERD）。在概念结构设计阶段就要开始数据库完整性设计的实质阶段，因为此阶段的实体关系将在逻辑结构设计阶段转化为实体完整性约束和参照完整性约束，到逻辑结构设计阶段将完成设计的主要工作。</p>
<p>3）逻辑结构设计阶段</p>
<p>此阶段就是将概念结构转换为某个DBMS所支持的数据模型，并对其进行优化，包括对关系模型的规范化。此时，依据DBMS提供的完整性约束机制，对尚未加入逻辑结构中的完整性约束列表，逐条选择合适的方式加以实现。</p>
<p>在逻辑结构设计阶段结束时，作为数据库模式一部分的完整性设计也就基本完成了。每种业务规则都可能有好几种实现方式，应该选择对数据库性能影响最小的一种，有时需通过实际测试来决定。</p>
<h4 id="案例：电子商务系统的安全性设计"><a href="#案例：电子商务系统的安全性设计" class="headerlink" title="案例：电子商务系统的安全性设计"></a>案例：电子商务系统的安全性设计</h4><p>本节以一个具体的电子商务系统——高性能的RADIUS，来阐明电子商务系统的安全设计的基本原理和设计方法。</p>
<h5 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h5><p>AAA（Authentication Authorization and Accounting，验证、授权和审记）是运行于宽带网络接入服务器上的客户端程序。AAA提供了一个用来对验证、授权和审记三种安全功能进行配置的一致的框架，实际上是对网络安全的一种管理。这里的网络安全主要指访问控制，包括哪些用户可以访问网络服务器？如何对正在使用网络资源的用户进行记账？下面简单介绍验证、授权和记账的作用。</p>
<p>（1）验证（Authentication）：验证用户是否可以获得访问权，认证信息包括用户名、用户密码和认证结果等。</p>
<p>（2）授权（Authorization）：授权用户可以使用哪些服务，授权包括服务类型及服务相关信息等。</p>
<p>（3）审记（Accounting）：记录用户使用网络资源的情况，用户IP地址、MAC地址掩码等。</p>
<p>RADIUS服务器负责接收用户的连接请求，完成验证并把用户所需的配置信息返回给BAS建立连接，从而可以获得访问其他网络的权限时，BAS就起到了认证用户的作用。BAS负责把用户之间的验证信息传递通过密钥的参与来完成。用户的密码加密以后才能在网上传递，以避免用户的密码在不安全的网络上被窃取。</p>
<p>例如，用户A请求得到某些服务（如PPP、Telnet和Rlogin等），但必须通过BAS，由BAS依据某种顺序与所连接服务器通信从而进行验证。用户A通过拨号进入BAS，然后BAS按配置好的验证方式（如PPP、PAP和CHAP等）要求用户A输入用户名和密码等信息。用户A终端出现提示，用户按提示输入。通过与BAS的连接，BAS得到这些信息。而后BAS把这些信息传递给响应验证或记账的服务器，并根据服务器的响应来决定用户是否可以获得他所请求的服务。</p>
<p>一个网络允许外部用户通过宽带网对其进行访问，这样用户在地理上可以分散。大量分散用户可以通过DSL Modem等从不同的地方对这个网络进行随机的访问，用户可以把自己的信息传递给这个网络，也可以从这个网络得到自己想要的信息。由于存在内外的双向数据流动，网络安全就成为很重要的问题，因此对信息进行有效管理是必要的。管理的内容包括用户是否可以获得访问权、用户可以允许使用哪些服务，以及如何对使用网络资源的用户进行计费。AAA很好地完成了这3项任务。</p>
<h5 id="软件架构设计"><a href="#软件架构设计" class="headerlink" title="软件架构设计"></a>软件架构设计</h5><p>RADIUS软件主要应用于宽带业务运营的支撑管理，是一个需要可靠运行且高安全级别的软件支撑系统。RADIUS软件的设计还需要考虑一个重要的问题，即系统高性能与可扩展性。</p>
<p>电信数据业务的开展随着我国宽带业务的开展，在宽带接入方式、宽带业务管理等诸多方面均会发生变化，以适应市场的发展。业务的发展对RADIUS软件架构的设计就是重中之重了，其设计将会直接影响系统可持续建设的质量与成本。通过深入分析，高性能的RADIUS软件架构核心如图12-12所示。</p>
<details><summary>图12-12　RADIUS软件架构核心逻辑性</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904092916.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904092916.png';" /></details>

<p>RADIUS软件架构分为三个层面：协议逻辑层、业务逻辑层和数据逻辑层。</p>
<p>协议逻辑层主要实现RFC框架中的内容，处理网络通信协议的建立、通信和停止方面的工作。在软件功能上，这个部分主要相当于一个转发引擎，起到分发处理的内容分发到不同的协议处理过程中，这一层的功能起到了协议与业务处理的分层处理的作用。</p>
<p>业务逻辑层的设计是RADIUS软件架构设计的核心部分，架构设计的好坏将直接关系到应用过程中能否适应RADIUS协议扩展部分的实现，更重要的是会直接影响到用户单位的业务能否顺利开展。协议处理进程主要是对转发引擎发来的包进行初步分析，并根据包的内容进一步分发到不同的业务逻辑处理进程。协议处理进程可以根据项目的情况，配置不同的协议进程数，提高包转发与处理的速度。业务逻辑进程分为认证、计费和授权三种类型，不同的业务逻辑进程可以接收不同协议进程之间的信息并进行处理。转发进程与协议进程之间采用共享内存的方法，实现进程之间的通信。协议进程与业务逻辑处理进程之间采用进程加线程的实现方法，这样实现的好处在于不需要对业务处理线程进行应用软件层面的管理，而由UNIX系统进行管理，进一步提高应用系统处理的效率与质量。</p>
<p>数据逻辑层需要对来自业务逻辑处理线程统一管理与处理数据库代理池的数据，由数据库代理池统一连接数据库，以减少对数据库系统的压力。同时减小了系统对数据库的依赖性，增强了系统适应数据库系统的能力。</p>
<p>RADIUS软件分层架构的实现，一是对软件风险进行了深入的分析，并且在软件实现的过程中得到更多的体现；二是可以构建一个或多个重用的构件单元，同时也可以继承原来的成果。BAS和RADIUS之间验证信息的传递是通过密钥的参与来完成的。从原来的窄带拨号上网到现在的宽带接入、无线接入，在信息加密方面从传统的MD5、PAP和CHAP方式增加了EAP-tls、P-ttls和EAP-sim等多种格式。基于分层架构的协议处理进程有自然的灵活性，可快速适应RFC指南中增加的内容。</p>
<p>RADIUS的功能，一是实际处理大量用户并发的能力，二是软件架构的可扩展性。负载均衡是提高RADIUS软件性能的有效方法，它主要完成以下任务。</p>
<p>（1）解决网络拥塞问题，就近提供服务，实现地理位置无关性。</p>
<p>（2）为用户提供更好的访问质量。</p>
<p>（3）提高服务器响应速度。</p>
<p>（4）提高服务器及其他资源的利用效率。</p>
<p>（5）避免了网络关键部位出现单点失效。</p>
<p>当同时在线的宽带用户量巨大时，BAS发送给后台RADIUS的用户数据更新包的数量会急剧增加，RADIUS服务器的处理能力就成为性能瓶颈。当包的数量大于RADIUS服务器的处理能力时，就会出现丢包，造成用户数据的丢失或不完整。</p>
<p>通过代理转发的方式，把从BAS发送过来的数据包平均转发到其他RADIUS服务器中进行处理，实现RADIUS服务器之间的负载均衡。</p>
<p>RADIUS高性能还体现在自我管理的功能，该功能包括UNIX守护管理监控和进程管理监控。在有故障时，服务进程能内部调度进程，以协调进程的工作情况。同时对RADIUS报文进行SNMP的代理管理，向综合网络管理平台实时发送信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch11-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch11-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch11-信息安全技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:20" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:20+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-15 19:01:58" itemprop="dateModified" datetime="2021-10-15T19:01:58+08:00">2021-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="信息安全技术"><a href="#信息安全技术" class="headerlink" title="信息安全技术"></a>信息安全技术</h2><h3 id="信息安全关键技术"><a href="#信息安全关键技术" class="headerlink" title="信息安全关键技术"></a>信息安全关键技术</h3><h4 id="加密和解密技术"><a href="#加密和解密技术" class="headerlink" title="加密和解密技术"></a>加密和解密技术</h4><p>计算机网络的广泛应用，产生了大量的电子数据，这些电子数据需要传输到网络的许多地方，并存储起来。对于这些数据，有意的计算机犯罪和无意的数据破坏成为最大的威胁。原则上来说，对电子数据的攻击有两种形式：一种称为 $\color{red}{\text{被动攻击}}$ ，就是非法地 $\color{green}{\text{从传输信道上截取信息}}$ ，或 $\color{green}{\text{从存储载体上偷窃}}$ 、 $\color{green}{\text{复制信息}}$ 。另一种称为 $\color{red}{\text{主动进攻}}$ ，就是对传输或存储的数据进行恶意的 $\color{green}{\text{删除}}$ 、 $\color{green}{\text{篡改}}$ 等。实践证明，密码技术是防止数据攻击的一种有效而经济的方法。</p>
<p>我们把消息的发送者称为信源；消息的目的地称为信宿；没有加密的消息称为明文；加密后的消息称为密文；用来传输消息的通道称为信道。通信时，明文M通过变换E得到密文C，即C＝E（u, v, …，W; m）。这个过程称为加密，参数u, v, …, w称为密钥。这里所说的变换E，就是加密算法。从密文C恢复到明文M，这个过程称为解密。解密算法D是加密算法E的逆运算。</p>
<p>加密密钥与解密密钥相同，或者加密密钥与解密密钥可以简单相互推导的密码体制称为对称密码体制。现代密码学修正了密钥的对称性，加密、解密密钥是不同的，也是不能（在有效的时间内）相互推导的，称为非对称密码体制。</p>
<h5 id="对称密钥密码体制及典型算法"><a href="#对称密钥密码体制及典型算法" class="headerlink" title="对称密钥密码体制及典型算法"></a>对称密钥密码体制及典型算法</h5><p>对称算法（Symmetric Algorithm），有时又称为传统密码算法，在大多数对称算法中，加密密钥和解密密钥是相同的，所以也称秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。</p>
<p>对称加密的优点在于算法实现的效率高、速度快。对称加密的缺点在于密钥的管理过于复杂。常用的对称加密算法有DES、IDEA等。</p>
<p>1）DES算法简介</p>
<p>DES （Data Encryption Standard，数据加密标准）是由IBM公司研制的一种加密算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准。二十年来，它一直活跃在国际保密通信的舞台上，扮演了十分重要的角色。</p>
<p>DES是一个分组加密算法，它以64位为分组对数据加密；同时DES也是一个对称算法。它的密匙长度是56位（因为每个第8位都用作奇偶校验），密匙可以是任意56位的数，而且可以任意时候改变。其保密性依赖于密钥。</p>
<p>DES算法分如下3个步骤进行。</p>
<p>（1）对给定的64位的明文x，通过一个初始置换函数IP来排列x，从而构造出长为64位的串X0，记X0为IP（X）＝L0R0，L0表示X0的前32位，R0表示X0的后32位。</p>
<p>（2）计算16次迭代，设前i－1次迭代结果为Xi－1＝Li－1Ri－1，则第i轮迭代运算为：</p>
<p>Li＝Ri－1　　Ri＝Li－1⊕f（Ri－1, ki）</p>
<p>其中，Li－1表示Xi－1的前32位，Ri－1表示Xi－1的后32位，⊕表示两位串的“异或”运算，f主要是由一个称为S盒的置换构成。Ki是一些由初始的56位经过密钥编排函数产生的48位长的块。</p>
<p>（3）对位串L16R16作逆置换IP-1得密文y，y＝IP-1（R16L16），置换IP-1是IP的逆置换。</p>
<p>DES算法的示意图如图11-1所示。</p>
<details><summary>图11-1　DES算法示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904083750.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904083750.png';" /></details>

<p>2）IDEA算法简介</p>
<p>国际数据加密算法（International Data Encryption Algorithm, IDEA）是1992年来学嘉等人设计的算法。该算法的前身是1990年公布的推荐加密标准（Proposed Encryption Standard, PES）算法。</p>
<p>IDEA分组长度为64b，密钥长度为128b。其使用的运算非常简单，只需要异或，模216加和模（216＋1）乘，这些算法都很容易使用硬件或者软件实现（而DES算法便于用硬件实现，难以用软件实现），所有运算都是使用基于16b数运行，很容易在现在的16b、32b、64b CPU上实现。由于这一特性，使用软件实现的IDEA算法的运算速度比DES算法要快。由于IDEA算法使用的密钥长度为128b，远远大于DES算法的56b，对于128b密钥来说，使用穷举法攻击的方法是不现实的。</p>
<h5 id="不对称密码加密算法"><a href="#不对称密码加密算法" class="headerlink" title="不对称密码加密算法"></a>不对称密码加密算法</h5><p>不对称密码体制又称为双密钥和公钥密码体制，是于1976年由Diffie和Hellman提出的。与对称密码体制相比，非对称密码体制有两个不同的密钥，其中一个密钥称为私钥，该密钥被秘密保存；另一个密钥公开，不需要保密。</p>
<p>公钥密码系统的工作方式为：任何人都可以将自己加密的公钥公布在网络或其他可以公开的地方。其他人欲传送信息给该接收方时，可使用该接收方所公布的公钥将信息加密之后传送给接收方。接收方收到加密后的信息时，就可以利用拥有的与此公钥相对应的私钥，将该加密信息解出来。所以公开密钥密码系统的通信双方，不需要事先通过安全秘密管道交换密钥，即可进行通信。</p>
<p>RSA密码体制是一个常用的非对称的密码体制，它是一个既能用于数据加密也能用于数字签名的算法。</p>
<p>RSA的安全性依赖于大素数分解。公钥和私钥都是两个大素数（大于100个十进制位）的函数。据猜测，从一个密钥和密文推断出明文的难度等同于分解两个大素数的积。</p>
<p>1）密钥对的产生</p>
<p>（1）选择两个大素数，p和q。</p>
<p>（2）计算n＝p*q。</p>
<p>（3）随机选择加密密钥e，e必须满足以下条件：</p>
<p>GCD（e, φ（N））＝1</p>
<p>其中，φ为Euler’s Function，φ（N）为小于N、且与N互质的整数的个数。在此，φ（N）＝（p－1）<em>（q－1）（也有些做法是取LCM（（p－1）</em>（q－1）））。</p>
<p>（4）利用Euclid算法计算解密密钥d，满足d＝e-1modφ（N）。</p>
<p>产生出加密公钥e、N与解密密钥d之后，使用者将e及N公开，就可以使用它们来执行加解密的工作了。</p>
<p>2）加密程序</p>
<p>使用者将其欲加密的信息M，在取得对方的公钥e及N之后，执行模（mod，即同余的运算，C＝MmodN，C等于M除以N的余数）指数运算，就可获得密文C。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904083931.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904083931.png';" /></details>

<p>3）解密程序</p>
<p>对方在收到密文C后，以自己的私钥执行下面的解密程序，解密时作如下计算：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904083947.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904083947.png';" /></details>

<p>即可获得明文M。</p>
<p>RSA可用于数字签名，方案是用（b）签名，用（a）验证。具体操作时考虑到安全性和M信息量较大等因素，一般是先作HASH运算。</p>
<p>RSA的安全性依赖于大数分解，由于进行的都是大数计算，使得RSA最快的情况也是DES百分之一。无论是软件还是硬件实现，速度慢一直是RSA的缺陷，因此一般来说，RSA只用于少量数据加密。</p>
<h4 id="散列函数与数字签名"><a href="#散列函数与数字签名" class="headerlink" title="散列函数与数字签名"></a>散列函数与数字签名</h4><h5 id="MD5散列算法"><a href="#MD5散列算法" class="headerlink" title="MD5散列算法"></a>MD5散列算法</h5><p>散列函数是一种公开的数学函数。散列函数运算的输入信息叫做报文，运算后所得到的结果叫做散列码或者叫做消息摘要。散列函数h＝H（M）具有如下一些特点。</p>
<p>（1）不同内容的报文具有不同的散列码，给定M，要找到另一消息M，使H（M）＝H（M′）很难。</p>
<p>（2）散列函数是单向的，给出M，容易计算出h。给定h，根据h＝H（M）反推M却很难。</p>
<p>（3）对于任何一个报文，无法预知它的散列码。</p>
<p>（4）散列码具有固定的长度，不管原始报文的长度如何，通过散列函数运算后的散列码都具有一样的长度。</p>
<p>由于散列函数具有这些特征，因此散列函数可以用来检测报文的可靠性。接收者对收到的报文用与发送者相同的散列函数进行运算，如果得到与发送者相同的散列码，则可以认为报文没有被篡改，否则报文就是不可信的。</p>
<p>常见的散列函数有MD5、SHA和HMAC等。</p>
<p>MD5（Message Digest 5）是一种非常著名的散列算法，已经成为国际标准。它是在MD4的基础上改进的算法，是具有更好的安全性能的散列算法。MD5散列算法对输入的任意长度消息产生128位（16字节）长度的散列值（或称消息摘要）。MD5算法包括以下4个步骤。</p>
<p>（1）附加填充位。首先对输入的报文进行填位补充，使填充后的数据长度模512后余448。如果数据长度正好模512余448，则需增加512个填充位，也就是说填充的个数为1～512位。填充位第一个位为1，其余全部为0。</p>
<p>（2）补足长度。将数据长度表示为二进制，如果长度超过64位，则截取其低64位；如果长度不足64位，则在其高位补0。将这个64位的报文长度补在经过填充的报文后面，使得最后的数据为512位的整数倍。</p>
<p>（3）初始化MD缓存器。MD5运算要用到一个128位的MD5缓存器，用来保存中间变量和最终结果。该缓存器又可看成是4个32位的寄存器A、B、C、D，初始化为：</p>
<p>A:01 23 45 67　B: 89 ab cd ef　C: fe dc ba 98　D: 76 54 32 10</p>
<p>（4）处理数据段。首先定义4个非线性函数F、G、H、I，对输入的报文运算以512位数据段为单位进行处理。对每一个数据段都要进行4轮的逻辑处理，在4轮中分别使用4个不同的函数F、G、H、I。每一轮以ABCD和当前的512位的块为输入，处理后送入ABCD（128位）。</p>
<h5 id="数字签名与数字水印"><a href="#数字签名与数字水印" class="headerlink" title="数字签名与数字水印"></a>数字签名与数字水印</h5><h6 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h6><p>数字签名可以解决否认、伪造、篡改及冒充等问题。具体要求：发送者事后不能否认发送的报文签名、接收者能够核实发送者发送的报文签名、接收者不能伪造发送者的报文签名、接收者不能对发送者的报文进行部分篡改、网络中的某一用户不能冒充另一用户作为发送者或接收者。凡是需要对用户的身份进行判断的情况都可以使用数字签名，例如加密信件、商务信函、订货购买系统、远程金融交易和自动模式处理等。</p>
<p>数字签名方案一般包括三个过程：系统的初始化过程、签名产生过程和签名验证过程。在签名产生的过程中，用户利用给定的算法对消息产生签名；在签名验证过程中，验证者利用公开验证方法对给定消息的签名进行验证，得出签名的有效性。</p>
<p>实现数字签名的方法有很多，目前采用得比较多的是非对称加密技术和对称加密技术。虽然这两种技术的实施步骤不尽相同，但大体的工作程序是一样的。用户首先可以下载或者购买数字签名软件，然后安装在个人计算机上。在产生密钥对后，软件自动向外界传送公开密钥。由于公共密钥的存储需要，所以需要建立一个鉴定中心（Certification Authority, CA）完成个人信息及其密钥的确定工作。用户在获取公开密钥时，首先向鉴定中心请求数字确认，鉴定中心确认用户身份后，发出数字确认，同时鉴定中心向数据库发送确认信息。然后用户使用私有密钥对所传信息签名，保证信息的完整性、真实性，也使发送方无法否认信息的发送，之后发向接收方；接收方接收到信息后，使用公开密钥确认数字签名，在使用这种技术时，签名者必须注意保护好私有密钥，因为它是公开密钥体系安全的重要基础。如果密钥丢失，应该立即报告鉴定中心取消认证，将其列入确认取消列表之中。其次，鉴定中心必须能够迅速确认用户的身份及其密钥的关系。一旦接收到用户请求，鉴定中心要立即认证信息的安全性并返回信息。</p>
<p>目前已经有大量的数字签名算法，如RSA、E1Gama1、Fiat-Shamir、美国的数字签名标准/算法（DSS/DSA）、椭圆曲线等多种。</p>
<h6 id="数字水印"><a href="#数字水印" class="headerlink" title="数字水印"></a>数字水印</h6><p>随着数字技术和因特网的发展，各种形式的多媒体数字作品（如图像、视频和音频等）纷纷以网络形式发表，其版权保护成为一个迫切需要解决的问题。数字水印（Digital Watermarking）是实现版权保护的有效办法，如今已成为多媒体信息安全研究领域的一个热点，也是信息隐藏技术研究领域的重要分支。该技术是通过在原始数据中嵌入秘密信息——水印（Watermark）来证实该数据的所有权。这种被嵌入的水印可以是一段文字、标识或序列号等，而且这种水印通常是不可见或不可察的，它与原始数据（如图像、音频和视频数据）紧密结合并隐藏其中，在经过一些不破坏源数据使用价值或商用价值的操作后仍能保存下来。数字水印技术必须具有较强的鲁棒性、安全性和透明性。</p>
<p>（1）典型数字水印系统模型。</p>
<p>图11-2为水印信号嵌入模型，其功能是将水印信号加入原始数据中；图11-3为水印信号检测模型，用来判断某一数据中是否含有指定的水印信号。</p>
<details><summary>图11-3　水印信号检测模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904084113.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904084113.png';" /></details>

<h6 id="数字水印主要应用领域。"><a href="#数字水印主要应用领域。" class="headerlink" title="数字水印主要应用领域。"></a>数字水印主要应用领域。</h6><p>①版权保护。即数字作品的所有者可用密钥产生一个水印，并将其嵌入原始数据，然后公开发布他的水印版本作品。当该作品被盗版或出现版权纠纷时，所有者即可利用图11-2或图11-3的方法从盗版作品或水印版作品中获取水印信号作为依据，从而保护所有者的权益。</p>
<p>②加指纹。为避免未经授权的复制制作和发行，出品人可以将不同用户的ID或序列号作为不同的水印（指纹）嵌入作品的合法备份中。一旦发现未经授权的备份，就可以根据此备份所恢复出的指纹来确定它的来源。</p>
<p>③标题与注释。即将作品的标题、注释等内容（如一张照片的拍摄时间和地点等）以水印形式嵌入该作品中，这种隐式注释不需要额外的带宽，且不易丢失。</p>
<p>④篡改提示。当数字作品被用于法庭、医学、新闻及商业时，常需确定它们的内容是否被修改、伪造或特殊处理过。为实现该目的，通常可将原始图像分成多个独立块，再将每个块加入不同的水印。同时可通过检测每个数据块中的水印信号，来确定作品的完整性。与其他水印不同的是，这类水印必须是脆弱的，并且检测水印信号时，不需要原始数据。</p>
<p>⑤使用控制。这种应用的一个典型例子是DVD防复制系统，即将水印信息加入DVD数据中，这样DVD播放机即可通过检测DVD数据中的水印信息而判断其合法性和可复制性。从而保护制造商的商业利益。</p>
<p>典型数字水印算法有空域算法、变换域算法、压缩域算法、NEC算法和生理模型算法等。</p>
<h4 id="密钥分配中心与公钥基础设施"><a href="#密钥分配中心与公钥基础设施" class="headerlink" title="密钥分配中心与公钥基础设施"></a>密钥分配中心与公钥基础设施</h4><p>在现代密码系统中，算法本身的保密已经不重要了，对于数据的保密在很大程度上、甚至完全依赖于对密钥的保密。只要密钥能够保密，即使加密算法公开，甚至加密设备丢失，也不会对加密系统的坚固性和正常使用产生多大影响。相反，如果密钥丢失，则不但非法用户可以窃取机密数据，而且合法用户面对密文却如读天书，无法提取有效的信息。因此，在密码系统中，如何高效地分配密钥、安全地管理密钥对保证数据安全来说至关重要。</p>
<h5 id="密钥分配中心"><a href="#密钥分配中心" class="headerlink" title="密钥分配中心"></a>密钥分配中心</h5><p>一个信息系统中任意两个用户之间都可以自己协商来选择不同的密钥，显然，对于总共有N个用户的系统，每个用户都要保存N×（N－1）个密钥。在用户数量较少时，这样来分配密钥还是比较简单、易用的，但是一旦用户数量多起来，系统中要保存的密钥会急剧增多，让每个用户自己高效、安全地管理数量庞大的密钥实际上是不可能的。</p>
<p>有一种非常有效的密钥自动分配方案是密钥分配中心（Key Distribution Center, KDC）技术。</p>
<p>在KDC方案中，每一个用户都只保存自己的私钥SK和KDC的公钥PKKDC，而在通信时再从KDC获得其他用户的公钥或者仅仅在某一次通信中可以使用的对称密钥加密算法的临时密钥K。</p>
<p>假设A和B都是KDC的注册用户，他们分别拥有私钥SKA、SKB。设用对称密钥来加密他们之间的这次对话，那么密钥的分配过程如下。</p>
<p>首先，A向密钥分配中心发送SKA（A, B），表示自己想与B会话。该请求用自己的私钥SKA加密，KDC收到A的请求，用A的公钥来验证请求是由A发出的后，根据某种算法来生成供A、B之间会话使用的对称密钥K。KDC向A返回PKA（K, PKB（A, K）），该应答是用A的公钥加密的，只有A能解读。A用自己的私钥解密应答，得到密钥K，并将PKB（A, K）发送给B，表明A欲与B进行会话。B用自己的私钥解密得到会话密钥K。</p>
<p>至此，完成一次密钥分配。</p>
<p>2．数字证书和公开密钥基础设施</p>
<p>数字签名和公钥加密都是基于不对称加密技术的，存在的问题有：如何保证公开密钥的持有者是真实的；大规模信息系统环境下公开密钥如何产生、分发和管理。</p>
<p>要解决以上问题，就要用到数字证书和PKI。</p>
<p>1）数字证书</p>
<p>数字证书提供了一个在公钥和拥有相应私钥的实体之间建立关系的机制。目前最常用的数字证书格式是由国际标准ITU-T X.509 V3版本定义的。</p>
<p>数字证书中采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己保存私钥，用它进行解密和签名；同时设定一个公钥，并由本人公开，为一组用户所共享，用于加密和验证签名。</p>
<p>数字证书是用户在系统中作为确认身份的证据。在通信的各个环节中，参与通信的各方通过验证对方数字证书，从而确认对方身份的真实性和有效性，从而解决相互间的信任问题。</p>
<p>数字证书的内容一般包括：唯一标识证书所有者的名称、唯一标识证书签发者的名称、证书所有者的公开密钥、证书签发者的数字签名、证书的有效期及证书的序列号等。</p>
<p>2）公钥基础设施</p>
<p>PKI（Public Key Infrastructure，公钥基础设施）的目标是向广大的信息系统用户和应用程序提供公开密钥的管理服务。</p>
<p>PKI的结构模型中有三类实体：管理实体、端实体和证书库。管理实体是PKI的核心，是服务的提供者；端实体是PKI的用户，是服务的使用者；证书库是一个分布式的数据库，用于证书和CRL的存放和检索。</p>
<p>CA和RA是两种管理实体。CA是框架中唯一能够发布和撤销证书的实体，维护证书的生命周期；RA负责处理用户请求，在验证了请求的有效性后，代替用户向CA提交。RA可以单独实现，也可以合并在CA中实现。作为管理实体，CA和RA以证书方式向端实体提供公开密钥的分发服务。</p>
<p>持有者和验证者是两种端实体。持有者是证书的拥有者，是证书所声明的事实上的主体。持有者向管理实体申请并获得证书，也可以在需要时请求撤销或更新证书。持有者使用证书声明自己的身份，从而获得相应的权力。验证者确认持有者所提供的证书的有效性和对方是否为该证书的真正拥有者，只有在成功鉴别之后才可与对方进行更进一步的交互。</p>
<p>由于证书库的存取对象为证书和CRL，其完整性由数字签名来保证，因此不需要额外的安全机制。</p>
<p>不同的实体间通过PKI操作完成证书的请求、确认、发布、撤销、更新和获取等过程。PKI操作分为存取操作和管理操作两类。其中，存取操作包括管理实体或端实体把证书和CRL存放到证书库、从证书库中读取证书和CRL；管理操作则是管理实体与端实体之间或管理实体与管理实体之间的交互，是为了完成证书的各项管理任务和建立证书链。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>访问控制是通过某种途径限制和允许对资源的访问能力以及范围的一种方法。它是针对越权使用系统资源的保护措施，通过限制对文件等资源的访问，防止非法用户的侵入或者合法用户的不当操作造成的破坏，从而保证信息系统资源的合法使用。</p>
<p>访问控制技术可以通过对计算机系统的控制，自动、有效地防止对系统资源进行非法访问或者不当的使用，检测出一部分安全侵害，同时可以支持应用和数据的安全需求。</p>
<p>访问控制技术并不能取代身份认证，它是建立在身份认证的基础之上的。</p>
<h5 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h5><p>在网络通信中，需要确定通信双方的身份，这就需要身份认证技术。在有安全需求的应用系统中，识别用户的身份是系统的基本要求，认证是安全系统中不可缺少的一部分。识别用户的身份有两种不同的形式：一种是身份认证，要求对用户所有的权限角色或自身的身份进行认证；一种是身份鉴定，要求对使用者本身的身份进行检查。</p>
<p>认证的方法多种多样，其安全强度也不相同。具体方法可归结为3大类：根据用户知道什么、拥有什么、是什么来进行认证。用户知道什么，一般就是口令；用户拥有什么，通常为私钥或令牌：用户是什么，这是一种基于生物识别技术的认证。</p>
<p>1）用户名和口令认证</p>
<p>简单认证方式主要是通过一个客户与服务器共知的口令（或与口令相关的数据，如散列、密文等）进行验证。根据处理形式的不同，有3种简单认证的方式：验证数据的明文传送、利用单向散列函数处理验证数据、利用单向散列函数和随机数处理验证数据，这3种方式的安全强度依次增加，处理复杂度也依次增高。</p>
<p>2）使用令牌认证</p>
<p>在使用令牌进行认证的系统中，进行验证的密钥存储于令牌中。对密钥的访问用口令进行控制。令牌是一个像IC卡一样可以加密存储并运行相应加密算法的设备，这种简单认证可以快速、方便地实现用户身份认证，但是认证的安全强度不高。通过令牌可以完成对用户必须拥有某物的验证。令牌的实现分为质询响应令牌和时间戳令牌，其中使用较多的是时间戳令牌。</p>
<p>质询响应令牌的工作原理是：在进行身份认证时，认证服务器首先发送一个随机数到客户机的登录程序。用户将这个随机数读出，输入令牌，并输入令牌的PIN码（实际就是口令），得以访问令牌。令牌对输入的随机数用存储的私钥进行签名，并把结果用Base64编码输出。用户把令牌的输出填入客户机的验证程序中，数据传输到认证的服务器端，在服务器端将使用用户的公钥对签名进行验证，以确定是否允许客户通过登录认证。在该方案中，由于使用数字签名进行登录认证，系统的安全强度大大增加：私钥采用令牌存储的方式解决了私钥自身的安全问题。令牌是一个可移动的设备，可以随身携带，而且令牌有PIN码保护，对令牌的非法访问超过一定的次数后，令牌会死锁。</p>
<p>时间戳令牌解决了质询响应令牌中随机数的问题，时间戳令牌利用时间代替上面的随机数。时间戳令牌每时每刻都在工作，一般每分钟产生一个登录数据，用户只需输入PIN码。登录数据被传送到认证的服务器端，服务器利用当前时间对登录数据进行验证，完成用户的登录过程。使用时间戳令牌需要重点考虑时间同步问题，由于令牌的时钟和认证服务器的时钟不同步，产生的验证码并不会通过验证。解决方法是在验证服务器上进行多次试探验证，在一个时间范围内试探，如果成功则在服务器上存储令牌时钟与服务器时钟的偏移量，以便下次登录时使用。目前，在安全性要求较高的认证系统中，多是采用这种方案。</p>
<p>采用PIN码与令牌实现了双因素验证，根据用户知道什么、拥有什么进行认证，也提供了一个保密认证密钥的方法。但是实现双因素验证需要用户输入数据，给用户的操作增加了麻烦。</p>
<p>3）生物识别与三因素认证</p>
<p>现在兴起了一种基于生物识别技术的认证，主要是根据认证者的图像、指纹、气味和声音等作为认证数据。基于用户知道什么（口令）、拥有什么（私钥和令牌）、是什么（生物特征）的3因素认证是目前强认证中使用最多的手段。在安全性要求较高的系统中，认证必须能对用户进行身份鉴定。要将用户知道什么、拥有什么、是什么结合起来，同时对认证用的密钥进行保护。</p>
<h5 id="访问控制技术"><a href="#访问控制技术" class="headerlink" title="访问控制技术"></a>访问控制技术</h5><p>根据控制手段和具体目的的不同，通常将访问控制技术划分为如下几个方面：入网访问控制、网络权限控制、目录级安全控制、属性安全控制以及网络服务器的安全控制等。</p>
<p>入网访问控制为网络访问提供了第一层访问控制。它控制哪些用户能够登录到服务器并获取网络资源，控制准许用户入网的时间和准许入网的工作站等。基于用户名和口令的用户的入网访问控制可分为三个步骤：用户名的识别与验证、用户口令的识别与验证、用户账号的默认限制检查。三个步骤中只要任何一个未通过校验，该用户便不能进入该网络。可以说，对网络用户的用户名和口令进行验证是防止非法访问的第一道防线。但由于用户名口令验证方式容易被攻破，目前很多网络都开始采用基于数字证书的验证方式。</p>
<p>网络权限控制是针对网络非法操作所提出的一种安全保护措施。能够访问网络的合法用户被划分为不同的用户组，用户和用户组被赋予一定的权限。访问控制机制明确了用户和用户组可以访问哪些目录、子目录、文件和其他资源；以及指定用户对这些文件、目录、设备能够执行哪些操作。它有两种实现方式，“受托者指派”和“继承权限屏蔽”。“受托者指派”控制用户和用户组如何使用网络服务器的目录、文件和设备；“继承权限屏蔽”相当于一个过滤器，可以限制子目录从父目录那里继承哪些权限。可以根据访问权限将用户分为以下几类：特殊用户（即系统管理员）；一般用户，系统管理员根据他们的实际需要为他们分配操作权限；审计用户，负责网络的安全控制与资源使用情况的审计。用户对网络资源的访问权限可以用访问控制表来描述。</p>
<p>目录级安全控制是针对用户设置的访问控制，控制用户对目录、文件、设备的访问。用户在目录一级指定的权限对所有文件和子目录有效，用户还可以进一步指定对目录下的子目录和文件的权限。对目录和文件的访问权限一般有8种：系统管理员权限、读权限、写权限、创建权限、删除权限、修改权限、文件查找权限和访问控制权限。8种访问权限的有效组合可以让用户有效地完成工作，同时又能有效地控制用户对服务器资源的访问，从而加强了网络和服务器的安全性。</p>
<p>属性安全控制在权限安全控制的基础上提供更进一步的安全性。当用户访问文件、目录和网络设备时，网络系统管理员应该给出文件、目录的访问属性，网络上的资源都应预先标出安全属性，用户对网络资源的访问权限对应一张访问控制表，用以表明用户对网络资源的访问能力。属性设置可以覆盖已经指定的任何受托者指派和有效权限。属性能够控制以下几个方面的权限：向某个文件写数据、复制文件、删除目录或文件、查看目录和文件、执行文件、隐含文件、共享、系统属性等，避免发生非法访问的现象。</p>
<p>因为网络允许用户在服务器控制台上执行一系列操作，所以用户使用控制台就可以执行装载和卸载模块、安装和删除软件等操作，这就需要网络服务器有安全控制。网络服务器的安全控制包括可以设置口令锁定服务器控制台，从而防止非法用户修改、删除重要信息或破坏数据。具体包括设定服务器登录时间限制、非法访问者检测和关闭的时间间隔等。</p>
<h4 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h4><h5 id="IPSec协议简述"><a href="#IPSec协议简述" class="headerlink" title="IPSec协议简述"></a>IPSec协议简述</h5><p>为了满足Internet的安全需求，因特网工程任务组（ $\color{green}{\text{IETF}}$ ）于1998年11月颁布IP层安全标准IP SECURITY协议（IPSec），IPSec在IP层上对数据包进行高强度的安全处理提供数据源验证、无连接数据完整性、数据机密性、抗重播和有限通信流机密性等安全服务。</p>
<p>1）IPSec协议工作原理</p>
<p>IPSec通过使用两种通信安全协议来为数据报提供高质量的安全性：认证头（AH）协议和封装安全载荷（ESP）协议，以及像Internet密钥交换（Internet Key Exchange, IKE）协议这样的密钥管理过程和协议。其中AH协议提供数据源认证、无连接的完整性以及一个可选的抗重放服务。ESP协议提供数据保密性、有限的数据流保密性、数据源验证、无连接的完整性以及抗重放服务。IPSec允许系统或网络用户控制安全服务提供的粒度。IPSec的安全服务是由通信双方建立的安全关联（Security Association, SA）来提供的，SA为通信提供了安全协议、模式、算法和应用于单向IP流的密钥等安全信息。每一个IPSec节点包含一个局部的安全策略库（Security Polioy Database, SPD），系统在处理输入、输出IP流时必须参考该策略库，并根据从SPD中提取的策略对IP流进行不同的处理：拒绝、绕过、进行IPSec保护。如果策略决定IP流需要经过IPSec处理，则根据SPD与SAD的对应关系，找到相应的SA，并对IP包进行指定的IPSec处理。SA由一个三元组唯一地标识，该三元组包含一个安全参数索引（Security Parameter Index, SPI），一个用于输出处理SA的目的IP地址或者一个用于输入处理SA的源IP地址以及一个特定的协议（例如AH或者ESP）。SPI是为了唯一标识SA而生成的一个32位整数。它在AH和ESP头中传输，IPSec数据报的接收方易于识别SPI并利用它连同源或者目的IP地址和协议来搜索SAD，以确定与该数据报相关联的SA或者SA束。SA中所选用的安全协议、SA模式、SA的两端及安全协议内所要求的服务等具体地决定了怎样为通信流提供安全服务。但是，最终安全服务的具体实施是通过使用AH和ESP协议。</p>
<p>2）IPSec协议实现模式</p>
<p>IPSec协议既可用来保护一个完整的IP载荷，也可用来保护某个IP载荷的上层协议。这两方面第11章　信息安全技术</p>
<p>11.1　信息安全关键技术</p>
<p>11.1.1　加密和解密技术</p>
<p>计算机网络的广泛应用，产生了大量的电子数据，这些电子数据需要传输到网络的许多地方，并存储起来。对于这些数据，有意的计算机犯罪和无意的数据破坏成为最大的威胁。原则上来说，对电子数据的攻击有两种形式：一种称为被动攻击，就是非法地从传输信道上截取信息，或从存储载体上偷窃、复制信息。另一种称为主动进攻，就是对传输或存储的数据进行恶意的删除、篡改等。实践证明，密码技术是防止数据攻击的一种有效而经济的方法。</p>
<p>我们把消息的发送者称为信源；消息的目的地称为信宿；没有加密的消息称为明文；加密后的消息称为密文；用来传输消息的通道称为信道。通信时，明文M通过变换E得到密文C，即C＝E（u, v, …，W; m）。这个过程称为加密，参数u, v, …, w称为密钥。这里所说的变换E，就是加密算法。从密文C恢复到明文M，这个过程称为解密。解密算法D是加密算法E的逆运算。</p>
<p>加密密钥与解密密钥相同，或者加密密钥与解密密钥可以简单相互推导的密码体制称为对称密码体制。现代密码学修正了密钥的对称性，加密、解密密钥是不同的，也是不能（在有效的时间内）相互推导的，称为非对称密码体制。</p>
<p>1．对称密钥密码体制及典型算法</p>
<p>对称算法（Symmetric Algorithm），有时又称为传统密码算法，在大多数对称算法中，加密密钥和解密密钥是相同的，所以也称秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。</p>
<p>对称加密的优点在于算法实现的效率高、速度快。对称加密的缺点在于密钥的管理过于复杂。常用的对称加密算法有DES、IDEA等。</p>
<p>1）DES算法简介</p>
<p>DES （Data Encryption Standard，数据加密标准）是由IBM公司研制的一种加密算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准。二十年来，它一直活跃在国际保密通信的舞台上，扮演了十分重要的角色。</p>
<p>DES是一个分组加密算法，它以64位为分组对数据加密；同时DES也是一个对称算法。它的密匙长度是56位（因为每个第8位都用作奇偶校验），密匙可以是任意56位的数，而且可以任意时候改变。其保密性依赖于密钥。</p>
<p>DES算法分如下3个步骤进行。</p>
<p>（1）对给定的64位的明文x，通过一个初始置换函数IP来排列x，从而构造出长为64位的串X0，记X0为IP（X）＝L0R0，L0表示X0的前32位，R0表示X0的后32位。</p>
<p>（2）计算16次迭代，设前i－1次迭代结果为Xi－1＝Li－1Ri－1，则第i轮迭代运算为：</p>
<p>Li＝Ri－1　　Ri＝Li－1⊕f（Ri－1, ki）</p>
<p>其中，Li－1表示Xi－1的前32位，Ri－1表示Xi－1的后32位，⊕表示两位串的“异或”运算，f主要是由一个称为S盒的置换构成。Ki是一些由初始的56位经过密钥编排函数产生的48位长的块。</p>
<p>（3）对位串L16R16作逆置换IP-1得密文y，y＝IP-1（R16L16），置换IP-1是IP的逆置换。</p>
<p>DES算法的示意图如图11-1所示。</p>
<p>alt</p>
<p>图11-1　DES算法示意图</p>
<p>2）IDEA算法简介</p>
<p>国际数据加密算法（International Data Encryption Algorithm, IDEA）是1992年来学嘉等人设计的算法。该算法的前身是1990年公布的推荐加密标准（Proposed Encryption Standard, PES）算法。</p>
<p>IDEA分组长度为64b，密钥长度为128b。其使用的运算非常简单，只需要异或，模216加和模（216＋1）乘，这些算法都很容易使用硬件或者软件实现（而DES算法便于用硬件实现，难以用软件实现），所有运算都是使用基于16b数运行，很容易在现在的16b、32b、64b CPU上实现。由于这一特性，使用软件实现的IDEA算法的运算速度比DES算法要快。由于IDEA算法使用的密钥长度为128b，远远大于DES算法的56b，对于128b密钥来说，使用穷举法攻击的方法是不现实的。</p>
<p>2．不对称密码加密算法</p>
<p>不对称密码体制又称为双密钥和公钥密码体制，是于1976年由Diffie和Hellman提出的。与对称密码体制相比，非对称密码体制有两个不同的密钥，其中一个密钥称为私钥，该密钥被秘密保存；另一个密钥公开，不需要保密。</p>
<p>公钥密码系统的工作方式为：任何人都可以将自己加密的公钥公布在网络或其他可以公开的地方。其他人欲传送信息给该接收方时，可使用该接收方所公布的公钥将信息加密之后传送给接收方。接收方收到加密后的信息时，就可以利用拥有的与此公钥相对应的私钥，将该加密信息解出来。所以公开密钥密码系统的通信双方，不需要事先通过安全秘密管道交换密钥，即可进行通信。</p>
<p>RSA密码体制是一个常用的非对称的密码体制，它是一个既能用于数据加密也能用于数字签名的算法。</p>
<p>RSA的安全性依赖于大素数分解。公钥和私钥都是两个大素数（大于100个十进制位）的函数。据猜测，从一个密钥和密文推断出明文的难度等同于分解两个大素数的积。</p>
<p>1）密钥对的产生</p>
<p>（1）选择两个大素数，p和q。</p>
<p>（2）计算n＝p*q。</p>
<p>（3）随机选择加密密钥e，e必须满足以下条件：</p>
<p>GCD（e, φ（N））＝1</p>
<p>其中，φ为Euler’s Function，φ（N）为小于N、且与N互质的整数的个数。在此，φ（N）＝（p－1）<em>（q－1）（也有些做法是取LCM（（p－1）</em>（q－1）））。</p>
<p>（4）利用Euclid算法计算解密密钥d，满足d＝e-1modφ（N）。</p>
<p>产生出加密公钥e、N与解密密钥d之后，使用者将e及N公开，就可以使用它们来执行加解密的工作了。</p>
<p>2）加密程序</p>
<p>使用者将其欲加密的信息M，在取得对方的公钥e及N之后，执行模（mod，即同余的运算，C＝MmodN，C等于M除以N的余数）指数运算，就可获得密文C。</p>
<p>alt</p>
<p>然后通过网络传送至通信的对方。</p>
<p>3）解密程序</p>
<p>对方在收到密文C后，以自己的私钥执行下面的解密程序，解密时作如下计算：</p>
<p>alt</p>
<p>即可获得明文M。</p>
<p>RSA可用于数字签名，方案是用（b）签名，用（a）验证。具体操作时考虑到安全性和M信息量较大等因素，一般是先作HASH运算。</p>
<p>RSA的安全性依赖于大数分解，由于进行的都是大数计算，使得RSA最快的情况也是DES百分之一。无论是软件还是硬件实现，速度慢一直是RSA的缺陷，因此一般来说，RSA只用于少量数据加密。</p>
<p>11.1.2　散列函数与数字签名</p>
<p>1．MD5散列算法</p>
<p>散列函数是一种公开的数学函数。散列函数运算的输入信息叫做报文，运算后所得到的结果叫做散列码或者叫做消息摘要。散列函数h＝H（M）具有如下一些特点。</p>
<p>（1）不同内容的报文具有不同的散列码，给定M，要找到另一消息M，使H（M）＝H（M′）很难。</p>
<p>（2）散列函数是单向的，给出M，容易计算出h。给定h，根据h＝H（M）反推M却很难。</p>
<p>（3）对于任何一个报文，无法预知它的散列码。</p>
<p>（4）散列码具有固定的长度，不管原始报文的长度如何，通过散列函数运算后的散列码都具有一样的长度。</p>
<p>由于散列函数具有这些特征，因此散列函数可以用来检测报文的可靠性。接收者对收到的报文用与发送者相同的散列函数进行运算，如果得到与发送者相同的散列码，则可以认为报文没有被篡改，否则报文就是不可信的。</p>
<p>常见的散列函数有MD5、SHA和HMAC等。</p>
<p>MD5（Message Digest 5）是一种非常著名的散列算法，已经成为国际标准。它是在MD4的基础上改进的算法，是具有更好的安全性能的散列算法。MD5散列算法对输入的任意长度消息产生128位（16字节）长度的散列值（或称消息摘要）。MD5算法包括以下4个步骤。</p>
<p>（1）附加填充位。首先对输入的报文进行填位补充，使填充后的数据长度模512后余448。如果数据长度正好模512余448，则需增加512个填充位，也就是说填充的个数为1～512位。填充位第一个位为1，其余全部为0。</p>
<p>（2）补足长度。将数据长度表示为二进制，如果长度超过64位，则截取其低64位；如果长度不足64位，则在其高位补0。将这个64位的报文长度补在经过填充的报文后面，使得最后的数据为512位的整数倍。</p>
<p>（3）初始化MD缓存器。MD5运算要用到一个128位的MD5缓存器，用来保存中间变量和最终结果。该缓存器又可看成是4个32位的寄存器A、B、C、D，初始化为：</p>
<p>A:01 23 45 67　B: 89 ab cd ef　C: fe dc ba 98　D: 76 54 32 10</p>
<p>（4）处理数据段。首先定义4个非线性函数F、G、H、I，对输入的报文运算以512位数据段为单位进行处理。对每一个数据段都要进行4轮的逻辑处理，在4轮中分别使用4个不同的函数F、G、H、I。每一轮以ABCD和当前的512位的块为输入，处理后送入ABCD（128位）。</p>
<p>2．数字签名与数字水印</p>
<p>1）数字签名</p>
<p>数字签名可以解决否认、伪造、篡改及冒充等问题。具体要求：发送者事后不能否认发送的报文签名、接收者能够核实发送者发送的报文签名、接收者不能伪造发送者的报文签名、接收者不能对发送者的报文进行部分篡改、网络中的某一用户不能冒充另一用户作为发送者或接收者。凡是需要对用户的身份进行判断的情况都可以使用数字签名，例如加密信件、商务信函、订货购买系统、远程金融交易和自动模式处理等。</p>
<p>数字签名方案一般包括三个过程：系统的初始化过程、签名产生过程和签名验证过程。在签名产生的过程中，用户利用给定的算法对消息产生签名；在签名验证过程中，验证者利用公开验证方法对给定消息的签名进行验证，得出签名的有效性。</p>
<p>实现数字签名的方法有很多，目前采用得比较多的是非对称加密技术和对称加密技术。虽然这两种技术的实施步骤不尽相同，但大体的工作程序是一样的。用户首先可以下载或者购买数字签名软件，然后安装在个人计算机上。在产生密钥对后，软件自动向外界传送公开密钥。由于公共密钥的存储需要，所以需要建立一个鉴定中心（Certification Authority, CA）完成个人信息及其密钥的确定工作。用户在获取公开密钥时，首先向鉴定中心请求数字确认，鉴定中心确认用户身份后，发出数字确认，同时鉴定中心向数据库发送确认信息。然后用户使用私有密钥对所传信息签名，保证信息的完整性、真实性，也使发送方无法否认信息的发送，之后发向接收方；接收方接收到信息后，使用公开密钥确认数字签名，在使用这种技术时，签名者必须注意保护好私有密钥，因为它是公开密钥体系安全的重要基础。如果密钥丢失，应该立即报告鉴定中心取消认证，将其列入确认取消列表之中。其次，鉴定中心必须能够迅速确认用户的身份及其密钥的关系。一旦接收到用户请求，鉴定中心要立即认证信息的安全性并返回信息。</p>
<p>目前已经有大量的数字签名算法，如RSA、E1Gama1、Fiat-Shamir、美国的数字签名标准/算法（DSS/DSA）、椭圆曲线等多种。</p>
<p>2）数字水印</p>
<p>随着数字技术和因特网的发展，各种形式的多媒体数字作品（如图像、视频和音频等）纷纷以网络形式发表，其版权保护成为一个迫切需要解决的问题。数字水印（Digital Watermarking）是实现版权保护的有效办法，如今已成为多媒体信息安全研究领域的一个热点，也是信息隐藏技术研究领域的重要分支。该技术是通过在原始数据中嵌入秘密信息——水印（Watermark）来证实该数据的所有权。这种被嵌入的水印可以是一段文字、标识或序列号等，而且这种水印通常是不可见或不可察的，它与原始数据（如图像、音频和视频数据）紧密结合并隐藏其中，在经过一些不破坏源数据使用价值或商用价值的操作后仍能保存下来。数字水印技术必须具有较强的鲁棒性、安全性和透明性。</p>
<p>（1）典型数字水印系统模型。</p>
<p>图11-2为水印信号嵌入模型，其功能是将水印信号加入原始数据中；图11-3为水印信号检测模型，用来判断某一数据中是否含有指定的水印信号。</p>
<p>alt</p>
<p>图11-3　水印信号检测模型</p>
<p>（2）数字水印主要应用领域。</p>
<p>①版权保护。即数字作品的所有者可用密钥产生一个水印，并将其嵌入原始数据，然后公开发布他的水印版本作品。当该作品被盗版或出现版权纠纷时，所有者即可利用图11-2或图11-3的方法从盗版作品或水印版作品中获取水印信号作为依据，从而保护所有者的权益。</p>
<p>②加指纹。为避免未经授权的复制制作和发行，出品人可以将不同用户的ID或序列号作为不同的水印（指纹）嵌入作品的合法备份中。一旦发现未经授权的备份，就可以根据此备份所恢复出的指纹来确定它的来源。</p>
<p>③标题与注释。即将作品的标题、注释等内容（如一张照片的拍摄时间和地点等）以水印形式嵌入该作品中，这种隐式注释不需要额外的带宽，且不易丢失。</p>
<p>④篡改提示。当数字作品被用于法庭、医学、新闻及商业时，常需确定它们的内容是否被修改、伪造或特殊处理过。为实现该目的，通常可将原始图像分成多个独立块，再将每个块加入不同的水印。同时可通过检测每个数据块中的水印信号，来确定作品的完整性。与其他水印不同的是，这类水印必须是脆弱的，并且检测水印信号时，不需要原始数据。</p>
<p>⑤使用控制。这种应用的一个典型例子是DVD防复制系统，即将水印信息加入DVD数据中，这样DVD播放机即可通过检测DVD数据中的水印信息而判断其合法性和可复制性。从而保护制造商的商业利益。</p>
<p>典型数字水印算法有空域算法、变换域算法、压缩域算法、NEC算法和生理模型算法等。</p>
<p>11.1.3　密钥分配中心与公钥基础设施</p>
<p>在现代密码系统中，算法本身的保密已经不重要了，对于数据的保密在很大程度上、甚至完全依赖于对密钥的保密。只要密钥能够保密，即使加密算法公开，甚至加密设备丢失，也不会对加密系统的坚固性和正常使用产生多大影响。相反，如果密钥丢失，则不但非法用户可以窃取机密数据，而且合法用户面对密文却如读天书，无法提取有效的信息。因此，在密码系统中，如何高效地分配密钥、安全地管理密钥对保证数据安全来说至关重要。</p>
<p>1．密钥分配中心</p>
<p>一个信息系统中任意两个用户之间都可以自己协商来选择不同的密钥，显然，对于总共有N个用户的系统，每个用户都要保存N×（N－1）个密钥。在用户数量较少时，这样来分配密钥还是比较简单、易用的，但是一旦用户数量多起来，系统中要保存的密钥会急剧增多，让每个用户自己高效、安全地管理数量庞大的密钥实际上是不可能的。</p>
<p>有一种非常有效的密钥自动分配方案是密钥分配中心（Key Distribution Center, KDC）技术。</p>
<p>在KDC方案中，每一个用户都只保存自己的私钥SK和KDC的公钥PKKDC，而在通信时再从KDC获得其他用户的公钥或者仅仅在某一次通信中可以使用的对称密钥加密算法的临时密钥K。</p>
<p>假设A和B都是KDC的注册用户，他们分别拥有私钥SKA、SKB。设用对称密钥来加密他们之间的这次对话，那么密钥的分配过程如下。</p>
<p>首先，A向密钥分配中心发送SKA（A, B），表示自己想与B会话。该请求用自己的私钥SKA加密，KDC收到A的请求，用A的公钥来验证请求是由A发出的后，根据某种算法来生成供A、B之间会话使用的对称密钥K。KDC向A返回PKA（K, PKB（A, K）），该应答是用A的公钥加密的，只有A能解读。A用自己的私钥解密应答，得到密钥K，并将PKB（A, K）发送给B，表明A欲与B进行会话。B用自己的私钥解密得到会话密钥K。</p>
<p>至此，完成一次密钥分配。</p>
<p>2．数字证书和公开密钥基础设施</p>
<p>数字签名和公钥加密都是基于不对称加密技术的，存在的问题有：如何保证公开密钥的持有者是真实的；大规模信息系统环境下公开密钥如何产生、分发和管理。</p>
<p>要解决以上问题，就要用到数字证书和PKI。</p>
<p>1）数字证书</p>
<p>数字证书提供了一个在公钥和拥有相应私钥的实体之间建立关系的机制。目前最常用的数字证书格式是由国际标准ITU-T X.509 V3版本定义的。</p>
<p>数字证书中采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己保存私钥，用它进行解密和签名；同时设定一个公钥，并由本人公开，为一组用户所共享，用于加密和验证签名。</p>
<p>数字证书是用户在系统中作为确认身份的证据。在通信的各个环节中，参与通信的各方通过验证对方数字证书，从而确认对方身份的真实性和有效性，从而解决相互间的信任问题。</p>
<p>数字证书的内容一般包括：唯一标识证书所有者的名称、唯一标识证书签发者的名称、证书所有者的公开密钥、证书签发者的数字签名、证书的有效期及证书的序列号等。</p>
<p>2）公钥基础设施</p>
<p>PKI（Public Key Infrastructure，公钥基础设施）的目标是向广大的信息系统用户和应用程序提供公开密钥的管理服务。</p>
<p>PKI的结构模型中有三类实体：管理实体、端实体和证书库。管理实体是PKI的核心，是服务的提供者；端实体是PKI的用户，是服务的使用者；证书库是一个分布式的数据库，用于证书和CRL的存放和检索。</p>
<p>CA和RA是两种管理实体。CA是框架中唯一能够发布和撤销证书的实体，维护证书的生命周期；RA负责处理用户请求，在验证了请求的有效性后，代替用户向CA提交。RA可以单独实现，也可以合并在CA中实现。作为管理实体，CA和RA以证书方式向端实体提供公开密钥的分发服务。</p>
<p>持有者和验证者是两种端实体。持有者是证书的拥有者，是证书所声明的事实上的主体。持有者向管理实体申请并获得证书，也可以在需要时请求撤销或更新证书。持有者使用证书声明自己的身份，从而获得相应的权力。验证者确认持有者所提供的证书的有效性和对方是否为该证书的真正拥有者，只有在成功鉴别之后才可与对方进行更进一步的交互。</p>
<p>由于证书库的存取对象为证书和CRL，其完整性由数字签名来保证，因此不需要额外的安全机制。</p>
<p>不同的实体间通过PKI操作完成证书的请求、确认、发布、撤销、更新和获取等过程。PKI操作分为存取操作和管理操作两类。其中，存取操作包括管理实体或端实体把证书和CRL存放到证书库、从证书库中读取证书和CRL；管理操作则是管理实体与端实体之间或管理实体与管理实体之间的交互，是为了完成证书的各项管理任务和建立证书链。</p>
<p>11.1.4　访问控制</p>
<p>访问控制是通过某种途径限制和允许对资源的访问能力以及范围的一种方法。它是针对越权使用系统资源的保护措施，通过限制对文件等资源的访问，防止非法用户的侵入或者合法用户的不当操作造成的破坏，从而保证信息系统资源的合法使用。</p>
<p>访问控制技术可以通过对计算机系统的控制，自动、有效地防止对系统资源进行非法访问或者不当的使用，检测出一部分安全侵害，同时可以支持应用和数据的安全需求。</p>
<p>访问控制技术并不能取代身份认证，它是建立在身份认证的基础之上的。</p>
<p>1．身份认证技术</p>
<p>在网络通信中，需要确定通信双方的身份，这就需要身份认证技术。在有安全需求的应用系统中，识别用户的身份是系统的基本要求，认证是安全系统中不可缺少的一部分。识别用户的身份有两种不同的形式：一种是身份认证，要求对用户所有的权限角色或自身的身份进行认证；一种是身份鉴定，要求对使用者本身的身份进行检查。</p>
<p>认证的方法多种多样，其安全强度也不相同。具体方法可归结为3大类：根据用户知道什么、拥有什么、是什么来进行认证。用户知道什么，一般就是口令；用户拥有什么，通常为私钥或令牌：用户是什么，这是一种基于生物识别技术的认证。</p>
<p>1）用户名和口令认证</p>
<p>简单认证方式主要是通过一个客户与服务器共知的口令（或与口令相关的数据，如散列、密文等）进行验证。根据处理形式的不同，有3种简单认证的方式：验证数据的明文传送、利用单向散列函数处理验证数据、利用单向散列函数和随机数处理验证数据，这3种方式的安全强度依次增加，处理复杂度也依次增高。</p>
<p>2）使用令牌认证</p>
<p>在使用令牌进行认证的系统中，进行验证的密钥存储于令牌中。对密钥的访问用口令进行控制。令牌是一个像IC卡一样可以加密存储并运行相应加密算法的设备，这种简单认证可以快速、方便地实现用户身份认证，但是认证的安全强度不高。通过令牌可以完成对用户必须拥有某物的验证。令牌的实现分为质询响应令牌和时间戳令牌，其中使用较多的是时间戳令牌。</p>
<p>质询响应令牌的工作原理是：在进行身份认证时，认证服务器首先发送一个随机数到客户机的登录程序。用户将这个随机数读出，输入令牌，并输入令牌的PIN码（实际就是口令），得以访问令牌。令牌对输入的随机数用存储的私钥进行签名，并把结果用Base64编码输出。用户把令牌的输出填入客户机的验证程序中，数据传输到认证的服务器端，在服务器端将使用用户的公钥对签名进行验证，以确定是否允许客户通过登录认证。在该方案中，由于使用数字签名进行登录认证，系统的安全强度大大增加：私钥采用令牌存储的方式解决了私钥自身的安全问题。令牌是一个可移动的设备，可以随身携带，而且令牌有PIN码保护，对令牌的非法访问超过一定的次数后，令牌会死锁。</p>
<p>时间戳令牌解决了质询响应令牌中随机数的问题，时间戳令牌利用时间代替上面的随机数。时间戳令牌每时每刻都在工作，一般每分钟产生一个登录数据，用户只需输入PIN码。登录数据被传送到认证的服务器端，服务器利用当前时间对登录数据进行验证，完成用户的登录过程。使用时间戳令牌需要重点考虑时间同步问题，由于令牌的时钟和认证服务器的时钟不同步，产生的验证码并不会通过验证。解决方法是在验证服务器上进行多次试探验证，在一个时间范围内试探，如果成功则在服务器上存储令牌时钟与服务器时钟的偏移量，以便下次登录时使用。目前，在安全性要求较高的认证系统中，多是采用这种方案。</p>
<p>采用PIN码与令牌实现了双因素验证，根据用户知道什么、拥有什么进行认证，也提供了一个保密认证密钥的方法。但是实现双因素验证需要用户输入数据，给用户的操作增加了麻烦。</p>
<p>3）生物识别与三因素认证</p>
<p>现在兴起了一种基于生物识别技术的认证，主要是根据认证者的图像、指纹、气味和声音等作为认证数据。基于用户知道什么（口令）、拥有什么（私钥和令牌）、是什么（生物特征）的3因素认证是目前强认证中使用最多的手段。在安全性要求较高的系统中，认证必须能对用户进行身份鉴定。要将用户知道什么、拥有什么、是什么结合起来，同时对认证用的密钥进行保护。</p>
<p>2．访问控制技术</p>
<p>根据控制手段和具体目的的不同，通常将访问控制技术划分为如下几个方面：入网访问控制、网络权限控制、目录级安全控制、属性安全控制以及网络服务器的安全控制等。</p>
<p>入网访问控制为网络访问提供了第一层访问控制。它控制哪些用户能够登录到服务器并获取网络资源，控制准许用户入网的时间和准许入网的工作站等。基于用户名和口令的用户的入网访问控制可分为三个步骤：用户名的识别与验证、用户口令的识别与验证、用户账号的默认限制检查。三个步骤中只要任何一个未通过校验，该用户便不能进入该网络。可以说，对网络用户的用户名和口令进行验证是防止非法访问的第一道防线。但由于用户名口令验证方式容易被攻破，目前很多网络都开始采用基于数字证书的验证方式。</p>
<p>网络权限控制是针对网络非法操作所提出的一种安全保护措施。能够访问网络的合法用户被划分为不同的用户组，用户和用户组被赋予一定的权限。访问控制机制明确了用户和用户组可以访问哪些目录、子目录、文件和其他资源；以及指定用户对这些文件、目录、设备能够执行哪些操作。它有两种实现方式，“受托者指派”和“继承权限屏蔽”。“受托者指派”控制用户和用户组如何使用网络服务器的目录、文件和设备；“继承权限屏蔽”相当于一个过滤器，可以限制子目录从父目录那里继承哪些权限。可以根据访问权限将用户分为以下几类：特殊用户（即系统管理员）；一般用户，系统管理员根据他们的实际需要为他们分配操作权限；审计用户，负责网络的安全控制与资源使用情况的审计。用户对网络资源的访问权限可以用访问控制表来描述。</p>
<p>目录级安全控制是针对用户设置的访问控制，控制用户对目录、文件、设备的访问。用户在目录一级指定的权限对所有文件和子目录有效，用户还可以进一步指定对目录下的子目录和文件的权限。对目录和文件的访问权限一般有8种：系统管理员权限、读权限、写权限、创建权限、删除权限、修改权限、文件查找权限和访问控制权限。8种访问权限的有效组合可以让用户有效地完成工作，同时又能有效地控制用户对服务器资源的访问，从而加强了网络和服务器的安全性。</p>
<p>属性安全控制在权限安全控制的基础上提供更进一步的安全性。当用户访问文件、目录和网络设备时，网络系统管理员应该给出文件、目录的访问属性，网络上的资源都应预先标出安全属性，用户对网络资源的访问权限对应一张访问控制表，用以表明用户对网络资源的访问能力。属性设置可以覆盖已经指定的任何受托者指派和有效权限。属性能够控制以下几个方面的权限：向某个文件写数据、复制文件、删除目录或文件、查看目录和文件、执行文件、隐含文件、共享、系统属性等，避免发生非法访问的现象。</p>
<p>因为网络允许用户在服务器控制台上执行一系列操作，所以用户使用控制台就可以执行装载和卸载模块、安装和删除软件等操作，这就需要网络服务器有安全控制。网络服务器的安全控制包括可以设置口令锁定服务器控制台，从而防止非法用户修改、删除重要信息或破坏数据。具体包括设定服务器登录时间限制、非法访问者检测和关闭的时间间隔等。</p>
<p>11.1.5　安全协议</p>
<p>1．IPSec协议简述</p>
<p>为了满足Internet的安全需求，因特网工程任务组（IETF）于1998年11月颁布IP层安全标准IP SECURITY协议（IPSec），IPSec在IP层上对数据包进行高强度的安全处理提供数据源验证、无连接数据完整性、数据机密性、抗重播和有限通信流机密性等安全服务。</p>
<p>1）IPSec协议工作原理</p>
<p>IPSec通过使用两种通信安全协议来为数据报提供高质量的安全性：认证头（AH）协议和封装安全载荷（ESP）协议，以及像Internet密钥交换（Internet Key Exchange, IKE）协议这样的密钥管理过程和协议。其中AH协议提供数据源认证、无连接的完整性以及一个可选的抗重放服务。ESP协议提供数据保密性、有限的数据流保密性、数据源验证、无连接的完整性以及抗重放服务。IPSec允许系统或网络用户控制安全服务提供的粒度。IPSec的安全服务是由通信双方建立的安全关联（Security Association, SA）来提供的，SA为通信提供了安全协议、模式、算法和应用于单向IP流的密钥等安全信息。每一个IPSec节点包含一个局部的安全策略库（Security Polioy Database, SPD），系统在处理输入、输出IP流时必须参考该策略库，并根据从SPD中提取的策略对IP流进行不同的处理：拒绝、绕过、进行IPSec保护。如果策略决定IP流需要经过IPSec处理，则根据SPD与SAD的对应关系，找到相应的SA，并对IP包进行指定的IPSec处理。SA由一个三元组唯一地标识，该三元组包含一个安全参数索引（Security Parameter Index, SPI），一个用于输出处理SA的目的IP地址或者一个用于输入处理SA的源IP地址以及一个特定的协议（例如AH或者ESP）。SPI是为了唯一标识SA而生成的一个32位整数。它在AH和ESP头中传输，IPSec数据报的接收方易于识别SPI并利用它连同源或者目的IP地址和协议来搜索SAD，以确定与该数据报相关联的SA或者SA束。SA中所选用的安全协议、SA模式、SA的两端及安全协议内所要求的服务等具体地决定了怎样为通信流提供安全服务。但是，最终安全服务的具体实施是通过使用AH和ESP协议。</p>
<p>2）IPSec协议实现模式</p>
<p>IPSec协议既可用来保护一个完整的IP载荷，也可用来保护某个IP载荷的上层协议。这两方面的保护分别由IPSec的两种不同“模式”来提供，如图11-4所示。</p>
<details><summary>图11-4　IPSec数据报结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904084355.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904084355.png';" /></details>

<p>其中，传输模式用来保护上层协议，而隧道模式用来保护整个IP数据报。在传输模式中，IP头与上层协议头之间需插入一个特殊的IPSec头：而在隧道模式中，要保护的整个IP包都需封装到另一个IP数据包里，同时在外部与内部IP头之间插入一个IPSec头。两种IPSec协议（AH和ESP）均能同时以传输模式或隧道模式工作。由构建方法所决定，对传输模式所保护的数据包而言，其通信终点必须是一个加密的终点。在后一种情况下，通信终点便是由受保护的内部头指定的地点，而加密终点则是那些由外部IP头指定的地点。在IPSec处理结束的时候，安全网关会剥离出内部IP包，再将那个包转发到它最终的目的地。</p>
<p>3）IPsec协议安全性分析</p>
<p>IPSec的安全性可以归纳为如下方面。</p>
<p>（1）当IPSec在路由器或防火墙中实现时，它提供很强的安全保证，可以应用于所有跨越网络边界的通信。一个实体内部的通信量不会引起与安全处理相关的开销。</p>
<p>（2）如果所有来自外部的通信必须使用IP，且防火墙是Internet与组织的唯一入口，则IPSec是不能被绕过的。</p>
<p>（3）IPSec位于传输层（TCP、UDP）之下，因此对应用程序是透明的。当IPSec在防火墙或是路由器上实现时，没有必要在用户或是服务器上更改软件。即使IPSec在末端系统、更高层软件（包括应用程序）上运行，也不会受到影响。</p>
<p>（4）IPSec对最终用户是透明的。没有必要培训用户掌握安全机制，也没有必要基于每个用户来发行关键资料，在用户离开组织时再撤回关键资料。</p>
<p>如果需要，IPSec可以为单个用户提供安全保证。这适用于站点外的工作人员，并适用于在组织内设置保密的专用子网，以用于敏感的应用程序。</p>
<h5 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h5><p>SSL协议（Secure Socket Layer）是Natscape推出的一种网络安全协议，是在传输过程通信协议（TCP/IP）上实现的一种安全协议。在SSL中，采用了公开密钥和私有密钥两种加密方式，它对计算机之间的整个会话进行加密。SSL的安全服务位于TCP和应用层之间，可为应用层，如HTTP、FPT、SMTP提供安全业务，服务对象主要是Web应用，即客户浏览器和服务器。它的基本目标是在通信双方之间建立安全的连接，可运行在任何可靠的通信协议之上、应用层协议之下。</p>
<p>1）SSL协议工作原理</p>
<p>在SSL中，所有数据被封装在记录中，记录层把从上层获得的数据分成可管理的块、可选的压缩数据、应用MAC（Message Authentication Code）、加密、增加SSL首部、在TCP报文段中传输结果单元。被接收的数据被解密、验证、解压和重新装配，然后交付给更高级的用户。SSL中两个重要的概念是SSL连接和SSL会话。</p>
<p>连接是提供恰当类型服务的传输。对于SSL，这样的连接是点到点的关系。连接是短暂的，每个连接与一个会话相联系。连接状态由服务器和客户的随机数、服务器写MAC密码、客户写MAC密码、服务器写密钥、客户写密钥、初始化向量、序号等参数来定义。</p>
<p>SSL的会话是客户和服务器之间的关联，会话通过握手协议来创建。会话定义了加密安全参数的一个集合，该集合可以被多个连接所共享。会话可以用来避免为每个连接进行昂贵的新安全参数的协商。每个会话由会话标识符、对方的证书、压缩方法、密文规约、主密钥和可重用标志等参数来定义。</p>
<p>2）SSL协议工作过程</p>
<p>SSL客户和服务器首次开始通信时，它们就协议版本、加密算法、是否验证及密钥等进行协商，这一过程由握手协议完成。握手过程结束后，客户端与服务器端开始交换应用层数据。握手协商过程主要包括以下几个阶段：</p>
<p>（1）建立安全能力</p>
<p>（2）服务器身份验证和密钥交换</p>
<p>（3）客户机验证和密钥交换</p>
<p>（4）完成</p>
<p>该阶段完成安全连接的建立。</p>
<p>3）SSL协议安全性分析</p>
<p>（1）防止窃听及中间人攻击。</p>
<p>（2）防止剪贴攻击。</p>
<p>（3）防止重放攻击及短包攻击。</p>
<h5 id="PGP协议"><a href="#PGP协议" class="headerlink" title="PGP协议"></a>PGP协议</h5><p>PGP（Pretty Good Privacy）是由Hil Zimmermann提出的方案，是针对电子邮件在Internet上通信的安全问题而设计的一种混合加密系统。PGP包含4个密码单元，即单钥密码（IDEA）、双钥密码（RSA）、单向杂凑算法（MD-5）和一个随机数生成算法。该协议规定公钥密码和分组密码是在同一个系统中。PGP的用户拥有一张公钥列表，列出了所需要通信的用户及其公钥。PGP应用程序具有很多优点，如速度快、效率高，同时具有很好的可移植性。</p>
<p>2）PGP协议的加密过程</p>
<p>PGP的加密过程是：先根据一些随机的环境数据（例如键盘的敲击间隔）产生一个密钥，用IDEA算法对明文加密。接着用接收者的RSA公钥对这个IDEA密钥进行加密，然后把这两种加密的结果作为密文发送出去。接收方接到密文后，先用自己的RSA私钥解密得到IDEA密钥，再用这个IDEA密钥对密文进行解密。也就是说，PGP没有用RSA算法直接对明文加密，而是对IDEA密钥进行加密。</p>
<p>对于数字签名，PGP先根据明文的内容利用Hash函数（散列算法）计算出一个128位的摘要，这个摘要就像是明文的一个精华，明文中任何改变都会导致这个精华的改变，并且从这个精华无法推导出明文的内容。发送者用自己的私钥对这个精华进行签名。因此在邮件传送过程中，任何对明文内容的改变都会导致摘要内容与签名的摘要内容不相符，以至签名的内容无效。由于IDEA算法的速度很快，所以不会因为邮件的数据量大而耽误时间；而IDEA的密钥位数较少，所以对它使用RSA算法在速度上也不会有太大影响。又因为IDEA的密码是以RSA加密的形式传送的，使得PGP既避免了IDEA的密钥管理缺陷，又避免了RSA的大量运算。 $\color{green}{\text{PGP}}$ 的这些优点使其在 $\color{green}{\text{邮件发送领域}}$ 具有广泛的应用。</p>
<p>使用PGP传递公钥的过程如下：假设用户A拥有用户B和用户C的公钥，用户B只拥有用户A的公钥，用户C也只拥有用户A的公钥。因为用户A和用户B、用户A和用户C都拥有对方的公钥，所以他们之间可以安全通信。但是用户B和用户C是不能直接通信的。用户B和用户C都知道用户A拥有对方的公钥，如果他们都同时信任用户A，可以从用户A处获得对方的公钥。即用户A利用自己的私钥分别对用户B和用户C的公钥签名，然后分别发给用户B和用户C，这样用户B和用户C就可以安全通信了。这是一个比较简单的情况，如果用户B和用户C要经过多个用户才能获得对方的公钥，这就给用户B和用户C的正常通信带来了麻烦。同时，安全也会随着链式信任网的扩大而急速下降。</p>
<h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><h5 id="备份的类型"><a href="#备份的类型" class="headerlink" title="备份的类型"></a>备份的类型</h5><p>随着计算机的日益普及以及信息技术的飞速发展，人们已经逐渐认识到信息安全的重要性。但是作为信息安全的重要成员——数据备份却常常被人们遗忘，这样导致的后果就是大量的有用信息被丢失，造成的后果有时是毁灭性的。</p>
<p>导致数据被破坏、丢失的原因很多，如硬盘的损坏、病毒的侵入等。而作为一名合格的系统管理员，关键要做到的就是保证数据的完整性以及准确性。如何才能真正做到这一点呢，这是一项非常艰巨但又非常重要的工作。一般情况下，采取的措施包括安装防火墙、杀毒软件等。但是，事情总不像人们想象的那么完美，数据的安全性和准确性一直都面临着极大的考验。因此，数据备份就显得十分有必要，同时它也是防止“主动攻击”的最重要一道防线。</p>
<p>数据备份包括以下几种类型，在不同的情况下，应该根据具体情况，选出最合适的方法。</p>
<p>（1）完全备份。是指备份全部选中的文件夹，并不依赖文件的存档属性来确定备份哪些文件（在备份过程中，任何现有的标记都被清除，每个文件都被标记为已备份。换言之，即清除存档属性）。完全备份的特点是备份所需时间最长，但恢复时间最短，操作最方便可靠。</p>
<p>（2）差异备份。也称差分备份，它是针对完全备份的，即备份上一次的完全备份后发生变化的所有文件。换句话说，没有发生变化的就不需要备份（差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，即备份后不标记为已备份文件。换言之，不清除存档属性）。差异备份的特点是备份时间较长，占用空间较多，但恢复时间较短。</p>
<p>（3）增量备份。是针对上一次备份（无论是哪种备份，这也是与差分备份不同的），即上一次备份后，所有发生变化的文件（增量备份过程中，只备份有标记的选中的文件和文件夹，它清除标记，即备份后标记文件。换言之，清除存档属性）。增量备份的特点是备份时间较短，占用空间较少，但恢复时间较长。</p>
<p>（4）按需备份。也就是说，它是根据需要有选择地进行数据备份。很明显，它的特点就是有很好的选择性。</p>
<h5 id="异地备份"><a href="#异地备份" class="headerlink" title="异地备份"></a>异地备份</h5><p>数据异地备份是容灾系统的核心技术，它不同于上述介绍的备份方法，它的特点是具有异地性。它对于保证数据的一致性、可靠性及系统的可扩展性具有举足轻重的作用，通过有效的数据复制，实现远程的业务数据与本地业务数据的同步，确保一旦本地系统出现故障，远程的容灾中心能够迅速进行完整的业务接管。</p>
<p>异地备份在金融业中有着典型的应用，它为保证金融业的正常运行做出了巨大的贡献。在“9.11”期间，美国的金融业虽然遭受了巨大的损失，但是还能够正常运行，为什么这么巨大的灾难也没有给美国金融业带来致命的打击呢？就是因为他们对数据的异地备份做得非常好，才没有导致金融业的全面崩溃。</p>
<p>在进行异地备份时，要注意以下几个问题。</p>
<p>（1）在进行异地备份前，要集中精力进行杀毒查毒工作，避免让备份带上病毒。</p>
<p>（2）对于软盘，要保证磁片质量，非常有必要定期对其进行质量检查。</p>
<p>（3）对于CD-RW光盘，它的一个最大的缺点就是兼容性不好，因此最好就是由哪台刻录机刻录的盘片，就在哪台刻录机上继续刻录、改写等操作。</p>
<p>（4）对于移动硬盘，要做磁盘检查，保证其性能良好。</p>
<h5 id="自动备份软件"><a href="#自动备份软件" class="headerlink" title="自动备份软件"></a>自动备份软件</h5><p>随着人们对数据备份意识的逐渐增强，各种自动备份软件也应运而生，给我们提供了很多数据备份的选择方案，下面主要介绍几种。</p>
<p>1）自动备份精灵</p>
<p>自动备份精灵是为方便我们的备份工作而特别设计开发的软件，其最大的优点是支持网络自动备份和本机自动备份。一方面，自动备份精灵可以帮助我们定时备份数据，可以设置关机备份数据，也可以手动备份。另一方面，它也允许我们自由地选择需要备份文件的源路径和目的路径，可以查看备份日志等。</p>
<p>2）利用GHOST实现自动备份</p>
<p>Ghost是最著名的硬盘复制备份工具，因为它可以将一个硬盘中的数据完全相同地复制到另一个硬盘中，因此大家就将Ghost这个软件称为“硬盘克隆”。Ghost不但有硬盘到硬盘的克隆功能，还有硬盘分区、硬盘备份、系统安装、网络安装和升级系统等功能。1998年6月，出品Ghost的Binary公司被著名的Symantec公司并购，因此该软件的后续版本就改称为Norton Ghost，成为Norton系列工具软件中的一员。</p>
<p>3）使用DiskWin实现自动备份</p>
<p>DiskWin主要是针对企业的备份软件。它很好地解决了企业数据备份问题。将所有员工机的文件自动备份到服务器；管理员定义每一员工机强制备份的工作文件类型和备份时间。可规定公司不同的部门备份不同的文件类型，如公司销售部备份Word文件和电子邮件，公司软件开发部备份程序代码文件，设计部备份PhotoShop设计图片等；全盘搜索每一员工机变化的文件，保证每天新增或者变化的工作文件一个不多，一个不少，全部压缩打包，自动上传到服务器。具备多个备份的文件无论怎样重命名都只备份一个；客户端可以设置隐藏运行，无论是搜索文件还是上传备份可以不出现任何提示，对员工正常工作无任何干扰，就好像这个软件根本不存在一样。</p>
<h5 id="几种新型的备份解决方案"><a href="#几种新型的备份解决方案" class="headerlink" title="几种新型的备份解决方案"></a>几种新型的备份解决方案</h5><p>对重要数据进行备份，就是为了在发生意外时能够及时进行恢复，使损失降低到最低。但是，如果备份文件存放不好，或者是备份策略不恰当，所付出的努力将付之东流。为了避免发生这种情况，我们就应该采取正确的备份方案。</p>
<p>一个优秀的备份解决方案应该做到以下几点。</p>
<p>（1）最大限度地降低对应用数据流量的影响，从而保证通信性能。</p>
<p>（2）最大限度地降低服务器的负载，保证服务器的性能；</p>
<p>（3）优化备份资源的使用，包括服务器、驱动器等。</p>
<p>在现代化的企业环境中，随着应用系统负载的增加，服务器的数量也在增加。但是由于磁带设备的分散特性，并且它们相互独立、不能执行全局统一的备份策略；需要的磁带机数量与应用服务器的数量成正比，所以要花费很高的维护成本。</p>
<p>下面介绍几种新型的备份解决方案。</p>
<p>1）网络备份模式</p>
<p>网络备份模式的原理是把一个磁带设备放置在LAN上，供多个服务器共享。由于网络设备模式对磁带进行统一的调度和使用，因此可以提高磁带的利用率和可管理性。需要管理的磁带驱动器的大幅度减少有助于降低成本，网络备份是一种非常好的企业备份模式。</p>
<p>如果普通备份的时间比较长，则可以安装一套独立的局域网，并在每套要备份的系统中连接一网卡，从而可以使备份数据与生产数据相互独立，互不影响。</p>
<p>在一个典型的基于LAN的备份模式中，生产数据和备份数据都是通过相同的LAN进行传输，这样需要备份的海量数据就会增加LAN上的流量，导致应用性能的降低。备份通常是在下班的时间进行，这样可以最大限度地减少对生产流量的影响。然而不断增长的数据量会导致备份时间的延长，而且随着企业业务的全球化，对系统的正常运行的要求也越来越高，可以用来备份的时间也越来越短。</p>
<p>为了在一个共同的LAN中消除这些潜在的冲突，可以将应用和备份隔离开来，这就是利用存储网络的方法。</p>
<p>另外，备份需要增加服务器的操作。服务器通常忙于处理大量对延迟和性能非常敏感的数据，数据的移动和调度需要占用额外的CPU周期，而进行备份通常会对应用本身的性能造成很大的影响，因此可以采用SCSI扩展复制命令的备份方法加以解决。</p>
<p>2）用存储网络备份</p>
<p>这个方案是让每个应用服务器都可以通过一个专用的存储网络，直接将数据备份到某个磁带设备，而不需要经过专门的备份服务器。利用通用的共享存储设备，每个应用服务器都可以充当一个介质服务器，因为它们可以直接将数据发送到磁带。每个服务器确定一个专门的磁带驱动器，并在备份过程中独自占有该磁带驱动器。用户还可以利用对磁带库中磁带驱动器的专有访问权限对应用服务器进行配置，而不是使用共享过程。</p>
<p>经过存储网络传输的数据可以隔离备份数据和应用数据，从而减少LAN上的流量。一个磁带也可以被多个应用共享，并且可以将多个备份流量合并到所管理的磁带库和驱动器中。此时，LAN仍可以用于在备份的服务器和客户端之间传输元数据和跟踪数据备份的状态，但是实际的备份数据将通过存储网络传输。利用网络存储备份可以隔离应用数据和备份数据，但是不能减轻服务器的CPU负载，因为它们仍然需要从磁带读取备份数据。</p>
<p>3）磁带和磁带之间直接传输数据的备份</p>
<p>为了减轻服务器在备份时的CPU负载，需要在数据不经过服务器本身的情况下，将备份数据从磁盘发送到磁带，这是通过在磁盘和磁带之间直接传输数据的机制（即SCSI扩展复制命令的方法）来实现的。在这种方式中，执行SCSI扩展复制命令的组件可能位于存储网络的交换阵列或者是服务器软件中，数据的副本会智能地从磁盘发送到磁带，而不需要经过服务器。复制并传输所要备份的数据对服务器CPU的负载影响非常小，这是因为服务器并不需要参与备份数据的任何具体操作，可以大大地减轻服务器的负担，保证服务器的性能不会受到备份的影响。</p>
<h4 id="计算机病毒与免疫"><a href="#计算机病毒与免疫" class="headerlink" title="计算机病毒与免疫"></a>计算机病毒与免疫</h4><h5 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h5><p>从计算机病毒刚诞生之际，它就给人们带来了麻烦，随着网络的发展，其破坏力越来越强，计算机病毒已成为危害个人系统及网络安全的一大隐患，正如生物学上的病毒能够使我们生病一样，计算机病毒会破坏计算机的正常工作。计算机病毒的一些典型破坏包括影响用户的工作（如妨碍鼠标、键盘的操作，间隔性地在用户的屏幕上显示一段文字或播放一段音乐），破坏用户系统上的一些程序（如使得Microsoft Word不能正常运行），大量占用系统的资源，使系统无法正常工作（蠕虫病毒的典型做法），破坏用户的数据（如删除用户的文件，格式化硬盘），有时也会破坏系统的硬件。</p>
<p>1）计算机病毒的定义</p>
<p>提到病毒，人们通常就会想到一些恶意的、时常破坏机器上的程序、数据的小程序。但如何给病毒下一个科学的、精确的定义呢？病毒的定义最早由F.B.Cohen于1984年提出，在他的经典文章Computer Viruses-Theory and Experiments（计算机病毒一理论与实践）中，描述如下：</p>
<p>“计算机病毒是这样的一种程序，它通过修改其他程序使之含有该程序本身或它的一个变体。病毒具有感染力，它可借助其使用者的权限感染他们的程序，在一个计算机系统中或网络中得以繁殖、传播。每个被感染的程序也像病毒一样可以感染其他程序，从而使更多的程序受到感染。”</p>
<p>2）病毒的基本特征</p>
<p>●　感染性</p>
<p>●　潜伏性</p>
<p>●　可触发性</p>
<p>●　破坏性</p>
<p>●　人为性</p>
<p>●　衍生性</p>
<p>3）计算机病毒的分类</p>
<p>分类的方式、角度是多种多样的，从病毒的工作机制角度主要分为以下5类。</p>
<p>●　引导区病毒（boot sector virus）</p>
<p>●　文件感染病毒（file infector virus）</p>
<p>●　宏病毒（Marco virus）</p>
<p>●　特洛伊木马（Trojan/Trojan Horse）</p>
<p>●　蠕虫病毒（Worm）</p>
<h5 id="计算机病毒免疫的原理"><a href="#计算机病毒免疫的原理" class="headerlink" title="计算机病毒免疫的原理"></a>计算机病毒免疫的原理</h5><p>我们知道，计算机病毒的传染模块一般包括传染条件判断和实施传染两个部分，在病毒被激活的状态下，病毒程序通过判断传染条件的满足与否，以决定是否对目标对象进行传染。一般情况下，病毒程序在传染完一个对象后，都要给被传染对象加上传染标识，传染条件的判断就是检测被攻击对象是否存在这种标识，若存在这种标识，则病毒程序不对该对象进行传染；若不存在这种标识，则病毒程序就对该对象实施传染。由于这种原因，人们自然会想到是否能在正常对象中加上这种标识，就可以不受病毒的传染，起到免疫的作用呢？</p>
<p>从实现计算机病毒免疫的角度看病毒的传染，可以将病毒的传染分成两种。第一种是像香港病毒、1575病毒这样，在传染前先检查待传染的扇区或程序里是否含有病毒代码，如果没有找到则进行传染，如果找到了则不再进行传染。这种用作判断是否为病毒自身的病毒代码被称作传染标志或免疫标志。第二种是在传染时不判断是否存在免疫标志，病毒只要找到一个可传染对象就进行一次传染。就像黑色星期五那样，一个文件可能被黑色星期五反复传染多次，滚雪球一样越滚越大（需要说明的是，黑色星期五病毒的程序中具有判别传染标志的代码，由于程序设计错误，使判断失败，形成现在的情况，对文件会反复感染，传染标志形同虚设）。</p>
<p>目前常用的免疫方法有如下两种。</p>
<p>1）针对某一种病毒进行的计算机病毒免疫</p>
<p>例如对小球病毒，在DOS引导扇区的1FCH处填上1357H，小球病毒一旦检查到这个标志就不再对它进行传染了。对于1575文件型病毒，免疫标志是文件尾的内容为0CH和OAH的两个字节，1575病毒若发现文件尾含有这两个字节，则不进行传染。这种方法的优点是可以有效地防止某一种特定病毒的传染。但缺点很严重，主要有以下几点。</p>
<p>（1）对于没有设感染标识的病毒不能达到免疫的目的。有的病毒只要在激活的状态下，会无条件的把病毒传染给被攻击对象，而不论这种对象是否已经被感染过或者是否具有某种标识。</p>
<p>（2）当出现这种病毒的变种不再使用这个免疫标志时或出现新病毒时，免疫标志发挥不了作用。</p>
<p>（3）某些病毒的免疫标志不容易仿制，非要加上这种标志不可，则对原来的文件要做大的改动。例如对大麻病毒就不容易做免疫标志。</p>
<p>（4）由于病毒的种类较多，又由于技术上的原因，不可能对一个对象加上各种病毒的免疫标识，这就使得该对象不能对所有的病毒具有免疫作用。</p>
<p>（5）这种方法能阻止传染，却不能阻止病毒的破坏行为，仍然放任病毒驻留在内存中。目前使用这种免疫方法的商品化反病毒软件已不多见了。</p>
<p>2）基于自我完整性检查的计算机病毒的免疫方法</p>
<p>目前这种方法只能用于文件而不能用于引导扇区。这种方法的原理是：为可执行程序增加一个免疫外壳，同时在免疫外壳中记录有关用于恢复自身的信息。免疫外壳占1～3KB。执行具有这种免疫功能的程序时，免疫外壳首先得到运行，检查自身的程序大小、校验生成日期和时间等情况，没有发现异常时才转去执行受保护的程序。</p>
<p>但是，它仍存在如下一些缺点和不足。</p>
<p>（1）每个受到保护的文件都要增加1～3KB，需要额外的存储空间。</p>
<p>（2）现在使用中的一些校验码算法不能满足防病毒的需要，被某些种类的病毒感染的文件不能被检查出来。</p>
<p>（3）无法对付覆盖方式的文件型病毒。</p>
<p>（4）有些类型的文件不能使用外加免疫外壳的防护方法，这样将使那些文件不能正常执行。</p>
<p>当某些尚不能被病毒检测软件检查出来的病毒感染了文件，而该文件又被免疫外壳包在里面时，这个病毒就像穿了“保护盔甲”，使查毒软件查不到它，而它却能在得到运行机会时跑出来继续传染扩散。</p>
<h3 id="信息安全管理和评估"><a href="#信息安全管理和评估" class="headerlink" title="信息安全管理和评估"></a>信息安全管理和评估</h3><h4 id="安全管理技术"><a href="#安全管理技术" class="headerlink" title="安全管理技术"></a>安全管理技术</h4><p>由于数据在网络上进行传输时，可能会存在各种攻击，因此，必须加强对网络安全的管理。概括性地说，安全管理技术就是监督、组织和控制网络通信服务以及信息处理所必需的各种技术手段和措施的总称。其目标是确保计算机网络的持续正常运行，并在计算机网络运行出现异常时能及时响应和排除故障。</p>
<h5 id="安全管理的发展现状"><a href="#安全管理的发展现状" class="headerlink" title="安全管理的发展现状"></a>安全管理的发展现状</h5><p>在20世纪90年代中后期，随着因特网的发展以及社会信息化程度越来越高，各种安全设备在网络中的应用也越来越多，市场上开始出现了独立的安全管理产品。</p>
<p>相对而言，国外计算机网络安全管理的需求多样，起步较早，已经形成了较大规模的市场，有一部分产品逐渐在市场上获得了用户的认可。近年来，国内厂商也开始推出网络安全管理产品，但一般受技术实力限制，大多是针对自己的安全设备开发的集中管理软件、安全审计系统等。</p>
<p>由于各种网络安全产品的作用体现在网络中的不同方面，统一的网络安全管理平台必然要求对网络中部署的安全设备进行协同管理，这是统一安全管理平台的最高追求目标。</p>
<h5 id="网络安全管理技术简介"><a href="#网络安全管理技术简介" class="headerlink" title="网络安全管理技术简介"></a>网络安全管理技术简介</h5><p>安全管理（Security Management, SM），不管是对于个人管理，还是对企业管理（Enterprise　Management），都是十分重要的。从信息管理的角度看，安全管理涉及到策略与规程、安全缺陷以及保护所需的资源、防火墙、密码加密问题、鉴别与授权、客户机/服务器认证系统、报文传输安全以及对病毒攻击的保护等。</p>
<p>实际上，安全管理不是一个简单的软件系统，它包括的内容非常多，主要涵盖了安全设备的管理、安全策略管理、安全风险控制和安全审计等几个方面。</p>
<p>（1）安全设备管理：是指对网络中所有的安全产品，如防火墙、VPN、防病毒、入侵检测（网络、主机）和漏洞扫描等产品实现统一管理、统一监控。</p>
<p>（2）安全策略管理：是指管理、保护及自动分发全局性的安全策略，包括对安全设备、操作系统及应用系统的安全策略的管理。</p>
<p>（3）安全分析控制：确定、控制并消除或缩减系统资源的不定事件的总过程，包括风险分析、选择、实现与测试、安全评估及所有的安全检查（含系统补丁程序检查）。</p>
<p>（4）安全审计：对网络中的安全设备、操作系统及应用系统的日志信息收集汇总，实现对这些信息的查询和统计；并通过对这些集中信息的进一步分析，可以得出更深层次的安全分析结果。</p>
<h5 id="安全管理主要解决以下问题"><a href="#安全管理主要解决以下问题" class="headerlink" title="安全管理主要解决以下问题"></a>安全管理主要解决以下问题</h5><p>1）集中化的安全策略管理（Centralized Security Policy Management, CSPM）</p>
<p>企业的安全保障需要自上而下地制定安全策略，这些安全策略会被传送并装配到不同的执行点（Enforcement Point）中。</p>
<p>2）实时安全监视（Real-Time Security Awareness, RTSA）</p>
<p>企业用户实时了解企业网络内的安全状况。</p>
<p>3）安全联动机制（Contain Mechanism, CM）</p>
<p>安全设备之间需要具备有中心控制或无中心控制的安全联动机制，即当IDS发现在某网段有入侵动作时，它需要通知防火墙阻断此攻击。</p>
<p>4）配置与补丁管理（Configuration and Patching Management）</p>
<p>企业用户可以通过对已发现的安全缺陷快速反应，大大提高自己抵抗风险的能力。</p>
<p>5）统一的权限管理（Privilege Management across the Enterprise）</p>
<p>通过完善的权限管理和身份认证实现对网络资源使用的有效控制和审计。</p>
<h4 id="安全性规章"><a href="#安全性规章" class="headerlink" title="安全性规章"></a>安全性规章</h4><h5 id="信息系统安全制度"><a href="#信息系统安全制度" class="headerlink" title="信息系统安全制度"></a>信息系统安全制度</h5><p>一段时间以来，国际和国内一些著名网站被“黑”的事件引起了社会多方的关注。计算机信息系统的安全问题越来越受到重视，因为安全问题将影响到电子商务、国家信息甚至是国防等各个方面。针对大幅度上升的黑客攻击、病毒传播和有害信息传播等计算机违法犯罪活动，有关部门出台了一系列的信息系统安全法规与制度，从而进一步保证了信息系统的安全运行。</p>
<p>1）计算机信息系统安全保护等级划分标准</p>
<p>《计算机信息系统安全保护等级划分标准》规定，从2001年1月1日起对计算机信息系统安全保护实行等级划分，此举标志着我国计算机信息系统安全保护纳入了等级管理的轨道。</p>
<p>由公安部提出并组织制定、国家质量技术监督局发布的强制性国家标准《计算机信息系统安全保护等级划分准则》，将计算机信息系统的安全保护等级划分为用户自主保护级、系统审计保护级、安全标记保护级、结构化保护级和访问验证保护级5个级别。用户可以根据自己计算机信息系统的重要程度确定相应的安全保护级别，并针对相应级别进行建设。</p>
<p>实行安全等级保护制度后，公安机关能够通过规范、科学、公正的评定和监督管理，全面、及时地预防和发现计算机信息系统建设和使用中存在的安全风险和安全漏洞，有利于提高公安机关对计算机信息系统安全保护的监督管理水平。此外，实行这一制度还有利于提高信息安全产业化发展水平，为安全产品的普及使用提供广阔的市场和发展空间。</p>
<p>2）计算机信息安全保护条例</p>
<p>根据公安部的有关规定，计算机信息系统安全保护包括以下几个方面。</p>
<p>（1）实体安全：包括周围危险建筑与设施、监控系统、防火措施、防水措施、机房环境、防雷措施、备用电源、防静电措施、用电质量和防盗措施等。</p>
<p>（2）网络通信安全：包括通信设备的场所标志、重要的通信线路及通信控制装置备份、加密措施、网络运行状态安全审计跟踪措施、网络系统访问控制措施和工作站身份识别措施等。</p>
<p>（3）软件与信息安全：包括操作系统及数据库访问控制措施、应用软件、系统信息能防止恶意攻击和非法存取、数据库及系统状态监控、防护措施、用户身份识别措施、系统用户信息异地备份等。</p>
<p>（4）管理组织与制度安全：包括专门的安全防范组织和计算机安全员、健全的安全管理规章制度、详尽的工作手册和完整的工作记录、定期进行风险分析，制定灾难处理对策、建立安全培训制度、制定人员的安全管理制度等。</p>
<p>（5）安全技术措施：包括灾难恢复的技术措施、开发工作与业务工作分离的措施、应用业务、系统安全审计功能、系统操作日志、服务器备份措施、计算机防病毒措施等。</p>
<h5 id="计算机防毒制度"><a href="#计算机防毒制度" class="headerlink" title="计算机防毒制度"></a>计算机防毒制度</h5><p>为了加强计算机病毒的防治管理工作，2000年公安部发布了《计算机病毒防治管理办法》，规定各级公安机关负责本行政区域内的计算机病毒防治管理工作。</p>
<p>规定禁止制作、传播计算机病毒，向社会发布虚假计算机病毒疫情，承担计算机病毒的认定工作的机构应由公安部公共信息网络安全监察部门批准，计算机信息系统的使用单位应当履行防治计算机病毒的职责。</p>
<h3 id="信息安全保障体系"><a href="#信息安全保障体系" class="headerlink" title="信息安全保障体系"></a>信息安全保障体系</h3><p>对一个信息网络，必须从总体上规划，建立一个科学全面的信息安全保障体系，从而实现信息系统的整体安全。一个全面的信息安全保障体系，应该能够解决信息系统存在的大部分安全威胁。目前的信息安全威胁主要有：针对系统稳定性和可靠性的破坏行为，包括从外部网络针对内部网络的攻击入侵行为和病毒破坏等；大量信息设备的使用、维护和管理问题，包括违反规定的计算机、打印机和其他信息基础设施的滥用，以及信息系统违规使用软件和硬件的行为；知识产权和内部机密材料等有价值信息存储、使用和传输的保密性、完整性和可靠性存在可能的威胁，其中尤其以信息的保密性存在威胁的可能性最大。</p>
<p>针对这些复杂且技术手段各异的信息安全威胁，要建立一个完整的信息安全保障体系，包含以下几个方面的内容。</p>
<p>1）建立统一的身份认证体系</p>
<p>身份认证是信息交换最基础的要素，如果不能确认交换双方的实体身份，那么信息的安全就根本无从得到保证。身份认证的含义是广泛的，其泛指一切实体的身份，包括人、计算机、设备和应用程序等，只有确认了所有这些信息在存储、使用和传输中可能涉及的实体，信息的安全性才有可能得到基本保证。</p>
<p>2）建立统一的信息安全管理体系</p>
<p>建立对所有信息实体有效的信息安全管理体系，对信息网络系统中的所有计算机、输出端口、存储设备、网络、应用程序和其他设备进行有效集中的管理，从而有效管理和控制信息网络中存在的安全风险。信息安全管理体系的建立主要集中在技术性系统的建立上，同时，也应该建立相应的管理制度，才能使信息安全管理系统得到有效实施。</p>
<p>3）建立规范的信息安全保密体系</p>
<p>信息的保密性是一个大型信息应用网络不可缺少的需求，所以，必须建立符合规范的信息安全保密体系。这个体系不仅仅应该提供完善的技术解决方案，也应该建立相应的信息保密管理制度。</p>
<p>4）建立完善的网络边界防护体系</p>
<p>重要的信息网络一般会跟公共的互联网进行一定程度的分离，在内部信息网络和互联网之间存在一个网络边界。必须建立完善的网络边界防护体系，使得内部网络既能够与外部网络进行信息交流，同时也能防止从外网发起的对内部网络的攻击等安全威胁。</p>
<p>此外，要加快信息安全立法，建立信息安全法制体系，这样才能做到有法可依、有法必依。建立国家信息安全组织管理体系，加强国家信息安全机构及职能；建立高效能的、职责分工明确的行政管理和业务组织体系；建立信息安全标准和评估体系；建立国家信息安全技术保障体系，使用科学技术实施安全的防护保障。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><h4 id="信息系统安全属性"><a href="#信息系统安全属性" class="headerlink" title="信息系统安全属性"></a>信息系统安全属性</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231922.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231922.png';" /></details>

<p>不可抵赖性：数字签名</p>
<h4 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h4><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906232249.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906232249.png';" /></details>

<p>rar加密是对称加密，解密输入的密码和加密的密码一致</p>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906232302.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906232302.png';" /></details>

<p>加密速度慢，适合小数据</p>
<h4 id="信息摘要"><a href="#信息摘要" class="headerlink" title="信息摘要"></a>信息摘要</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906232904.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906232904.png';" /></details>

<p>原始信息发生变化，摘要也会发生变化</p>
<p>使用单向散列函数</p>
<h4 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906233235.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906233235.png';" /></details>

<p>用A的私钥加密，叫数字签名，A的公钥解密叫做验证过程</p>
<p>数字签名+信息摘要结合起来使用</p>
<h4 id="数字证书与PGP"><a href="#数字证书与PGP" class="headerlink" title="数字证书与PGP"></a>数字证书与PGP</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906233527.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906233527.png';" /></details> 

<p>传公钥的时候被截获</p>
<h4 id="设计邮件加密系统"><a href="#设计邮件加密系统" class="headerlink" title="设计邮件加密系统"></a>设计邮件加密系统</h4><p>要求邮件以加密方式传输，邮件最大附件内容可达50OMB，发送者不可抵赖，若邮件被第三方截获,第三方无法篡改。</p>
<p>信息摘要+数字签名+数据证书</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907083954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907083954.png';" /></details>

<h4 id="PKI公钥体系"><a href="#PKI公钥体系" class="headerlink" title="PKI公钥体系"></a>PKI公钥体系</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084024.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084024.png';" /></details>

<p>基于非对称，类似数字证书</p>
<ul>
<li>证书颁发机构（CA, Certificate Authority）</li>
</ul>
<h4 id="PKI公钥系分层情况"><a href="#PKI公钥系分层情况" class="headerlink" title="PKI公钥系分层情况"></a>PKI公钥系分层情况</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084245.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084245.png';" /></details>

<ul>
<li>密匙管理中心，（kmc，key management center）</li>
<li>公钥基础设施 （pki，Public Key Infrastructure ）</li>
<li>注册机构（RA，register Authority）</li>
</ul>
<h4 id="信息系统安全保证层次"><a href="#信息系统安全保证层次" class="headerlink" title="信息系统安全保证层次"></a>信息系统安全保证层次</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084347.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084347.png';" /></details>

<p>访问控制：权限这一层</p>
<p>强制访问控制：分层</p>
<p>基于任务的访问控制:OA</p>
<h4 id="安全审核与安全系统设计原则"><a href="#安全审核与安全系统设计原则" class="headerlink" title="安全审核与安全系统设计原则"></a>安全审核与安全系统设计原则</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084752.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084752.png';" /></details>

<p>安全审计:从日志了解</p>
<h4 id="各个网络层次的安全保障"><a href="#各个网络层次的安全保障" class="headerlink" title="各个网络层次的安全保障"></a>各个网络层次的安全保障</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084954.png';" /></details>

<h4 id="网络威胁与共计"><a href="#网络威胁与共计" class="headerlink" title="网络威胁与共计"></a>网络威胁与共计</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907085356.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907085356.png';" /></details>

<p>业务流分析：跟窃听比有分析的成分</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907085530.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907085530.png';" /></details>


<h4 id="DOS和DDOS共计"><a href="#DOS和DDOS共计" class="headerlink" title="DOS和DDOS共计"></a>DOS和DDOS共计</h4><p>破坏可用性</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907085934.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907085934.png';" /></details>


<h4 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090013.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090013.png';" /></details>


<h4 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090340.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090340.png';" /></details>

<h4 id="计算机病毒与木马"><a href="#计算机病毒与木马" class="headerlink" title="计算机病毒与木马"></a>计算机病毒与木马</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090736.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090736.png';" /></details>



<h4 id="法律法规知识-保护年限"><a href="#法律法规知识-保护年限" class="headerlink" title="法律法规知识(保护年限)"></a>法律法规知识(保护年限)</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143758.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143758.png';" /></details>

<h4 id="法律法规知识-知识产权人确定"><a href="#法律法规知识-知识产权人确定" class="headerlink" title="法律法规知识(知识产权人确定)"></a>法律法规知识(知识产权人确定)</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144046.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144046.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144247.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144247.png';" /></details>

<h4 id="侵权判定"><a href="#侵权判定" class="headerlink" title="侵权判定"></a>侵权判定</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144431.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144431.png';" /></details>


<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144610.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144610.png';" /></details>


<h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144854.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144854.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144915.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144915.png';" /></details>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch10-%E6%9E%84%E5%BB%BA%E5%B9%B3%E5%8F%B0%E4%B8%8E%E5%85%B8%E5%9E%8B%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch10-%E6%9E%84%E5%BB%BA%E5%B9%B3%E5%8F%B0%E4%B8%8E%E5%85%B8%E5%9E%8B%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch10-构建平台与典型架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:07" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:07+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-19 15:35:43" itemprop="dateModified" datetime="2021-09-19T15:35:43+08:00">2021-09-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="构件平台与典型架构"><a href="#构件平台与典型架构" class="headerlink" title="构件平台与典型架构"></a>构件平台与典型架构</h2><p>几乎没有构件能独立的部署，它们大多数依赖于特定的基础设施平台。由于行业高度竞争，公用构建基础设施目前只有CORBA+Java和Microsoft COM+CLR两大阵营。尽管只有两大阵营，SOA技术也飞速发展，不同平台构件连接能力有了一定改善，但在设计、管理、规范等方面存在很大差异。因此，我们有必要了解这些平台特点和差异，为应用开发选择合适的构件开发平台。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wssiqi/article/details/49689447">Corba 学习笔记 (一)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/eunjungF/article/details/119306083">Corba执行过程</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wn084/article/details/80729230">JNDI</a></p>
</blockquote>
<h3 id="OMG方式"><a href="#OMG方式" class="headerlink" title="OMG方式"></a>OMG方式</h3><p>成立于1989年的对象管理组（OMG）是目前计算工业中最大的组织。作为一个非营利性组织，OMG旨在通过规范化对象开放市场的所有层次上的互操作性。至2002年，有近800成员加入OMG。</p>
<h4 id="对象请求代理"><a href="#对象请求代理" class="headerlink" title="对象请求代理"></a>对象请求代理</h4><p>CORBA的主要目标就是使不同语言、不同实现和不同平台间能进行交互。因此，OMG从没有停步在“二进制”标准上（可配置、可执行级的标准），而是保证每个细节都被标准化，使其能顾及不同的实现及CORBA兼容不同产品的独立供应商增值的需要。这一开放式方法的不利一面就是CORBA兼容产品不能在二进制级进行有效的互操作，只能以较高的代价在高层协议上协作。OMG的跨ORB（对象请求代理）协议——IIOP（Internet InterORB Protocol）互操作协议，在1995年7月的CORBA 2.0中被规范化。与ORB的互操作兼容则必须支持ⅡOP。在1996年7月的CORBA 2.0更新版本中，加入了一条关于相互作用的协议，该协议明确了基于CORBA的系统与基于微软COM系统之间的互操作细节。</p>
<p>CORBA包括三个基本部分：一套调用接口、对象请求代理（ORB）和一套对象适配器。面向对象操作的调用实现后期绑定。对象引用所指代的对象实现决定了被调用方法的最终实现。调用接口支持不同级别的后期绑定，同时编排调用参数，使ORB核心能定位接收对象，调用方法，以及传递参数。在接收端，一个对象适配器还原参数，调用接收对象相应的方法。图10-1简单地描述了基本的CORBA结构。</p>
<h4 id="公共对象服务规范"><a href="#公共对象服务规范" class="headerlink" title="公共对象服务规范"></a>公共对象服务规范</h4><p>现有的CORBA Service包含16种对象服务（CORBA服务），其中的通告服务是电信领域设施正式的组成部分。这些服务划分为两大类：一类服务应用于企业计算系统。这些系统往往将CORBA对象视为模块，并视CORBA为易用的通信中间件，此时的CORBA服务大多用来支持大规模的操作；另一类服务则应用于细粒度的对象操作，但目前这些服务的实用价值较差。CORBA 3.0中的持久状态服务（Persistent State Service, PSS）可能是一个例外，它替代了CORBA 2.0中的持久对象服务（POS）。PSS是CORBA构件模型的三个主要支撑服务之一，另两个是事务服务和通告服务。值得注意的是，大型基于CORBA系统往往只使用少量的CORBA服务，包括名字服务、安全服务、事务服务和交易服务。现有大部分ORB产品并不试图支持全部的CORBA服务也说明了这一点。</p>
<details><summary>图10-1　基于ORB系统的简化结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081201.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081201.png';" /></details>

<h5 id="支持企业分布式计算的服务"><a href="#支持企业分布式计算的服务" class="headerlink" title="支持企业分布式计算的服务"></a>支持企业分布式计算的服务</h5><p>许多大型企业系统只是将CORBA作为对象总线，依靠ORB与其他各种各样的系统进行互操作。名字服务是关键服务之一。</p>
<p>1）命名服务，交易器服务</p>
<p>每个对象内部都有唯一的标志符。命名服务则允许任意地给对象赋予一个名字，这个名字在其所属的命名语境中是唯一的。而命名语境所形成的层次结构，使得所有的名字形成名字树。</p>
<p>交易器服务允许给对象赋予一个复杂的描述，从而允许客户基于该描述来定位所需的对象。交易器通过交易语境来组织对象。客户则在指定的交易语境中根据对象描述的部分内容或关键字来搜寻对象，而搜寻结果往往是一个包含满足查询条件的一组对象的列表。OMG交易器服务规范同时被ISO（ISO/IEC 13235-1）和ITU（ITU-T推荐X.950）所采用。</p>
<p>2）事件服务，通告服务</p>
<p>事件服务允许定义那些从事件生产者被发送到事件消费者的事件对象。由于信息只能从生产者流向消费者，因而事件对象是不变的。事件必须通过事件通道传播，从而松散了生产者和消费者之间的耦合关系。事件可以具有类型（使用OMG IDL定义），而通道可以根据类型过滤事件。</p>
<p>事件通道支持“推”和“拉”两种方式的事件通告模型。在“推”模型中，事件生产者调用事件通道的“推”方法将事件上传给事件通道，事件通道进而调用所有注册的事件消费者的“推”方法将事件传给消费者。在“拉”模型中，事件消费者调用事件通道的“拉”方法，这将导致事件通道调用所有注册的事件生产者的“拉”方法，此时获得的新事件将返回给消费者。</p>
<p>1998年，通告服务为事件服务增加了几个重要的特征——服务质量（Quality of Service, QoS）规范和管理；标准的类型化和结构化事件；基于类型和QoS的动态事件过滤；作用于资源、通道、一组消费者或单个消费者的事件过滤；针对资源、通道和客户的事件发现。值得注意的是，通告服务本身并不是CORBA服务，而是电信领域工作组（Te1DTF）提交的CORBA设施。</p>
<p>3）对象事务服务</p>
<p>对象事务服务（Object Transaction Service, OTS）是建立分布式应用最重要的服务之一。OMG于1994年12月制定的OTS规范在大多数的ORB产品及若干J2EE服务器中得到支持。OTS实现必须支持平坦事务，而嵌套事务是可选的。遵循X/Open分布事务处理标准的其他事务服务可以与OTS集成。同样，多个异构ORB提供的事务也可集成。</p>
<p>在基于构件的系统中，嵌套事务似乎不可避免。因为一个构件的实现可能创建一个覆盖一系列操作的事务闭包，而这些事务属性无须在构件接口中声明。这种独立扩展性原则需要嵌套事务的支持。作为唯一的OTS实现必须支持的事务类型，平坦事务在构件系统中的价值有限。实际上，现有的主流事务中间件也不支持嵌套事务，这是它们共同的缺点。</p>
<p>OTS自动维护当前的事务语境，该语境将随请求在ORB系统中传递，也可传递给其他的非CORBA的事务系统。对于CORBA对象，事务语境可以传递给任何实现了Transactional Object的对象。当前的事务语境可从ORB获得，因此必须保证随时可用。事务操作，如begin, commit, rollback都在当前的语境中定义。</p>
<p>所有希望在一次事务中执行修改，或者需要执行事务控制的对象都必须向OTS协调器注册。该协调器可从当前语境中获得。一个资源可以指明它是否支持嵌套事务。任何资源都必须实现Resource接口，从而允许协调器执行两段提交协议（众所周知，两段提交协议在完全分布的环境下可能发生死锁，这只能通过特定的广播协议避免；三段提交协议能够避免死锁问题（Mullender, 1993），但开销太大。因此，OTS规定协调器在逻辑上必须是集中式的）。</p>
<p>OTS的设计目标之一是希望将事务控制作为一个独立的服务，但目前更普遍的是将事务和其他服务集成到应用服务器提供的语境或容器中。</p>
<p>4）安全服务</p>
<p>可靠的安全服务对于一个跨越多个相互信赖的组织的分布系统极为重要。安全服务必须得到普及。所有可互操作的ORB或可共同工作的系统必须协作，而这要求为所有的参与者建立统一的安全策略。</p>
<p>CORBA安全规范定义了一系列的服务，包括认证、安全通信、证书委托（也称为“替身”）及防抵赖等。目前仅有少数产品完全支持该规范，如BEA的WebLogic和IBM的WebSphere。很多产品仅仅依赖Netscape的安全套接字（Secure Socket Layer, SSL）实施安全保障，尤其采用独立ORB，而不是完全集成的应用服务器时。因为利用SSL可以很方便地实现简单的认证及安全的通信，但不能支持类似委托和防抵赖等较高级的安全机制。</p>
<p>5）支持细粒度对象互操作的服务</p>
<p>尽管有些服务，包括收集、外部化和查询服务，仍未被任何产品实现（原因很多，如查询服务的规范过于松散，收集服务的某些假设不切实际，本节仍将介绍余下的服务，以便读者对OMA涉及的对象服务有一个全面的认识。</p>
<p>6）并发控制服务</p>
<p>该服务支持对资源进行加锁和解锁。锁必须依赖于事务的语境或其他语境才能获得。依赖事务语境创建的锁将作为事务回滚的部分被释放。锁具有不同的模式，如读锁、写锁、升级锁。其中，读锁允许多个客户同时执行读操作；而写锁保证只有一个客户才能执行写操作；升级锁是可以升级为写锁的读锁，支持互斥的读操作。锁有多个锁集合。每个受保护的资源都拥有一个锁集合，该集合决定了可用的锁的种类及数量。一个锁集合的工厂接口支持创建新的锁集合。锁集合不是事务型就是非事务型的，并可与其他锁集合建立关联。锁协调器可以释放指定锁集合中所有的锁。</p>
<p>7）许可服务</p>
<p>组装构件的过程中需要获取所有非免费构件的使用许可。许可服务支持多种类型的许可模式。该服务定义了两个接口（抽象）——许可服务管理器和特定于厂商的许可服务。如果一个对象与一个许可协议绑定，那么它可以通过许可服务管理器检查其使用是否合法。</p>
<p>8）生命周期服务</p>
<p>这类服务支持创建、复制、移动和删除CORBA对象及其相关的对象组。下面将介绍如何利用关系服务提供的包含与引用关系来处理对象组。包含关系支持嵌套复制，即所有被包含的对象都会被复制。为了支持对象创建，生命周期服务支持注册与获取工厂对象。一旦获得所需的工厂对象，就能够用它来创建新的对象。</p>
<p>生命周期服务允许删除对象或对象组，但并不提示何时销毁该对象。这意味着分布式内存管理需要高层应用的参与，这被认为是CORBA较为明显的缺点。相比较而言，DCOM支持分布引用的计数，Java和CLR甚至支持基于租借的远程引用的分布式垃圾收集。</p>
<p>9）关系服务</p>
<p>关系服务指允许定义和维护对象之间的关系。不依赖语言级的指针或引用，该服务引入了一种关系模型，以支持在不影响相关对象的情况下创建对象间的关系。但是，关系服务基本上没有实际应用，甚至没有产品实现，极有可能被基于CCM的业务对象关系所取代。</p>
<p>10）持久状态服务</p>
<p>持久性是指对象在其创建程序终止后仍然存活。为此，CORBA 2.0制定了持久对象服务（POS），用来支持CORBA对象的持久性。尽管在1994年年初就被OMG标准化为关键服务，但直到1996年年中才出现一个beta版的实现。一些报告甚至指出该规范及其与其他对象服务的互操作存在严重的技术问题。另外，POS没有解决“正确性”的问题，尤其是它把存储的申请交给应用代码处理。POS规范最终在CORBA 3.0版本中被新的持久状态服务（PSS）所代替。</p>
<p>11）外部化服务</p>
<p>这项服务支持对象网和对象流之间的双向映射。对象网外部化后再内部化意味着创建该对象网的副本。外部化服务并不保证引用的完整性，仅保留同时外部化的对象之间的引用。外部化使得对象网的值复制成为可能。而外部化对象所需的其他对象的引用可保存为ORB为对象引用提供的字符串标志。</p>
<p>对象必须实现Streamable接口才能被外部化。为了外部化一个Streamable对象，必须首先调用实现了Stream接口的某个对象的外部化方法，该方法将调用流对象的externalize_to_stream方法，并传递一个实现StreamIO接口的对象。最后，流对象将任何OMG IDL定义的数据类型或实现写入streamIO对象。流对象也可以外部化由关系服务定义的整个对象图表。</p>
<p>12）属性服务</p>
<p>这种服务允许将任意的属性与对象关联起来，被关联对象必须实现PropertySet接口。属性可以独立地或成组地添加、获取和删除。如果一个对象还实现了PropertySetDef接口，则可按以下4种模式中的任一种进一步控制属性，这4种模式是：标准属性（可以修改和删除）、只读属性（能被删除但是不能修改）、强制标准属性（能被修改但不能删除）和强制只读属性。</p>
<p>属性服务并不说明属性的语义和内容。一般而言，对于程序有用的属性都需要由程序显式地赋予相应的信息。作为一个重要的例子，系统管理工具被赋予“粘贴”特性来有效地跟踪对象。</p>
<p>13）对象查询服务</p>
<p>该服务用来依靠属性定位对象。该服务类似于对象交易服务，但该服务定位对象实例而不是定位服务器。查询使用的属性由对象公布或者允许通过操作获得。有两种查询语言可供选择，面向对象数据库管理组的ODMG-93对象查询语言（Object Query Language, OQL）和扩展的SQL。一个更为普遍的查询语言正在建立。</p>
<p>查询服务定义了其自身的一个简单的集合服务——是通用集合服务的子集。查询结果集返回给用户时会用到集合。这些简单的集合提供了有序集的语义，包括增加或删除元素和元素集的操作。服务提供了一个Iterator接口来支持对集合元素的遍历。</p>
<p>14）对象集合服务</p>
<p>对象集合服务支持各种抽象拓扑集合，例如，包、集合、队列、表、树、角色模型是Smalltalk集合类库（Goldberg与Robson，1983，1989）。CORBA的集合服务（基于CORBA对象的相对重权模型）是否可与本地的对象集合库竞争是一个有争议的问题，另外，对象库可能更适于在ORB间传输各种形态与属性的集合。</p>
<p>15）时间服务</p>
<p>这一服务处理拥有众多异步时钟的分布式系统固有的误差问题。许多应用程序中，用实时信息将内部事件（如创建文件）与外部通用时间建立关联。一个时间服务必须在允许的误差范围内实现这种关联，并避免其他非因果的关联。例如，假设一个新对象的产生是对另一个对象触发某事件的反应，那么，如果给前一个对象赋予“生成日期”的时间戳，而该时间戳却先于后一个对象产生的时刻，此时就会产生一个非因果的时间信息——这恰恰是非因果时间服务的典型结果。</p>
<h4 id="CORBA构件模型"><a href="#CORBA构件模型" class="headerlink" title="CORBA构件模型"></a>CORBA构件模型</h4><p>CORBA 3.0是CORBA标准中最新的一个。尽管2002年6月左右该规范最后部分仍未定稿，但针对CORBA 2.0全面的改进已经获得了显著的进展。除了对象服务的全面修订，最主要的成就恐怕就是新的CORBA构件模型（CCM）——尽管最终的CCM规范的发布仍未定案。（有时，CCM也被称做CORBA构件。）</p>
<h5 id="可移植对象适配器"><a href="#可移植对象适配器" class="headerlink" title="可移植对象适配器"></a>可移植对象适配器</h5><p> $\color{red}{\text{CORBA对象适配器主要的作用}}$ 就是 $\color{green}{\text{在一个ORB和真正接收调用并且返回结果的对象实现之间进行协调}}$ 。目前采用的对象适配器的规范针对可移植的对象适配器，它代替了已过时的基本对象适配器。目前还没有其他的对象适配器规范。这种可移植对象适配器的一个实例为一组对象接收请求。任何ORB支持的服务器进程至少有一个POA（Portable Object Adapter）的实例，当然，该进程中的每个服务对象都可能有一个POA实例。</p>
<p>一个POA实例通过将收到的请求传递给一个“服务体”来对其进行处理。“服务体”是CORBA对象的实现。图10-2给出了一个典型的工具使用场景，从一个IDL定义开始，客户端的指代，服务器端的POA骨架，服务器端的“服务体”模板被一一建立。开发者可以通过完成该模板来补充实现细节。CORBA对象不强制使用面向对象语言，因而“服务体”也不一定为“类”。如果使用了面向对象语言，那么“服务体”就是类的实例。</p>
<h5 id="CCM构件"><a href="#CCM构件" class="headerlink" title="CCM构件"></a>CCM构件</h5><p>一个CCM应用程序是CCM构件的一个组装，其中构件可以是客户创建的或者是现成的、企业内部的或者是后来获得的。企业级JavaBean构件和CCM构件能够在一个应用程序中集成在一起。单个构件通过构件包发布，该构件包含有一个描述其内容的XML文档，还可以包含支持不同平台的二进制代码。CCM的装配包含一个描述它们所引用的构件包信息的XML文档，以及它们的部署配置。</p>
<details><summary>图10-2　根据IDL文件生成指代、POA骨架、服务体模板</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081435.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081435.png';" /></details>

<h5 id="CCM容器"><a href="#CCM容器" class="headerlink" title="CCM容器"></a>CCM容器</h5><p>CORBA 3.0定义了一个构件实现框架（Component Implementation Framework, CIF），其中包括接收CIDL（Component Implementation Definition Language，构件实现描述语言）输入并产生实现代码的生成器。另外，每个构件实例都放在一个CCM容器里。构件通过容器的接口与POA、事务、安全、持久化及通知服务相作用。一个容器同样也有插座接口来接收对构件实例的回调。</p>
<h4 id="CORBA设施"><a href="#CORBA设施" class="headerlink" title="CORBA设施"></a>CORBA设施</h4><p>CORBA设施可以分为水平的（普遍的）和垂直的（特定领域的）支持。不管是哪种支持，每个CORBA设施都定义了一个特定的构件框架，从而能够集成构件。最初，OMG试图标准化4个领域的水平设施：用户界面、信息管理、系统管理和任务管理。但是这些努力都失败了，而且水平设施在今天的OMA（Open Mobile Architecture）中的影响力很弱，之所以保留下来，是因为垂直设施的工作很可能产生并不特定于单个领域的设施。水平设施的例子，或者已经被标准化或者正在考虑之中，包括全球服务、移动代理、时间和打印设施。</p>
<p>领域任务组定义了垂直设施。在2002年年初，有10个这样的任务组：商业企业集成命令控制、计算机通信和集成、财政、卫生保健、生命科学研究、制造业、空间、电信、运输和共用设施建设。</p>
<h3 id="SUN公司的方式"><a href="#SUN公司的方式" class="headerlink" title="SUN公司的方式"></a>SUN公司的方式</h3><h4 id="Java构件技术的概述"><a href="#Java构件技术的概述" class="headerlink" title="Java构件技术的概述"></a>Java构件技术的概述</h4><p>就像上面说到的，Applet是Java中最初引起广泛关注并取得突破的地方。事实上，Java最初为了使不可靠的并可下载得到的Applet能够在客户端浏览器的进程中执行，在很多地方进行了特别设计，因而，不会造成无法接受的安全隐患。为实现这个目的，在Java中，编译器会检查Applet代码的安全性。这个做法的指导思想是：一个通过了编译器检查的Applet代码不会带来安全隐患。由于编译得到的字节码仍然可能被人修改，代码在装载时刻会被再次检查（称为“校验”）。通过校验的Applet是安全的，并受强制安全策略的约束。这一点对于现有的包括C++和对象Pascal在内的绝大多数编程语言来说都是不可能实现的。当然，安全策略可以在Smalltalk或者Visual Basic这些解释执行的语言中得到加强。然而Java是为允许编写在目标环境下有效执行的代码而设计的。这是通过所谓的“即时编译器（JIT）”实现的。</p>
<h5 id="Java与Java-2"><a href="#Java与Java-2" class="headerlink" title="Java与Java 2"></a>Java与Java 2</h5><p>虽然最初Java的规范集深受Applet思想的影响，Java 2平台（在1998年后期发布）打破原有框架，并将Applet改变成一个边缘的角色。Java 2引入了平台版本的概念，从Java规范集中选出，并共同服务于一组特定用户关心的问题。图10-3给出了Java 2的组织形式。更多的关于Java 2的内容将在下面的章节中介绍。作为Java标志性的平台版本，J2EE（Java 2平台企业版）最初于1999年年底发布，并获得了巨大成功。J2EE是一组以EJB为核心的规范，在这些规范之下是由许多不同厂商提供的应用服务器（其中最大的两个厂商是提供WebSphere产品的IBM公司和提供WebLogic产品的BEA公司；到2001年年底，在Flashline.com评测比较表中列出了40个左右的厂商，它们的产品的价格从免费/开放源码到每个CPU 75000美元不等）。微型版本J2ME也相当成功，特别是在用于移动电话的部分，企业版为构件化软件提供了丰富的环境。</p>
<p>除了版本之外，Java 2还区分了运行环境（Runtime Environent, RE）、软件开发工具包（Software Development Kit, SDK）和参考实现。运行环境是Java虚拟机和必须具有的J2SE API的实现。运行环境一般与一个SDK的版本相对应，SDK提供包括编译器和调试器在内的开发工具。容易混淆的是，按顺序为Java 1规范编号的1.x编号被继续用来给Java 2的运行环境和SDK编号。所以，运行环境可以这样提出“Java 2运行环境，标准版，v1.4”。</p>
<details><summary>图10-3　Java 2组织结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081659.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081659.png';" /></details>

<h5 id="运行环境和参考实现"><a href="#运行环境和参考实现" class="headerlink" title="运行环境和参考实现"></a>运行环境和参考实现</h5><p>Java运行环境（Java Runtime Environment, JRE）是J2SE平台的一部分，而J2SE本身又是J2EE平台的一个子集。JRE包括运行时刻、核心库和浏览器插件。Sun公司的JRE 1.4参考实现基于HotSpot运行时刻和提供对JIT编译的二进制代码进行在线再优化的HotSpot JIT编译器。单独的HotSpot编译器也有对应客户端和服务器端环境的版本。它们的区别在于根据内存占用历史信息、启动时刻、吞吐量和延时等不同而折中并对目标过程进行优化。Java SDK 1.4在包含Java编译器、调试器、平台调试体系结构API（JPDA）和用于生成文档（javadoc）的工具的同时，也包含了JRE 1.4。图10-4给出了J2SE平台1.4版本的主要结构。</p>
<p>J2EE体系结构概况通过使用专有的构件模型来区分了J2EE支持的范围。JavaBean和它的核心技术可以被用在图中几乎所有的层次。此外，请注意图中的箭头表示了控制流的典型情况，当然，并不完全。数据流一般也沿着同样的路径，但在两个方向都存在。一个底层的用于支持J2EE所有部分的系统是通过JNDI（Java Naming and Directory Interfoce，Java的命名与目录接口）访问的命名和目录的基础结构。另一个集成平台是通过JMS（Java Message Service，Java消息服务）可访问的消息基础结构。在EJB容器的消息驱动构件的帮助下，消息在到来的时候可以触发处理过程。消息和命名/目录是两个重要的集成的层次服务，但也有一些其他的部分，比如事务协作和安全服务。</p>
<details><summary>图10-4　Java 2平台标准版1.4的组织结构（资料来源：java.sun.com）</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081738.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081738.png';" /></details>

<details><summary>图10-5　J2EE体系结构概况</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081801.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081801.png';" /></details>

<h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>JavaBean填补了部分空白，成为一种新的可行的产品——Java构件，我们称之为Bean（Sun, 1996）。不幸的是，Java中类和对象之间明确的区别并没有被贯彻到JavaBean中。尽管一个Bean的确是一个构件（一系列类和其他资源），但是它的那些定制好的连接的实例仍然被称做Bean。这很让人迷惑。因此，我们用Bean来指代构件，用Bean实例来指代构件对象。“Bean对象”将会带来困扰，因为一个Bean通常包含了许多Java对象。</p>
<p>Bean模型主要包括以下几个方面。</p>
<p>（1）事件：Bean可以声明它们的实例是潜在的事件源或者特定类型事件的监听者。一个组装工具能够把事件源和监听者连接起来。</p>
<p>（2）属性：Bean通过成对的getter和setter方法暴露出一系列的属性。这些属性可以用来进行定制或者编程。属性的变化可以触发事件，也可以被事件强制修改。一个受限的属性只有在修改不被禁止的情况下才可以被修改。</p>
<p>（3）自检：一个组装工具能够检查一个Bean，发现这个Bean的属性、事件，以及所支持的方法。</p>
<p>（4）定制：使用组装工具，一个Bean实例能够通过设置它的各种属性来完成定制。</p>
<p>（5）持久化：定制好的、已经连接的Bean实例需要进行保存，以便在应用程序使用它的时候重新装载。</p>
<h4 id="基本的Java服务"><a href="#基本的Java服务" class="headerlink" title="基本的Java服务"></a>基本的Java服务</h4><p>经过这些年，Java已经添加了许多标准服务。这一节我们将看到反射、对象序列化，以及Java本地接口。</p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>Java的核心反射服务是一个集合体，包括原始Java语言的特性、一套支持类（在JDK 1.1中引入），以及支持类文字的语言特性。反射服务受到活动安全策略的约束，它允许我们：</p>
<p>（1）检查类和接口，包括它们的属性域和方法。</p>
<p>（2）构建新的类实例和新数组。</p>
<p>（3）对象和类的属性域的访问和修改。</p>
<p>（4）数组元素的访问和修改。</p>
<p>（5）对象和类的方法调用。</p>
<p>由此，反射服务涵盖了Java语言的所有特性。Java语言级的访问控制机制，比如域的私有性，被大大增强了（无限制的访问对于实现可信任的底层服务，例如便携式调试器，是很有用的。为了实现这些无限制的访问，Java平台的调试器体系结构提供了一个特别的接口——JPDA（Java Platform Debugger Architecture）。为了进行反射操作，反射服务引入了包java.lang.reflect。</p>
<p>类Field，Method，以及Constructor提供了关于属性域、方法和构造器的反射信息，这些信息由它们描述，并对这个域、方法和构造器进行类型安全的使用。这三个类都是最终的，没有公有的构造器。它们三个都实现了接口Member，这使得我们可以弄清楚成员如何被调用，确定成员的改动及该成员属于哪个类或者接口。</p>
<h5 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h5><p>在JDK 1.0.2以前，Java都不支持把对象序列化至字节流——仅仅支持基本类型。如果一个应用想把整个对象网写到输出流，它需要使用特别的编码方案来遍历和序列化对象自身。Java对象序列化服务解决了这个问题，它通过定义一个标准的连续编码方案来达到目标，同时提供编码和解码（“序列化”和“反序列化”）对象网的机制。</p>
<p>一个对象能够被序列化，它必须实现接口java.io.Serializable。另外，所有不应该被序列化的域需要用暂时修饰符标记。这一点很重要，因为域可能指向巨大的计算机结构（比如缓存）或者固有绑定到当前JVM的值（比如打开文件的描述符）。对实现Serializable接口的对象而言，足够的信息被写入一个流，以使得反序列化能继续进行，即使使用不同（但是兼容）的类版本。通过实现方法readObject和writeObject，可以进一步控制将哪些信息或者添加更多的信息写入流。如果这些方法没有实现，所有指向可序列化对象的非暂时域将自动被序列化。指向对象的共享引用被保存起来。</p>
<h5 id="Java本地接口"><a href="#Java本地接口" class="headerlink" title="Java本地接口"></a>Java本地接口</h5><p>Java本地接口（Java Native Interface, JNI）为每一个平台规定了本地调用方式，在Java虚拟机之外我们可以调用本地代码。JNI还规定了这些外部代码如何按照传递过去的引用来访问Java对象。这包括了调用Java方法的可能性。JNI并没有规定Java二进制对象模型——也就是说，它没有规定在一个特定的Java虚拟机中属性如何被访问及方法如何被调用。同一平台上不同Java虚拟机之间的互操作仍然是一个未解决的问题，比如实时编译器这样的边界服务。JNI允许本地方法：</p>
<p>（1）创建、检查和更新一个Java对象。</p>
<p>（2）调用Java方法。</p>
<p>（3）捕捉和抛出异常。</p>
<p>（4）装载类，获得类的信息。</p>
<p>（5）进行运行时刻类型检查。</p>
<h5 id="Java-AWT和JFC-Swing"><a href="#Java-AWT和JFC-Swing" class="headerlink" title="Java AWT和JFC/Swing"></a>Java AWT和JFC/Swing</h5><p>Java抽象窗口工具包（Abstract Windowing Toolkit, AWT）和Java基础类（Java Foundation Classes, JFC）提供了一个图形用户接口，这对于任何Java开发都具有重要意义。</p>
<p>基于委托的事件模型——这也许是在JDK 1.1中最富有戏剧性的改变。以前的事件模型基于从构件类的继承及事件管理方法的重载。“基于委托”有一点用词不当，因为它沿用了COM中的术语委托。JDK 1.1事实上提供了一个基于转发的事件模型。对象连接和组装被用来更好地实现继承。</p>
<p>●　数据传输和剪贴板支持：就像COM通用数据传输服务，AWT定义了可传输数据项的概念。Internet MIME（多用途Internet邮件扩展）类型被用来和非Java的应用程序相互作用。</p>
<p>Java应用程序之间的数据传输也可以直接使用Java类。</p>
<p>●　拖放：支持在Java和非Java应用程序之间进行拖放（通过连接底层系统的拖放协议，比如Windows中的OLE）。</p>
<p>●　Java 2D：新的2D图形和图片类。Java2D包含了线、文本和图片。支持的属性包括图片合成、Alpha合成（透明化）、精确颜色空间定义和转化，以及面向显示的图像操作。</p>
<p>●　打印：打印模型比较简单。非显式地处理打印的图形构件将使用它们的屏幕透视方法被打印出来。因此，对于简单的构件，打印可以随时进行。然而，打印模型并不处理打印那些需要在多个页面分布的嵌入内容（ActiveX打印模型对此提供了支持，它和容器合作，允许嵌入的内容跨业若干页进行打印。这个是一个复杂的模型，然而只有很少的ActiveX容器真正实现了这个高级打印模型）。</p>
<p>●　可访问性：允许所谓的辅助技术来和JFC及AWT构件交互的接口。辅助技术包括屏幕读取器、屏幕放大器和语音识别。</p>
<p>●　国际化：以Unicode 2.1字符编码为基础，提供了对文本、数字、日期、货币，以及用户自定义对象和当地习惯相适应的支持，使用语言和区域标志符来识别正确的格式。</p>
<h4 id="各种构件——Applet，Servlet，Bean和Enterprise-Bean"><a href="#各种构件——Applet，Servlet，Bean和Enterprise-Bean" class="headerlink" title="各种构件——Applet，Servlet，Bean和Enterprise Bean"></a>各种构件——Applet，Servlet，Bean和Enterprise Bean</h4><p>在Java领域中定义了5种不同的构件模型，而且将来可能会出现更多。这其中不仅包括了Applet和JavaBean模型（J2SE的一部分），还有Enterprise JavaBean，servlet和应用程序客户端构件（J2EE的一部分）。本节将对这些不同的构件模型进行简要地描述。</p>
<p>servlet/JSP和EJB是J2EE服务器端模型的两个关键元素，在下面的论述中将对它们进行更详细的介绍。在J2EE中，所有的构件将被打包成JAR文件，这样J2EE应用就可以将这些JAR文件包含进来。J2EE中的构件都有一个很重要的方面，就是它们都支持部署描述符（Deployment Descriptors）。部署描述符是一个XML文件，和相应的构件一起打包，用来描述这个构件应该怎样进行部署。部署是指根据实际的部署语境将一个构件进行准备的动作，这一步骤可以是，也经常是从安装软件的概念中分离出来的。部署描述符的详细内容依赖于特定的构件模型。例如，一个EJB实体Bean的描述符，就要有容器管理的持久性的描述，以及对EJB实体Bean中的属性到数据库中表的映射的详细描述。</p>
<p>Applet是第一个Java构件模型，用于轻量级的可下载的构件，以增强网站在浏览器中的视觉效果。最初的Applet安全模型非常严格，以致Applet不比eye candy发送得多。eye candy是指在通过别的技术捕捉一个区域，这些技术包括GIF动画、Macromedia Shockwave和Flash技术、JScript、对HTML的增强（包括DHTML（动态HTML）的引入）等。为了充分利用浏览器端技术，绝大多数的基于J2EE的应用均使用servlet和JSP来通过脚本生成HTML页面，而不是通过下载Applet来实现。</p>
<p>第二个Java构件模型是JavaBean。它主要用于支持基于连接的程序，比如同时用在客户端和服务器端的程序。从历史上来说，JavaBean在客户端占比重较大的应用中使用得更广泛，而在服务器端有时候还会被EJB所替代。但这种观点从技术角度上来说是错误的：EJB远远不只是它的名字看上去的那样，和JavaBean的相似之处也很少。当建造一个明确支持可视化应用设计模式的客户端应用时，JavaBean依然是有用的（就像J2SE 1.3中所述，一个Bean也可以是一个Applet。但无论如何，这种支持是有限的——BeanApplet所接受的总是空的Applet语境和存根）。</p>
<p>EJB是Java的第三个构件模型。它使用容器集成服务，用以支持EJB（构件）使用声明属性和部署描述符的方式来请求服务。在最新的修订版中，JavaBean也加入了容器模型，但它的容器模型与EJB容器有很大的不同。前者仅仅是一种容纳的机制，而后者则是一种声明型构造驱动的模式。因为JavaBean不需要在设计时之外与用户交互，所以也可以使用JavaBean来构造更复杂的EJB。（JavaBean和EJB与NET框架中的构件类及被服务的构件类大致对应。）</p>
<p>第四个Java构件模型是servlet。它跟Applet相似，但属于服务器端构件模型，而且是通常由Web服务器进程进行实例化的轻量级构件，Web页面就是一个典型的例子。Java Server Page（SP）是一种与之匹配的技术，能够声明式地定义要生成的页面，然后JSP会被编译成servlet。</p>
<p>J2EE引入的第五种Java构件模型为应用客户端构件。它本质上是在客户端的不受限制的Java程序。一个客户端构件通过用命名语境的JNDI企业来访问J2EE服务器中的环境属性、EJB和各种资源。这些资源可以包括对E-mail（通过JavaMail）或数据库（通过JDBC）的访问。</p>
<p>对Java构件模型不同种类的支持是不同的需求的反映。但无论如何，要在这些不同的领域实际地建立构件市场，还需要在基于领域的概念等方面建立更深入的标准化。现在，只有很少的EJB构件在需要开发它们的系统之外的其他系统中使用。</p>
<h4 id="高级Java服务"><a href="#高级Java服务" class="headerlink" title="高级Java服务"></a>高级Java服务</h4><p>本节将介绍Java如何在企业级范围支持分布式计算。实际上Java中有4种模式支持分布式计算——RMI，RMI over IIOP,CORBA和EJB容器（本身是建立在RMI或RMI over IIOP上的）。EJB在前面已经论述了。本章将论述其他的几种，以及一些最重要的支持分布式应用的服务。</p>
<h5 id="分布式对象模型和RMI"><a href="#分布式对象模型和RMI" class="headerlink" title="分布式对象模型和RMI"></a>分布式对象模型和RMI</h5><p>分布式计算主要由对象序列化服务和远程方法调用（Remote Method Invocation，RMI）服务支持。这两种服务都是在JDK 1.1引入的。下面的章节介绍RMI和RMI over IIOP，它们有细微的差别。</p>
<p>一个分布式对象的句柄为一个接口类型的引用——它不能指向一个remote对象类及其超类。能够远程访问的接口必须直接或间接从java.rmi.Remote继承下来。一个远程操作可以由于网络或远程硬件故障而失败。remote接口的所有方法都要声明检查java.rmi.Remote Exception异常。将参数传给远程操作很有意思，如果一个参数是remote接口类型，那么就是按引用来传，其他类型则按值来传——这就意味着，参数将在调用端序列化，在调用remote接口方法的时候反序列化。Java对象不需要序列化。如果企图传一个无法序列化的对象将会抛出运行时刻异常。如果语言规定使用Java RMI，那么编译器可以静态地规定只有可序列化对象可以通过值来传送，而且所有的方法都声明Remote Exception异常。</p>
<p>Java分布式模型扩展了垃圾回收。它将所有有远程引用指向它们的对象都记录下来，这样就可以支持分布式的垃圾回收了。回收器是基于Network Object（Birrel，1993）的工作的。分布式垃圾回收是RMI比当今其他模型出色的一点。唯一的另外一种基于Network Object的和有租用引用思想的就是CLI remoting，但这种方法的提出比JavaRMI晚了四年。</p>
<h5 id="Java和CORBA"><a href="#Java和CORBA" class="headerlink" title="Java和CORBA"></a>Java和CORBA</h5><p>一个OMG IDL到Java的绑定和OMG最先给出的Java到OMG IDL的绑定，是1998年在CORBA 2.2中定义的。将CORBA包含在Java项目的一个重要原因是能用ⅡOP和非Java系统通信。为了能访问CORBA服务，通常使用Java规范定义的接口会更方便，这些接口能够映射到兼容CORBA或其他服务。</p>
<h5 id="企业级服务接口"><a href="#企业级服务接口" class="headerlink" title="企业级服务接口"></a>企业级服务接口</h5><p>J2EE的重要部分就是一些适合于企业级服务的接口。这些服务接口也可以通过CORBA来建立。然而，Java-CORBA的集成必然会引起一些冲突。与此相反，在本节讨论的以Java为中心的接口，从客户和实现者的角度来减小这些不足。</p>
<p>1）Java命名和目录接口（JNDI）</p>
<p>在计算系统中的一个全局性问题就是通过名字或属性来定位服务的问题。命名服务针对前一个问题，目录服务针对后一个。命名服务的例子包括Internet域名服务（DNS）、RMI注册表和CORBA命名服务。目录服务的例子包括兼容LDAP的目录系统，比如Novell的eDirectory、微软的Active Directory和开放源码的OpenLDAP（<a target="_blank" rel="noopener" href="http://www.openldap.org)./">www.openldap.org）。</a></p>
<p>JNDI为命名服务（javax.naming）和目录服务（javax.naming.directory）提供了统一的API。Context这个最普遍使用的接口使命名语境对lookup方法有效，使用这个方法就可以根据名字来定位对象了。一个命名语境也可以用来对绑定在某个语境中的名字进行列表，或者是解除一个绑定，或是创建或删除一个子语境。</p>
<p>EJB的Bean的一个重要的命名语境就是EJB容器提供的环境命名语境（Environment Narning Context, ENC）。通过它可以访问环境属性、其他Bean和资源。接口DirContext扩展Context来提供目录功能，包括检查和更新与目录上列出的对象相关联的属性，以及通过值来搜索一个目录第10章　构件平台与典型架构</p>
<p>几乎没有构件能独立的部署，它们大多数依赖于特定的基础设施平台。由于行业高度竞争，公用构建基础设施目前只有CORBA+Java和Microsoft COM+CLR两大阵营。尽管只有两大阵营，SOA技术也飞速发展，不同平台构件连接能力有了一定改善，但在设计、管理、规范等方面存在很大差异。因此，我们有必要了解这些平台特点和差异，为应用开发选择合适的构件开发平台。</p>
<p>10.1　OMG方式</p>
<p>成立于1989年的对象管理组（OMG）是目前计算工业中最大的组织。作为一个非营利性组织，OMG旨在通过规范化对象开放市场的所有层次上的互操作性。至2002年，有近800成员加入OMG。</p>
<p>10.1.1　对象请求代理</p>
<p>CORBA的主要目标就是使不同语言、不同实现和不同平台间能进行交互。因此，OMG从没有停步在“二进制”标准上（可配置、可执行级的标准），而是保证每个细节都被标准化，使其能顾及不同的实现及CORBA兼容不同产品的独立供应商增值的需要。这一开放式方法的不利一面就是CORBA兼容产品不能在二进制级进行有效的互操作，只能以较高的代价在高层协议上协作。OMG的跨ORB（对象请求代理）协议——IIOP（Internet InterORB Protocol）互操作协议，在1995年7月的CORBA 2.0中被规范化。与ORB的互操作兼容则必须支持ⅡOP。在1996年7月的CORBA 2.0更新版本中，加入了一条关于相互作用的协议，该协议明确了基于CORBA的系统与基于微软COM系统之间的互操作细节。</p>
<p>CORBA包括三个基本部分：一套调用接口、对象请求代理（ORB）和一套对象适配器。面向对象操作的调用实现后期绑定。对象引用所指代的对象实现决定了被调用方法的最终实现。调用接口支持不同级别的后期绑定，同时编排调用参数，使ORB核心能定位接收对象，调用方法，以及传递参数。在接收端，一个对象适配器还原参数，调用接收对象相应的方法。图10-1简单地描述了基本的CORBA结构。</p>
<p>10.1.2　公共对象服务规范</p>
<p>现有的CORBA Service包含16种对象服务（CORBA服务），其中的通告服务是电信领域设施正式的组成部分。这些服务划分为两大类：一类服务应用于企业计算系统。这些系统往往将CORBA对象视为模块，并视CORBA为易用的通信中间件，此时的CORBA服务大多用来支持大规模的操作；另一类服务则应用于细粒度的对象操作，但目前这些服务的实用价值较差。CORBA 3.0中的持久状态服务（Persistent State Service, PSS）可能是一个例外，它替代了CORBA 2.0中的持久对象服务（POS）。PSS是CORBA构件模型的三个主要支撑服务之一，另两个是事务服务和通告服务。值得注意的是，大型基于CORBA系统往往只使用少量的CORBA服务，包括名字服务、安全服务、事务服务和交易服务。现有大部分ORB产品并不试图支持全部的CORBA服务也说明了这一点。</p>
<p>alt</p>
<p>图10-1　基于ORB系统的简化结构</p>
<p>1．支持企业分布式计算的服务</p>
<p>许多大型企业系统只是将CORBA作为对象总线，依靠ORB与其他各种各样的系统进行互操作。名字服务是关键服务之一。</p>
<p>1）命名服务，交易器服务</p>
<p>每个对象内部都有唯一的标志符。命名服务则允许任意地给对象赋予一个名字，这个名字在其所属的命名语境中是唯一的。而命名语境所形成的层次结构，使得所有的名字形成名字树。</p>
<p>交易器服务允许给对象赋予一个复杂的描述，从而允许客户基于该描述来定位所需的对象。交易器通过交易语境来组织对象。客户则在指定的交易语境中根据对象描述的部分内容或关键字来搜寻对象，而搜寻结果往往是一个包含满足查询条件的一组对象的列表。OMG交易器服务规范同时被ISO（ISO/IEC 13235-1）和ITU（ITU-T推荐X.950）所采用。</p>
<p>2）事件服务，通告服务</p>
<p>事件服务允许定义那些从事件生产者被发送到事件消费者的事件对象。由于信息只能从生产者流向消费者，因而事件对象是不变的。事件必须通过事件通道传播，从而松散了生产者和消费者之间的耦合关系。事件可以具有类型（使用OMG IDL定义），而通道可以根据类型过滤事件。</p>
<p>事件通道支持“推”和“拉”两种方式的事件通告模型。在“推”模型中，事件生产者调用事件通道的“推”方法将事件上传给事件通道，事件通道进而调用所有注册的事件消费者的“推”方法将事件传给消费者。在“拉”模型中，事件消费者调用事件通道的“拉”方法，这将导致事件通道调用所有注册的事件生产者的“拉”方法，此时获得的新事件将返回给消费者。</p>
<p>1998年，通告服务为事件服务增加了几个重要的特征——服务质量（Quality of Service, QoS）规范和管理；标准的类型化和结构化事件；基于类型和QoS的动态事件过滤；作用于资源、通道、一组消费者或单个消费者的事件过滤；针对资源、通道和客户的事件发现。值得注意的是，通告服务本身并不是CORBA服务，而是电信领域工作组（Te1DTF）提交的CORBA设施。</p>
<p>3）对象事务服务</p>
<p>对象事务服务（Object Transaction Service, OTS）是建立分布式应用最重要的服务之一。OMG于1994年12月制定的OTS规范在大多数的ORB产品及若干J2EE服务器中得到支持。OTS实现必须支持平坦事务，而嵌套事务是可选的。遵循X/Open分布事务处理标准的其他事务服务可以与OTS集成。同样，多个异构ORB提供的事务也可集成。</p>
<p>在基于构件的系统中，嵌套事务似乎不可避免。因为一个构件的实现可能创建一个覆盖一系列操作的事务闭包，而这些事务属性无须在构件接口中声明。这种独立扩展性原则需要嵌套事务的支持。作为唯一的OTS实现必须支持的事务类型，平坦事务在构件系统中的价值有限。实际上，现有的主流事务中间件也不支持嵌套事务，这是它们共同的缺点。</p>
<p>OTS自动维护当前的事务语境，该语境将随请求在ORB系统中传递，也可传递给其他的非CORBA的事务系统。对于CORBA对象，事务语境可以传递给任何实现了Transactional Object的对象。当前的事务语境可从ORB获得，因此必须保证随时可用。事务操作，如begin, commit, rollback都在当前的语境中定义。</p>
<p>所有希望在一次事务中执行修改，或者需要执行事务控制的对象都必须向OTS协调器注册。该协调器可从当前语境中获得。一个资源可以指明它是否支持嵌套事务。任何资源都必须实现Resource接口，从而允许协调器执行两段提交协议（众所周知，两段提交协议在完全分布的环境下可能发生死锁，这只能通过特定的广播协议避免；三段提交协议能够避免死锁问题（Mullender, 1993），但开销太大。因此，OTS规定协调器在逻辑上必须是集中式的）。</p>
<p>OTS的设计目标之一是希望将事务控制作为一个独立的服务，但目前更普遍的是将事务和其他服务集成到应用服务器提供的语境或容器中。</p>
<p>4）安全服务</p>
<p>可靠的安全服务对于一个跨越多个相互信赖的组织的分布系统极为重要。安全服务必须得到普及。所有可互操作的ORB或可共同工作的系统必须协作，而这要求为所有的参与者建立统一的安全策略。</p>
<p>CORBA安全规范定义了一系列的服务，包括认证、安全通信、证书委托（也称为“替身”）及防抵赖等。目前仅有少数产品完全支持该规范，如BEA的WebLogic和IBM的WebSphere。很多产品仅仅依赖Netscape的安全套接字（Secure Socket Layer, SSL）实施安全保障，尤其采用独立ORB，而不是完全集成的应用服务器时。因为利用SSL可以很方便地实现简单的认证及安全的通信，但不能支持类似委托和防抵赖等较高级的安全机制。</p>
<p>5）支持细粒度对象互操作的服务</p>
<p>尽管有些服务，包括收集、外部化和查询服务，仍未被任何产品实现（原因很多，如查询服务的规范过于松散，收集服务的某些假设不切实际，本节仍将介绍余下的服务，以便读者对OMA涉及的对象服务有一个全面的认识。</p>
<p>6）并发控制服务</p>
<p>该服务支持对资源进行加锁和解锁。锁必须依赖于事务的语境或其他语境才能获得。依赖事务语境创建的锁将作为事务回滚的部分被释放。锁具有不同的模式，如读锁、写锁、升级锁。其中，读锁允许多个客户同时执行读操作；而写锁保证只有一个客户才能执行写操作；升级锁是可以升级为写锁的读锁，支持互斥的读操作。锁有多个锁集合。每个受保护的资源都拥有一个锁集合，该集合决定了可用的锁的种类及数量。一个锁集合的工厂接口支持创建新的锁集合。锁集合不是事务型就是非事务型的，并可与其他锁集合建立关联。锁协调器可以释放指定锁集合中所有的锁。</p>
<p>7）许可服务</p>
<p>组装构件的过程中需要获取所有非免费构件的使用许可。许可服务支持多种类型的许可模式。该服务定义了两个接口（抽象）——许可服务管理器和特定于厂商的许可服务。如果一个对象与一个许可协议绑定，那么它可以通过许可服务管理器检查其使用是否合法。</p>
<p>8）生命周期服务</p>
<p>这类服务支持创建、复制、移动和删除CORBA对象及其相关的对象组。下面将介绍如何利用关系服务提供的包含与引用关系来处理对象组。包含关系支持嵌套复制，即所有被包含的对象都会被复制。为了支持对象创建，生命周期服务支持注册与获取工厂对象。一旦获得所需的工厂对象，就能够用它来创建新的对象。</p>
<p>生命周期服务允许删除对象或对象组，但并不提示何时销毁该对象。这意味着分布式内存管理需要高层应用的参与，这被认为是CORBA较为明显的缺点。相比较而言，DCOM支持分布引用的计数，Java和CLR甚至支持基于租借的远程引用的分布式垃圾收集。</p>
<p>9）关系服务</p>
<p>关系服务指允许定义和维护对象之间的关系。不依赖语言级的指针或引用，该服务引入了一种关系模型，以支持在不影响相关对象的情况下创建对象间的关系。但是，关系服务基本上没有实际应用，甚至没有产品实现，极有可能被基于CCM的业务对象关系所取代。</p>
<p>10）持久状态服务</p>
<p>持久性是指对象在其创建程序终止后仍然存活。为此，CORBA 2.0制定了持久对象服务（POS），用来支持CORBA对象的持久性。尽管在1994年年初就被OMG标准化为关键服务，但直到1996年年中才出现一个beta版的实现。一些报告甚至指出该规范及其与其他对象服务的互操作存在严重的技术问题。另外，POS没有解决“正确性”的问题，尤其是它把存储的申请交给应用代码处理。POS规范最终在CORBA 3.0版本中被新的持久状态服务（PSS）所代替。</p>
<p>11）外部化服务</p>
<p>这项服务支持对象网和对象流之间的双向映射。对象网外部化后再内部化意味着创建该对象网的副本。外部化服务并不保证引用的完整性，仅保留同时外部化的对象之间的引用。外部化使得对象网的值复制成为可能。而外部化对象所需的其他对象的引用可保存为ORB为对象引用提供的字符串标志。</p>
<p>对象必须实现Streamable接口才能被外部化。为了外部化一个Streamable对象，必须首先调用实现了Stream接口的某个对象的外部化方法，该方法将调用流对象的externalize_to_stream方法，并传递一个实现StreamIO接口的对象。最后，流对象将任何OMG IDL定义的数据类型或实现写入streamIO对象。流对象也可以外部化由关系服务定义的整个对象图表。</p>
<p>12）属性服务</p>
<p>这种服务允许将任意的属性与对象关联起来，被关联对象必须实现PropertySet接口。属性可以独立地或成组地添加、获取和删除。如果一个对象还实现了PropertySetDef接口，则可按以下4种模式中的任一种进一步控制属性，这4种模式是：标准属性（可以修改和删除）、只读属性（能被删除但是不能修改）、强制标准属性（能被修改但不能删除）和强制只读属性。</p>
<p>属性服务并不说明属性的语义和内容。一般而言，对于程序有用的属性都需要由程序显式地赋予相应的信息。作为一个重要的例子，系统管理工具被赋予“粘贴”特性来有效地跟踪对象。</p>
<p>13）对象查询服务</p>
<p>该服务用来依靠属性定位对象。该服务类似于对象交易服务，但该服务定位对象实例而不是定位服务器。查询使用的属性由对象公布或者允许通过操作获得。有两种查询语言可供选择，面向对象数据库管理组的ODMG-93对象查询语言（Object Query Language, OQL）和扩展的SQL。一个更为普遍的查询语言正在建立。</p>
<p>查询服务定义了其自身的一个简单的集合服务——是通用集合服务的子集。查询结果集返回给用户时会用到集合。这些简单的集合提供了有序集的语义，包括增加或删除元素和元素集的操作。服务提供了一个Iterator接口来支持对集合元素的遍历。</p>
<p>14）对象集合服务</p>
<p>对象集合服务支持各种抽象拓扑集合，例如，包、集合、队列、表、树、角色模型是Smalltalk集合类库（Goldberg与Robson，1983，1989）。CORBA的集合服务（基于CORBA对象的相对重权模型）是否可与本地的对象集合库竞争是一个有争议的问题，另外，对象库可能更适于在ORB间传输各种形态与属性的集合。</p>
<p>15）时间服务</p>
<p>这一服务处理拥有众多异步时钟的分布式系统固有的误差问题。许多应用程序中，用实时信息将内部事件（如创建文件）与外部通用时间建立关联。一个时间服务必须在允许的误差范围内实现这种关联，并避免其他非因果的关联。例如，假设一个新对象的产生是对另一个对象触发某事件的反应，那么，如果给前一个对象赋予“生成日期”的时间戳，而该时间戳却先于后一个对象产生的时刻，此时就会产生一个非因果的时间信息——这恰恰是非因果时间服务的典型结果。</p>
<p>10.1.3　CORBA构件模型</p>
<p>CORBA 3.0是CORBA标准中最新的一个。尽管2002年6月左右该规范最后部分仍未定稿，但针对CORBA 2.0全面的改进已经获得了显著的进展。除了对象服务的全面修订，最主要的成就恐怕就是新的CORBA构件模型（CCM）——尽管最终的CCM规范的发布仍未定案。（有时，CCM也被称做CORBA构件。）</p>
<p>1．可移植对象适配器</p>
<p>CORBA对象适配器主要的作用就是在一个ORB和真正接收调用并且返回结果的对象实现之间进行协调。目前采用的对象适配器的规范针对可移植的对象适配器，它代替了已过时的基本对象适配器。目前还没有其他的对象适配器规范。这种可移植对象适配器的一个实例为一组对象接收请求。任何ORB支持的服务器进程至少有一个POA（Portable Object Adapter）的实例，当然，该进程中的每个服务对象都可能有一个POA实例。</p>
<p>一个POA实例通过将收到的请求传递给一个“服务体”来对其进行处理。“服务体”是CORBA对象的实现。图10-2给出了一个典型的工具使用场景，从一个IDL定义开始，客户端的指代，服务器端的POA骨架，服务器端的“服务体”模板被一一建立。开发者可以通过完成该模板来补充实现细节。CORBA对象不强制使用面向对象语言，因而“服务体”也不一定为“类”。如果使用了面向对象语言，那么“服务体”就是类的实例。</p>
<p>2．CCM构件</p>
<p>一个CCM应用程序是CCM构件的一个组装，其中构件可以是客户创建的或者是现成的、企业内部的或者是后来获得的。企业级JavaBean构件和CCM构件能够在一个应用程序中集成在一起。单个构件通过构件包发布，该构件包含有一个描述其内容的XML文档，还可以包含支持不同平台的二进制代码。CCM的装配包含一个描述它们所引用的构件包信息的XML文档，以及它们的部署配置。</p>
<p>alt</p>
<p>图10-2　根据IDL文件生成指代、POA骨架、服务体模板</p>
<p>3．CCM容器</p>
<p>CORBA 3.0定义了一个构件实现框架（Component Implementation Framework, CIF），其中包括接收CIDL（Component Implementation Definition Language，构件实现描述语言）输入并产生实现代码的生成器。另外，每个构件实例都放在一个CCM容器里。构件通过容器的接口与POA、事务、安全、持久化及通知服务相作用。一个容器同样也有插座接口来接收对构件实例的回调。</p>
<p>10.1.4　CORBA设施</p>
<p>CORBA设施可以分为水平的（普遍的）和垂直的（特定领域的）支持。不管是哪种支持，每个CORBA设施都定义了一个特定的构件框架，从而能够集成构件。最初，OMG试图标准化4个领域的水平设施：用户界面、信息管理、系统管理和任务管理。但是这些努力都失败了，而且水平设施在今天的OMA（Open Mobile Architecture）中的影响力很弱，之所以保留下来，是因为垂直设施的工作很可能产生并不特定于单个领域的设施。水平设施的例子，或者已经被标准化或者正在考虑之中，包括全球服务、移动代理、时间和打印设施。</p>
<p>领域任务组定义了垂直设施。在2002年年初，有10个这样的任务组：商业企业集成命令控制、计算机通信和集成、财政、卫生保健、生命科学研究、制造业、空间、电信、运输和共用设施建设。</p>
<p>10.2　SUN公司的方式</p>
<p>10.2.1　Java构件技术的概述</p>
<p>就像上面说到的，Applet是Java中最初引起广泛关注并取得突破的地方。事实上，Java最初为了使不可靠的并可下载得到的Applet能够在客户端浏览器的进程中执行，在很多地方进行了特别设计，因而，不会造成无法接受的安全隐患。为实现这个目的，在Java中，编译器会检查Applet代码的安全性。这个做法的指导思想是：一个通过了编译器检查的Applet代码不会带来安全隐患。由于编译得到的字节码仍然可能被人修改，代码在装载时刻会被再次检查（称为“校验”）。通过校验的Applet是安全的，并受强制安全策略的约束。这一点对于现有的包括C++和对象Pascal在内的绝大多数编程语言来说都是不可能实现的。当然，安全策略可以在Smalltalk或者Visual Basic这些解释执行的语言中得到加强。然而Java是为允许编写在目标环境下有效执行的代码而设计的。这是通过所谓的“即时编译器（JIT）”实现的。</p>
<p>1．Java与Java 2</p>
<p>虽然最初Java的规范集深受Applet思想的影响，Java 2平台（在1998年后期发布）打破原有框架，并将Applet改变成一个边缘的角色。Java 2引入了平台版本的概念，从Java规范集中选出，并共同服务于一组特定用户关心的问题。图10-3给出了Java 2的组织形式。更多的关于Java 2的内容将在下面的章节中介绍。作为Java标志性的平台版本，J2EE（Java 2平台企业版）最初于1999年年底发布，并获得了巨大成功。J2EE是一组以EJB为核心的规范，在这些规范之下是由许多不同厂商提供的应用服务器（其中最大的两个厂商是提供WebSphere产品的IBM公司和提供WebLogic产品的BEA公司；到2001年年底，在Flashline.com评测比较表中列出了40个左右的厂商，它们的产品的价格从免费/开放源码到每个CPU 75000美元不等）。微型版本J2ME也相当成功，特别是在用于移动电话的部分，企业版为构件化软件提供了丰富的环境。</p>
<p>除了版本之外，Java 2还区分了运行环境（Runtime Environent, RE）、软件开发工具包（Software Development Kit, SDK）和参考实现。运行环境是Java虚拟机和必须具有的J2SE API的实现。运行环境一般与一个SDK的版本相对应，SDK提供包括编译器和调试器在内的开发工具。容易混淆的是，按顺序为Java 1规范编号的1.x编号被继续用来给Java 2的运行环境和SDK编号。所以，运行环境可以这样提出“Java 2运行环境，标准版，v1.4”。</p>
<p>alt</p>
<p>图10-3　Java 2组织结构</p>
<p>2．运行环境和参考实现</p>
<p>Java运行环境（Java Runtime Environment, JRE）是J2SE平台的一部分，而J2SE本身又是J2EE平台的一个子集。JRE包括运行时刻、核心库和浏览器插件。Sun公司的JRE 1.4参考实现基于HotSpot运行时刻和提供对JIT编译的二进制代码进行在线再优化的HotSpot JIT编译器。单独的HotSpot编译器也有对应客户端和服务器端环境的版本。它们的区别在于根据内存占用历史信息、启动时刻、吞吐量和延时等不同而折中并对目标过程进行优化。Java SDK 1.4在包含Java编译器、调试器、平台调试体系结构API（JPDA）和用于生成文档（javadoc）的工具的同时，也包含了JRE 1.4。图10-4给出了J2SE平台1.4版本的主要结构。</p>
<p>J2EE体系结构概况通过使用专有的构件模型来区分了J2EE支持的范围。JavaBean和它的核心技术可以被用在图中几乎所有的层次。此外，请注意图中的箭头表示了控制流的典型情况，当然，并不完全。数据流一般也沿着同样的路径，但在两个方向都存在。一个底层的用于支持J2EE所有部分的系统是通过JNDI（Java Naming and Directory Interfoce，Java的命名与目录接口）访问的命名和目录的基础结构。另一个集成平台是通过JMS（Java Message Service，Java消息服务）可访问的消息基础结构。在EJB容器的消息驱动构件的帮助下，消息在到来的时候可以触发处理过程。消息和命名/目录是两个重要的集成的层次服务，但也有一些其他的部分，比如事务协作和安全服务。</p>
<p>alt</p>
<p>图10-4　Java 2平台标准版1.4的组织结构（资料来源：java.sun.com）</p>
<p>alt</p>
<p>图10-5　J2EE体系结构概况</p>
<p>10.2.2　JavaBean</p>
<p>JavaBean填补了部分空白，成为一种新的可行的产品——Java构件，我们称之为Bean（Sun, 1996）。不幸的是，Java中类和对象之间明确的区别并没有被贯彻到JavaBean中。尽管一个Bean的确是一个构件（一系列类和其他资源），但是它的那些定制好的连接的实例仍然被称做Bean。这很让人迷惑。因此，我们用Bean来指代构件，用Bean实例来指代构件对象。“Bean对象”将会带来困扰，因为一个Bean通常包含了许多Java对象。</p>
<p>Bean模型主要包括以下几个方面。</p>
<p>（1）事件：Bean可以声明它们的实例是潜在的事件源或者特定类型事件的监听者。一个组装工具能够把事件源和监听者连接起来。</p>
<p>（2）属性：Bean通过成对的getter和setter方法暴露出一系列的属性。这些属性可以用来进行定制或者编程。属性的变化可以触发事件，也可以被事件强制修改。一个受限的属性只有在修改不被禁止的情况下才可以被修改。</p>
<p>（3）自检：一个组装工具能够检查一个Bean，发现这个Bean的属性、事件，以及所支持的方法。</p>
<p>（4）定制：使用组装工具，一个Bean实例能够通过设置它的各种属性来完成定制。</p>
<p>（5）持久化：定制好的、已经连接的Bean实例需要进行保存，以便在应用程序使用它的时候重新装载。</p>
<p>10.2.3　基本的Java服务</p>
<p>经过这些年，Java已经添加了许多标准服务。这一节我们将看到反射、对象序列化，以及Java本地接口。</p>
<p>1．反射</p>
<p>Java的核心反射服务是一个集合体，包括原始Java语言的特性、一套支持类（在JDK 1.1中引入），以及支持类文字的语言特性。反射服务受到活动安全策略的约束，它允许我们：</p>
<p>（1）检查类和接口，包括它们的属性域和方法。</p>
<p>（2）构建新的类实例和新数组。</p>
<p>（3）对象和类的属性域的访问和修改。</p>
<p>（4）数组元素的访问和修改。</p>
<p>（5）对象和类的方法调用。</p>
<p>由此，反射服务涵盖了Java语言的所有特性。Java语言级的访问控制机制，比如域的私有性，被大大增强了（无限制的访问对于实现可信任的底层服务，例如便携式调试器，是很有用的。为了实现这些无限制的访问，Java平台的调试器体系结构提供了一个特别的接口——JPDA（Java Platform Debugger Architecture）。为了进行反射操作，反射服务引入了包java.lang.reflect。</p>
<p>类Field，Method，以及Constructor提供了关于属性域、方法和构造器的反射信息，这些信息由它们描述，并对这个域、方法和构造器进行类型安全的使用。这三个类都是最终的，没有公有的构造器。它们三个都实现了接口Member，这使得我们可以弄清楚成员如何被调用，确定成员的改动及该成员属于哪个类或者接口。</p>
<p>2．对象序列化</p>
<p>在JDK 1.0.2以前，Java都不支持把对象序列化至字节流——仅仅支持基本类型。如果一个应用想把整个对象网写到输出流，它需要使用特别的编码方案来遍历和序列化对象自身。Java对象序列化服务解决了这个问题，它通过定义一个标准的连续编码方案来达到目标，同时提供编码和解码（“序列化”和“反序列化”）对象网的机制。</p>
<p>一个对象能够被序列化，它必须实现接口java.io.Serializable。另外，所有不应该被序列化的域需要用暂时修饰符标记。这一点很重要，因为域可能指向巨大的计算机结构（比如缓存）或者固有绑定到当前JVM的值（比如打开文件的描述符）。对实现Serializable接口的对象而言，足够的信息被写入一个流，以使得反序列化能继续进行，即使使用不同（但是兼容）的类版本。通过实现方法readObject和writeObject，可以进一步控制将哪些信息或者添加更多的信息写入流。如果这些方法没有实现，所有指向可序列化对象的非暂时域将自动被序列化。指向对象的共享引用被保存起来。</p>
<p>3．Java本地接口</p>
<p>Java本地接口（Java Native Interface, JNI）为每一个平台规定了本地调用方式，在Java虚拟机之外我们可以调用本地代码。JNI还规定了这些外部代码如何按照传递过去的引用来访问Java对象。这包括了调用Java方法的可能性。JNI并没有规定Java二进制对象模型——也就是说，它没有规定在一个特定的Java虚拟机中属性如何被访问及方法如何被调用。同一平台上不同Java虚拟机之间的互操作仍然是一个未解决的问题，比如实时编译器这样的边界服务。JNI允许本地方法：</p>
<p>（1）创建、检查和更新一个Java对象。</p>
<p>（2）调用Java方法。</p>
<p>（3）捕捉和抛出异常。</p>
<p>（4）装载类，获得类的信息。</p>
<p>（5）进行运行时刻类型检查。</p>
<p>4．Java AWT和JFC/Swing</p>
<p>Java抽象窗口工具包（Abstract Windowing Toolkit, AWT）和Java基础类（Java Foundation Classes, JFC）提供了一个图形用户接口，这对于任何Java开发都具有重要意义。</p>
<p>基于委托的事件模型——这也许是在JDK 1.1中最富有戏剧性的改变。以前的事件模型基于从构件类的继承及事件管理方法的重载。“基于委托”有一点用词不当，因为它沿用了COM中的术语委托。JDK 1.1事实上提供了一个基于转发的事件模型。对象连接和组装被用来更好地实现继承。</p>
<p>●　数据传输和剪贴板支持：就像COM通用数据传输服务，AWT定义了可传输数据项的概念。Internet MIME（多用途Internet邮件扩展）类型被用来和非Java的应用程序相互作用。Java应用程序之间的数据传输也可以直接使用Java类。</p>
<p>●　拖放：支持在Java和非Java应用程序之间进行拖放（通过连接底层系统的拖放协议，比如Windows中的OLE）。</p>
<p>●　Java 2D：新的2D图形和图片类。Java2D包含了线、文本和图片。支持的属性包括图片合成、Alpha合成（透明化）、精确颜色空间定义和转化，以及面向显示的图像操作。</p>
<p>●　打印：打印模型比较简单。非显式地处理打印的图形构件将使用它们的屏幕透视方法被打印出来。因此，对于简单的构件，打印可以随时进行。然而，打印模型并不处理打印那些需要在多个页面分布的嵌入内容（ActiveX打印模型对此提供了支持，它和容器合作，允许嵌入的内容跨业若干页进行打印。这个是一个复杂的模型，然而只有很少的ActiveX容器真正实现了这个高级打印模型）。</p>
<p>●　可访问性：允许所谓的辅助技术来和JFC及AWT构件交互的接口。辅助技术包括屏幕读取器、屏幕放大器和语音识别。</p>
<p>●　国际化：以Unicode 2.1字符编码为基础，提供了对文本、数字、日期、货币，以及用户自定义对象和当地习惯相适应的支持，使用语言和区域标志符来识别正确的格式。</p>
<p>10.2.4　各种构件——Applet，Servlet，Bean和Enterprise Bean</p>
<p>在Java领域中定义了5种不同的构件模型，而且将来可能会出现更多。这其中不仅包括了Applet和JavaBean模型（J2SE的一部分），还有Enterprise JavaBean，servlet和应用程序客户端构件（J2EE的一部分）。本节将对这些不同的构件模型进行简要地描述。</p>
<p>servlet/JSP和EJB是J2EE服务器端模型的两个关键元素，在下面的论述中将对它们进行更详细的介绍。在J2EE中，所有的构件将被打包成JAR文件，这样J2EE应用就可以将这些JAR文件包含进来。J2EE中的构件都有一个很重要的方面，就是它们都支持部署描述符（Deployment Descriptors）。部署描述符是一个XML文件，和相应的构件一起打包，用来描述这个构件应该怎样进行部署。部署是指根据实际的部署语境将一个构件进行准备的动作，这一步骤可以是，也经常是从安装软件的概念中分离出来的。部署描述符的详细内容依赖于特定的构件模型。例如，一个EJB实体Bean的描述符，就要有容器管理的持久性的描述，以及对EJB实体Bean中的属性到数据库中表的映射的详细描述。</p>
<p>Applet是第一个Java构件模型，用于轻量级的可下载的构件，以增强网站在浏览器中的视觉效果。最初的Applet安全模型非常严格，以致Applet不比eye candy发送得多。eye candy是指在通过别的技术捕捉一个区域，这些技术包括GIF动画、Macromedia Shockwave和Flash技术、JScript、对HTML的增强（包括DHTML（动态HTML）的引入）等。为了充分利用浏览器端技术，绝大多数的基于J2EE的应用均使用servlet和JSP来通过脚本生成HTML页面，而不是通过下载Applet来实现。</p>
<p>第二个Java构件模型是JavaBean。它主要用于支持基于连接的程序，比如同时用在客户端和服务器端的程序。从历史上来说，JavaBean在客户端占比重较大的应用中使用得更广泛，而在服务器端有时候还会被EJB所替代。但这种观点从技术角度上来说是错误的：EJB远远不只是它的名字看上去的那样，和JavaBean的相似之处也很少。当建造一个明确支持可视化应用设计模式的客户端应用时，JavaBean依然是有用的（就像J2SE 1.3中所述，一个Bean也可以是一个Applet。但无论如何，这种支持是有限的——BeanApplet所接受的总是空的Applet语境和存根）。</p>
<p>EJB是Java的第三个构件模型。它使用容器集成服务，用以支持EJB（构件）使用声明属性和部署描述符的方式来请求服务。在最新的修订版中，JavaBean也加入了容器模型，但它的容器模型与EJB容器有很大的不同。前者仅仅是一种容纳的机制，而后者则是一种声明型构造驱动的模式。因为JavaBean不需要在设计时之外与用户交互，所以也可以使用JavaBean来构造更复杂的EJB。（JavaBean和EJB与NET框架中的构件类及被服务的构件类大致对应。）</p>
<p>第四个Java构件模型是servlet。它跟Applet相似，但属于服务器端构件模型，而且是通常由Web服务器进程进行实例化的轻量级构件，Web页面就是一个典型的例子。Java Server Page（SP）是一种与之匹配的技术，能够声明式地定义要生成的页面，然后JSP会被编译成servlet。</p>
<p>J2EE引入的第五种Java构件模型为应用客户端构件。它本质上是在客户端的不受限制的Java程序。一个客户端构件通过用命名语境的JNDI企业来访问J2EE服务器中的环境属性、EJB和各种资源。这些资源可以包括对E-mail（通过JavaMail）或数据库（通过JDBC）的访问。</p>
<p>对Java构件模型不同种类的支持是不同的需求的反映。但无论如何，要在这些不同的领域实际地建立构件市场，还需要在基于领域的概念等方面建立更深入的标准化。现在，只有很少的EJB构件在需要开发它们的系统之外的其他系统中使用。</p>
<p>10.2.5　高级Java服务</p>
<p>本节将介绍Java如何在企业级范围支持分布式计算。实际上Java中有4种模式支持分布式计算——RMI，RMI over IIOP,CORBA和EJB容器（本身是建立在RMI或RMI over IIOP上的）。EJB在前面已经论述了。本章将论述其他的几种，以及一些最重要的支持分布式应用的服务。</p>
<p>1．分布式对象模型和RMI</p>
<p>分布式计算主要由对象序列化服务和远程方法调用（Remote Method Invocation，RMI）服务支持。这两种服务都是在JDK 1.1引入的。下面的章节介绍RMI和RMI over IIOP，它们有细微的差别。</p>
<p>一个分布式对象的句柄为一个接口类型的引用——它不能指向一个remote对象类及其超类。能够远程访问的接口必须直接或间接从java.rmi.Remote继承下来。一个远程操作可以由于网络或远程硬件故障而失败。remote接口的所有方法都要声明检查java.rmi.Remote Exception异常。将参数传给远程操作很有意思，如果一个参数是remote接口类型，那么就是按引用来传，其他类型则按值来传——这就意味着，参数将在调用端序列化，在调用remote接口方法的时候反序列化。Java对象不需要序列化。如果企图传一个无法序列化的对象将会抛出运行时刻异常。如果语言规定使用Java RMI，那么编译器可以静态地规定只有可序列化对象可以通过值来传送，而且所有的方法都声明Remote Exception异常。</p>
<p>Java分布式模型扩展了垃圾回收。它将所有有远程引用指向它们的对象都记录下来，这样就可以支持分布式的垃圾回收了。回收器是基于Network Object（Birrel，1993）的工作的。分布式垃圾回收是RMI比当今其他模型出色的一点。唯一的另外一种基于Network Object的和有租用引用思想的就是CLI remoting，但这种方法的提出比JavaRMI晚了四年。</p>
<p>2．Java和CORBA</p>
<p>一个OMG IDL到Java的绑定和OMG最先给出的Java到OMG IDL的绑定，是1998年在CORBA 2.2中定义的。将CORBA包含在Java项目的一个重要原因是能用ⅡOP和非Java系统通信。为了能访问CORBA服务，通常使用Java规范定义的接口会更方便，这些接口能够映射到兼容CORBA或其他服务。</p>
<p>3．企业级服务接口</p>
<p>J2EE的重要部分就是一些适合于企业级服务的接口。这些服务接口也可以通过CORBA来建立。然而，Java-CORBA的集成必然会引起一些冲突。与此相反，在本节讨论的以Java为中心的接口，从客户和实现者的角度来减小这些不足。</p>
<p>1）Java命名和目录接口（JNDI）</p>
<p>在计算系统中的一个全局性问题就是通过名字或属性来定位服务的问题。命名服务针对前一个问题，目录服务针对后一个。命名服务的例子包括Internet域名服务（DNS）、RMI注册表和CORBA命名服务。目录服务的例子包括兼容LDAP的目录系统，比如Novell的eDirectory、微软的Active Directory和开放源码的OpenLDAP（<a target="_blank" rel="noopener" href="http://www.openldap.org)./">www.openldap.org）。</a></p>
<p>JNDI为命名服务（javax.naming）和目录服务（javax.naming.directory）提供了统一的API。Context这个最普遍使用的接口使命名语境对lookup方法有效，使用这个方法就可以根据名字来定位对象了。一个命名语境也可以用来对绑定在某个语境中的名字进行列表，或者是解除一个绑定，或是创建或删除一个子语境。</p>
<p>EJB的Bean的一个重要的命名语境就是EJB容器提供的环境命名语境（Environment Narning Context, ENC）。通过它可以访问环境属性、其他Bean和资源。接口DirContext扩展Context来提供目录功能，包括检查和更新与目录上列出的对象相关联的属性，以及通过值来搜索一个目录语境。因为DirContext是从Context继承而来的，所以一个目录语境也是命名语境。绝大部分的语境是通过对其他语境的递归查找而找到的。而查找的起始点就是通过初始化InitialContext这个类得到的。</p>
<p>JNDI也定义了一个事件API（javax.naming.event）、一个支持LDAP v3的超过DirContext的功能，以及一个能够使命名和目录服务的提供者与JNDI连接起来的服务提供者接口（javax.naming.spi）。事件机制用来为改变通知进行注册。J2SE 1.4内置了4种服务提供者——CORBA命名、DNS、LDAP和RMI。</p>
<p>2）Java消息服务（JMS）</p>
<p>异步消息是将实例的操作和覆盖的组装模型通过消息进行通信。基于事务的消息队列建立的可靠性级别，正常情况下需要基于同步调用的模型。灵活的消息路由、广播和过滤增强了灵活性。JMS是Java对消息系统的访问机制，但它本身并不实现消息。</p>
<p> $\color{red}{\text{JMS}}$ 支持点对点分发的消息队列，也支持多个目标订阅的消息主题。当消息发布给一个主题的适合，消息就会发送给所有那个主题的订阅者。JMS支持各种消息类型（二进制、流、名—值表、序列化的对象和文本）。通过声明与SQL的WHERE相近的句段，可以建立消息的过滤器。</p>
<p>3）Java数据库连接（JDBC）</p>
<p>JDBC是根据流行的微软ODBC（Open DataBase Connectivity，开放数据库连接）标准建立的一个通用的与数据库交互的方法。JDBC API分成核心API（在java.sql包和J2SE的一部分中）和JDBC可选包（在javax.sql包中，J2SE可选但J2EE必须遵循）。JDBC像ODBC一样，需要驱动程序将JDBC API映射到特定数据库的本地接口。</p>
<p>JDBC驱动程序有4种。Type 1和Type 2驱动通过JNI来使用本地代码（非Java代码）。Type 1驱动使用具有通用接口的本地代码，而Type 2允许使用数据库特定的接口。最普遍的Type 1驱动就是JDK包含的JDBC-ODBC桥，它将JDBC调用映射为ODBC调用。因为ODBC是用字句的驱动模型来访问特定的数据库，因此这种方式相对会慢一些。Type 3和Type 4驱动都是纯Java的。Type 3通过网络协议和数据库网关来间接地访问数据库，Type 4则是直接访问数据库。驱动程序的选择不会影响客户的代码，因为JDBC API本身是不受驱动影响的。对于性能来说，Type 4通常是最好的，接下来是Type 2，再接下来是Type 1，最后是Type 3。</p>
<p>4）Java事务API和服务（JTA, JTS）</p>
<p>事务管理常常是由EJB容器来委派的，但有些情况还需要显式的事务管理。CORBA对象事务服务（OTS）或者它的Java实现（Java Transaction Service, JTS）可以用于这个目的。然而，EJB中有一个更为简单的接口，称为Java事务API。它是服务器/容器的实现使用的低级XA接口（X/Open事务API接口标准）和EJB Bean的实现可以访问的高级客户端接口。</p>
<p>在JTS（或OTS）中，需要显式地和仔细地使用事务中的资源，这样，这个显式的对事务的划分会形成一个边界。高级JTA（Java Transaction API）接口，这个容易出错的功能是由EJB容器来完成的。然而，由于资源由长事务所掌握，显式的事务管理仍然是很容易出错的，并且将引起不一致或效率低下。</p>
<h5 id="J2EE连接器架构（JCA）"><a href="#J2EE连接器架构（JCA）" class="headerlink" title="J2EE连接器架构（JCA）"></a>J2EE连接器架构（JCA）</h5><p> $\color{red}{\text{JCA标准化连接}}$ 是由J2EE 1.3首先提出的，它位于J2EE应用服务器和企业信息系统（Enterprise Information System, EIS）之间，比如数据库管理、企业资源规划（ERP）、企业资产管理（Enterprise Asset Management, EAM）和客户关系管理（CRM）系统。不是用Java开发的企业应用或者在J2EE框架内的应用都可以通过JCA连接。JCA是在javax.resource包和它的子包（cci, spi和spi.security）中定义的（JCA的形式也用于Javacryptography API的缩写）。</p>
<h5 id="Java和XML"><a href="#Java和XML" class="headerlink" title="Java和XML"></a>Java和XML</h5><p>Sun是XML的一个早期提倡者。然而，最初Java对XML的支持只是限定在定义能够处理XML文档的接口，能够表示XML文档（Document Object Module, DOM）和XML流（Sinple API for XML, SAX）的模型。而更多对XML支持，包括对XML Schema和Web服务标准的支持已经作为预发布版本，在2002年初加了进来。</p>
<h4 id="Java和Web服务——SunONE"><a href="#Java和Web服务——SunONE" class="headerlink" title="Java和Web服务——SunONE"></a>Java和Web服务——SunONE</h4><p>SunONE（Sun开放网络环境）是J2EE的扩展，它可以通过特殊的servlet来处理Web服务协议。SunONE也包含了以前由iPlanet策划的J2EE服务器产品。（注意：Netscape公司和Sun公司组建的iPlanet联盟在2002年年初已经结束了，并把iPlanet开发的产品留给了Sun公司。在2002年年初，iPlanet在J2EE的市场份额中占7％，排名在它之前的是IBM公司的WebSphere和BEA公司的WebLogic（各占34％），紧随其后的是Oracle公司（占6％）。随着在2002年年初Java Web服务开发包（JavaWSDP）可用版的发布，Sun公司对SOAP、WSDL、UDDI都提供了支持。JavaWDSP包括了Java为XML消息处理（Java API for XML Messaging, JAXM）、XML处理（Java API for XML Processing, JAXP）、XML注册（JAXR）和基于XML的RPC（JAX-RPC）提供支持的API。另外它还包括JSP标准标签库（Java Server Pages Standard Tag Library, JSTL）、Ant创建工具、Java WSDP登记服务器、网络应用工具，以及Apache Tomcat网络服务器容器。</p>
<h3 id="Microsoft的方式"><a href="#Microsoft的方式" class="headerlink" title="Microsoft的方式"></a>Microsoft的方式</h3><p>从某种意义上讲，微软选择的是最简单的路线。它没有提出一整套标准，并期望依此改变自己的系统。相反，它不断地对已有的应用和平台基础进行再工程。构件技术是渐进引入的，这就可以获益于以前的成功技术，例如，Visual Basic控件（VBX，一种不是面向对象的构件！），对象链接和嵌入（OLE），OLE数据库连接（ODBC），ActiveX，微软事务服务器技术（MTS），以及主动式服务器端页面技术（ASP）。</p>
<p>在技术标准的领域里，微软的主要兴趣放在Internet标准（Internet Engineering Task Force, IETF）和Web标准（W3C）上。最近，它的.NET规范的一部分被ECMA（European Computer Manufacturers Association）组织采纳。ECMA是欧洲的一家标准化组织，它被视为通向ISO的捷径（参见ECMA, 2001a, 2001b）。微软并未试图让自己的方法与OMG或Java标准保持一致。尽管Java曾在微软的战略中扮演过一段重要角色，它目前的地位却已不高，而仅仅是为了继续支持一项较老的Visual J++产品。这其中有一部分是解决Sun公司和微软公司争讼所带来的后果。而且，微软还重点瞄准使用Visual J++6.0的用户，靠着Visual J#.NET的名称，推出一个向.NET迁移的工具。</p>
<p>作为.NET计划的一部分，微软正在推动语言无关性，把它作为CLR的一条主要原则，并构造了一种新的语言C#。C#吸纳了Java的很多成功特性，另一方面，它又新增若干独有的特征（例如值类型），且不支持某些关键的Java特征（例如内部类）。C#虽然定位于CLR的模型语言，但它与若干其他语言占有同等地位，包括被全面革新过的Visual Basic .NET, Managed C++（对C++的扩展，它与ANSI兼容），以及许多被其他供应商或组织支持的语言。</p>
<p>在依赖语境的组装方面，微软、OMG和Sun这些公司技术之间的螺旋演进很有意思。依赖环境的组装最先在COM套间模型被粗略描述，又在微软事务服务器（Microsoft Transaction Server, MTS）中被丰富，在被Enterprise JavaBean采纳和改进的同时它又在COM+技术中独立地发展，后来被CORBA构件模型（CCM）采纳和改善，最后，它变为CLR中的一项可扩展的和开放的机制，与此同时，EJB 2.0的发展超越了意欲成为各项技术超集的CCM，这意味着CCM规范进入了“维护阶段”。</p>
<p>COM可能在未来多年内仍很重要，而且，CLR与它的互操作能力格外强。鉴于此，下面对微软方法的讨论就以COM介绍开始。COM+在COM基础上新增了服务，CLR的首次发布是使用COM互操作来提供COM+服务的，因此，许多服务并非冗余。</p>
<h4 id="第一个基础关联模型——COM"><a href="#第一个基础关联模型——COM" class="headerlink" title="第一个基础关联模型——COM"></a>第一个基础关联模型——COM</h4><p>COM是微软平台上所有构件的基石，微软还将之在Macintosh系统实现。在其他的许多平台，COM也被诸如Software AG、惠普这样的第三方厂商实现。即便如此，可以说，COM从未在微软的Windows平台之外赢得更多支持。但是，COM的基本理念却有着相当的影响力。</p>
<p>COM所定义的一个基础实体是接口。在二进制层面上，一个接口被表示为指向一个接口结点的指针。而一个接口结点唯一被指定的部分是置于其内部第一个域的另一个指针，这个指针指向一个过程变量表（或者说，函数指针表）。这些表源自C++等语言用来实现虚函数（方法）的表，因此，也被称做vtable。图10-6所示为二进制层面的一个COM接口。</p>
<details><summary>图10-6　COM接口的二进制表示</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082436.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082436.png';" /></details>


<p>表示COM对象的通常方法是将其画成带有插口的盒子。由于每个COM对象都有IUnknown接口（它标志着COM对象），通常把IUnknown接口置于COM对象图的顶端。图10-7所示为COM对象图，这里是一个ActiveX文档对象。</p>
<details><summary>图10-7　COM对象描述</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082452.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082452.png';" /></details>

<p>回到IUnknown接口。它的“真实”名字当然是它的IID，即00000000-0000-0000-C000-000000000046。但为了方便，所有接口也有一个可读名。根据习惯，可读接口名以字母I开头。与IID不同，可读名并不保证是唯一的。因此，编程中的接口引用均使用IID。</p>
<p>IUnknown接口的首要用途是在最抽象的情况下标志COM对象，此时COM对象没有任何特殊功能。因此，IUnknown接口的引用可被用来和ANY类型的引用或面向对象语言的Object引用比较。从某种意义上，IUnknown用词不当。它并不是一个未知的接口，相反，它是唯一能被保证永远存在的接口。对于一个没有别的已知接口的COM对象，它被获知的唯一途径就是通过IUnknown接口的引用。</p>
<p>IUnknown接口只提供对任何COM接口都必须的三个强制性方法。第一个强制性方法是QueryInterface，前面已提及。另两个强制性方法名为AddRef和Release。结合关于何时调用的规则，这两个强制性方法被用来控制对象的生命周期。后面会有更多解释。使用类似COM IDL的表示法，IUnknown可被定义为：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082516.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082516.png';" /></details>

<p>类型HRESULT被大多数COM接口的方法用来表示调用的成功或失败。QueryInterface则用它表明查询的接口是否被支持。如果接口属于一个远程对象，HRESULT也可能表示网络错误。</p>
<p>每个COM对象都会进行引用计数，或者是对整个对象体，或者是对每个单独的接口结点。引用计数变量被共享使用的情况下，COM对象不能释放接口结点，即使这个结点已经没有引用。一般来说，这样做没有问题。而共享一个引用计数变量也是通常的做法。可是，某些情况下，接口结点会占据很多资源，例如当它们保留着一个大缓冲结构时。对于这类接口结点，可以使用独立的引用计数变量，以便结点可以尽早释放。这种根据需要创建和删除接口结点的技术有时被称做“快速装卸接口（Tear-Off Interface）”。</p>
<p>当对象或结点被创建，其第一个引用被传出之前，引用计数变量会初始化为1。之后，每逢一个引用复制被创建，计数值必须增加（AddRef）；每逢一个引用被丢弃，计数值必须减少（Release）。在引用值变成0的瞬间COM对象无法被访问，因此它就该自行销毁。销毁工作的一部分是通过调用Release方法释放对其他对象的引用。其后果是，被正待销毁对象引用的所有对象都会被递归销毁。最终，被销毁的对象释放它所占有的内存空间。</p>
<h4 id="COM对象重用"><a href="#COM对象重用" class="headerlink" title="COM对象重用"></a>COM对象重用</h4><p>COM不支持任何形式的实现继承。注意，COM没有定义或考虑单独的构件从内部如何去实现。构件可以由使用了实现继承的类组成。无论何种情况，缺少实现继承并不意味着缺少对重用的支持。为实现对象重用，COM支持两种形式的对象组装：包含（Containment）和聚集（Aggregation）。</p>
<p>包含就是一种简单的对象组装技术，其含义是一个对象拥有指向另一个对象的唯一引用。从概念上来说，前者（称做外部对象）“包含”后者（称做内部对象）。外部对象只是把请求转发给内部对象。所谓转发，就是调用内部对象的方法，以实现对某个外部对象方法的调用。</p>
<p>包含能重用内含于其他构件的实现。特别是，对于使用外部对象的客户程序，包含是完全透明的。调用接口函数的客户无法辨别调用是由提供接口的对象处理，还是被转发给另一个对象处理。如果包含层次较深，或者被转发的方法本身相对简单，包含会存在性能上的问题，因此COM定义第二类重用形式，即聚集。聚集的基本思想很简单，直接把内部对象的接口引用传给外部对象的客户，而不再转发请求。对此接口的调用将直接到达内部对象，从而省去转发的代价。当然，只有在外部对象不希望截取调用以执行诸如过滤等额外处理时聚集。还有，保持透明性是很重要的，因为外部对象的客户无法辨别哪个特定接口是从内部对象聚集而来的。</p>
<h4 id="接口和多态"><a href="#接口和多态" class="headerlink" title="接口和多态"></a>接口和多态</h4><p>COM接口可通过（单）接口继承从其他COM接口中派生。实际上，所有COM接口都直接或间接地继承了Iunknown，它是接口体系中的公共基类型。除了Iunknown外，只有Idispatch和Ipersist这两种重要的基接口被公共继承。COM中接口继承为什么如此鲜为使用呢？</p>
<p>令人吃惊的是，COM的接口继承与其支持的多态无关。例如，假定客户持有一个接口，比方说IDispatch的引用。实际上，客户引用的接口可以是IDispatch的任何子类型。换句话说，函数表可以包含IDispatch所需之外的方法。但重要的是，客户无法发现这一点。如果客户想要更特殊的接口，必须使用QueryInterface。这样就能保证获得更多的方法，至于返回的接口结点实际上是否就是QueryInterface被调用发出的那个结点，对客户来说没有关系。</p>
<p>接口和版本化。一旦公布，COM接口和它的规范不允许以任何形式改变。这种避免的方法既解决了语法问题，也解决了语义上的脆弱基类的问题。换言之，COM中的IID可用于标志接口中的版本。因为接口总是通过IID被请求的，系统中的所有参与者都对接口的版本达成一致。CORBA讨论中所提及的传递性版本冲突问题在COM中不会发生。</p>
<p>构件可以选择实现接口的多个版本，只不过处理方式就像处理任何别的不同接口一样。使用这种策略，基于COM的系统能并发支持旧接口和新接口，同时允许渐进的迁移。在某些系统中，由单个对象实现的多个接口被合并成单个类的命名空间，类似上述的策略实现起来就变得困难，或至少不自然。对于建立在传统对象模型（像Java或CORBA）之上的方法，这会给二进制兼容性带来问题。CLR避免此问题的方法是，在相同的类实现的不同接口上，允许分别实现具有相同名字和签名的方法。除此之外的其他方面，CLR还是基于传统对象模型。</p>
<h4 id="COM对象的创建和COM库"><a href="#COM对象的创建和COM库" class="headerlink" title="COM对象的创建和COM库"></a>COM对象的创建和COM库</h4><p>创建对象的最简单方法是调用CoCreateInstance（所有COM库的过程名以Co起头，它代表COM）。此函数需要一个CLSID和一个IID，然后创建指定类（CLSID）的新实例，并返回所请求类型（IID）的接口。如果COM无法定位或启动能实现所请求CLSID的服务器，或者指定的类不支持所请求的接口，就会返回错误提示。</p>
<p>创建COM类的实例对象时，COM需要把给定的CLSID映射为包含所请求类的实际构件。为此目的，COM支持系统注册器，它类似CORBA存储器。注册器指明哪些服务器是可用的，它们支持哪些类。服务器可以是进程内（inprocess）服务器、本地服务器和远程服务器这三种类型中的一种。进程内服务器支持存在于客户进程中的对象；本地服务器支持的对象位于客户所在的机器上，但在不同的进程内；远程服务器支持的对象位于不同的机器上。</p>
<p>CoCreateInstance接受一个额外的参量，用于指定何种服务器是可接受的。CoCreateInstance查询注册器以定位服务器。若服务器尚未被激活，就载入并启动它。对于进程内服务器，需要载入和链接动态链接库（DLL）。而对于本地服务器，独立的可执行文件会被载入。最后，对于远程机器，会联系远程机器上的服务控制管理器，以载入并启动该机器上的服务器（以中间件观点看，SCM起着类似CORBA ORB的作用）。</p>
<p>COM服务器具有定义好的结构，包含一个或多个类，对每个类它又实现一个工厂对象（在COM里，工厂对象被称做类工厂。这个名称可能让人误解，因为工厂创建的不是类，而是类的实例）。工厂是支持IClassFactory或IClassFactory2接口的对象，使用后一个接口意味着需要许可机制。COM使用工厂的原因是，COM对象不一定是简单的单体对象（single-object），因此其创建需要由其构件而非系统提供的服务来指定。</p>
<p>图10-8含两个coclasses的COM服务器，每个都有一个工厂。启动时，自注册服务器为每个类创建一个工厂对象，并将之注册到COM。CoCreateInstance使用工厂对象创建实例。为了提升性能，客户也可以使用CoGetClassObject获得对工厂的直接访问。在需要创建许多新对象时，这种做法较有用。很多时候，客户所要的不是具体的类，而是更一般的东西。例如，客户并不使用对应Microsoft Word的CLSID，而是使用对应rich text的CLSID。为了支持这种一般性CLSID和相应的配置，COM允许一个类仿真另一个类。仿真配置保存在系统注册器里。例如，某个仿真项也许会指定类Microsoft Word仿真类rich text。</p>
<h4 id="从COM到分布式COM（DCOM）"><a href="#从COM到分布式COM（DCOM）" class="headerlink" title="从COM到分布式COM（DCOM）"></a>从COM到分布式COM（DCOM）</h4><p>COM透明地扩展COM的概念和服务。DCOM中已存在客户端代理（Proxy）对象和服务器端桩（Stub）对象，它们只被用于支持进程间通信。DCOM建立在这两者的基础上，在前面谈到远程服务器时已暗示过DCOM服务。</p>
<p>为支持跨进程或跨机器的透明通信，COM在客户端创建代理对象，在服务器端创建桩对象。为了单个机器内进程间的通信，代理和桩需要实现的，仅仅是从简单数据类型到字节流和从字节流到简单数据类型的映射。因为发送和接收进程在同样的机器上执行，所以不需要担心数据类型是如何表达的。而当接口引用被传递时，尽管仍在相同机器的不同进程间，情况也会变得稍微复杂些。</p>
<details><summary>图10-8　一个COM服务器支持两个各带工厂的COM类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082642.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082642.png';" /></details>

<p>跨进程传递的接口引用需要被映射为对象引用，它的意义在穿过进程时仍能维持不变。当接到对象引用时，COM需要确定对应的代理对象存在于接收端。然后，COM选择该代理的对应接口，并传送这个接口引用而非先前的那个接口引用。先前的引用会指向“错误”进程的接口。</p>
<p>图10-9显示了客户向对象A发出一个调用。被调用的方法只有一个参量，它引用对象B的一个接口。由于对象A位于另一进程，本地代理对象中转此调用。代理决定对象B的对象标志符（OID）和被传递接口的接口指针标志符（IPID）。OID和IPID一起随着客户进程ID被传递给服务器进程的桩。桩使用OID定位对象B的本地代理，使用IPID定位具体的接口。接着，桩代表客户发出先前的调用，它将本地B代理的接口引用传给调用接受者——对象A。</p>
<details><summary>图10-9　单机上进程间接口引用的编排与起源</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082659.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082659.png';" /></details>

<p>DCOM所用的方法相当近似。有两点不同，在不同机器上数据类型的表达可能是不一样的，并且对象引用需要包含比OID和IPID更多的信息。为了解决数据表达的差异，DCOM将数据整理成平台无关的网络数据表达（NDR）形式。为了形成与机器无关的对象引用，DCOM将OID、IPID和那些足以定位对象输出器（Object Exporter）的信息结合在一起。对象输出器是DCOM提供的对象，它知道如何绑定服务器公布的对象。每个对象输出器有唯一的标志符（OXID），它被包括在对象引用中。</p>
<h4 id="复合文档和OLE对象"><a href="#复合文档和OLE对象" class="headerlink" title="复合文档和OLE对象"></a>复合文档和OLE对象</h4><p>链接和嵌入是微软的复合文档标准。创造OLE的原本意图是为了将各以应用为中心的遗留程序融合成单一的以文档为中心的范型。也有可能创建只存在于OLE环境中的对象，ActiveX就是最好的例子。然而，OLE也继续用变化的OLE集成程序来支持独立的应用。这种实用化的一面使很多OLE技术非常复杂。然而，可以按平滑的路径进行技术迁移，以保护在开发和用户培训方面的投资，这样就可以保住客户。</p>
<p>如同COM之上的每项技术，OLE可被概括为一组预定义的COM接口。OLE所需的几项关键技术由COM服务提供。这包括结构化存储、绰号、包含拖放的统一数据传输、可连接对象和自动化支持。</p>
<p>OLE复合文档的方法对文档容器和文档服务器进行区分。文档服务器提供某种内容模型和显示、操作内容的能力。文档容器没有自己的内容，但可以接受任意文档服务器提供的内容成分。许多文档容器也是文档服务器，这即是说，它们支持外来的成分，同时也有自己的内容。大多数流行的“重家伙”，像微软的Office应用（如Word、Excel和PowerPoint等），是结合为一体的服务器和容器。例如，Excel有自己的内容模型，它是按照电子数据表排列的数据和公式单元。Excel也是容器，作为容器，它能接受所插入的Word文本对象。</p>
<h4 id="NET框架"><a href="#NET框架" class="headerlink" title=".NET框架"></a>.NET框架</h4><p>.NET框架是更大的.NET空间的一部分。它包含的内容有通用语言运行环境，许多部分接口化和基于类的框架（被打包成配件），以及许多工具。CLR是通用语言基础设施规范的实现，它增加了COM+互操作和Windows平台访问服务。特别地，CLR提供了动态载入和卸载、垃圾回收、语境截取、元数据自省、远程化、持久性，以及其他完全和语言无关的运行时刻服务。目前，微软在CLR上支持4种语言：C#、JScript、ManagedC++和Visual Basic .NET。</p>
<p>配件（Assemblies）是.NET中部署、版本控制和管理的单元，也就是说，它们是.NET的软件构件。“并排”使用同一配件的多个版本是完全可以的。配件包含元数据、模块和资源，所有这些以平台无关的方式被表达。模块中的代码以CIL（通用中介语言）表达，CIL大致像Java、Smalltalk的字节码，或者Pascal P码。与早期字节码格式不同，配件中使用的语言不重视解释。MSIL（微软中介语言）是与CLI兼容的超集，它带有支持CLR互操作特性的指令，这些特性就在CLI规范之外。CLR在安装或者载入时被编译，执行的始终是本地码。CLR自省和其他基于类型的概念覆盖了很大的类型系统空间，此空间被称做CTS（通用类型系统）。</p>
<p>下面涵盖了各种与.NET框架相关的技术细节。</p>
<h5 id="NET大图景"><a href="#NET大图景" class="headerlink" title=".NET大图景"></a>.NET大图景</h5><p>微软公司的.NET计划的目标是，将范围广泛的微软产品和服务组织起来，置于各种互联设备共同的视野范围内，这些设备包括服务器、固定和移动PC及特殊设备。在技术层次，.NET瞄准如下三个层面。</p>
<p>（1）Web服务。</p>
<p>（2）部署平台（服务器和客户机）。</p>
<p>（3）开发平台。</p>
<p>Web服务想达到因特网的传递式可编程性（这就不仅仅是传统意义上瞄准人类客户的Web了，它应包括支持Web服务的构造、定位和使用的因特网和Web的标准和建议）。为启动Web服务空间，微软公司计划推出许多基础的核心服务。第一个这样的服务已推出一段时间，它就是用于验证用户的.NET护照。另一个是.NET警报，它在2002年早期被应用。它是通用警报服务，在引入时是通过Windows信使发送警报的。作为.NET MyServices和其他计划的一部分，微软公司公布了更多的服务，例如用于存储的服务。从各式服务器产品和Windows.NET服务器开始，微软平台正在经过一系列步骤被转变，以便以本地和有效的方式支持、使用Web服务和处理XML。</p>
<p>最后，也是本章的焦点，会有新的开发平台，它包含CLR、框架和工具。CLR提供了新的构件基础设施，可以（但不是必须）为构件屏蔽底层硬件平台的细节。类似JVM，CLR定义了一套脱离具体处理器的指令集。与JVM不同的是，CLR还支持需要和特定底层平台紧密集成的构件。</p>
<h5 id="通用语言基础设施"><a href="#通用语言基础设施" class="headerlink" title="通用语言基础设施"></a>通用语言基础设施</h5><p>通用语言基础设施规范由微软公司、英特尔公司和惠普公司联合提交给ECMA，它建立了类似CORBA的语言中性平台。可是与CORBA不同，CLI也定义了中介语言（Intermediate Language, IL）和部署文件格式（配件），例如Java字节码、类和JAR文件。与CORBA和Java不同，CLI支持可扩展元数据。通用语言运行环境是微软.NET框架的一部分，它是微软公司对CLI规范的实现。CLR超出了CLI兼容的范围，它包括对COM和平台互操作的支持（细节参见下个小节）。CLI包括了执行引擎服务的规范（例如载入器、JIT编译器、起垃圾回收作用的内存管理器）、通用类型系统（Common Type System, CTS）和通用语言规范（Common Language Specification, CLS）。CTS和CLS起着互补的作用，CTS范畴是许多语言在类型空间的核心概念的超集。与CLI兼容的代码能够在整个CTS空间运行。可是，没有哪两种语言能精确覆盖相同的CTS子集。以不同语言实现的代码要互操作，CLS空间就显得有用。CLS是CTS的严格子集，它被构建的方式使许多语言都完全覆盖它。特别地，若某个定义是与CLS兼容的，那么任何被归为CLS消费者的语言均能使用该定义，这是CLI目标语言中最简单而有用的一类。能在CLS空间引入新定义的语言称做CLS生产者，能扩展CLS空间已有定义的语言称做CLS扩展者。CLS扩展者也总是CLS生产者，CLS生产者也总是CLS消费者。CTS为所有类型定义了单根类型——System.Object。Object之下，CTS区分了值类型和引用类型。所有值类型是System.ValueType的单态子类型，它本身又是System.Object子类型。引用类型被分成接口、类、数组和代理（技术上，接口被建模为CTS中特殊的类），其中的类被分成按值排置（Marshal-by-value）和按引用排置（Marshal-by-reference）两种。按引用排置又被分成随环境变化和与环境绑定两种。从图10-10可看到CTS类型体系的概况。</p>
<details><summary>图10-10　顶层CTS类型层次</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082824.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082824.png';" /></details>

<p>原始类型是没有的，因此，诸如整型或浮点等类型只是预定义的值类型。多个接口和单个类继承关系是被支持的，甚至值类型也能继承（实现）多个接口。访问权限从两个方面被控制，即定义点和使用点是否位置相同，以及定义点和使用点是否通过类继承而相关。为了前者，区分了三种位置范畴：类、配件和全局。因此，访问权限关系有6种可能的约束组合，但大多数语言支持的只是其子集。例如，C#不支持把protected访问权限定义在小于全局的范畴上。某些语言，像Managed C++，则支持所有组合。</p>
<p>方法可以是静态的、与实例绑定的或者虚拟的（虚拟也暗示着是与实例绑定）。对重载的支持要依靠方法名、签名，但没有返回类型。重载的解析策略依语言而定（因此，CLI自省机制引入了自己的重载解析策略）。</p>
<p>类能实现多个接口，并可以用引入的接口名修饰方法名。因此，能够在相同的类上实现两个接口，即使它们包含具有相同名字和特征的方法，但这两个方法应以不同的方式实现。例如，C#完全支持显式地实现接口方法的概念。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082843.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082843.png';" /></details>

<p>尽管上面的cowboy/shape例子被广为使用，但实际上它没有包含一个重要情况：偶然的名字冲突会发生这个问题。然而，重要得多的是这样一个例子：发布新的接口版本时还希望能并排支持多个构件。图10-11显示了类C应该如何实现版本1的接口I和版本2的接口I，以便和类A和B正确交互，此二者都需要接口I，只是版本不同。CTS把所有的名字定义锚定在包含它们的配件的名字里。因为配件的名字包含了版本信息，接口I的两个版本实际上可以被区分开，不过它们的方法名还有可能冲突。CTS支持在同样的类上实现接口的两个版本，这是支持并排使用配件多个版本的重要步骤。</p>
<details><summary>图10-11　一个接口不同版本的并行实现</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082856.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082856.png';" /></details>

<p>各种方法命名规范，例如属性和索引器的取值—设值方法，也是CTS的一部分。定义这些规范的目的是支持跨语言互操作，而没有考虑对各种语言中传统命名的特性的显式支持。例如，对于C#属性Foo，对应的访问方法被称做get_Foo和set_Foo。C#不允许直接使用这些方法名，但其他不直接支持属性的语言就可以调用这些方法来访问属性。</p>
<p>可抛出异常不是CTS方法特征的一部分。与Java和C++不同，CTS没有规定调用方法时要静态检查可抛出的异常。语言仍可以在它们自己领域内自由执行这类检查。没有哪两种语言对声明和检查的语义能达成完全一致，这使得跨语言检查没什么用处，即便CTS曾支持注释。</p>
<h4 id="COM和平台的互操作"><a href="#COM和平台的互操作" class="headerlink" title="COM和平台的互操作"></a>COM和平台的互操作</h4><p>CLR能真正支持与COM的互操作，并能直接访问底层平台（即Win32和其他基于DLL的API）。通过整合对COM互操作和平台调用的支持，CLR执行引擎能提供几乎最优的性能。例如，平台调用通过JIT被编译为本地代码序列，它实际上和传统编译的代码是等同的。COM互操作是通过提供两类自动合成的包装达到的。一种是COM可调用包装，它通过COM接口来呈现CLR对象；另一种是运行环境可调用包装，它通过CLR接口呈现COM对象。</p>
<p>为了和COM互操作，CLR工具可被用来创建互操作配件，这些配件定义的类型和COM类型库定义的类型相匹配。被多个.NET应用共享的CLR配件必须有唯一的强名字，这对COM互操作有微妙的影响。正是这点使多方可能为相同的COM接口（相同的IID）产生互操作配件。然而，得到的互操作配件会公布相互不兼容的类型，尽管所有这些类型对应着有相同IID的相同COM接口。为避免此种情况，定义了主互操作配件（Primary Interop Assemblies, PIA）。PIA应由COM接口（IID“所有者”）的发布者产生。如果得不到PIA，可以产生替代的互操作配件，只是它的类型只能在配件内部使用。把这些类型公布在新的配件特征中，最终会导致与其他配件的不兼容，它们或者依赖PIA，或者将自己的依赖公布于另一个替代的互操作配件。</p>
<p>尽管COM表面简单，但是COM互操作却是微妙而复杂的。原因是，COM调用规范的细节（包括分派接口），排置规范（包括由谁分配或释放的规则），以及对底层不安全类型的支持（包括指向大小未知的数组的指针）。远程化接口（DCOM代理能自动生成的接口）更容易处理，因为代理需要的是和CLR包装所需大致相同的信息。不幸的是，DCOM给自己带来了麻烦——类似[call_as()]属性的IDL注释只有过程意义，不能被自动解释，以产生合适的CLR包装。</p>
<p>奇怪的是，若接口被限制为“同构类型”（此类型在穿过CLR/COM边界时无需变换），调用代码中的COM方法时，其开销大约只有50个指令周期。</p>
<h3 id="战略比较"><a href="#战略比较" class="headerlink" title="战略比较"></a>战略比较</h3><p>迄今为止，讨论过的每个方法都已给出了丰富的技术细节，那么它们有什么显著的区别和基本的共同点呢？战略上的后果又是什么呢？</p>
<h4 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h4><p>很明显，所讨论过方法的共性不能帮助决定应该遵循哪一种方法。然而不管具体的方法是什么，这些方法的共性有助于我们做出使用构件化软件技术的决定。对这些共性的理解还可以避免一些没有意义的争论，这些争论的产生是因为把一些次要问题简单地误解为主要的不同点了。</p>
<p>所有的方法都依赖于延后绑定机制、封装和动态多态性（也被称为包含多态性或者子类型化）。除了COM之外，其他方法都支持接口继承（COM中的多态性来源于接口及类的分离及每个类的多接口支持）。换一个说法就是，所有的方法都依赖于某种类型的对象模型。</p>
<p>另外，随着时间的推移，这些方法互相取长补短。大多数的方法目前支持：</p>
<p>（1）一种构件传输格式——JavaJAR文件、COMcab文件、CCM:-、CLI配件。</p>
<p>（2）统一方式的数据传输。</p>
<p>（3）事件和事件连接或者信道、单播和多播。</p>
<p>（4）元信息——自省、反射。</p>
<p>（5）某种形式的持久化、序列化或者外部化。</p>
<p>（6）基于属性的编程或部署描述符。</p>
<p>（7）适合于应用服务器的特定构件模型——EJB、COM+、CCM和CLR:COM+。</p>
<p>（8）适合于Web服务器的特定构件模型——JSP/servlets、COM:-、CCM:-和ASP.NET。</p>
<p>一个通常被忽视的事实是，非COM方法慢慢地汇聚到同样支持COM方法已经拥有的功能上来，这个功能就是构件对象通过多个截然不同的对象将自身展现给客户的构件对象。这样做使得动态配置成为可能，这已经得到了认可。CORBA构件模型的等价接口的概念几乎等同于COM的QueryInterface方法。JavaBean引入了间接的库java.beans.Beans，来代替Java语言的类型测试（instanceof）和类型检查（检查转换）。通过这种方法，将来的bean可以将它们自己作为一组Java对象表示给客户，而不是一个单独的对象。有趣的是，CLI/CLR在第一个版本中没有追随COM，不提供对处理拥有多个实现体的实例的支持和转换，尽管提供了通用的设计模式，使用C#的属性从主对象中获得子对象。</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>一旦做出使用软件构件的决定，下一步就要选择使用哪一种方法。鉴于很多方法具有较多的共性，可以同时遵循几种不同的方法。特别地，支持者们和第三方或许会提供主要方法之间的互连的解决方案。这里有若干例子。IONA公司的Orbix 2000 COMet是一个CORBA/COM集成工具。Sun公司的ActiveX bridge允许JavaBean实例被嵌入到ActiveX容器中。IONA公司的技术总监Annrai说：“我们的座右铭是，不兼容就意味着商业机会，对于我们而言是巨大的机遇。”</p>
<p>以下是一个这些方法间明显区别的（不全面的）列表。</p>
<h5 id="每个平台的二进制接口标准"><a href="#每个平台的二进制接口标准" class="headerlink" title="每个平台的二进制接口标准"></a>每个平台的二进制接口标准</h5><p>构件交互的二进制标准是COM的核心（值得注意的是，虽然从技术上是可行的，也曾经做过尝试，但是COM从来没有脱离过Windows领域。从而，有一个平台就有一个二进制标准）。Java通过标准化字节码来避免实际的二进制标准。Java为二进制接口定义了Java本地接口（JNI），JNI的设计是基于COM的，不过是特定于Java。特别的是，其设计为支持现代的垃圾搜集器提供了空间。CORBA仍然没有定义二进制标准。二进制标准是Direct-to-*编译器需要的，这些编译器将一种特定编程语言的语言构造直接映射到二进制接口。CLR（CLI的超集）和Java类似，采用标准化MSIL（CIL的超集）来代替二进制标准。CLR支持了领先时代的编译，提供了对平台API调用进行转换的有效支持和与COM的互操作。</p>
<h5 id="兼容性和可移植性的源代码级的标准"><a href="#兼容性和可移植性的源代码级的标准" class="headerlink" title="兼容性和可移植性的源代码级的标准"></a>兼容性和可移植性的源代码级的标准</h5><p>CORBA在标准化语言绑定方面做得相当好，语言绑定保证了跨ORB实现的源代码的兼容性。大量的标准化的服务接口增强了它在这方面的地位。目前在对象服务器上对ORB特定的功能进行存取的实践，降低了基于CORBA服务器的可移植性。对于Java，对Java语言规范达成一致，即只要没有其他语言在Java平台上被使用，就解决了这个问题。于是语言绑定的标准化成为一个问题，不然由多种源语言产生的字节码之间的互操作将受到危害。Java包含了越来越多的（事实上是Sun的）标准，特别是其中的J2EE标准受到很多厂商的追随并提供了实现。COM没有任何源代码级标准或标准语言绑定的概念。COM接口市场的标准也没有超出微软事实上的标准。.NET CLR提供了通用语言规范（Common Language Specification, CLS）来指导语言绑定，它在没有规定单个语言绑定的情况下达到了很高程度的互操作性。位于CLR之下的公共语言基础设施（Common Language Infrastructure, CLI）规范，以及一组基框架和C#语言，都已经由ECMA进行了标准化</p>
<h5 id="逐渐形成的和仓促造就的标准"><a href="#逐渐形成的和仓促造就的标准" class="headerlink" title="逐渐形成的和仓促造就的标准"></a>逐渐形成的和仓促造就的标准</h5><p>在被制定成“标准”之前，COM、CORBA、Java和CLI标准（按照这个次序）经历了越来越短的演化期。COM（具有OLE1的）与CORBA（1.2）已经经过了不少实质性的修订，已经没有了向后的兼容性。COM/OLE/ActiveX有许多冗余的机制——例如外出接口和可连接对象（又被称为变化通知接口，也被称为advice接口）与分派接口（又叫做verb接口，在ActiveX出现以后，还被称为command target接口）。不同演化期长度的一个结果就是这些方法在市场上产品数量的不同。市场上有成千上万的ActiveX对象，而只有很少的Bean。然而，EJB构件已经在工业界获得了实质性的支持，虽然目前大多数的EJB构件只是在内部被开发和使用。对于CLI/CLR标准的构件，报告其市场的接受程度还为时过早。</p>
<h5 id="内存管理、生命周期和垃圾回收"><a href="#内存管理、生命周期和垃圾回收" class="headerlink" title="内存管理、生命周期和垃圾回收"></a>内存管理、生命周期和垃圾回收</h5><p>目前CORBA尚未提供解决分布式对象系统中的全局内存管理问题的一般方法。COM和DCOM完全依赖于引用计数——这在所有构件都遵循特定规则的情况下是可行的，但是在大的开放的分布式系统中存在伸缩问题。Java完全依赖于垃圾回收机制，JDK1.1以后通过使用Java RMI也定义了分布式对象模型并支持分布式垃圾回收，这个概念基于“租期”——预先指定远程引用的生命周期。CLR也采用垃圾回收机制并融入基于“租期”的对远程引用的生命周期控制。另外，CLR支持其他的通信和列集协议，诸如HTTP之上的SOAP。</p>
<h5 id="容器管理的持久性和关系"><a href="#容器管理的持久性和关系" class="headerlink" title="容器管理的持久性和关系"></a>容器管理的持久性和关系</h5><p>EJB创新性地引入了容器管理的持久性技术，并且从EJB2.0开始，还引入了容器管理的关系。CCM也有类似的技术，因为它可以算是EJB的超集。迄今为止，COM+和CLR都尚未提供这样的支持。这些机制仍然需要进行改进，例如一个J2EE服务器中过度热心地装载一个关系中的所有实体，导致了很多应用程序的性能低下。OLEDB（及COM+和CLR）支持可插拔的持久性映射，允许将数据保存到除数据库外的其他多种外部存储的持久性。2.0版本的EJB不包括对可插拔映射的支持，使得纯数据库应用程序外的容器管理的持久性和关系功能很弱。同样地，当映射需要复杂的连结或存储过程时，EJB 2.0的局限性也很大。</p>
<h5 id="演化和版本的概念"><a href="#演化和版本的概念" class="headerlink" title="演化和版本的概念"></a>演化和版本的概念</h5><p>COM坚持一旦接口和它们的接口ID被公布之后，就必须冻结接口和接口的规约。这样可以解决版本和移植问题，但在某些特定的部署场所使用受控的版本兼容策略时会暴露出一些问题。CORBA没有直接处理这个问题，而是选择支持主、次版本号这样一个较弱的概念。CORBA的解决方案是有问题的，因为它允许某个版本的对象的引用被传递给另一个希望接收不同版本对象引用的对象——版本检查只在对象创建的时候进行。Java只在二进制兼容性级别上考虑版本，为此给出了令人头痛的规则列表。有些规则的实际意义可能不大。例如，一个版本中某个常量的值在另一个版本中被改变，这对于以前编译过的客户程序不会有影响，它们只需简单地保持以前的值就可以了。虽然客户程序使用了不同版本，但是原有的客户程序仍然是可用的（尽管可能会出现一些功能失常），而不用声称该客户程序被破坏。构件Pascal的实现使用指纹标注每个接口的算法来保持小粒度上的兼容性（Crelier, 1994）。CLI拥有最完整的版本控制方法。CLI构件，被称为配件，都标记它们自己的版本信息，以及它们依赖的构件集合的所有版本信息。策略可以用来建立匹配版本的可容忍的范围。通过支持并行运行来允许一个构件的多个版本同时存在，这使得滑动窗口方式的移植成为可能——不是每个构件都需要立刻更新到一个新的版本。然而，最初的.NET框架和面向CLR的语言都没有利用CLI版本支持的全部优势。</p>
<h5 id="分类的概念"><a href="#分类的概念" class="headerlink" title="分类的概念"></a>分类的概念</h5><p>COM中的分类通常被忽视，因为这个概念比较新，并且看起来没有什么坏处，不过实际上，它引入了合约绑定到包含任意多个接口的规约这样的概念。一个构件可以属于任意数目的分类，一个框架或者其他构件可以使用分类成员资格作为高层的断言。Java和CORBA没有任何类似的概念，虽然Java中的空标记接口按照类似的目的被使用。CLI提供定制属性来扩展构件的元数据，因此分类和其他元信息可以使用定制属性来获取。</p>
<h5 id="产业界的实现支持及应用状况"><a href="#产业界的实现支持及应用状况" class="headerlink" title="产业界的实现支持及应用状况"></a>产业界的实现支持及应用状况</h5><p>这里，所有的方法有它们自己的领地。COM在客户机/桌面系统方面最强。J2EE和COM+则在基于非PC和基于PC的服务器的解决方案中占主导地位。Web服务器主要使用JSP或者ASP（现在还有ASP.NET）。CORBA在商业计算层次上对传统的遗留系统的集成是最强的。COM和CLR很大程度被限制在微软所提供的实现上。很多厂商提供了CORBA和J2EE的实现。从一个J2EE服务器移植到另一个J2EE服务器并不是一件容易的事情，但是当然要比J2EE和.NET间的移植简单很多。</p>
<h5 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h5><p>支持COM的开发环境相当多。Java的开发环境也比较多。支持CORBA的开发环境非常少，几乎没有。对于CLR——微软对CLI的实现，其开发环境是与之一起发布的Visual Studio.NET，该环境包括对Visual Basic、JScript、C#和Managed C++的支持。</p>
<h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>CORBA目前拥有全套的标准化服务，不过其中的大部分缺少商业实现。COM+用一组丰富的关键服务对COM进行了补充，其中包括事务和消息。包括EJB的J2EE也拥有相对丰富的服务。CLR用COM+提供高度的互操作性支持，包括所有的COM+服务（现在被称为企业服务）。然而，这些服务没有被CLI规范所涵盖。在未来，一些COM+服务可能发展成为真正的基于CLR的服务。在CORBA和COM+中提供了对分布式事务协作的支持（对于CLR也是同样的），不过并不包括在EJB 2.0标准的范围中。J2EE服务器的支持则会相应的不同。</p>
<h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><p>J2EE、COM+、CCM和CLR全都遵循基于属性编程的MTS概念。EJB将属性分离出来并将它们放置在单独的基于XML的部署描述符中，使得在特定的部署步骤中可以拥有清晰的操作对象。J2EE将部署描述符的概念扩大到若干个构件模型。CLR将基于XML的配置和基于CLI的定制属性组合到一起。定制属性简化了代码的排列，作为属性的元数据被直接存放在相应的源代码中。这样划分了开发者（放置定制属性）和部署者（处理配置文件）两者的任务。</p>
<h5 id="网络服务构件"><a href="#网络服务构件" class="headerlink" title="网络服务构件"></a>网络服务构件</h5><p>CORBA和COM在这方面没有特定的构件模型。J2EE有JSP和servlet构件。.NET框架有ASP.NET的页面构件类。JSP在某些方面遵循以前的ASP模型，但是在JSP页面与servlet方面有所改进。ASP.NET在某些方面遵循JSP模型，不过使用目标独立的方式，从而作为取代提供生成HTML的构件的方式，ASP.NET鼓励使用已有的生成界面显示的构件。因此，很多ASP.NET构件连一行HTML也不直接生成，使得它们独立于特定目标设备的要求，例如为移动设备生成WML显示。</p>
<h5 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h5><p>CORBA支持IIOP，用来作为ORB之间互操作的标准的传输协议。另外，OMG采用XML和XML Schema规范作为应用程序层的传输格式描述。Java支持IIOP绑定，不过也自然支持它自己的RMI协议。Java对XML的支持正在改进中。COM使用DCOM作为自身的传输协议，COM+增加了对多种消息格式的支持。CLR延续了COM和COM+所支持的所有格式，并添加了对XML schema定义和SOAP调用协议的支持。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch9-%E9%9D%A2%E5%90%91%E6%9E%84%E5%BB%BA%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch9-%E9%9D%A2%E5%90%91%E6%9E%84%E5%BB%BA%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch9-面向构建的软件设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:54:43" itemprop="dateCreated datePublished" datetime="2021-07-19T12:54:43+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-19 15:26:34" itemprop="dateModified" datetime="2021-09-19T15:26:34+08:00">2021-09-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="面向构件的软件设计"><a href="#面向构件的软件设计" class="headerlink" title="面向构件的软件设计"></a>面向构件的软件设计</h2><p>面向构件的软件设计是现在软件设计的重要方法，是软件生产线技术、软件工厂技术重要的理论基础。而在20世纪90年代之前，软件领域中的构件一直没有成功发展，这与软件领域中软件复杂度管理和软件复用粒度需求有关。术语“软件构件”的定义以及“构件化软件”等的仍然存在许多不同的观点，但构件概念已经在工程中被建立并且发展较为成熟，本章讨论软件构件的概念及构件化软件开发设计的方法与存在问题。</p>
<blockquote>
<p>他这里的构件,给我的感觉更像是docker的容器？<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/121698366">构件开发技术与微服务架构的区别</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuwc/p/13989081.html">SOA和微服务</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25089273">领域建模</a></p>
</blockquote>
<h3 id="构件的概念"><a href="#构件的概念" class="headerlink" title="构件的概念"></a>构件的概念</h3><p>人们经常不做区分地使用术语“构件”和“对象”，以及像“构件对象”这样的短语组合。对象常被称为是类的实例，对象和构件都通过类或接口向外界提供服务。对于对象和构件之间的交互，设计人员常用模式描述，用框架规范。而构件和框架又都常被称为是白盒的或黑盒的。程序语言设计者还不断提出诸如名字空间、模块、包等各种名词。这种术语和概念泛滥的现象亟待改变，应该消除它们的冗余歧义，或者对它们进行阐明、解释与辨析。这些都让术语“构件”更加扑朔迷离。</p>
<h4 id="术语与概念"><a href="#术语与概念" class="headerlink" title="术语与概念"></a>术语与概念</h4><p>构件技术蕴涵了太多概念。一个典型的例子就是含义众多的术语“对象”。随着时间的推移，模块、类和构件的概念都最终为“对象”所包括。最近，术语“软件构件”甚至到了把以前的普通对象也称作是构件的程度。将几个术语合并为一个，看起来似乎方便了使用，但除此之外再无其他好处。所以，必须在保证术语的准确度和直观性的前提下取得某种平衡。下面定义了几个关键的术语，并描述了它们之间的关系。</p>
<h5 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h5><p>构件的特性如下。</p>
<p>●　独立部署单元。</p>
<p>●　作为第三方的组装单元。</p>
<p>●　没有（外部的）可见状态。</p>
<p>这些特性有几重含义。一个构件是独立可部署的，意味着它必须能跟它所在的环境及其他构件完全分离。因此，构件必须封装自己的全部内部特征。并且，构件作为一个部署单元，具有原子性，是不可拆分的。也就是说，第三方没有权利访问其所使用的任何构件的内部细节信息。</p>
<p>在这样的约束下，如果第三方厂商能将一个构件和其他构件组装在一起，那么这个构件不但必须具备足够好的内聚性，还必须将自己的依赖条件和所提供的服务说明清楚。换句话说，构件必须封装它的实现，并且只通过良好定义的接口与外部环境进行交互。</p>
<p>最后，一个构件不能有任何（外部的）可见状态——这要求构件不能与自己的拷贝有所区别。但对于不影响构件功能的某些属性，例如，用于计费的序列号，则没有这种限制。通过对属性的可见性进行限制，允许用户在不影响构件的可见行为的前提下，使用合法的技术手段对那些影响性能的状态进行特殊处理。特别是，构件可以将某些状态专门用于缓存（缓存具有这样的特性：当它被清空时除了可能会降低性能以外，没有其他后果）。</p>
<p>构件在特定的系统中可以被装载和激活。但是，由于构件本质上没有状态，因此，在同一操作系统进程中装载多个构件的拷贝是毫无意义的，而且它们之间是不可区分的。也就是说，给定一个进程（或者其他的语境），至多会存在一个特定构件的拷贝。因此，谈论某个构件的可用拷贝的数量是没有什么意义的。</p>
<p>在目前许多系统中，构件被实现为大粒度的单元，系统中的构件只能有一个实例。例如，一个数据库服务器可以作为一个构件。如果这个服务器刚好只维护了一个数据库，那么会很容易把该数据库误认为是实例，如公司里的员工工资管理服务器。该数据库服务器连同其中的数据库，可以被视为一个有可见状态的模块。根据上面的定义，该数据库并不是一个构件，但那个静态的数据库服务器程序却是一个构件——它只支持一个数据库“对象”实例。也就是说，在这个例子中，工资管理服务器程序是一个构件，而其中的工资数据只是实例（对象）。这种将不易变的“模型”和易变的“实例”分离的做法避免了大量的维护问题。如果允许构件拥有可见状态的话，那么任何两个来自同一个构件的实例都不会拥有相同的属性。</p>
<p>在这一点上一定要分辨清楚。这里所说的构件的概念与对象层次上的可见或不可见状态无关，也与对象状态的生命周期（每次呼叫，每次会话，或是永久的）无关。这些全都是对象层次上所关心的东西，与构件的概念并没有直接的关系，但是通过构件，我们可以获得拥有任何这些属性的对象。</p>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>说起对象，不得不提实例化、标志和封装。与构件的特性不同，对象的特性是：</p>
<p>（1）一个实例单元，具有唯一的标志。</p>
<p>（2）可能具有状态，此状态外部可见。</p>
<p>（3）封装了自己的状态和行为。</p>
<p>同样，对象的一系列属性随之而来。由于对象是一个实例化的单元，所以不能被局部初始化。由于对象有各自的状态，它必须有唯一的标志，以使它在整个生命周期内，无论状态如何变化，都能够被唯一地识别。</p>
<p>当对象被实例化的时候，需要一个构造方案来描述其状态空间、初始状态和新生对象的行为。该方案在对象存在之前就已经存在。显式存在的实例化方案称为类。也有隐式的实例化方案，即通过克隆一个已存在的对象来实现，即原型对象。</p>
<p>无论使用类的形式，还是用原型对象的形式来初始化一个对象，这个新生的对象都必须被设置一个初始状态。创建与初始化控制对象的代码可以是一个静态的过程——如果它是对象所从属类的一部分，就被称为构造函数。如果这个对象是专门用来创建与初始化对象的，则简称为工厂。对象中专门用来返回其他新创建的对象的方法常被称为工厂方法。</p>
<h5 id="构件与对象"><a href="#构件与对象" class="headerlink" title="构件与对象"></a>构件与对象</h5><p>构件的行为显然可以通过对象来实现，因此构件通常包含了若干类或不可更改的原型对象。除此之外，构件还包括一系列对象，这些对象被用来获取默认的初始状态和其他的构件资源。</p>
<p>但构件并非一定要包含类元素，它甚至可以不包含类。实际上，构件可以拥有传统的过程体，甚至全局变量，它也可以通过函数语言，或者汇编语言，或者其他可用方法实现自身的全部特性。构件创建的对象——更确切地说是对这些对象的引用——可以与该构件分离开来，并对构件的客户可见。构件的客户通常是指其他的构件。除非构件的对象对客户可见，否则我们无从判断一个构件内部是否是“完全面向对象”的。</p>
<p>一个构件可以包含多个类元素，但是一个类元素只能属于一个构件。将一个类拆分进行部署通常没什么意义。另外，正如类之间可以通过继承关系等产生依赖一样，构件之间也可以存在互相依赖的关系——这种依赖很重要。一个类的父类并不一定与它的子类存在于同一个构件中。如果一个类的父类存在于外部的其他构件中，那么这两个类之间的继承关系便是跨构件的，这种关系将会导致相关联的构件间的导入关系。规约的继承是保证正确性的一项很关键的技术，因为共同的规约是构件间达成共识的基础。至于构件间对实现的继承是好是坏，仍然是众多学术流派争论的焦点。</p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>构件与模块的概念其实非常类似。模块的概念出现于20世纪70年代后期的模块化语言（Wirth, 1977; Mitchell等人，1979）。最广泛使用的模块化语言是Modula-2 (Wirth, 1982）和Ada。在Ada里面，模块被称做包，但其实两者是相同的。模块化方法成熟的标志是其对分离编译技术的支持，包括跨模块的正确的类型检查能力。</p>
<p>随着Eiffel语言的面世，类被认为是更好的模块（Meyer, 1988）。这似乎是正确的，因为我们最初的想法是每个模块实现一种抽象数据类型。毕竟，我们可以把一个类看成是一个抽象数据类型的实现，只不过它多了继承和多态的特性而已。然而，模块常常被用于把多个诸如抽象数据类型、类等实体打包到一个单元中。并且，模块没有实例化的概念，而类却有。</p>
<p>在其后出现的程序设计语言中——比如Modula-3，Component Pascal，和C#模块的概念（C#中的集合）与类的概念是区分对待的。在任何情况下，模块都可以包含多个类。在有些没有模块概念的语言（诸如Java语言）中，模块可以通过嵌套类来模拟实现。类之间的继承关系并不受模块界限的限制。另外值得一提的是，在Smalltalk系统中，经常会通过修改当前已存在的类来构造一个应用程序，人们已经开始尝试定义“模块系统”，这将使Smalltalk越过类而直接达到构件级水平，例如Fresco（Wills, 1991）。</p>
<p>模块本身就可以作为一个最简单的构件。即使不包含任何类元素的模块也可以实现构件的功能。传统的数值计算函数库就是一个很好的例子，这些库是功能性的，而不是面向对象的，但却可以打包成模块。然而，一个成熟的复杂的构件却并不是简单地仅用模块就可以实现的。模块没有持久不变的资源，有的只是那些被硬编码到程序中的常量。资源可以参数化一个构件。通过替换这些资源，就可以重新配置该构件而无需更改构件代码。例如，本地化设置可以通过资源配置实现。看起来资源配置好像为构件赋予了可变的状态值。但是我们知道，构件不能修改它们自身的资源，这些资源与编译后的代码一样只是构件的组成部分。追踪一个构件与它所派生的本地化了的构件之间的关联，在某种程度上，和追踪同一构件的不同的发布版本之间的关系相似。</p>
<p>某些情况下，模块并不适合作为构件，掌握这些情况是非常有用的。根据本书的定义，构件没有外部可见的状态，但是模块却可以显式地用全局变量来使其状态可见。并且，通过直接导入其他模块的接口，模块之间可以存在静态的代码依赖。而对于构件来说，虽然也允许存在对构件外部代码的静态依赖关系，但却并不提倡。这种静态依赖关系应被限定用于那些合约元素，包括类型和常量。使用间接而非直接的接口表示模块的依赖关系，把对实现代码的依赖关系限定于对象层次，就可以利用同一接口的不同实现来灵活地组装模块。</p>
<p>总的说来，模块化是构件技术产生的前提，但对于构件来说，传统的模块化的概念和标准是远远不够的。很多模块化的概念源自Parnas（1972），其中包括最大化内聚性与最小化耦合性这条基本原理。因此，模块化的思想并不新鲜。但遗憾的是，现今的大部分的软件仍然不是模块化的。比如，有不少的大型企业应用都是对一个单一的数据库进行操作，允许应用系统的任何一部分依赖于数据模型的任何部分。但构件技术则要求系统中各部分必须互相独立，或者存在可控的显式依赖关系。因此构件技术必将导致模块化的解决方案。这种软件工程效益充分说明对构件技术的投资是有价值的。</p>
<h5 id="白盒抽象、黑盒抽象与重用"><a href="#白盒抽象、黑盒抽象与重用" class="headerlink" title="白盒抽象、黑盒抽象与重用"></a>白盒抽象、黑盒抽象与重用</h5><p>黑盒抽象与白盒抽象的区别主要在于接口“后面”的实现细节是否可见。在理想的黑盒抽象的情况下，客户对接口和规约之外的实现细节一无所知。而在白盒抽象中，在接口限制了用户行为并确保了封装性的情况下，客户仍然可以通过继承对构件的实现细节进行修改。由于在白盒方式中实现细节对外界是完全可见的，因此可以对实现细节进行研究，以加深对该接口抽象含义的理解。</p>
<p>揭示实现细节的可控部分。这是一个有争议的概念，因为部分可见的实现细节可以是规约的一部分。一个完整的实现只需要保证，能被客户看见的那部分实现细节与抽象的接口规约一致即可。这是将规约实现的标准方式。</p>
<p>黑盒重用指仅仅依赖接口和规约来实现。比如，在绝大多数系统中，应用程序接口（Application Programming Interface, API）完全与内部的具体实现无关。用这样的应用程序接口构造系统相当于黑盒重用这些接口的实现。</p>
<p>相反，白盒重用指依赖于对具体实现细节的理解，通过接口来使用软件部件。大部分类库和框架都会提供源代码，应用程序开发人员通过学习类的具体实现，就可以知道如何构造该类的子类。</p>
<p>在白盒重用中，被重用的软件不可以轻易地被另外的软件替换。如果贸然替换将有可能破坏正在重用的客户端，因为这些客户端依赖于那些在未来可能发生改变的实现细节。</p>
<p>根据上述特性可以得出以下的定义：“软件构件是一种组装单元，它具有规范的接口规约和显式的语境依赖。软件构件可以被独立地部署并由第三方任意地组装。”</p>
<p>这个定义最先是在1996年的面向对象程序设计欧洲会议上（European Conference on Object-Oriented Programming, ECOOP），由面向构件程序设计工作组（Szyperski和Pfister, 1997）提出。该定义涵盖了我们之前讨论的那些构件特性。它既包括了技术因素，例如独立性、合约接口、组装，也包括了市场因素，例如第三方和部署。就技术和市场两方面的因素融为一体而言，即使是超出软件范围来评价，构件也是独一无二的。</p>
<p>而从当前的角度看，上述定义仍然需要进一步澄清。一个可部署构件的合约内容远不只接口和依赖，它还要规定构件应该如何部署、一旦被部署（和启动）了应该如何被实例化、实例如何通过规定的接口工作等。事实上，各个接口的规约都应该被独立地看待，任何提供与使用该接口实现的构件之间都是相对独立的。比如，一个实现队列操作的构件通过一个接口获得物理存储空间，通过另外两个接口提供入队列和出队列的操作。在构件的合约中说明，通过入队列接口插入队列的元素，可以通过出队列接口中的操作取出来，这种关联关系，任何接口规约都不能单独提供。该合约同时也规定构件一旦被实例化，就必须在关联一个实现了物理存储空间接口的构件之后才能被使用。这种关联将受到底层构件模型的组装规则的影响。具体的部署和安装的细节由特定的构件平台提供。</p>
<h5 id="color-green-text-接口"><a href="#color-green-text-接口" class="headerlink" title="$\color{green}{\text{接口}}$"></a>$\color{green}{\text{接口}}$</h5><p>接口是一个已命名的一组操作的集合。构件的客户（通常是其他构件）通过这些访问点来使用构件提供的服务。通常来说，构件在不同的访问点有多个不同的接口。每一个访问点会提供不同的服务，以迎合不同的客户需求。强调构件接口规范的合约性非常重要，因为构件和它的客户是在互不知情的情况下分别独立开发的，是合约提供了保证两者成功交互的公共中间层。</p>
<p>成功的合约接口需要遵循哪些非技术因素？首先，必须时刻关注经济效益。一个构件可以有多个接口，每一个接口提供一种服务。有一些服务会格外受客户欢迎，但是如果所有服务都不受欢迎，那么服务的组合也不会受欢迎，这个构件就没有市场价值了。这样的话，就没有必要在非构件的实现方案的构件化上进行投资了。</p>
<p>其次，应当避免不当的市场分化，因为这威胁到构件的生存。所以，尽量不要重复引入功能相近的接口。在市场经济中，这通常是主要生产商在市场早期努力推行标准化的结果，或者是经过残酷的市场竞争优胜劣汰的结果。但是，前者可能会由于笨拙官僚的“委员会设计”问题而不能达到最优；而对于后者，市场竞争的非技术本质也可能导致结果不是最优的。</p>
<p>最后，为了使一个接口的规范和实现该接口的构件得到广泛应用，需要有一个公共传媒来向大众进行宣传和推广。要做到这一点，至少需要几种能被广泛认可的保证命名唯一性的命名方案。 $\color{red}{\text{接口标准化}}$ 的一个非常有意思的变种，是对 $\color{green}{\text{消息的格式}}$ 、 $\color{green}{\text{模式}}$ 和 $\color{green}{\text{协议}}$ 的标准化。它不是要将接口格式化为参数化操作的集合，而是关注输入输出的消息的标准化，它强调当机器在网络中互连时，标准的消息模式、格式、协议的重要性。这也是因特网（IP、UDP、TCP、SNMP等）和Web（HTTP、HTML等）标准的主要做法。为了获得更广泛的语义，有必要在一个单一通用的消息格式语境中标准化消息模式。这就是XML的思想。XML提供了一种统一的数据格式。</p>
<h5 id="显式语境依赖"><a href="#显式语境依赖" class="headerlink" title="显式语境依赖"></a>显式语境依赖</h5><p>在上文的构件定义中，构件除了要说明所提供的接口外，还要说明其需求。也就是说为了使构件正常地工作，必须说明其对部署环境的具体要求。这些要求被称为语境依赖，指的是构件组装和部署的语境，包括了定义组装规则的构件模型和定义构件部署、安装和激活规则的构件平台。如果只存在一种软件构件体系的话，那么只需要列举该构件所需的所有其他构件提供的接口，这样就足够可以说明全部的语境依赖。例如，一个合并邮件的构件会声明它需要一个文件系统的接口。但是，今天的大多数构件即使连这样的需要的接口也通常不进行声明。而构件提供的接口更受关注。</p>
<p>事实上，目前有几种构件体系同时存在，它们相互竞争，彼此冲突。例如，现在就有OMG的CORBA，Sun的Java，以及微软的COM和CLR（Common Language Runtime）等体系。并且，因为要支持不同的计算和网络平台，构件体系本身并不是单一的。这种状况还没有很快改善的迹象。而另外一种观点则认为，所有这些构件体系最终都只能归结为两类——CORBA+Java体系和微软体系（包括COM+和.NET/CLR）。但即使构件体系被刻意减少到不能再少的区区两种，在具体实现层次上还是存在着千差万别的。</p>
<h5 id="构件的规模"><a href="#构件的规模" class="headerlink" title="构件的规模"></a>构件的规模</h5><p>显然，构件只有在提供了“恰当”的接口集，以及对语境依赖没有严格限制的情况下，该构件可以在所有的构件体系中运行，并且其依赖的接口不会超出那些构件体系所能提供的范围时最好用。然而，只有极少的构件拥有这么弱的环境依赖性。技术上来说，一个构件可能和它所需要的所有软件捆绑起来被提供，但这显然违背了使用构件的初衷。注意，环境需求往往取决于构件运行的目标机器。如果是虚拟机，例如Java虚拟机，这就显然是该构件体系规范的内容之一。如果是本地代码平台，仍然有类似于Apple的将多个二进制文件打包成一个文件的Fat Binaries这样的机制，可以使构件在“所有地方”运行。</p>
<p>构件设计者通常不会构造自给自足的构件，将所需的所有东西都打包进来，而是采取一种“最大化重用”的策略。为了避免在构件中重复实现那些次要的服务，设计师通常会只实现该构件的核心功能，然后重用其他所有的一切。面向对象的设计有向这种极端发展的趋势，许多面向对象的方法论者都大力提倡这种最大化重用的思想。</p>
<p>虽然最大化重用的思想有很多为人称道的优点，但是它也有一个潜在的缺点——语境依赖的爆炸性增长。如果构件在发布后其设计一直冻结不变，同时所有的部署环境也都一样，那么这个问题就不会出现。然而，构件会不断地演化，不同的部署环境会提供不同的配置，多种版本会同时存在，在这样的情况下大量的语境依赖只会使构件成为众矢之的。语境依赖越多，能满足构件环境需求的客户构件就越少。总之，最大化重用降低了可用性。</p>
<p>构件设计者需要为以上两者找到一个平衡点。当要描述构件的基本接口的时候，设计者们就需要做出抉择。增加语境依赖通常会使构件因重用而简洁，但却会降低可用性。此外，还必须考虑环境的演化会使构件更加脆弱，例如引入新版本带来的变化。增加构件的自给性可以减少语境依赖，增加可用性，并且使构件更健壮，但却会使构件规模过大。</p>
<h4 id="标准化与规范化"><a href="#标准化与规范化" class="headerlink" title="标准化与规范化"></a>标准化与规范化</h4><p>通过提高接口与构件体系的标准化和规范化程度，可以使上文优化问题中的最优点偏向于简洁性一侧。一个东西越稳定，越容易被广泛接受，其成为某个构件的特殊需求的危险就越小。如果语境依赖能够被广泛支持，就不是什么缺点。比如仅仅在50年前，要求客户必须拥有电话才能谈妥生意是极不明智的。而现在，在世界上的许多地方，拥有电话已经成为必要条件。</p>
<h5 id="通用市场与专业市场"><a href="#通用市场与专业市场" class="headerlink" title="通用市场与专业市场"></a>通用市场与专业市场</h5><p>如果要制定一种覆盖所有领域、有广泛市场的标准，就有必要区分面向通用市场与面向专业市场的两种标准。通用市场覆盖了多数甚至全部不同的市场领域；它对所有或绝大多数的客户和生产商都有影响。专业市场往往只限于某个特定的领域，相对来说影响比较小。例如，因特网和万维网的标准都属于通用市场标准。与之相反，放射医学领域的标准就只影响一个比较窄的专业市场，却同样会占有相当大的市场份额。</p>
<p>通用市场的标准化是非常困难的。如果有一项服务几乎和每个人都相关，那么它就得满足所有人的需求。想像一下那些通用程序设计语言标准化委员会，他们为顾全各方面的利益而疲于奔命。与此同时，成功的标准只有在通用市场中才能形成最广泛的影响，网络标准就是其中最好的例子。</p>
<p>令人吃惊的是，专业市场的标准化与通用市场同样艰辛，虽然原因各不相同。由于专业市场中涉及的人相对较少，所以比较容易形成一种折中的方案。然而，如果某个专业领域正在考虑标准化，那么为了培育市场，该领域就不能够太窄。由于所涉及的人较少，市场经济的机制就不容易很好地发挥作用，也就不太可能在短期内找到理想的、成本效益好的解决方案。</p>
<h5 id="标准的构件体系与规范化"><a href="#标准的构件体系与规范化" class="headerlink" title="标准的构件体系与规范化"></a>标准的构件体系与规范化</h5><p>在基本构件体系和那些最重要的接口合约形成标准，并且在这些标准被相关的工业界支持的情况下，构件技术最为成功。然而，要发挥标准化的作用，就必须使与之竞争的其他标准的数目尽量很小。如果某个标准背后有一个强大的国际标准化组织认可，有一个非常有实力的企业推动，有众多有影响力的公司或组织联合支持，那么一切自然不成问题。然而，通常却是几个标准在相互竞争。如果因专业市场各自为政，导致某标准在不同领域重复建设，而该标准又可能适合其他领域，就可能出现戏剧性的结果：很多原先互不知情的标准竞争者在一夜之间一起出现。例如，放射医学和射电天文学就可以共享多种图像处理标准。</p>
<p>如果相互竞争的标准过多，而其相应的市场份额过小，就可能引发危机，这个问题可以通过规范化的手段来解决。公布共同的设计“模式”，并对其进行编目，原来互不知情的各方标准化实体就有可能在各自的目标领域发现共同点。当然，寻找和利用共同点的努力是否值得，即成本效益是否理想是个规模效益的问题。</p>
<h3 id="构件的布线标准"><a href="#构件的布线标准" class="headerlink" title="构件的布线标准"></a>构件的布线标准</h3><p>“布线”用于连接电子构件。无论天然气、水或排污系统，对于所有要连接的部件来说，管道工程本质上是相同的。对于可连接的构件来说，这一级的标准是重要的。但是，需要注意的是不要高估了“布线”标准的重要性。比如说，庞大的世界范围内的电话系统之间的互联互通就是一个例子。</p>
<h4 id="布线标准从何而来"><a href="#布线标准从何而来" class="headerlink" title="布线标准从何而来"></a>布线标准从何而来</h4><p>由于过程的交互为进程边界所限，所以操作系统支持多种多样的进程间通信（Internet Process Connection, IPC）机制，典型的例子有文件、套接字（socket）及共享内存。除了BSD-UNIX套接字外，这些机制都不能跨平台移植。</p>
<p>IPC机制的一个共同的优势是：它们可以很容易地被扩展到网络甚至是因特网上。这是传统进程模型的直接结果。在这个传统进程模型中，每个进程产生了一个幻象，就好像一个共享的物理主机上的每个进程都拥有单独的虚拟机。</p>
<p>RPC的设想是在本地被调用者和远程调用者两端都使用指代（stub）。调用者使用严格的本地调用约定，就像调用了一个本地被调用者，实际上，却调用了一个本地指代来编排（串行化）参数，并把它们发送到远端。在远端，另一个指代接收参数，并还原（反串行化）参数，然后调用真正的被调用者。和调用者一样，被调用者的过程本身也要遵循本地调用约定，并且不知道自己被远程调用了。编排和还原过程负责转化数据值，将它们从本地表示转化为网络格式，然后再转化为远端表示。通过这种方法，格式的差异等被跨越了。</p>
<p>分布式计算环境（DCE）是OSF （Open Software Foundation, Open Group的一部分）的一个标准，它是在跨越异构的平台上实现RPC机制的最重要的服务。在另一个极端，轻量RPC变化能被用来处理单机上的IPC问题。例如，Windows支持跨进程的轻量RPC；DCOM出现后，可以支持不同机器间的完全RPC。DCE也通过对每个服务附加主版本号来支持版本控制。客户可以指定他们想要版本的服务。</p>
<p>潜在的透明性既是RPC的优点，同时也是其负担。因为它隐藏了本地调用、进程间调用及机器间调用的很重要的代价上的差异。在大多数当前的体系结构上，进程间调用比本地调用慢10～1000倍，而机器间调用比进程间调用慢10～10000倍。</p>
<blockquote>
<p>RPC<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41609070/answer/2079027802">既然有 HTTP 请求，为什么还要用 RPC 调用？</a>:RPC的接口规范基于代码。http的接口规范基于文档。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357118189">RPC实现原理之高并发场景下的技术运用</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349263565">RPC是在什么场景使用？</a></p>
</blockquote>
<p>接口定义语言（Interface Definition Language, IDL），保证了不同环境下过程调用语义的一致性。对每一个可以被远程调用的过程，IDL指定了参数的数目、传递模式和类型，以及可能的返回值的类型。为了确保跨机器边界的通信正常工作，所有的IDL都必须固定基本类型的范围，例如指定整数是32位的二进制的补码值（二进制的补码表示是一种以二进制形式表示负数的数学方案）。</p>
<p>过程调用及它们的二进制调用约定提供了一个良好证明的“布线”标准。但是它们还不能直接支持对象所需要的远程方法调用。如果和动态链接库（Dynamic Link Library, DLL）结合起来，远程过程调用就会在为构件“布线”形成一个有用的基础的过程中更进一步。服务可以通过名字（DLL的名字）来定位，并被动态地绑定（不仅在编译时刻），而且服务可以是远程的。今天，Web服务似乎已成为事实上的构件布线标准。</p>
<h4 id="从过程到对象"><a href="#从过程到对象" class="headerlink" title="从过程到对象"></a>从过程到对象</h4><p>使对象调用与过程调用区别开来的首要因素在于它们很靠后的、数据驱动的调用代码选择。一个方法调用，除非是优化过的，否则总会去检查接收消息的对象的类，并从该类提供的方法中选择方法实现。而且，一个方法总是将目标对象的引用作为另一个参数向外提供，该引用是消息发往的地址。面向对象编程的大多数优点来自方法调用的属性。</p>
<p>有趣的是，当前的对象调用并不遵循标准平台调用约定。原因很简单，就是由于当前的操作系统和它们的库有过程化的接口，因而对操作系统提供商来说从来就没有必要定义方法调用约定。结果，使用不同的编译器编译出来的代码就无法互操作，甚至使用同一种语言实现的代码也不行。为了通用，一个面向对象的库必须以源代码的形式发布。这也是为什么可执行类库（而不是源代码）在这种面向对象的情况下远不及在过程化的情况下流行的原因。</p>
<p>在实现了过程调用的机器上实现方法调用是可能的。比如IBM的系统对象模型（System Object Model, SOM）就是这么做的。在SOM中，所有的语言绑定只是简单地调用SOM库过程，然后在SOM运行时刻动态地选择要调用的方法。CORBA的ORB（Object Request　Broker）是另一个例子——最新版本的SOM实际上就是基于CORBA的。Microsoft的COM也非常接近于仅使用过程调用约定，虽然它依赖包含函数指针的过程变量表（也称分配表）。但这不是问题，因为过程变量很久以来已经是调用约定的一部分。</p>
<p>另一个可能的方法是为方法调用定义一个带有内建支持的新的虚拟机层。这就是Java虚拟机和.NET的运行时刻公共语言采用的方法。但是，和库的支持及系统范围的调用约定不同，虚拟机可能阻止或干扰超越它的边界的互操作。因此，JVM和CLR都为跨越虚拟机边界的互操作提供特殊的支持。</p>
<h4 id="深层次问题"><a href="#深层次问题" class="headerlink" title="深层次问题"></a>深层次问题</h4><p>如果在执行层上过程调用约定几乎是能胜任的，那为什么还要有这么多不同的竞争的提议呢？原因在于，为了实现互操作，还有其他的重要方面需要被考虑和标准化。需要回答的问题包括“接口如何指定”、“当离开它们的本地进程后对象引用如何处理”、“服务如何被定位和提供”及“构件演化如何处理”。</p>
<h5 id="接口和对象引用规范"><a href="#接口和对象引用规范" class="headerlink" title="接口和对象引用规范"></a>接口和对象引用规范</h5><p>什么是接口？所有当前的方法一律将接口定义为一个已命名的操作的集合，每个操作带有一个已定义的特征标记（signatrue）和可能的返回值的类型。操作的特征标记定义了该操作的参数的数目、类型及传递模式。接口和什么相连接？对于这个问题，每种方法的处理是不同的。那些基于传统的对象模式的方法在接口和对象之间定义一个一对一的关系（CORBA 2.0, SOM）。对象在接口后面提供状态和实现。其他的方法将多个接口和一个单独的对象联系起来（Java, CLR），或者把多个接口和一个构件对象的多个部分对象联系起来（CORBA 3.0的COM, CCM）。明显地，一旦出现一个接口后面有多个对象的情况，就有身份标志的问题产生并且需要处理（为了这个原因，COM和CCM提供了一个特殊的接口）。</p>
<p>如何指定接口？所有传统的处理方式都遵循DCE（Data Communications Equipment），并且使用IDL。遗憾的是，真正使用的不是单个的IDL，而是存在着的几个竞争的提议，特别是OMGIDL和COMIDL这两个最强大的竞争者。Java和CLR没有IDL，这里，相关信息作为元数据被保留并可以映射到任何被支持的语言。程序员可以使用他们熟悉的语言来看待接口和其他类型定义，而不需要去学习他们熟悉的语言之外的一种IDL。所谓的Java IDL，实际上是一种结合了一个IDL到Java编译器的Java可调用的CORBA ORB。通过一个从Java类型到OMG IDL（反之亦可）的映射来支持Java。在OMG IDL和COM IDL之间也已经定义了一个相似的双向映射。目前OMG IDL和CLR类型之间或者和更多的特定于C#的类型之间还没有相似的映射。</p>
<p>什么是对象引用？当它们作为一个远程方法调用的参数被传递时是如何被处理的？每种方法的做法是不同的。但所有的方法都有一些机制，用于把本地的有意义的引用映射到包含跨进程、机器及网络边界的引用。</p>
<h5 id="接口关系和多态性"><a href="#接口关系和多态性" class="headerlink" title="接口关系和多态性"></a>接口关系和多态性</h5><p>所有的方法都规定了多态性。在所有的情况下，某个具有一个已知接口的实体可以是多个不同的、可能实现中的一个。同时，在所有的情况下，一个实现所能提供的方法比接口指定的要多。</p>
<p>在细节上，所有的做法都是不同的。CORBA 2.0遵循一个传统的对象模型。一个对象有一个单独的接口，但这个接口可能是由其他的接口使用接口多继承组合而成的。实际提供的接口可能是所期望接口的子类型，其额外附加的能力可以被动态地发现。CORBA 3.0中的CCM支持多接口继承及在它们间动态的导航。COM也明确地支持除了被共同支持的已经提供的接口之外的必需的接口。COM拥有不变的接口，也就是说一旦发布则不可扩展或修改。单接口继承被支持用来从已发布的接口派生出新的接口。但是，一个COM对象可以拥有多个接口。对一个特定的对象来说，它提供的接口的集合可能会随着时间的流逝而变化，并且可以被动态地发现。通过约定，COM支持必需的接口。一个Java对象也可以实现多个接口，但是这更接近于多接口继承而不是COM那样的完全分离的接口，一个对象所实现的接口的集合由这个对象的类静态地确定。同样的情况也适用于CLR对象。Java接口的多继承的传统在试图支持有冲突的方法名的接口时会导致问题的出现——Java对象不能支持多个这样的接口。COM和CLR都维护不同接口上的方法在实现层次上的分离，而不关心方法的名字。CLR模型在支持多接口继承方面也超出了COM，像Java或CORBA。和COM一样，Java和CLR仅通过约定的方式采取了支持必需的接口的做法。</p>
<h5 id="命名和定位服务"><a href="#命名和定位服务" class="headerlink" title="命名和定位服务"></a>命名和定位服务</h5><p>接口是如何命名的？它们是如何相互关联的？没有两种做法对这两个问题的处理是完全一致的。COM采用了DCE的UUID（Universally Unique Identifier）的做法，在COM中被称为全局唯一标志符（Globals Unique Identifiers, GUID）。GUID用来唯一地命名多样性的实体，包括接口（Image Impoet Descriptor, IID）、接口的组（称为分类（Category ID, CATID））以及类（Class ID, CLSID）。OMG CORBA最初是把唯一命名留下用来单独实现的，依赖语言的绑定来维护程序的可移植性。在CORBA 2.0中，引入了全局唯一标志符。这些既可以是DCE UUID，也可以是类似于常见的用于万维网的统一资源定位符（URL）的字符串。Java完全依赖由内嵌的命名包来建立的唯一的名字路径。CLR提供类似的有资格的名字来建立一个可读的命名方案，但最后把所有的名字都放入那些所谓的强组装名字（strong names of assemblies）。其实有很大的可能性，私有/公有密钥对中公有的那一半是独一无二的。这就是说，尽管标志符使用唯一的标志符来支持个别的名字，但CLR可以使用一个独一无二的标志符来支持整个名字家族，只要这样的名字家族是在一个单独的组装中（一个CLR软件构件）被一起发布的。通过给定一个名字，所有的服务都提供一些注册表或者库的分类来帮助定位相应的服务。在这个类似目录的功能之上，所有的方法都还提供某种程度上的关于可用服务的一些元信息。所有方法都支持的最小的功能是，对被提供的接口类型的运行时刻的测试、接口的运行时刻反射及新实例的动态生成。</p>
<h5 id="复合文档"><a href="#复合文档" class="headerlink" title="复合文档"></a>复合文档</h5><p>软件构件的第一个实用方法是复合文档模型。复合文档是一个模型，对那些构成，即用户来说，在模型中构件及其合成具有直观的意义。Xerox Star系统是第一个基于Xerox Palo Alto研究中心的研究结果的，但是没有能够获得足够的市场和观念份额。第一个突破是苹果公司的Hypercard，因为它有简单直观的合成及使用模型，但是创建新的构件却是一件困难的事情。Microsoft的Visual Basic也遵循了它，对Visual Basic控件有一个合理的编程模型。有了Microsoft的OLE和苹果公司的OpenDoc技术后，一般的文档都可以遵循它了。后来，嵌入对象比如Java applets和ActiveX控件的网页的出现，增加了一个新的维度。</p>
<p>在OLE中，复合文档的概念更前进了一步。首先，任意的容器可以被允许。除Visual Basic表单外，Word文本、Excel电子表格、PowerPoint幻灯片等，都变成了OLE（Object Linking and Embedding）容器。而且，“控件”的概念被推广到任意的文档服务器中去。然而最大的变化是构件可以同时是文档容器和服务器。结果，Word文本能被用来注释一张PowerPoint幻灯片，而这张幻灯片也能被嵌入到另一Word文本里去。</p>
<p>复合文档还可以是一个把对象嵌入到了HTML页面里的网页。浏览器为所有的Web页面提供一个统一的文档模型。嵌入对象，比如Java applets，能根据需要加入细节。但是，现在有了强大的服务器端Web编程模型，例如Sun的JSP（Java Server Page）和Microsoft的ASP（Active Server Pages）及目前的ASP.NET。当合成一个基于后端数据和用户输入相结合的复合文档的时候，现代Web页面远远超过OLE技术的地方，正是这种服务器端模型。</p>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>尽管1998年才出现，但XML（扩展标记语言；W3C, 2000b）在此前大量尝试都失败的地方获得了成功。一部分原因是由于XML的一些有趣的属性；一部分是由于合适的时机。XML的到来与一个数量大量增长着的领域相关，特别是电子商务的领域需要用XML标准化。</p>
<p>XML对于表示任何（半）结构化的数据十分有用，新的XML的应用就应运而生了。除了消息、Web页和传统文档之外，现在普遍用XML来配置数据，即使这些数据从未被其他任何应用（而不是为之定义方案的应用）处理过或者阅读过，使用XML仍然是有用的。浏览器比如Internet Explorer，直接支持显示和查找XML文档。还有很多的工具为基于XML的数据提供其他普遍支持的形式，这些工具包括编辑器、方案检查器和方案驱动的翻译器。没有异常情况的话，XML在独立起源和操作的应用间作为一门公共语言来使用会获得最大的好处。在某种意义上，XML成了从协议和“布线”格式层到持久数据表示层的“布线”标准的概念。</p>
<h3 id="构件框架"><a href="#构件框架" class="headerlink" title="构件框架"></a>构件框架</h3><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>系统的体系结构是任何大规模软件技术的关键基础，在基于构件的系统中起着至关重要的作用。只有当整体的体系结构良好地定义和维护，构件及系统的升级和维护才会有坚实的基础。构件体系结构的核心包括：构件和外部环境的交互；构件的角色；标准化工具的界面；对最终用户和部署人员的用户界面等。</p>
<h5 id="体系结构的角色"><a href="#体系结构的角色" class="headerlink" title="体系结构的角色"></a>体系结构的角色</h5><p>体系结构是关于一个系统的整体视图，一个体系结构从总体上定义了总体的不变性，即那些根据这个特定的体系结构建立起来的所有系统的共同属性。体系结构把核心资源分类，以支持在资源竞争下的独立性。操作系统就是一个很好的例子，通过定义独立的进程之间如何竞争资源，操作系统部分地定义了运行于其上的系统所采用的体系结构。</p>
<p>体系结构为所有涉及的机制规定了恰当的框架，限制自由度，以控制变化性并支持协作。体系结构包括了所有支持独立使用机制进行互操作的策略决策。策略决策包括构件的角色。</p>
<p>体系结构需要基于对整体功能、性能、可靠性和安全性的主要考虑过细的决策可以放在一边，但关于所期望层次功能和性能的指导是必须的。例如，体系结构可能确切地规定一些细节来保证性能、可靠性或者安全性。在安全关键的应用中，有强调这些所谓非功能需求的传统。在任何体系结构中把这4个方面都作为一个整体的高优先级问题仍然是一个重要的目标。</p>
<h5 id="概念化"><a href="#概念化" class="headerlink" title="概念化"></a>概念化</h5><p>在概念层次上，划分层次、标志构件、分离关注点的作用是显而易见的。但在一个具体的体系结构中，它们是否还存在？更具有争论性的是，超越对象的粒度是否真有必要？有趣的是，有时认为对象最主要的优势是对象和对象间的关系在需求、分析、设计和实现等阶段是一致的（Goldberg和Rubin, 1995）。这种说法的成立需要两个前提，一是如果在所有的上述过程中都只有对象起主要作用；二是系统中所有超越对象的事物都可以被隔离。这两个前提也是所谓的“纯”面向对象方法的主要动机。</p>
<p>显然，并不是所有的事物都是对象。然而，任何需要一组对象进行交互的系统都可以通过指定一个代表对象来抽象这个交互对象组。此时，区分“has a”（或者“contain a”）联系和“use a”关系就变得很必要了。这个代表对象“包含”（“has a”）对象组，而组中的对象之间也可以通过代表对象的协调而相互使用（use）。以图的形式建模对象之间的关系时，对象是节点，联系是这些节点间的有向边。“has a”和“use a”分别是图际边和图内边。让我们考虑在时间和空间语境中支持对象转换的外部服务，例如，存储复合文档。在典型的外部行为中，图内边需要追溯下去；图际边不需要追溯，但需要抽象地保持为“连接”，连接象征性地代表了有向边的目标节点。</p>
<h5 id="构件系统架构特性"><a href="#构件系统架构特性" class="headerlink" title="构件系统架构特性"></a>构件系统架构特性</h5><p>●　构件系统体系结构由一组平台决策、一组构件框架和构件框架之间的互操作设计组成。</p>
<p>平台是允许在其上安装构件和构件框架的一个基础设施，支持构件和构件框架的实例化和激活。平台可以是实际平台，也可以是虚拟平台。实际平台提供了直接的物理支持——也就是在硬件上实现了它们的服务。虚拟平台（也可以称做平台抽象或者平台外壳）在其他平台之上仿真了一个平台，以支持灵活的成本权衡能力。</p>
<p>●　构件框架是一种专用的体系结构（通常围绕一些关键的机制），同时，也是一组固定地作用于构件层次机制的策略。</p>
<p>构件框架常常实现一些协议以连接构件，并强制实施一些由框架决定的策略。管理如何使用框架自身所用机制的策略并不确定。实际上，它们可以留给更高一层的体系结构来确定。</p>
<p>●　概念框架的互操作设计包括系统体系结构连接的所有框架间的互操作的规则。</p>
<p>这样的设计是第二等的构件框架，构件框架可以看成是它的内插构件。到现在我们可以确信第二层次是必要的——包含所有内容的单个构件框架是不切实际的。现在还不清楚第三层或者更高的层次是否必要，但此处暗示的元体系结构模型是可扩展的，允许增长。</p>
<p>●　 $\color{red}{\text{构件}}$ 是一组通常需要同时部署的 $\color{green}{\text{原子构件}}$ 。构件和原子构件之间的区别在于，大多数 $\color{red}{\text{原子构件}}$ 永远都不会被单独部署，尽管它们 $\color{green}{\text{可以被单独部署}}$ 。</p>
<p>相反，大多数原子构件都属于一个构件家族，一次部署往往涉及整个家族。</p>
<p>●　一个原子构件是一个模块和一组资源。</p>
<p>原子构件是部署、版本控制和替换的基本单位。原子构件通常成组地部署，但是它也能够被单独部署。一个模块是不带单独资源的原子构件（在这个严格定义下，Java包不是模块——在Java中部署的原子单元是类文件。一个单独的包被编译成多个单独的类文件——每个公共类都有一个）。</p>
<p>●　模块是一组类和可能的非面向对象的结构体，比如过程或者函数。</p>
<p>显然，一个模块可能静态地需要另一个模块的存在才能起作用。因此，一个模块只有在其依赖的所有模块都已经可用后才能部署。这个依赖图必须是无循环的，否则一组循环依赖关系的模块总是需要同时部署，这就破坏了模块定义的性质。</p>
<p>●　资源是一个类型化的项的固定集合。</p>
<p>资源这个概念可以包含代码资源，进而包含模块。问题在于除了编译器编译一个模块或包生成的资源外，还可能存在其他的资源。在“纯对象”的方法中，资源是外部化的不可改变的对象——不可改变是因为构件没有持久化的标志，而且复制不能被区分。</p>
<h5 id="分层的构件体系结构"><a href="#分层的构件体系结构" class="headerlink" title="分层的构件体系结构"></a>分层的构件体系结构</h5><p>层的概念和层次分解在构件系统中十分有用。构件系统的每一个部分，包括构件本身，都可以被分层，因为在一个更大的体系结构中，构件可以被定位到特定层次。为了控制更大型的构件系统的复杂性，体系结构自身也需要分层。</p>
<p>如前所述的构件系统体系结构具有一组开放的构件框架。这组构件框架形成了第二水平层次，而每个构件框架都定义了第一水平层次的体系结构。在这里，区分水平分层和传统的垂直分层之间的本质区别非常重要。传统的垂直分层，自底向上地，抽象程度渐增，与应用相关的性质逐渐提高。在一个良好的垂直分层系统中，各个层次都应该考虑相应的性能和资源。相反，水平分层是性能和资源相关性递减而结构相关性渐增的。不同的水平层次关注不同的集成性，但都与同一个应用相关。图9-1描述了在一个三水平分层多垂直分层的体系结构中垂直分层和水平分层的相互影响。如同描绘的那样，高水平分层提供了共享的低垂直分层以集成低水平分层。水平分层被描绘成相邻的，而垂直分层则是一个叠于另一个的上面。</p>
<details><summary>图9-1　三水平分层多垂直分层的体系结构——构件、构件框架和构件系统</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904003123.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904003123.png';" /></details>

<p>图9-2展示了构件实例之间如何相互通信。它们可以直接通信（例如，通过使用COM可连接对象、COM消息服务的消息、CORBA的事件或者JavaBean的事件），也可以通过构件框架做中介来间接通信，这时构件框架可以规范构件间的交互。当构件框架实例交互的时候同样的选择又会发生——这次的中介者是第三水平层次的运行实例。在图9-2中，CI代表构件实例，CFI（Component framework instance）代表构件框架实例，CFFI（Component Framework of Framework Instance）代表构件系统（或者构件框架的框架）实例。</p>
<p>在单体软件处于主导地位的世界里，甚至第一水平分层的体系结构都是不常见的。值得一提的是，对象和类框架并没有形成最底层的水平分层。水平分层的结构是从可部署的实体——构件开始的。传统的类框架只能形成单独的构件，独立于水平分层体系结构的布局。对象和类框架可以存在于构件内部。这些对象和类框架可以形成自己的层次，这取决于构件的复杂性，比如在OLE中的MFC。但是，当编译构件的时候所有类框架的结构都会被展平。跟构件框架不一样的是，类框架和它的实例间的界限是很模糊的，这是因为这个框架在运行时刻并不是实体，而在编译时刻，实例并不存在。这种二重性也可解释我们对术语“类”和“对象”常见的混淆。</p>
<details><summary>图9-2　多水平分层体系结构中的自由与间接的交互</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904003143.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904003143.png';" /></details>

<p>轻量级体系结构把注意力集中到一个问题，而不覆盖所有的问题，以有效支持轻量级构件的创建。这种构件的创建在一些限制性假设的前提下很容易想象出来。如果轻量级构件的指导性体系结构在限定其他决策的同时支持较好的易扩展性，那么它的商业价值就非常大。</p>
<p>中间件是一个软件集合的名字，这些软件位于操作系统和高层次分布式编程平台之间。中间件有时被分为面向消息的中间件（Microsoft Operations Manager, MOM）和面向对象的中间件（Object Oriented Method, OOM）。然而，现有的大多数中间件都是这两种类型的混合体。当然，现在也有一种趋势是由传统的操作系统直接支持。操作系统总是包含了对通信协议的支持。Web服务的推进和程序世界从以程序为中心到以协议为中心的转变，导致两种中间件的价值观：支持合适的协议或者提供简化本地服务构造的结构。</p>
<p>独立的中间件产品，如消息队列系统、事务处理监控器或者集线器，已经慢慢地消失了。取而代之的是结合了中间件功能和某个特定构件框架的特殊的服务器。应用服务器结合了应用管理、数据事务、负载平衡和其他的功能。集成服务器结合了协议转换、数据变换、路由和其他功能。工作流和复杂交互服务器结合了事件路由、决策和其他功能。</p>
<p>应用服务器市场有很多种不同的产品，包括IBM的MQ系列工作流系统和Microsoft的BizTalk服务器。集成服务器市场可能是最分散的，有各种提供商提供的各种类型的产品，包括CrossWorlds，IBM（WebSphere B2B Integrator），Microsoft（BizTalk server），Oracle（XML lntegration server），Tibco（ActiveEnterprise），WebMethods（Enterprise）和WRQ（Verastream）等。</p>
<h5 id="构件与生成式编程"><a href="#构件与生成式编程" class="headerlink" title="构件与生成式编程"></a>构件与生成式编程</h5><p>生成式编程致力于通过转换的方法来构造软件。这种转换对软件工程师来说并不陌生。编译器把源代码转换成目标代码，JIT编译器将中间代码变换成机器代码。然而，生成式编程试图超越传统的转换方法中转换器固定不变的弊端。其思路是允许程序员定义新的转换器。Czarnecki和Eisenecker（2000）详尽探讨了一个方法，它使用C++模版来定义变换。他们同样也讨论了很多其他的方法，包括诸如GenVoca家族（Batory和O\Malley，1992）中的特殊的生成技术。而Biggerstaff则更广泛地讨论了生成式方法的动机（1998）。在可部署构件的世界中，生成式方法在两个领域里面起着重要作用。它们可以用来生产单独的构件，也可以用来增强由构件组装的系统。如果用于生产单独的构件，生成式方法就限定在单个构件中。当目标是生产规模较大的构件或者是生产潜在的数目较大的相关构件时，这个方法显得特别有用。仔细挑选可以被边界条件参数化的技术是很重要的，这些边界条件是对生成构件的需求。特别地，必须要精确控制实际的构件边界，包括提供接口和需求接口。此外，必须能精确控制同其他构件间的静态依赖。</p>
<h4 id="语境相关组合构件框架"><a href="#语境相关组合构件框架" class="headerlink" title="语境相关组合构件框架"></a>语境相关组合构件框架</h4><p>构件框架使构件化软件发展成为最重要的一步。当前大多数研究的重点都放在单个构件的创建和基本构件间的绑定支持。在这种条件下，独立开发的构件几乎不可能进行有效的协作。因而，构件的独立部署和集成将无法实现。</p>
<p>构件框架是一个软件实体，该实体支持符合某种标准的构件，允许这些构件的实例“插入”构件框架。构件框架为构件实例创建了环境条件、规定了对象实例间的交互。构件框架能单独存在并为某些构件创建其生存空间，构件框架也能与其他构件和构件框架协作。因而我们可以很自然地把构件框架自身建模为构件。这样，我们可以在构件框架的基础上建立更高层次的构件框架，该构件框架规定了其底层构件框架间的交互。</p>
<p>构件框架关键性的贡献在于体系结构准则的部分强制要求。在构件框架的控制下，通过强制构件实例执行某种任务，构件框架能够强制某些策略执行。我们来看一个具体的例子，一个构件框架可以强制规定事件多播时的某种顺序，这样就排除了一类由于误操作或竞争而导致的难以捉摸的错误。</p>
<p>第一个对语境相关组合提供商业支持的也许是COM的“套间”模型。事实上，其下一代，MTS（Microsoft Translation Server）语境，能看做是当前所有语境相关组合方法（EJB容器、COM+语境、CCM容器和CLR语境）的源头。顺便提一句，必须注意EJB（Enterprise JavaBean）和CCM（Component Category Model）容器紧密地对应于MTS，COM+和CLR语境，而不是对应于OLE和ActiveX容器。一个OLE和ActiveX容器并不截取所有内含的控件的输入或输出调用。</p>
<h5 id="COM-语境"><a href="#COM-语境" class="headerlink" title="COM+语境"></a>COM+语境</h5><p>COM+源于COM“套间”和MTS语境。COM“套间”使用线程模型来分离对象；MTS语境通过事务域分离对象。COM+统一了这两个概念，同时也加入了大量的新的语境属性。无论哪种情况，用于驱动语境运行时语境的构造和将对象放置在合适的语境中的都是公开声明的属性。在COM“套间”的情况下，属性声明采用每一个COM类都有一个注册表项的形式。注册的条目要求类的实例必须仅仅被放置在单线程“套间”中，或者仅仅被放置在多线程的“套间”中。（COM+增加了可租赁线程“套间”的概念，在这种类型的“套间”中一次只允许一个线程入住，但是多个线程能顺序地入住该“套间”。）</p>
<p>微软事务服务器（MTS）引入了事务语境的概念。在MTS中运行的COM类的事务声明属性规定，该类必须或者位于非事务语境，或者位于新的事务语境，或者位于新的或是已有的事务语境，或者不做任何要求。通过这些声明，MTS和分布式事务协调器（Distributed Transaction Coordinator, DTC）共同创建了一个合适的事务域。相同事务域中的对象共享一个单独的逻辑线程和一个单独的共享事务资源集合（比如数据库连接和锁）。一旦线程从事务域中返回，事务要么提交要么终止，该事务域被销毁，该域所持有的资源被释放。</p>
<p>对于MTS的事务域，COM+增加了临时从一个事务域中返回、保持当前正在进行的事务的状态和在下一次调用时继续执行事务的功能。该模型允许客户端通过多个调用/返回接口进入一个事务服务的对话。（COM+也极大地扩展了语境属性、域和声明配置等概念。通过与以前的微软消息队列（Microsoft Message Queue, MSMQ））。服务集成以及加入几个其他的服务，COM+具有了大量的声明属性。COM+还引入了队列构件，这种类型的构件通过接收消息而实例化。</p>
<p>在COM+中，如果两个构件共享一组兼容的语境属性集，则它们可以被看做是处在同一域中。比如，如果两个对象共享相同的事务ID，则它们处于相同的事务域中。MTS中的域能够扩展进程和机器的边界。而MTS中的语境自身对进程进行了划分，而不是扩展了进程边界。相同语境中的对象具有相同的语境属性。域是同一属性的分组，而语境则基于属性集。图9-3显示了三个语境，两个属于相同的事务域（c2和c3），两个属于相同的负载平衡域（cl和c2）。这两个域都含有相同的语境c2。图中还显示了三个语境中的4个对象。对象u，v和w共享相同的负载平衡资源（资源ID为7），对象w和x共享相同的事务（事务ID为42）。</p>
<details><summary>图9-3　域和语境</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904003406.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904003406.png';" /></details>

<p>跨越语境边界的调用被拦截，然后根据语境属性或者被预处理，或者被置后处理，或者被拒绝。</p>
<h5 id="EJB容器"><a href="#EJB容器" class="headerlink" title="EJB容器"></a>EJB容器</h5><p>EJB为EJB实例提供了容器。虽然这些容器在MTS语境的基础上被模式化，但它们仍然有自己——也就是说，该类的实例需要直接调用事务API来开始、提交和结束一个事务。如此明确的控制使得这些类组装更加困难，但是当添加合法的事务代码时这种控制开辟了一条更加容易的道路。明确的控制在COM+中是可能做到的，但是不如EJB直接（本质上，外部控制需要独立存在于COM+的事务域之外，并且和微软的分布式事务控制器DTC直接发生交互）。</p>
<p>此外，EJB容器通过支持会话Bean和实体Bean支持持久对象。会话Bean的行为类似于MTS语境中的COM实例——旦事务结束（异常中断或是正常提交）其状态将丢失。实体Bean在事务正常提交时就保存至事务永久存储器。也就是说，Bean能够作为永久对象保存，除了可显式编写语句——这是MTS或COM+的唯一选择。</p>
<p>从版本2.0开始，EJB提供了改进的由容器管理的持久性和关系，提高了EJB实体Bean从一个应用服务器的容器到另外一个应用服务器容器的可移植性。EJB 2.0也增加了消息驱动的Bean类型，这是一个完全由数据驱动的EJB构件类型。与无状态会话Bean一样，消息驱动的Bean也是在消息到达时实例化，消息处理完毕后被销毁。这类似于COM+中的队列构件。消息驱动激活的概念可以追溯到IBM信息管理系统（Information Management System, IMS）的事务管理功能，该系统激活和停止IMS程序以处理队列消息。</p>
<h5 id="CCM容器"><a href="#CCM容器" class="headerlink" title="CCM容器"></a>CCM容器</h5><p>CORBA构件模型（CCM），CORBA 3.0规范的语境中被引入。正如EJB建立在MTS的概念上一样，CCM建立在EJB的概念上。CCM容器可以定义为EJB容器的超集（EJB规范和CCM规范分别发展的事实意味着，如果EJB不吸收CCM的进步、将二者融合的话，CCM将赶上EJB）。CCM在EJB的会话构件和实体构件之外增加了对过程构件的支持。更确切地说是，CCM的会话构件相对于EJB中的有状态会话Bean，然而无状态的会话bean在CCM中被称为服务构件。过程构件的实例的状态在一次调用后不再保持。过程构件实例具有持久的状态但是不能通过主键来定位。因此，过程构件对于捕获正在进行的过程状态是有用的，但不能用于捕获可确认的实体状态。</p>
<h5 id="CLR语境和通道"><a href="#CLR语境和通道" class="headerlink" title="CLR语境和通道"></a>CLR语境和通道</h5><p>CLR语境的内部设施也许是第一个尝试为语境相关组装提供真正的可扩展设施的主流结构。它不像MTS，COM+，EJB和CCM容器，其所谓的语境属性的列表不是封闭的。如果语境中的对象确实需要，那么第三方就能够在语境边界上添加新的属性。这样，当调用跨越语境边界时，语境的属性能够截取、产生作用或操作任何输入和输出消息。</p>
<p>当构造一个新的语境时，CLR提供一个一次性的机会在语境边界上设置属性。一个特殊的语境属性可以通过编程的方式添加，比如通过其他的属性或是请求创建该属性的对象。另外，一个新的语境属性能够被创建它的对象公开地请求。公布的机制依赖于CLR的定制属性——能够直接被CLR类替换的可扩展元数据。类似于COM+属性或是EJB的部署描述，这样的定制属性需要明确的声明。比如，一个类需要同步支持。当实例化时，系统检查这个新的对象是否处于一个具有同步属性的语境中。.NET框架为COM+企业服务定义了标准的属性。这样，通过CLR-COM之间的互操作内部结构，在CLR中调用COM+的服务，创建被管理的对象就变得很容易了。</p>
<p>CLR对象有4种类型——值类型、传值类型、传引用类型和语境约束类型。在通过应用域（AppDomain）的边界通信时，值类型和传值类型都是使用值编排。传引用和语境约束类型则都是将应用编排。其中唯一有趣的方面在于它们创建了一个方便的编排边界。编排在通道上执行，并能加入新的通道类型。标准类型包括在SOAP/HTTP协议之上编排和在DCOM（Distributed Component Object Mode）之上编排。在通道的末端，如果系统为传引用类型的对象设置了代理则系统会重新构造传值对象。新的代理实现也可以被加入。</p>
<p>语境约束类型总是位于一个带有合适属性的语境中。位于语境之外的其他对象是语境“（agile）”。COM中类似的概念叫“套间（agile）”对象，但这个概念不安全。不过，在CLR中，对语境约束对象的应用不能撤销。当调用通过语境边界时，语境边界拦截所有调用者或者被调用者是语境约束对象的所有调用。例如，当在一个“（agile）”对象的域中存储一个语境约束对象的引用时，先传递该引用到另外一个语境，当通过该引用调用对象的一个方法时，该调用将会被拦截。如果该引用——通过各种方式——回到了原来的语境中，则当另外一个调用到达时，该调用将不会被拦截。</p>
<p>默认的情况下，新的对象放置在和请求创建新对象的对象一样的语境中。或者，新创建的对象可以选择其他的语境（不过需要该语境中另一个对象的“帮助”）或者创建一个新的语境。如果被选中的语境的属性与该对象声明的要求不匹配，则一个新的语境将自动被创建。</p>
<h5 id="元组和对象空间"><a href="#元组和对象空间" class="headerlink" title="元组和对象空间"></a>元组和对象空间</h5><p>在所有以上方法之前的一个关于语境相关组装的方法是基于无所不在的数据空间的概念，数据空间能够在不需要明确寻址的情况下被用于通信。该工作的发起人是耶鲁大学的David Gelernter和他的小组（<a target="_blank" rel="noopener" href="http://www.cs.yale.edu/Linda/linda.html%EF%BC%89%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%AF%A5%E8%AE%BE%E8%AE%A1%E9%A2%86%E5%9F%9F%E3%80%82%E7%89%B9%E5%88%AB%E8%A6%81%E6%8C%87%E5%87%BA%E7%9A%84%E6%98%AF%EF%BC%8C%E7%94%B1Nicholas">www.cs.yale.edu/Linda/linda.html），他们建立了该设计领域。特别要指出的是，由Nicholas</a> Carriero和David Gelernter创建的Linda协作语言引入了元组空间的概念。那些保存有原子数据的空间就称为元组。在元组空间上，Linda仅仅定义了三种基本的操作——添加一个元组到一个空间中、在一个空间中匹配和读取一个元组、在一个空间中匹配和删除一个元组。当前这种思想的“追随者”是JavaSpaces（java.sun.com/products/javaspaces）。</p>
<p>协调数据和对象空间有一些附加的好处，比如我们没有必要确认构件实例之间的位置和它们的依赖性，决策安排也与数据流上的功能需求完全分开。同时，这些性质也面临着挑战。比如，为了避免在分布式实现中的集中瓶颈问题，元组空间不应该位于一个单独的物理位置。然而，为了实现高效的安排，有效的信息和被请求的数据元组或对象需要被传播至系统的每一个部分。保持元组空间操作原子性的需求使得对机构的要求进一步复杂化。</p>
<p>元组和对象空间对语境相关组装的求精有潜在的好处——即数据驱动的组装。在写这本书的时候，该方法已经不局限于研究项目，并影响着主流的技术。然而，有的人会说目录结构的广泛使用是元组空间融合的有趣的例子。这方面的例子包括因特网域名服务（DNS），轻量级目录访问协议（LDAP）目录，微软的活动目录和Web服务的UDDI目录。</p>
<p>目录假定了一个弱一致性模型，即条目很少被复制，临时的更新不一致性也是可以忍受的，条目改变的频率远远低于读条目的频率。这些性质保证了目录实现能进行大规模甚至是全局的可扩展性。比如，DNS就被实现为DNS服务器的全局层次，这些服务器联合起来以惊人的速度来处理数百万台机器的基于DNS的名字解析请求。</p>
<p>可以证明，所有主流的构件方法都是依靠目录来进行某种形式的语境组装，而没有哪种主流方法是像Linda协作方法所建议的那样通过构件框架来做。相反，目录服务通过一些API得以应用，而协作的工作则留给客户端构件的开发人员。</p>
<p>更通用的数据驱动的构件框架也是存在的。在COM+的队列构件或者J2EE的消息驱动Bean中，数据的分布就是通过面向消息的中间件（消息排队系统）来进行的。消息的到达引起相应的处理构件的自动激活，后者则通过在局部产生影响或者进一步发送消息来做出响应。</p>
<h4 id="构件开发"><a href="#构件开发" class="headerlink" title="构件开发"></a>构件开发</h4><p>面向构件的编程目前仍然是一门年轻的学科，其涉及的许多方面仍需要进一步地研究。本章的论述主要涉及了面向构件编程的方法学、环境和语言等三个方面。编程方法学主要考虑如何用一种系统化的方式来进行构件系统的划分、构件的交互和建造。而编程的环境和语言则主要考虑如何表现和支持特定的编程方法学。</p>
<h5 id="color-red-text-面向构件的编程方法学"><a href="#color-red-text-面向构件的编程方法学" class="headerlink" title="$\color{red}{\text{面向构件的编程方法学}}$"></a>$\color{red}{\text{面向构件的编程方法学}}$</h5><p>如同面向对象的编程（OOP）关注于如何支持建立面向对象的软件解决方案一样，面向构件的编程（Component-Oriented Programming, COP）关注于如何支持建立面向构件的解决方案。一个基于一般OOP风格的COP定义如下（Szyperski, 1995）：“面向构件的编程需要下列基本的支持：</p>
<p>—— $\color{green}{\text{多态性}}$ （可替代性）；</p>
<p>—— $\color{green}{\text{模块封装性}}$ （高层次信息的隐藏）；</p>
<p>—— $\color{green}{\text{后期的绑定和装载}}$ （部署独立性）；</p>
<p>—— $\color{green}{\text{安全性}}$ （类型和模块安全性）。”</p>
<p>面向构件的编程仍然缺乏完善的方法学支持。现有的方法学往往只关注于单个构件本身，并没有充分考虑由于构件的复杂交互而带来的诸多困难。其中的一些问题可以在编程语言和编程方法的层次上进行解决。这其中，面向连接的编程尤其吸引了语言设计领域众多研究者的关注，例如，ArchJava（Aldrich等人，2002和Jiazzi McDermid等人，2001）。然而，面向连接的编程并不是通向面向构件的唯一途径。</p>
<p>分层体系结构或其他体系结构的设计方法有助于控制系统的复杂性，并能够指导系统的演化。但是，单独依靠体系结构并不能有效地指导构件及构件框架的开发活动。许多问题仍然没有得到根本的解决。主要问题如下。</p>
<p>1）异步问题</p>
<p>当前的构件互连标准大都使用某种形式的事件传播机制作为实现构件实例装配的手段。其思想是相对简单的：构件实例在被期望监听的状态发生变化时发布出特定的事件对象；事件分发机制负责接收这些事件对象，并把它们发送给对其感兴趣的其他构件实例；构件实例则需要对它们感兴趣的事件进行注册，因为它们可能需根据事件对象所标志的变化改变其自身的状态。</p>
<p>2）多线程</p>
<p>“多线程会使你寝食难安。”Swaine在后来的著作中解释，他的一些与此相似的论断具有明显的煽动性，但是他并不认为这些论断是错误的。多线程是指在同一个状态空间内支持并发地进行多个顺序活动的概念。相对于顺序编程，多线程的引入为编程带来了相当大的复杂性。特别是，需要避免对多个线程共享的变量进行并发的读写操作可能造成的冲突。这种冲突也被称做数据竞争，因为两个或多个线程去竞争对共享变量的操作。线程的同步使用某种形式的加锁机制来解决此类问题，但这又带来了一个新的问题：过于保守的加锁或者错误的加锁顺序都可能导致死锁。</p>
<p>多线程主要关注于对程序执行进行更好的分配，发送并发请求的客户端能够很好地观察到这种分配。然而，获取性能最大化的手段却根本不依赖于多线程，而是尽量在第一时间内以最快的速度处理用户的请求。即使能够避免死锁，同步也可能导致一定程度的性能损失。必须避免对经常使用的共享资源进行不必要的加锁。跨线程的异常传播也会导致处理非同步的异常变得更加困难。而且，使用多线程和复杂的互锁机制将使得代码调试变得异常困难。</p>
<p>显然，在真正并发的环境下，这些问题无一不需要考虑。例如，如果构件实例运行在独立的处理器上，就需要考虑并发请求的问题。可以在处理一个请求时对某个构件实例进行完全的加锁，但这样做可能会导致死锁或者糟糕的响应时间。</p>
<p>3）“生活”在没有实现继承的状态下</p>
<p>构件间的实现继承所引起的严重问题使得人们倾向于使用简单对象组合或消息转发来替代实现继承。但是，当我们仅需要对已有的实现进行轻微的修改时，这种替代方式却又显得太笨拙。创建一个具有很多方法的类的子类，且只重写父类中一小部分方法是很容易实现的。相对而言，仅为转发一小部分方法调用而生成一个新的包装类却是一件十分繁琐的事情。除了实现上的开销以外，简单的转发还增加了运行时的开销（执行时间和代码占用空间的增加）。</p>
<p>当一个对象中的方法被分组成若干个接口，每个接口中含有数目恰当的方法时，COM风格的聚合有助于避免由于转发所带来的性能损失。通过使用多种自动化技术，对于程序员而言，其实现成本没有丝毫的增加。</p>
<p>一种解决方案是根据转发目标对象的接口生成转发类的代码。这种方案的弱点也是所有代码生成途径所共有的：目标对象接口的改变要求重新生成转发类的代码，或者手工调整旧的生成代码。</p>
<p>另外一种解决方案是利用模板机制（如C++中的模板）在编译时刻生成所需的代码。模板可以通过参数化的方式配置，而不必手工编辑生成的代码。编译器根据模板的实例化参数来生成最终的代码。</p>
<p>4）坚壳类</p>
<p>第三种解决方案是使用实现继承。虽然一般来讲实现继承具有严重的问题，但对于白盒类（以完整的源代码形式发布并且不再被改变的类）使用实现继承是没有问题的。对经常成为转发目标的构件接口来说，可以为其关联一个专门负责处理转发者琐碎细节的坚壳类（Szyperski, 1992b）。坚壳类与转发目标具有相同的接口，而且所有方法的实现都是简单地向目标转发消息。坚壳类本身是抽象的，尽管所有的方法都有实现，但是这种实现完全没有引入新的功能。（有趣的是，某些语言包括C++，无法表现这样一个事实，即一个没有抽象方法的类仍然是抽象类。）然而，可以通过继承坚壳类去截取某些方法调用，从而产生一个有意义的转发者。由此导致的程序员工作量与一般的实现继承类似，但产生的效果是转发而不是代理。</p>
<p>Java中的代理类（proxy class）就是这样的一种机制。一个代理看起来是某种给定的类型，但其内部却实现为代理类的一个子类。这种实现提供了一种对调用进行截取的机会。CLR通过实时代理类也提供了类似的机制。</p>
<p>5）语言支持</p>
<p>第四种解决方案是语言支持，这种解决方案或许更易于被接受。如果编程语言直接支持转发类的构造，则所有以上方案的缺点都可以被避免。编程的开销也将是最小的，且在运行时刻时间和空间上的开销与实现继承方式相比也都是一样的。但目前还没有主流的编程语言来支持这种构造。比如，C++的虚拟基类机制不允许在几个独立的对象之间共享基类对象。它也不允许动态改变基类对象，或虚拟基类的独立子类化。Objective-C（Apple Computer, 2000; Pinson和Wiener, 1991）是一种支持对象动态继承的非主流编程语言。</p>
<p>6）调用者封装</p>
<p>语言支持带来的另外一个好处是接口定义。当构件对外提供一个接口时，可能会涉及两种不同的意图。一方面，构件外部的代码可能会调用这个接口中的操作。另一方面，构件内部的代码可能需要调用实现这个接口的一些操作。在COM技术中，这体现为入接口和出接口的差异。除了Component Pascal以外，没有别的语言能够恰当地支持构件的纯出接口。</p>
<p>正如许多传统的封装机制一样，如果出接口和入接口之间的对称可以被接受，那么仅对调用者而不是对被调用者进行封装也就不应该令人感到惊奇。然而，适合于构造构件的调用者封装机制被大多数的语言丢弃了。在类似Simula的语言，包括Beta语言（Lehrmann Madsen等人，1993），均支持内部方法。在类的层次上，这种机制和调用者封装很相似。引介基类（Introducing Base Class）之外的代码无法访问由子类所实现的内部方法。每个人都可以试图调用该方法，但是基类代码的执行受到了保护，至少能够动态地防止非法的外部调用者。</p>
<p>调用者封装策略被应用于黑盒构件框架的若干方面。例如，只有框架可以调用视图的关键方法。如果框架在早些时候捕获了对同一个视图的同一个方法调用产生的异常，它将会阻止对此方法的进一步调用。这样，产生错误的视图的某些方法将被屏蔽，从而不会再继续扰乱系统的运行。黑盒是很少几个能够保证嵌在复合文档中的视图不会破坏文档的整体性的系统之一。</p>
<h5 id="环境与选择目标框架"><a href="#环境与选择目标框架" class="headerlink" title="环境与选择目标框架"></a>环境与选择目标框架</h5><p>脱离了良好定义的环境，一个构件实例是不能正常工作的。构件框架定义了这样的环境。然而，一个构件实例可能被设计成可以在多个构件框架中工作。根据构件系统体系结构的不同，框架可以根据不同的角色被分割成不同的子框架。例如，每个框架都可能会采用某种特定的机制实现构件之间的协同运作。在这种情况下，分布式框架可能会负责在机器之间分发构件实例。而另外一个单独的框架将会负责对复合文档的集成。构件的设计可能需要考虑所有的这些子框架，以使得最终的构件实现能够在这些框架下正常运行。</p>
<h5 id="工具与选择编程语言"><a href="#工具与选择编程语言" class="headerlink" title="工具与选择编程语言"></a>工具与选择编程语言</h5><p>原则上，构件编程几乎可以使用任何一种语言，并采用任何范型。并不存在所谓的最低需求。构件编程主要关注的是对相关构件的多态处理。由于构件之间的交互需要动态进行，因此就必须支持后期绑定。参数构造安全性还需要封装及安全——类型安全和模块安全——的支持，在大多数情况下垃圾回收的支持也是必需的。此外，构件编程需要一种能够显式化声明状态依赖的机制，理想情况下应该保持这些依赖是可以参数化的。对实现中的依赖进行完全的参数化导致了面向连接的编程。在语言范型的层次上，面向对象范型最接近于面向构件的编程范型，但是其他的范型，比如功能范型，可能也是合适的。</p>
<p>到目前为止，只有少数编程语言在应用层次上支持面向构件的编程。许多流语言，如COBOL、Object COBOL、FORTRAN、C、C++ Pascal和Smalltalk在不同程度上均缺少对封装、多态、类型安全性、模块安全性的支持。</p>
<p>Java、C#和Component Pascal都分别支持在包一级或者模块一级的访问保护。通过这种方式，可以建立对模块安全性的支持。但Java的开放包机制对模块安全性的支持太过脆弱。即使不使用替换目标文件的方式，也可以通过向包中添加新的类，从而完全穿越包机制提供的保护！这种漏洞需要通过另外的途径来弥补。因此，需要把包放在文件系统中的保护目录下，或者其他带有访问控制的地方。在一个从远端服务器动态获取类文件的环境中，这种情况将变得更为复杂。需要一种机制来保证同一个包中的类文产生于同一个编译源。为了支持更加开放的设置，Java或许需要采用封闭的模块构造机制，其中每一个这样的模块被映射到一个被发布的编译文件上。Java的嵌套类机制有助于建立真正的所谓模块，但是Java缺少一个能够支持对一个类及其嵌套类的访问保护层。另外，由于JVM实际上并不真正支持嵌套类，Java编译器不得不把嵌套类抽取出来，放入单独的类文件中。</p>
<p>C#令人感兴趣的地方在于其模块级访问保护适用于集合。C#的任何构造机制（事实上任何基于CLR的语言都适用）可以被打包成为一个集合。一旦被打包，该集合也就被加密了，从而避免对其的任意窜改，这也使得对集合内部的访问控制机制变得强大和有效。因此这种基于CLR的集合内部访问机制是目前为止最灵活的包概念。</p>
<h4 id="构件组装"><a href="#构件组装" class="headerlink" title="构件组装"></a>构件组装</h4><p>构件是可被第三方独立部署的基本单元。每个构件的部署过程之间不是相互孤立的，构件实例之间通常会在一个或多个构件框架的介入下发生交互。将构件组装成系统的一种显而易见的方法是通过传统的编程方式进行。然而，由于这种方式支持用较简单的方式生成大多数常用的构件系统（或由于其能够完全避免单独的组装过程），因此构件的适用范围和生存能力都大大地增加了。</p>
<h5 id="构件初始化及互连"><a href="#构件初始化及互连" class="headerlink" title="构件初始化及互连"></a>构件初始化及互连</h5><p>体系结构描述语言（ADL）即遵从了这样的思想：这些语言通常都把构件和连接子作为其核心的建模概念。组装因此表现为选择一组构件并通过适当的连接子将这组构件进行连接的过程。基于这种方式的组装过程实际描述的是被选择的构件的“实例”应该如何通过适当的连接子“实例”互连的过程。这个细节揭示的一个重要之处在于：构成一个组合体的基本元素是构件或连接子的实例而不是构件或连接子本身。例如，虽然概念上一个构件可以出现在两个组合体中，但实际上是这个构件的不同实例将出现在这两个组合体的若干实例中。</p>
<p>BML（bean markup language）是种由IBMalphaWorks实验室在1998年发布的针对JavaBean的构件组装语言。BML基于XML并针对JavaBean构件模型进行了定制。通过使用XSLT，可以从更抽象的系统描述中生成BML。实际上，BML自身与JavaBean构件模型已相当接近，能够支持Bean构件实例的创建、访问及配置等操作。为了支持配置，BML允许对Bean属性进行访问和设置。当提供了具有这种配置方式的Bean构件实例后，BML能够用来绑定Bean构件，使其作为监听者监听其他Bean产生的事件。BML既可以通过直接产生配置后的可运行子系统而被解释，也可以被编译而生成Java代码。BML解释器的基础是bean定制化框架。该框架也能够支持实现不同于BML的其他形式的bean配置和互连语言。</p>
<p>1）构件的可视化组装</p>
<p>构件实例的可视化组装方式能够有效地简单化组装过程。例如，JavaBean构件能够区分其实例的使用和构造阶段。一个bean因此可以表现出特定的外观（例如，一个类似建筑单元的图标）、行为（例如，一个可以和其他实例连接的句柄）和帮助信息（例如，针对特定人员的构件组装帮助文档）。在组装过程中，构件被实例化，实例通过统一的方式把其具有的出接口和入接口连接到相关的实体上。JavaBean和COM技术均支持这种一般方式的连接范型。</p>
<p>2）用复合文档取代可视化组装</p>
<p>在构件实例可见的情况下（通过提供一个可视化的用户界面），专业的构造器或组装环境可以和一般用途的软件开发环境相统一。而通过复合文档，构造和使用这两个不同的环境也可以自然直接地集成在一起（文档代表应用系统），对文档的编辑相当于构件（实例）的组装过程。在这样的系统中，构件的组装者和使用者之间不存在任何的隔阂。这两者之间的平滑过渡就如同在已有构件组合体的基础上，通过后期组装生成新组合体，与通过编程生成新组合体可以随意地相互结合使用，以满足特定应用系统的需要一样。因此，为了全面地满足使用者的需求，组装机制应该具有在使用时刻的可用性。黑盒构件构造器及构件框架即遵循了这样的途径。虽然我们可以通过不部署所需的构造器构件的方式来区分构件的组装和使用，但复合文档并不对这两者做严格的区分。</p>
<p>构造环境和使用环境的无缝集成（特别是在复合文档的方式下）也形成了对于快速应用开发（Rapid Application Development, RAD）的强有力支持。在这样的环境中，工业级构件、原型构件及一次性解决方案可以自由地结合。需求捕获和对需求改变请求的确认也可以高效且有效地执行。如果企业或组织需要，经过相应的培训后，最终用户可以进一步地调整他们的系统。</p>
<p>3）非图形用户界面环境的构件</p>
<p>大多数早期的构件化软件方法往往关注于客户端的前台交互式应用系统。现代图形用户界面的需求本质，加上用户界面的相对规则性，使得与用户界面相关的可重用构件成为具有独特价值的软件资产。然而，计算的其他领域，特别是基于服务端的解决方案，存在同样甚至更多的复杂性，而且已经引起了现阶段许多构件化软件方法的关注。</p>
<p>对基于服务的构件，构造和使用阶段的清晰划分显得更为自然。Oliver Sims于1994年提出的业务对象，是最早提出的针对“无处不在的构件”（Components Everywhere）思想的建议之一。接下来的一个重要进展则是Java servlet的出现。Java servlet是运行于服务器上的构件，但它们仍可以通过可视化的方式来进行组装。为了与现存的构件模型良好协调（包括CORBA提出的构件模型），使用前的组装通常需要较早地做出某些决策，如分布式系统中构件实例的分布决策。值得注意的是，虽然对象迁移能够带来的益处仍然值得讨论，但大多数系统，包括当前的CORBA实现，都支持持有其他对象引用的对象的迁移能力。然而最近的一些围绕Web服务的途径（基于SOAP），却不支持对远程对象引用的传递。相反，SOAP主张对定位器（Locator）的传递，如URL或COM中的moniker。这些定位器在不同的机器上每次可能会被解析到不同的对象上。因此，远程对象标志这个概念在SOAP和Web服务中并不存在，迁移问题也由此变得非常简单。</p>
<p>关于服务端构件模型的典型解决方案包括适用于应用服务器的EJB模型（Sun公司J2EE的一部分）和COM+模型（微软公司），以及适用于Web服务器的servlet模型（基于Sun公司JSP技术）和Visual Basic及其他技术（基于微软公司ASP技术）。微软的.NET框架还引入了一种新的同时适用于客户端和服务端的基于CLI（Command Line Interface）的构件模型。</p>
<p>4）可管理且“自引导的”构件组装</p>
<p>构件的组装实际上是指对构件实例的组装（一个采用对象技术实现的构件实例通常是一个由若干对象形成的消息网络）。当然，通过组合已有构件来实现新构件也是可行的，这种方式类似于传统的基于底层函数库构建高层函数库的过程。换而言之，构件组装（不是构件实例）只不过是编程的一个代名词，而构件实例的组装并非如此。构件实例组装提倡把实现构件的代码和资源与“连接”构件实例的代码这两个方面保持分离。构件实例的连接可以通过轻量级编程的方式（如编写脚本）来实现，而新构件的编写则应采用其他的方式（脚本语言或接口语言并不适合编写构件，因为编写构件与连接构件实例有本质的不同）。</p>
<p>5）最终用户组装</p>
<p>当需要时，允许最终用户进行系统组装以获得高度定制的解决方案是非常有价值的。最终用户的参与导致产生了一个有趣的、介于完全自引导和完全静态预定义之间的构件组装模式。显然，即使有最终用户的参与，组装过程仍然需要一定程度的自引导性。我们不应当期望用户能够完全承担技术细节层次上的构件组装工作。</p>
<p>系统组装分为三个不同的层次：定制（customization）、集成（integration）和扩展（extension）。这三个层次对应于构件组装过程中的不同任务。但这种最终用户剪裁仅仅是从用户的角度观察其关心的领域问题，而不是从构件组装的技术角度来进行的。Robert Slagter和Henriter Hofte（2002）展示了这种思想在计算机支持的协作应用软件系统中的一个有趣应用。该系统支持最终用户根据需要去组合群件的行为。Groove Transceiver（<a target="_blank" rel="noopener" href="http://www.groove.net)具有的类似特征则允许最终用户通过选择和配置工具快速地组装工作空间./">www.groove.net）具有的类似特征则允许最终用户通过选择和配置工具快速地组装工作空间。</a></p>
<p>6）构件演化</p>
<p>构件技术体现了一种后期组装的思想。构件的逐渐成熟会进一步推后组装（或绑定）时间，但随之而来的是整个系统将变得越来越脆弱。构件通常也会经历一般软件产品具有的演化过程。</p>
<p>安装新版本的构件将会与期望使用旧版本构件的现有系统发生冲突，甚至直接与现存的旧版本构件实例发生冲突。相对于已经实例化的构件，一个构件从构件库中被获取并实例化的时间越晚，潜在的版本冲突问题就会越严重。</p>
<p>在分布式系统中，为安装新版本的构件实例而终止所有现有构件的运行是不现实的。不同版本的客户端和不同版本的构件实例之间的二进制互操作性需要在版本间二进制兼容性中就加以考虑。如何实现构件实例的在线版本升级仍然是一个非常活跃的研究领域。</p>
<p>在实际配置中，必须考虑构件的不同版本实例共存于一个系统的情况。系统的升级就是一个重要的例子。除采用多版本共存技术之外，解决“遗留系统移植”问题还需要通过使用包裹器构件来适配旧版软件或解决系统不兼容性。</p>
<p>支持版本共存和包裹器构件技术的方法之一是COM所使用的方法。按照约定，一旦COM接口被发布，其就不能再被更改。因此，COM中不存在针对单个接口的版本问题。一个提供新版本服务的构件将不得不使用一个新的接口。采用这种方式的一个重要优点是它使得同时支持具有不同语义的新旧接口成为可能。显然，一旦一个接口不再被支持时，该接口就可以从系统中安全删除。</p>
<p>CORBA采用的版本管理机制的能力则较弱，它仍然试图将所有版本的所有操作合并成一个接口。因此，这种方式不支持仅改变操作的语义而不改变该操作名称或原型的能力。由此导致的一个后果是，虽然可以引入操作的新名称，但若想删除一个旧的操作而不改变二进制兼容性却非常困难。甚至SOM的版本序列机制（SOMs Release Orders）也无法解决这个问题。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2662a2c4034a">什么是corba</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch8-XML%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch8-XML%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch8-XML技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:54:26" itemprop="dateCreated datePublished" datetime="2021-07-19T12:54:26+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-03 23:44:57" itemprop="dateModified" datetime="2021-09-03T23:44:57+08:00">2021-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="XML技术"><a href="#XML技术" class="headerlink" title="XML技术"></a>XML技术</h2><h3 id="XML概述"><a href="#XML概述" class="headerlink" title="XML概述"></a>XML概述</h3><p>可扩展标记语言（XML）是标准通用标记语言（Standard Generalized Markup Language, SGML）的一个子集：XML包含了很多SGML特性，但是比SGML要简单得多。像SGML一样，可以用XML来开发一种标记语言，它的元素和属性多是为专门行业和产业而定义的。创建这种语言之后，就可以使用XML——就像使用HTML（Hypertext Markup Language）一样——来标记并结构化文档了。</p>
<p>XML和HTML都支持统一字符编码协会（Unicode Consortium）制定的通用字符集（Universal Character Set, UCS），它不仅包括特殊字符、标点和数学符号，还包括了非英语语言的字符和字母表，这使得XML成为了国际标准，这些字符和符号被认为是实体。XML和HTML都支持样式表（style sheet）的使用，样式表有助于你定义整篇复杂的文档的结构和外观。然而，HTML在许多方面都传统地定义了它的输出样式（当然最新版的HTML和由它继承而来的XHTML极力鼓励你使用层叠样式表来编制文档的样式）。而且，XML在支持文档样式符号、规范语言（The Document Style Semantics and Specification Language, DSSSL）和层叠样式表（Cascading Style Sheets, CSS）等性能方面大大超过了HTML。</p>
<p>专为XML“服务”的样式表标准是可扩展样式表语言（Extensible Stylesheet Language, XSL），它是基于在线文档样式符号和规范语言（DSSSL-O）的，DSSSL-O是DSSSL的一个子集，像CSS一样是专门为电子文档而创建的。有关CSS的更多信息，请参考同样由Sandra E.Eddy著IDG Book Worldwide公司出版的《XHTML参考教程》，XSL在本书第2部分的“XSL样式表语法”和第7章的“使用XSL设计文档”中分别都有介绍。XSL现在还只是一个建议，要跟上它的发展，请浏览其最新的建议：<a target="_blank" rel="noopener" href="http://www.w3.org/TR/xsl/%E3%80%82XSL%E8%BD%AC%E6%8D%A2%EF%BC%88XSL">http://www.w3.org/TR/xsl/。XSL转换（XSL</a> Transformations, XSLT）是一种新的语言，它可以和XML协同工作。请参阅“XSLT组件”中的有关XSLT的内容。</p>
<p>XML包括如下特点和功能：</p>
<p>（1）XML允许各种各样的文档显示类型，不仅可以显示在许多计算机平台上，而且可以显示蜂窝电话、掌上电脑等其他设备上。程序员可以使用任何编程语言或脚本语言来定义文档。</p>
<p>（2）XML支持但并不需要DTD （Document Type Definition，文档类型定义）。如果你使用DTD，就要通知XML编辑器严格地按照DTD中设定的规则来处理文档。</p>
<p>（3）XML的支持标准（XLink和XPointer）支持比HTML更为复杂的链接。在HTML和XML中你只能链接到一个URL。然而在XML支持标准中可以同时使用几个或者一组链接。</p>
<p>（4）XML标准支持打印文档和电子文档以及其他的为不同用户定义了不同内容和外观的文档。</p>
<p>（5）XML支持客户端或者服务端计算机上的进程，这就允许开发人员分配资源和随时地节省资源。当前，XML 1.0规范已经定义了，而XLink和XPointer语言仍处在开发和候选建议状态，这意味着它们已经被各技术团体评论过了。在成为最后建议之前，两种语言都可能发生改变。</p>
<h4 id="XML基本语法"><a href="#XML基本语法" class="headerlink" title="XML基本语法"></a>XML基本语法</h4><p>本节将比较简略地介绍XML的基本语法，通过一个基本文档的例子来了解它的实质内容。希望这部分内容对于初次接触XML技术或者Web服务技术的读者，能有一个简要的知识铺垫。</p>
<p>以下是XML 1.0规范（第2版）的规范文本和该版本的中译本的URL。</p>
<p>●　<a target="_blank" rel="noopener" href="http://www.w3.org/TR/2000/REC-xml-20001006">http://www.w3.org/TR/2000/REC-xml-20001006</a></p>
<p>●　<a target="_blank" rel="noopener" href="http://lightning.prohosting.com/-ggiu/REC-xml-20001006-cn.html">http://lightning.prohosting.com/-ggiu/REC-xml-20001006-cn.html</a></p>
<h4 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h4><p>XML标签负责提供、描述一个XML文件或数据包（也就是大家所熟知的XML实体）的内容结构。它们由界定内容的不同部分的标签（tag）所组成，负责提供到特殊符号和文本宏的引用，或者将特殊指令传递给应用软件，以及把注释传递给文档编辑器。</p>
<p>XML元素的结构与HTML基本相同，XML也同样使用尖括号来界定标签：以小于号（〈）结尾，但二者的相同点也就仅此而已。</p>
<p>与HTML不同，几乎所有的XML标签都是大小写敏感的，其中包括元素的标签名和属性值，主要是满足XML国际化的设计目标和简化处理过程的需要。大多数非英语的语言并不把字母表分成若干种写法，许多字母可能也没有对应的大写或小写。合并写法会存在许多缺陷，尤其对于非ASCII码更是如此，而XML的设计者们大多选择避免这些问题。</p>
<h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><p>由于XML要在全球范围内使用，所以不能局限于7位的ASCII码字符集。XML指定的字符均在16位的Unicode2.1字符集（参见<a target="_blank" rel="noopener" href="http://www.unicode.org,它目前与iso/IEC">http://www.unicode.org，它目前与ISO/IEC</a> 10646一致，后者可参见<a target="_blank" rel="noopener" href="http://www.iso.ch)中定义.这些都是相对较新的标准,而且当今世界还有许多文字没有编入统一码中.但是,由于它被设计为大多数现存字符编码的超集,所以遗留的内容向统一码的转换也是简单直观的,例如,把ascii码转换成统一码只需要把16位字符的前8位填充为0(而保留后8位)即可./">http://www.iso.ch）中定义。这些都是相对较新的标准，而且当今世界还有许多文字没有编入统一码中。但是，由于它被设计为大多数现存字符编码的超集，所以遗留的内容向统一码的转换也是简单直观的，例如，把ASCII码转换成统一码只需要把16位字符的前8位填充为0（而保留后8位）即可。</a></p>
<h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p>在XML中使用的结构几乎总是被命名的。所有XML命名都必须以字母、下划线（_）或冒号（:）开头，后面跟着的是有效命名字符。有效命名字符除了前面的这些字符外，还包括数字、连字符（-）、句号（.）。在实际应用中不应该使用冒号，除非是用作命名空间修饰的分隔符（可参见本章后面的关于命名空间的相关描述）。字母并非局限于ASCII码，这一点是非常重要的，因为不说英语的人们可以把自己的语言用在标签中。</p>
<p>下面就是一些合法的命名：</p>
<p>Web、WEB、WebService: Interface、中国软件</p>
<p>注意前两个命名并不等同，因为XML的命名是大小写敏感的，第三个是使用建议的命名空间分隔符（冒号）的典型例子，最后一个例子提醒大家注意汉语同英语一样，都可以用于XML的命名。</p>
<p>下面是一些非法的命名：</p>
<p>-Web、4Web、Web$Service</p>
<h4 id="文档部分"><a href="#文档部分" class="headerlink" title="文档部分"></a>文档部分</h4><p>一个格式正规的XML文档由以下三个部分组成。</p>
<p>（1）一个可选的序言（prolog）。</p>
<p>（2）文档的主体（body），由一个或多个元素组成，其形式为层次树状结构，其中可能也包含了一些字符数据（character data）。</p>
<p>（3）可选的“繁杂”的尾声（epilog），其内容包括注释、处理指令（Processing Instruction, PI）和/或紧跟在元素树后面的空白。</p>
<h4 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h4><p>元素是XML标签的基本组成部分，它们可以包含其他的元素、字符数据、字符引用、实体引用、PI、注释和（或）CDATA（即Charactor Data缩写）部分——这些合在一起被称为元素内容（element content）（要注意这些元素都是容器）。所有的XML数据（除了注释、PI和空白）都必须包容在其他元素中。</p>
<p>元素使用标签（tag）进行分隔：由一对尖括号（〈 〉）围住元素类型名（一个字符串）。每一个元素都必须由一个起始标签和一个结束标签分隔开，这与要求比较松的HTML不同，后者的结束标签可以省略。这项规则唯一的例外是没有任何内容的元素，即空元素（Empty Element），它既可以使用起始标签/结束标签对，也可以使用短小精悍的混合形式——空元素标签。在后面，我们会看到许多标签的例子。</p>
<h5 id="起始标签"><a href="#起始标签" class="headerlink" title="起始标签"></a>起始标签</h5><p>一个元素开始的分隔符被称为起始标签。起始标签是一个包含在尖括号里的元素类型名。我们也可以把起始标签看作是“打开”了一个元素，就像我们打开一个文件或通信链路一样。</p>
<p>下面就是一些合法的命名：</p>
<p>〈Web〉、〈WEB〉、〈WebService: Interface〉、〈中国软件〉</p>
<h5 id="结束标签"><a href="#结束标签" class="headerlink" title="结束标签"></a>结束标签</h5><p>一个元素最后的分隔符被称为结束标签。结束标签由一个反斜杠和元素类型名组成，被围在一对尖括号中。每一个结束标签都必须与一个起始标签相匹配，我们可以把结束标签理解为“关闭”了一个由起始标签打开的元素。</p>
<p>下面是一些合法的结束标签，它们与前面列举的起始标签相对应。</p>
<p>〈/Web〉、〈/WEB〉、〈/WebService: Interface〉、〈/中国软件〉</p>
<p>所以，带有完整的起始、结束标签的元素应该是如下形式：</p>
<p>〈某个标签〉包含的内容〈/某个标签〉</p>
<h5 id="空元素标签"><a href="#空元素标签" class="headerlink" title="空元素标签"></a>空元素标签</h5><p>空元素可能不包含任何内容。比如说想准确地指明文档中的某些特定位置，我们可以只加入起始标签和结束标签，而不在其中包含任何内容。</p>
<p>〈WebService〉〈/WebService〉</p>
<p>当然，如果你只是想指定一个点，而不是提供一个包容器，节省些空间可能会更好。所以，XML指定空元素可以用缩略形式表示，它是起始和结束标签的混合体。它短小精悍，而且还能明确指出该元素既不会有内容，也不允许有内容。</p>
<p>空元素标签由一个元素类型名称紧跟一个反斜杠组成，并围在一对尖括号中。</p>
<p>〈WebService/〉</p>
<p>一个XML数据对象可能只包含单个文档根元素和一些空元素（可能有属性），这样的文件可以用来描述应用程序的配置信息或者面向对象编程语言中的对象模板。</p>
<h5 id="文档元素"><a href="#文档元素" class="headerlink" title="文档元素"></a>文档元素</h5><p>格式正规的XML文档的定义形式是一个简单的层次树，每个文档都有一个，而且只有一个根节点，它被称为文档实体（document entity）或文档根（document root）。这个节点可能包含PI和（或）注释，而且总是包含子元素树，它们的根被称为文档元素（document element）。这个元素是这个树中其他所有元素的父元素，而且它可能不包含在其他任何元素当中。每个XML文档的文档根也是使用DTD （Document Type Definition，文档类型定义）或模式定义的文档描述的附属品（由于本章并不想就DTD展开详细讨论，文章对于XML建模的重点是XML Schema，因此只对XMLSchema进行讨论）。</p>
<p>任何格式正规的XML文档都必须由形成一个简单的层次树的元素所组成，其中有一个被称为“文档根”的单个根节点。它包含第二层的元素树，这个树也存在一个被称为“文档元素”的根节点。</p>
<h5 id="元素嵌套"><a href="#元素嵌套" class="headerlink" title="元素嵌套"></a>元素嵌套</h5><p>XML对元素有一种非常重要的要求：它们必须正确地嵌套。对现实世界对象的分析会有助于解释“正确嵌套”的含义。实际上，我们甚至可以说XML元素是任何必须遵守它们的现实来源规则的单词。</p>
<p>让我们来看一看本书传递到读者手中的整个过程。在完成印刷后，本书会和其他23本书打包到一个盒子中。两个盒子会被封装到一个纸箱中，许多纸箱会被装入一辆卡车然后运送到书店中。</p>
<p>整个过程可以用以下XML元素表示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230807.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230807.png';" /></details>

<p>在上面的例子中，缩排只是为了突出这些嵌套元素的层次结构，为了简单起见也省略了许多对书和纸箱的描述。现实世界中的盒子能够包容整本书，但不可能出现书的某些部分在盒子中，而其他部分在外面的情况；同样，一本书也只能放在一个盒子中，不可能一部分在一个盒子，其他部分在另一个盒子。此外，盒子必须放在纸箱中，而纸箱必须顺序摆放在卡车里。当然，XML元素也必须遵守这些现实世界包容关系的基本法则。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>字符串（string literal）主要用在属性值、内部实体和外部标识符中。XML都使用单引号（’）或双引号（””）作为一对分隔符将其中的字符串包围起来。对于这些字符串的一个限制是用于分隔符的字符不能够出现在字符串中，如果字符串中包含单引号，分隔符就必须使用双引号，反之亦然。如果两个字符都必须出现在字符串中，用在字符串中（同时也用作分隔符）的字符必须用适当的实体引用顶替（&amp;apos；或者”）。</p>
<p>下面是一些合法的字符串表述：</p>
<p>‘string’, “string”. ‘this&apos;s a “Web Service”‘</p>
<p>而下面则是一些不合法的字符串表述：</p>
<p>“string’. ‘this’s a “Web Service”‘</p>
<p>从技术的角度讲，根据XML规范，字符串分隔符之间的文本是文档字符数据的一部分。在讨论属性之前，我们先看一看它所包含的意义。</p>
<h4 id="字符数据"><a href="#字符数据" class="headerlink" title="字符数据"></a>字符数据</h4><p>字符数据就是任何不是标记的文本，它是元素或属性值的文本内容。小于号、大于号和&amp;符号是标记分隔符，因此它们绝不能以字符串的形式出现在字符数据中（CDATA部分除外，这一点我们将在后面提到）。如果这些字符是字符数据所必需的，它们必须使用实体引用“&It;”、“&gt;”以及“&amp;”来代替。这几个替代物是XML规范定义的5个类似字符串中的一部分，而且在所有兼容XML的解析器中都得到实现。</p>
<p>这里，需要再次提醒大家，由于XML的目的是在全球范围使用，所以文本是指统一代码，而不仅仅是ASCII码。现在，我们就来讨论属性的问题。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>如果说元素是XML中的名词，那么属性就是这种语言的形容词。在很多情况下，我们会希望将某些信息附着在元素上，它们与元素本身包含的信息内容有所不同。我们利用属性（attribute）来做到这一点，它们都包括一个名称/值对组合，使用的格式有如下两种形式：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230937.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230937.png';" /></details>

<p>属性值必须是分隔开的字符串（字符串规则的要求），其中可能包含实体引用、字符引用以及（/或）文本字符。但是，正如我们刚才解释的那样，任何一个受保护的标记字符（“〉”、“〈”和“&amp;”）都不能简单地在属性值中当作字符使用，它们必须用“&It; ”、“&gt;”或“&amp;”实体引用来替代。</p>
<p>HTML允许数字化的属性，例如〈IMGWIDTH=300〉；或者不分隔的属性，比如〈PALIGN=LEFT〉；但这两种情况在XML中都不允许存在。</p>
<p>在起始标记或空标记中属性只允许有一个实例存在。例如，下面的例子在XML中就是非法的，因为src在一个标记中出现了两次：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230954.png';" /></details>

<p>这种限制极大地简化了XML的处理。正如我们在前面暗示的，起始标记和空标记可能在标记中包含属性。例如，回到我们前面提到的关于书本、盒子、纸箱和卡车的例子，如果我们希望给每个运送书本的纸箱编上一个号码的话，可以使用如下属性：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231010.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231010.png';" /></details>

<p>在这个例子中，属性名称是number，相应元素起始标签中的值为”0-232-93-1’”及’0-232-93-2’。注意两个合法的字符串分隔符”和’在本例中都被使用了。</p>
<h5 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h5><p>管是对于人类语言还是计算机语言来说，空白确实是一个非常重要的语言概念。在XML数据中，只有4个字符可以作为空白使用，如表8-1所示。</p>
<details><summary>表8-1　4个字符的描述</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231030.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231030.png';" /></details>

<p>无论如何，制表位占用的位置都不会只超过一个字符，所以它们中的每一个都可以简单地看作是一个字符。同样，任何由LF和（/或）CR隐含的格式也是交给应用程序和（/或）样式表处理；同时，Unicode定义了许多不同种类的空格，但其中没有一个能够成为XML中的空白。XML处理空白的规则非常简单：解析器会保留内容中所有的空白字符并不加修改地传递给应用程序，但元素标记和属性值中的空白会被删除。</p>
<p>现在，让我们看一看XML是如何处理文档中的行尾的。</p>
<h5 id="行尾的处理"><a href="#行尾的处理" class="headerlink" title="行尾的处理"></a>行尾的处理</h5><p>XML数据对象经常存储在离散的计算机文件中，它们被分割为若干个文本“行”。在4个XML空白字符中有两个是标准的ASCII码行尾控制字符。正如我们前面提到的，在用来表示行尾时，会有这两个字符的三种常见组合：CR/LF、只有LF以及只有CR。</p>
<p>为了简化XML应用程序的编码，XML解析器需要将所有的行尾字符串转换为单个LF（换行）字符。很自然，这会让Unix编程者感到非常高兴，而让许多MS-Windows的开发人员怨声载道（Mac OS用户已经适应了处理多种行尾字符串）。Tim Bray曾经提出过一些折衷办法（主要是考虑到MS-Windows的市场份额），但结果是XML仍然要求使用Unix风格的行尾字符。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>这种机制对于在文档当中插入提示，或者叫注释（comment）来说是相当有帮助的。这些注释可能提供修订记录、历史信息或者其他类型的可能，这对创建者或者文档编辑者来说有着特殊意义，但又不是真正的文档内容的元数据。注释可能出现在文档中除其他标记部分以外的任何地方。</p>
<p>XML注释的基本语法如下。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231135.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231135.png';" /></details>


<h4 id="CDATA部分"><a href="#CDATA部分" class="headerlink" title="CDATA部分"></a>CDATA部分</h4><p>CDATA部分是一种用来包含文本的方法，其对象是那些其中的字符如果不如此处理就会被识别为标记的文本。这项特性对于希望在自己的文档中包含XML标记的使用举例的作者来说是最有用的，就像本书中的举例。但这可能是在文档中包含CDATA部分的唯一说得过去的理由，因为在使用这些部分时XML几乎所有的优势都丧失殆尽。</p>
<p>只要有字符数据出现的地方就可能出现CDATA部分，但它们不能够嵌套。CDATA部分的基本语法如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231157.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231157.png';" /></details>

<p>在这里，”…。.”部分可以是任何字符串，只要不包含字符串”]]〉”。</p>
<p>由于在Web服务系列技术中，CDATA同样不是常用技术，因此在这里也不加以详细讨论。</p>
<h4 id="格式正规的文档"><a href="#格式正规的文档" class="headerlink" title="格式正规的文档"></a>格式正规的文档</h4><p>所有遵守XML语法规范的数据对象（文档）都是格式正规的XML文档。这类文档在使用时可以不使用DTD或模式来描述它们的结构，它们也被称作独立的（standalone）XML文档。这些文档不能够依靠外部的声明，属性值只能是没有经过特殊处理的值或默认值。</p>
<p>一个格式正规（well-formed）的XML文档包含一个或多个元素（用起始和结束标记分隔开），它们相互之间正确地嵌套。其中有一个元素，即文档元素，包含了文档中其他所有的元素。所有的元素构成一个简单的层次树，所以元素和元素之间唯一的直接关系就是父子关系。兄弟关系经常能够通过XML应用程序内部的数据结构推断出来，但这些既不直接，也不可靠（因为元素可能被插入到某个元素和它的一个或多个子元素之间）。文档内容可能包括标签和（/或）字符数据。</p>
<p>数据对象如果满足下列条件就是格式正规的文档。</p>
<p>（1）语法合乎XML规范。</p>
<p>（2）元素构成一个层次树，只有一个根节点。</p>
<p>（3）没有对外部实体的引用，除非提供了DTD。</p>
<p>任何XML解析器如果发现在XML数据中存在并不是格式正规的结构，就必须向应用程序报告一个“致命”错误。致命错误不一定导致解析器终止操作，它可以继续处理，试图找出其他错误，但它不再会以正常的方式向应用程序传递字符数据和（或）XML结构。之所以采用这类错误处理方式，一是因为XML简洁的设计风格，二是因为XML更多的不是用于显示，因为这不太容易使得XML数据对象做到格式正规。</p>
<p>对于HTML/SGML来说，它们的工具都要比XML宽容许多。HTML浏览器通常会显示出大多数支离破碎的Web页面，这为HTML的快速流行做出了巨大贡献。此外，真正的显示会因浏览器而异。同样，SGML（Standard Generalized Markup Language）工具即使遇到错误，通常也会尽力继续处理文档。</p>
<p>格式正规的文档的存在使得可以使用XML数据而不必承担构建和引用外部描述的重任。术语“格式正规”与正式的数学逻辑有着相似之处，一个命题如果满足语法规则就是格式正规，而不在于它的正确与否。</p>
<h3 id="XML命名空间"><a href="#XML命名空间" class="headerlink" title="XML命名空间"></a>XML命名空间</h3><p>我们知道，XML是一种元语言，我们可以使用XML来定义各种各样的应用。在上一节中，我们就已经看到了如此多的基于XML的规范，它们都是使用XML定义的XML Application（XML应用语言）。一般来说，我们可以使用DTD或者XML Schema来规范化定义每种特别的XML。本书将不再介绍DTD，如果有兴趣的话，可以阅读XML规范或者相关材料去了解其细节；对于XML Schema，本书将在下一节结合实例进行描述。</p>
<p>无论是使用DTD还是XML Schema，都是去定义一个专用XML词汇集以及使用这些词汇的规则，这样我们就不可避免地面对这样一些问题：</p>
<p>（1）如何知道我们在一个XML实例文档使用的XML词汇是在哪个XML Application中定义的？</p>
<p>（2）当我们混合使用两个XML Application的词汇集时，如果两个词汇集中有相同名字的元素名（当然它们表示的是不同的含义），如何区分它们？</p>
<p>同样，这些问题也会发生在我们自己来定义XML标签的场合中。比如说，如果你考虑使用monitor这样的元素，那么它在不同的环境将有几种不同的意思。如果你在计算机外围设备描述中使用，monitor可能指的是计算机屏幕，同时在音乐制作间里扬声器通常也叫做monitor。如果这里有一个专用于描述学校信息的数据模式，monitor可能指的是一个被赋予几种职责的学生，然而在原子核电站，monitor可能放在报警的地方。即便意思相同，在两种不同的定义中，其内容也会发生改变。</p>
<p>面对元素的这些潜在的不同用途，我们需要一种方法去区分元素的特定用途，特别是我们在同一个XML文档里混用不同的词汇。为了解决这个问题，W3C提出了称为XML命名空间的规范，它允许我们在一个命名空间定义元素的前后联系，同时可以使用不同的命名空间来区分不同的XML词汇集中的元素名。</p>
<p>1999年1月14日，XML命名空间成为了W3C的推荐标准的程度。这一节将主要介绍XML命名空间。命名空间帮助XML词汇表设计者去将复杂的问题分解成细小的问题，以及根据需要混合多义词来描述单一XML文档里的问题。模式允许词汇表设计者去建立更多而准确的词汇定义。</p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>XML命名空间是解决多义性和名字冲突问题的方案。根据W3C组织的推荐标准XML Namespace （1999年1月14日）中的描述，XML命名空间是一种名称的集合，通过一种URI （Uniform Resource Identifier）引用来标识，作为元素类型和属性名称，它应用于XML文档。</p>
<p>命名空间是一组具有结构的名称的集合，这听起来像一个DTD，的确，一个DTD可以是一种命名空间（因为一个DTD定义了一个XML词汇集）。在这种情况下，URI可以是在你的服务器上的地址，如<a target="_blank" rel="noopener" href="http://www.uddi-china.org/schema/PubCatalog.dtd%E3%80%82">http://www.uddi-china.org/schema/PubCatalog.dtd。</a></p>
<p>DTD规定了一个文档的整体结构（并且是那么的准确），我们正好以一个命名空间为资源，规划所需要的定义。说到这里，一个命名空间不需要是一个像DTD那样的有固定结构的定义，而这个有限的定义领域使命名空间广泛应用于XML。如果命名空间是DTD或者XML Schema，我们使用的定义就必须在所描述的结构和语法上保持连续性。但是我们可以自由地使用需要的名称，并且使用命名空间来区分元素的使用。</p>
<p>于是，为了在文档里有效地使用命名空间，而文档中连接着来自不同地方的元素，我们需要两部分：</p>
<p>（1）URI引用，定义了元素的使用方法。</p>
<p>（2）一个别名，我们可以用此来标识元素来自哪个命名空间，这将采用元素前缀的形式（例如在〈中，catalog是模糊的contact元素的命名空间别名）。</p>
<h4 id="定义和声明命名空间"><a href="#定义和声明命名空间" class="headerlink" title="定义和声明命名空间"></a>定义和声明命名空间</h4><p>看到了命名空间在XML里所带来的优点，我们需要仔细看一下如何真正地使用它们。首先看一下在文档里怎样声明一个命名空间，然后看一下在文档里怎样使用命名空间，最后给出了几个例子。</p>
<p>通常，简单描述的特性作为属性来建模，并且这就说明了命名空间是怎样在XML中声明的。但这里有几个变形与转化，于是我们需要一步一步地去学习当在一个XML文档里声明一个命名空间时所能描述的东西。</p>
<h5 id="声明一个命名空间"><a href="#声明一个命名空间" class="headerlink" title="声明一个命名空间"></a>声明一个命名空间</h5><p>如果每个人在他们打算去识别一个命名空间声明的时候，我们需要在XML表示中提供一个保留的词汇给他们，命名空间推荐标准为我们提供了xmlns属性。属性值就是URI，其唯一地定义了当前使用的命名空间。URI经常是一个指向模式定义描述的URL（可能是DTD，也可能是XML Schema文档，甚至是其他）。用这种方式管理一个URI,以唯一区分命名空间已经足够了。</p>
<p>这里有几个简单的命名空间声明：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231359.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231359.png';" /></details>

<p>关于Web资源的术语可能令人混淆。统一资源标识符（URI）是一些资源的唯一名称，它根据协议和网络位置定位资源。第一个例子是URL，因为它允许一个浏览器利用HTTP（Hypertext Transfer Protocolv）从一个特定的位置得到资源。第二个例子给资源命名但没提供位置，字面上的urn来自于URI。</p>
<p>最初使用命名空间的动机之一是能够从不同的来源混合名称。基于这个考虑，为命名空间提供别名就成为非常有用的机制。而你能在一个涉及到相关声明的文档里通篇使用这个别名，可以靠加个冒号和你的别名到xmlns属性而实现该功能。因此上面的例子就变成了：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231418.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231418.png';" /></details>

<p>通过这样的命名空间声明之后，文档中的元素如果使用了uddi前缀（形如uddi:businessEntity），那么表示这个元素使用了<a target="_blank" rel="noopener" href="http://www.uddi-china.org/schema/uddiv2.xsd">http://www.uddi-china.org/schema/uddiv2.xsd</a> 中描述的定义。而如果使用了catalog这个前缀（元素形如），那么则表明使用了urn:catalog-specification所标识的定义。使用这些声明和它们的别名为我们提供了更多的元素信息。当然如果没有前缀那就等同于使用了xmlns=”…”的命名空间约束。’</p>
<h5 id="修饰名"><a href="#修饰名" class="headerlink" title="修饰名"></a>修饰名</h5><p>如果不能和一个我们想要使用的特定的名称绑定在一起，声明一个命名空间是没有什么用处的。这些已经通过利用修饰名（或成为命名空间修饰名，也就是使用命名空间前缀进行修饰的元素名或属性名）做到了。这就可能是你所希望的，一个从命名空间勾画出来并经其限定了的名称。通过别名创建一个确认过的名称，确切地说称作命名空间前缀，并把它放在名称的开始。下面是一个命名空间的例子：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231506.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231506.png';" /></details>

<p>此后我们就能够使用前缀catalog来进一步修饰每个元素名，使元素更加明确地表示出是来自哪个命名空间。于是，将要告诉我们contact名来自catalog命名空间声明；同样可能来自其他的命名空间，比如某个Order命名空间也有contact名称，但经过修饰的名称避免了多义性和冲突的可能性。</p>
<p>命名空间前缀经常被提及为前缀，而名称本身是基本名。修饰名可被应用于元素和属性名称。这里有一个混合一些命名空间的例子：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231517.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231517.png';" /></details>

<p>这个元素从我们在上面看到的第一个命名空间那里产生，而属性id则从identifier命名空间产生。</p>
<h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><p>命名空间声明就像变量在程序语言里那样有它的作用范围。这非常重要，这是因为命名空间并不总是定义在XML文档开始，它们能够被包含在文档的较后部分。一个命名空间声明因此也应用于有声明出现的元素，尽管与此同时子元素并没有清清楚楚地描述出来。只要被用在命名空间声明的范围之内，就能够访问到命名空间。</p>
<p>但是我们也需要去混合命名空间，元素可能会回去另外地继承命名空间的作用域，于是这里有两种可以声明作用域的办法，即默认和修饰。</p>
<h6 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h6><p>如你所想象的，在一个文档里，在每一个名称前加一个前缀非常令人厌烦。实际上，通过在工具集里引入名称作用域的概念，能够分配很多前缀。如果定义了默认的命名空间（没有声明别名的，形式为xmlns=”…”），在声明作用域里所有没有经命名空间前缀修饰的名称被假定属于默认的命名空间。于是如果在根元素声明了一个默认的命名空间，它将被看作整个文档将默认的命名空间，并只能被在文档内部声明的其他的默认命名空间所覆盖。</p>
<p>通常省略前缀可以将一个命名空间声明为某范围内默认的。当一个前缀被定义并被一个名称引用时，明确地声明了命名空间。而对于那个带有命名空间声明但又不包含命名空间前缀修饰（使用默认命名空间）的元素，它们同样是属于其自身所带的命名空间声明所指定的命名空间的。</p>
<h6 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h6><p>如果你能够清楚地区分命名空间，那当然非常好。但有些时候可能想要在一篇文档里从某个元素之外的命名空间来修饰名称，你就需要一个更精细的划分尺度。除了在整个空间声明命名空间，还可以利用带命名空间修饰的名称。在文档开头声明将需要的命名空间，然后在使用地点使用命名空间来修饰那些需要的元素和属性。</p>
<p>命名空间的存在主要是用来将名称组织成特有的集合以及回避名称冲突。W3C命名空间推荐标准没有描述任何有关验证的使用方法。确实，XML 1.0规范中没有说任何有关命名空间的东西。XML Schema则将充分利用命名空间的功能。我们将在后面的章节中结合实例来阐述XML Schema的使用方法。</p>
<h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>一个XML文档是有效的，则它必须满足：文档和一个文档类型定义或者模式相关联，这样XML处理器才能够理解并解析。那么怎样定义并利用这样一个文档类型定义呢？本节会具体讲述文档类型定义（DTD）。</p>
<h4 id="什么是DTD"><a href="#什么是DTD" class="headerlink" title="什么是DTD"></a>什么是DTD</h4><p>DTD即文档类型定义，是SGML、标准经XML的简化继承而来的，顾名思义，它主要是用来查看XML文档的格式，正如第7章所提到的，有关DTD的声明如果存在，则应出现在XML文档的序言中，以便XML校验器一开始就可以得到DTD所定义的该份XML文档的格式定义。另外，已经介绍过良构的XML文档和有效的XML文档的区别，所以可以知道DTD声明不是必须出现的。</p>
<p>在DTD中主要定义以下几个方面的内容：</p>
<p>（1）元素声明，包括元素的内容和元素的排列组合方式。</p>
<p>（2）实体声明。</p>
<p>（3）属性的种类</p>
<h4 id="为什么引入DTD"><a href="#为什么引入DTD" class="headerlink" title="为什么引入DTD"></a>为什么引入DTD</h4><p>首先考虑一下DTD的作用问题。事实上，DTD也好，XML Schema也好，它们都是提供一种验证的手段。验证对于XML来说是一大贡献，正是有了验证才可以确保XML文件确实地遵守了指定的格式，而这个格式可能是一个标准，或是数据交换双方所共同制定的协议，也正是如此，XML在电子商务领域掀起了轩然大波。</p>
<p>DTD的使用实现了文件格式的统一化，促进了行业或系统内部的文件的标准化，同时也提高了文件的重用性。DTD定义了文件的格式，这种统一的格式可能为某一领域的大量文件所共用，减少了文件制作的时间。也正是由于DTD（和XML Schema）的存在才突出了XML文档的数据的结构性。</p>
<p>但是也应该看到，并不是所有的文件都强调结构性。对于本身的结构性很强，或是在实际应用中不强调它的结构性的文档，使用DTD进行验证，增加了操作时间，得不偿失，可以考虑不使用DTD，只建立良构的XMI文档就行了</p>
<h4 id="DTD的声明"><a href="#DTD的声明" class="headerlink" title="DTD的声明"></a>DTD的声明</h4><h5 id="内部DTD声明"><a href="#内部DTD声明" class="headerlink" title="内部DTD声明"></a>内部DTD声明</h5><p>DTD的声明分为内部DTD声明和外部DTD声明。在本节通过如下例子介绍内部DTD声明。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231707.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231707.png';" /></details>

<p>从上面的例子中可以看到内部DTD声明的语法是：</p>
<!DOCTYPE根元素名称[...DTD规则

...]>

<p>可以看出内部DTD声明是内嵌于相应的XML文档当中的，这种方式虽然简单，但是从引入DTD的原因考虑，很容易想到，这种做法并不利于文档结构的重用。为此XML还提供了另一种DTD声明——外部DTD声明。</p>
<h5 id="外部DTD声明"><a href="#外部DTD声明" class="headerlink" title="外部DTD声明"></a>外部DTD声明</h5><p>外部DTD声明的语法规则可以描述为如下形式。</p>
<!DOCTYPE根元素名称SYSTEM DTD的URI><p>或者</p>
<!DOCTYPE根元素名称PUBLIC DTD的名称DTD的URI>

<p>可以看出，外部DTD声明是依照两种方式进行的，分别把它们叫做SYSTEM方式和PUBLIC方式。下面分别说明两种方式的使用方法。</p>
<h6 id="SYSTEM方式的外部DTD声明"><a href="#SYSTEM方式的外部DTD声明" class="headerlink" title="SYSTEM方式的外部DTD声明"></a>SYSTEM方式的外部DTD声明</h6><p>与PUBLIC相对，使用SYSTEM模式的DTD一般在未公开、私人或小团体内使用，可以根据有关URL的规定设置该DTD与用它的XML文档之间的路径关系。</p>
<p>●　“..”代表到该文档所在目录的上层目录。</p>
<p>●　“/”代表子目录。</p>
<p>●　默认情况代表当前目录。</p>
<p>下面是一个XML文档，它使用的是SYSTEM方式的外部DTD声明。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231753.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231753.png';" /></details>

<p>这个XML文档引用的DTD文件dtd1.dtd内容如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231809.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231809.png';" /></details>

<p>关于这个例子，需要说明的是，在处理指令)<code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;standalone=&quot;no&quot;?)&gt;</code>时，属性standalone应该设置为no，因为此时不是单个的XML文件，还需要读取它的DTD文件。</p>
<h6 id="PUBLIC方式的外部DTD声明"><a href="#PUBLIC方式的外部DTD声明" class="headerlink" title="PUBLIC方式的外部DTD声明"></a>PUBLIC方式的外部DTD声明</h6><p>在很多情况下，可能与其他合作伙伴共同制定为一个行业或某个工作领域共同遵守的XML文档格式，这时所使用的DTD就不是小团体或个人所属的，而具有公共性质，就如本书下半部分将要介绍的电子商务领域的XML标准。这时作为一种公用的DTD，它可能存放在某个Web网站上，用PUBLIC方式的外部DTD声明指明这种公用的DTD。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231858.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231858.png';" /></details>

<p>关于这个例子，需要说明的是，DTD的URL必须是绝对路径，另外可能注意到了增加了一个参数”TransactionDTD”，这个参数是DTD的名称，如果公用DTD的原作者没有指明它的名称，可以自行定义一个名称。</p>
<p>事实上，XML的验证器在验证XML文档是否符合它所声明的PUBLIC方式的外部DTD声明时，首先将外部DTD从指定的URI.处下载，然后做与SYSTEM方式下同样的验证。</p>
<h5 id="内部DTD和外部DTD同时使用"><a href="#内部DTD和外部DTD同时使用" class="headerlink" title="内部DTD和外部DTD同时使用"></a>内部DTD和外部DTD同时使用</h5><p>DTD的使用方式相当的灵活，它不仅提供了内部DTD和外部DTD两种方式，而且还支持内部DTD和外部DTD的同时使用以及和多个外部DTD的同时使用，那么很自然想到一个问题，当两种DTD有一部分声明是重复的，该怎么办呢？事实上，在两种声明存在重复的情况下，处理重复部分的方式和面向对象概念中的重载很类似，把内部声明看作对外部声明中重复部分的再一次说明，重复的部分以内部声明为主。这样就大大提高了外部声明的重用率，使得取用外部DTD的机会增加。</p>
<h4 id="元素的声明"><a href="#元素的声明" class="headerlink" title="元素的声明"></a>元素的声明</h4><p>元素是XML文档中相当重要的组成部分，通过介绍在DTD中元素的声明方式进一步了解元素。</p>
<p>元素声明的基本语法可以写作：</p>
<!ELEMENT元素名称　元素定义>

<p>其中ELEMENT是XML中预留的关键字。可以看出在元素声明中比较复杂的是元素定义部分。下面分不同的情况介绍元素的定义。</p>
<h5 id="空元素的声明"><a href="#空元素的声明" class="headerlink" title="空元素的声明"></a>空元素的声明</h5><p>空元素应该说是最简单的元素，它通过预留关键字EMPTY来实现。下面是一个空元素的声明：</p>
<!ELEMENT附加条件EMPTY>

<h5 id="文本元素的声明"><a href="#文本元素的声明" class="headerlink" title="文本元素的声明"></a>文本元素的声明</h5><p>这里主要指元素的内容完全是文本形式的元素类型，XML中用（#PCDATA）来描述，意思是可解析数据。下面是一个文本元素的声明：</p>
<!ELEMENT地址 (#PCDATA)>

<h5 id="无限制元素的声明"><a href="#无限制元素的声明" class="headerlink" title="无限制元素的声明"></a>无限制元素的声明</h5><p>这里所指的无限制元素是XML为某些结构性比较差的元素提供的说明方法，它对该元素不作限制。这里的不作限制可以理解为：</p>
<p>（1）可以包含任何在该DTD中声明过的子元素。</p>
<p>（2）这些子元素的出现次数与次序不作限制。</p>
<p>（3）可以包含文本数据，即（#PCDATA）型数据。</p>
<p>（4）数据内容与子元素可以交错出现。</p>
<p>XML通过关键字ANY实现对无限制元素的声明。这类无限制元素的声明语法如下：</p>
<!ELEMENT附加条件ANY>

<h5 id="包含子元素的元素声明"><a href="#包含子元素的元素声明" class="headerlink" title="包含子元素的元素声明"></a>包含子元素的元素声明</h5><p>第7章就介绍过了关于根元素、父元素和子元素的概念。事实上，XML文档本身通过元素之间的嵌套关系描述了数据（元素）之间树状结构关系，正因如此DOM等应用程序接口才能十分方便地将XML文档转化为许多应用程序习惯处理的树状结构或其变种。</p>
<p>所以，考虑包含子元素的元素声明时，应该注意不只要定义包含的子元素是什么，而且要定义这些子元素出现的次数和次序，在XML中通过一些结构符号描述这些信息，这些符号的描述如表8-2所示。</p>
<details><summary>表8-2　结构符号的具体描述</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232017.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232017.png';" /></details>

<h4 id="实体的声明"><a href="#实体的声明" class="headerlink" title="实体的声明"></a>实体的声明</h4><h5 id="什么是实体"><a href="#什么是实体" class="headerlink" title="什么是实体"></a>什么是实体</h5><p>简单地说，实体（entity）是一些预先定义好的数据，在需要使用这些数据的时候通过引用的方法将它放入特定的位置。使用实体的好处在于对于一些重用率很高的数据，通过将它们定义成实体，减少对这类数据进行修改是必须做的重复工作。另外，通过实体可以把一些特殊的数据，如声音文件、图片文件等引入XML文档。</p>
<p>根据不同的角度可以对实体进行多种不同的分类：按照实体存储的部位的不同，实体可以分为内部实体和外部实体；按照实体的组成内容的不同，实体可以分为可分解实体和不可分解实体两种；按照实体引用方式的不同，可以分为一般型实体和参数型实体。不同类型的实体的声明和使用方法略有不同，下面进行详细的介绍。</p>
<h5 id="内部实体和外部实体"><a href="#内部实体和外部实体" class="headerlink" title="内部实体和外部实体"></a>内部实体和外部实体</h5><p>内部实体在声明的时候就被完整地定义，因此应该想到，内部实体只能是文本型的数据。内部实体的声明方法如下：</p>
<!ENTITY实体名称　实体内容>

<p>实体的引用方法是：</p>
<p>&amp;实体名称；</p>
<p>如下例子说明如何声明并引用实体。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232118.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232118.png';" /></details>

<p>外部实体的声明虽然在DTD文档中，但是实体代表的数据本身存储于DTD文档之外。外部实体的声明方法如下：</p>
<!ENTITY实体名称SYSTEM I PUBLIC"URI">

<p>有关属性SYSTEM和PUBLIC的意义和DTD声明中介绍的一样，这里不再重复。外部实体的引用方法和内部实体是一样的。</p>
<p>最后要说明的是特殊字符的使用问题。在XML中，一些字符被赋予了特殊的意义，当不想使用这些字符的特殊意义而引用它们时，就使用实体引用的方式。表8-3是常见特殊字符的实体引用方式。</p>
<details><summary>表8-3　常见特殊字符的实体引用方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232134.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232134.png';" /></details>

<h5 id="可分解实体和不可分解实体"><a href="#可分解实体和不可分解实体" class="headerlink" title="可分解实体和不可分解实体"></a>可分解实体和不可分解实体</h5><p>可分解实体又称为文本实体。所谓可分解是指可以被XML验证器所解读，并且在解读后将实体的内容放入引用该实体的位置上去，例如相对于可分解实体，不可分解实体就是不能直接被XML验证器所解读的实体，例如图片、声音文件等。由于XML校验器本身不能解读这种实体，所以在声明这类实体时应该声明它的格式以及处理该实体的应用程序的位置。下面是不可分解实体的声明方法：</p>
<!NOTATION格式SYSTEM|PUBLIC处理程序的URI>

<!ENTITY实体名称SYSTEM|PUBLIC实体的URI NDATA格式>

<p>实体的引用方式没有变化。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232209.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232209.png';" /></details>

<h5 id="一般型实体和参数型实体"><a href="#一般型实体和参数型实体" class="headerlink" title="一般型实体和参数型实体"></a>一般型实体和参数型实体</h5><p>到现在为止，所介绍的实体都是一般型实体。这种类型的实体不仅可以在XML文件本体中引用，而且可以在它所在的DTD中使用。在所在DTD中使用应该注意的是，一般只用于对另外的实体的声明，不用于对元素的声明中，同时应该避免实体中引用实体时产生循环引用的现象。</p>
<p>一般型实体在引用时都采用如下方式：&amp;实体名称；而将要介绍的参数型实体则有很大不同，这类实体只在外部DTD声明中使用，而且不同于一般型实体，它可以用于元素的声明中。它的声明语法如下：</p>
<!ENTITY％实体名称　实体内容>

<p>引用语法如下：</p>
<p>％实体名称</p>
<p>可见，参数型实体和一般型实体有着很大的不同。事实上，可以把参数型实体看作在声明外部DTD时为避免重复工作提供的一种方法。如果有机会读到一些用作行业标准的DTD文档，会发现其中存在着大量的参数型实体的引用。</p>
<p>对一般型实体和参数型实体的区别总结如表8-4所示。</p>
<details><summary>表8-4　一般型实体和参数型实体的区别</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232228.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232228.png';" /></details>

<details><summary>续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232240.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232240.png';" /></details>

<h4 id="属性的声明"><a href="#属性的声明" class="headerlink" title="属性的声明"></a>属性的声明</h4><p>属性是XML提供的描述元素某些性质的信息，XML本身提供了一些默认属性，如最早在处理语句<code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;standalone=&quot;no&quot;?&gt;</code>就接触到默认属性version、encoding和standalone。当然除了默认属性以外，还可以根据需要自行设计属性，在一个良构XML文档中，属性只要满足命名规则就可以了，但是在一个有效的XML文档中，属性要经过DTD的属性声明，这是DTD声明中比较复杂的一部分。</p>
<p>在DTD声明中，属性的声明语法可以归纳为如下形式。</p>
<!ATTLIST元素名称　属性名称　属性类型　属性默认值类型>

<p>这里需要说明的是，元素名称指的是属性所属的元素名称，关于属性类型和属性默认值类型是属性中比较复杂的内容，下面详细地进行介绍。</p>
<h5 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h5><p>属性类型是对属性取值的约束，属性值类型共有7种选择，下面一一介绍。</p>
<p>（1）CDATA类型：CDATA类型是最简单的属性类型，也是约束最少的属性类型，代表该属性值为一般的文字，除此没有其他限制。声明语法如下：</p>
<!ATTLIST元素名称　属性名称　CDATA　属性默认值类型>

<p>（2）枚举型：枚举型列举了该属性所能取得的全部值。声明语法如下：</p>
<!ATTLIST元素名称属性名称（可选属性值1|可选属性值2|...|可选属性值n）属性默认值类型>

<p>（3）NMTOKEN和NMTOKENS类型：使用NMTOKEN属性类型时，表明该属性的属性值只能由字母、数字、“_”等字符所构成的字符串，即属性值满足命名规则，且不能出现空格。NMTOKENS属性则表明属性值可能由若干个满足NMTOKEN属性要求结合在一起形成的，即多个NMTOKEN之间可能存在空格，声明语法如下：</p>
<!ATTLIST元素名称　属性名称　NMTOKENINMTOKENS属性默认值类型>

<p>（4）ENTITY和ENTITIES类型：当属性值是一个外部实体的引用时，用ENTITY来说明属性类型；一般来说，当属性值是一个内部实体引用时，将属性类型声明为CDATA即可。</p>
<p>（5）NOTATION类型：在介绍不可分解实体类型时已经提到过NOTATION的声明，当属性只是一个声明过NOTATION格式时，将属性声明为NOTATION类型。由此也可以看出，在把一个属性声明为NOTATION类型时，首先应该确定存在相应的NOTATION声明。下面把NOTATION声明和NOTATION类型属性声明的语法写在一起。</p>
<p><code>&lt;NOTATION格式SYSTEM I PUBLIC处理程序的URI&gt;</code></p>
<p><code>&lt;ATTLIST元素名称属性名称NOTATION属性默认值类型&gt;</code></p>
<p>（6）ID类型：CDATA类型对于属性的限制是比较少的，ID类型是在CDATA类型的属性类型上加入一点更强的约束条件，那就是作为此类型值的名字只能在XML文件中出现一次。此即，ID类型的值必须能唯一标识元素。</p>
<p>（7）IDREF和IDREFS类型与ID类型相对，IDREF就是ID REFERENCE的意思，表明该属性的取值是对声明过的一个ID型属性值的引用，也就是说，IDREF类型的值必须匹配某些ID属性的值。同样道理，IDREFS类型表明该属性的取值是对声明过的多个ID型属性值的引用。</p>
<h5 id="属性默认值类型"><a href="#属性默认值类型" class="headerlink" title="属性默认值类型"></a>属性默认值类型</h5><p>属性默认值类型有4种可选情况，下面一一介绍它们的使用时机和使用方法。</p>
<p>（1）#IMPLIED表明该属性可出现可不出现，声明语法：</p>
<!ATTLIST元素名称　属性名称#IMPLIED>

<p>（2）#REQUIRED表明该属性一定要出现，声明语法：</p>
<!ATTLIST元素名称　属性名称#IMPLIED>

<p>（3）#FIXED表明该属性一定要出现，且固定为特定值，不许用其他值，声明语法：</p>
<!ATTLIST元素名称　属性名称#FIXED属性特定值>

<p>（4）特定属性值表明该属性的默认值，当XML文档中没有显式给出该属性的取值时，取此值。当该属性的取值已经显式地给出时，则为给出值：</p>
<p>&lt;–!ATTLIST元素名称　属性名称　属性默认值&gt;</p>
<h3 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h3><p>DTD在制定标记语言方面历史悠久，早在XML正式标准出现以前就已经存在，当时它配合SGML来制定标记语言，是专门为SGML服务的DTD。当XML出现之后，DTD尽管进行了很大的简化，但还是一门风格和XML完全不同的语言，不经过细致学习，根本不可能应用这种语言制定标记语言。而schema文档是一种特殊的XML文档，它遵循XML的语法要求，避免用户再去另外学习一套语法，同时schema语法结构简单，容易学习和使用。因而在发展势头上schema远高于DTD。</p>
<p>DTD的另一个缺点是数据类型相当有限。在DTD中根本不提供数值数据类型，例如整数、浮点数、布尔数等，所有的文档内容都是字符数据。而schema则提供了丰富的数值类型，不但有整数、浮点数等常用的类型，还提供了自定义数据类型的机制。</p>
<p>一个XML文档只能使用一个DTD文档，尽管DTD可以通过多数实体机制来部分改变这种缺点，但还是严重地导致了DTD的继承和使用的有限性。schema则采用了名域空间的机制，使得一个XML文档可以调用多种schema文档。在代码的重用性和可扩展性方面要远远优于DTD。</p>
<h4 id="逻辑XML-Schema的文档结构"><a href="#逻辑XML-Schema的文档结构" class="headerlink" title="逻辑XML Schema的文档结构"></a>逻辑XML Schema的文档结构</h4><p>XML Schema则是一类特殊的XML文档，除了具有XML文档的语法要求外，还要有一些特殊的要求。下面给出了这种文档的一个模板程序1，任何的XML Schema文档只要在该文档的基础上进行继续编写即可。</p>
<p>程序1</p>
<p>文件l.xml</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232440.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232440.png';" /></details>

<p>所有的内容都添加在<code>&lt;Schema&gt;&lt;/Schema&gt;</code>当中，该程序可以作为所有schema文档的模板。关于schema的模板在语法方面总结几点：</p>
<p>（1）根标记必须为<code>&lt;Schema&gt;&lt;/Schema&gt;</code>。</p>
<p>（2）xmlns是一个名域声明，表示Schema文档中使用的标记都是内标识为urn:schemas-microsoft-com:xml-data规范所定义的，前面字符串可以当作是该规范的名字。</p>
<p>（3）xmtns:dt指定了文档中有关数据类型定义的标识都来自下面规范：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232502.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232502.png';" /></details>

<p>上面的模板是一切schema文档都要遵守的一般性语法要求，下面我们将分别的从各个方面来介绍XML Schema的一些细节知识。</p>
<h4 id="元素的定义"><a href="#元素的定义" class="headerlink" title="元素的定义"></a>元素的定义</h4><p>schema中元素的定义使用标记<code>&lt;ElementType&gt;</code>来完成，具体的语法如下面的例子所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232521.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232521.png';" /></details>

<p>上面一条语句声明了一个<code>&lt;name&gt;</code>标记，该标记内容的类型是一般的文字，如果想指定为其他的数值类型，可以按以下的语法来制定。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232551.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232551.png';" /></details>

<p>上面语句声明了一个<code>&lt;date&gt;</code>标记，它内容的数据类型是日期型的，其他数据类请参考表8-5。</p>
<details><summary>表8-5　XML Schema所提供的常用数据类型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232614.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232614.png';" /></details>

<p>此外还有entity、entities、enumerationn、id、idref、idrefs、nmtoken、nmtokens、notation等数据类型。</p>
<p>如果一个标记中含有子标记，则子标记的定义采用下面的语法：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232630.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232630.png';" /></details>

<p>上面程序段定义了一个标记<code>&lt;books&gt;</code>，它有一个子标记。下面我们通过一个完整的程序2来说明标记的定义方法。</p>
<p>程序2</p>
<p>文件2.XML</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232651.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232651.png';" /></details>

<p>下面是使用该schema的XML文档程序3。</p>
<p>程序3</p>
<p>文件3.xml</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232706.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232706.png';" /></details>

<p>程序3中有一点需要注意：<code>&lt;books xmlns=&quot;x-schema:2.xml&quot;&gt;</code>该语句的作用是指定标记<code>&lt;books&gt;&lt;/books&gt;</code>之间的所有标记都是在文件2中定义的。这也是XML调用一个schema文件的方法。</p>
<p>上面程序的错误在于，标记<code>&lt;book&gt;</code>的内容定义的是整数型，而实际的XML文档中使用的却是一个字符串，因而是一个不合法的文档。只要将<code>&lt;book&gt;&lt;/book&gt;</code>标记的内容改成整数型的就成为合法的文档，例如下面的程序：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232739.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232739.png';" /></details>

<h5 id="元素内容类型的指定"><a href="#元素内容类型的指定" class="headerlink" title="元素内容类型的指定"></a>元素内容类型的指定</h5><p>有的标记只能自己独立使用，有的标记必须包含其他标记作为自己的子标记，决定一个标记语言的该方面的技术是元素的内容类型。这里可以通过关键字content指定这种属性。</p>
<p>Content属性可以有下面的几种取值。</p>
<p>（1）textOnly:表示该标记只包含文本型的内容。</p>
<p>（2）eltOnly：表示该标记只包含元素类型的内容。</p>
<p>（3）empty：表示是一个空元素。</p>
<p>（4）mixed：表示上面的各种情况。</p>
<h5 id="标记的子标记的出现次数"><a href="#标记的子标记的出现次数" class="headerlink" title="标记的子标记的出现次数"></a>标记的子标记的出现次数</h5><p>一个标记子标记的出现次数有minOccurs、maxOccurs两个属性来设置，它有如下的几种设置情况。</p>
<p>（1）子标记可以出现不止一次，即可以出现一次或多次，如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232811.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232811.png';" /></details>

<p>如果一个标记的子标记可以出现一次或多次时，只要指定该标记的maxOccurs的属性值为“*”即可。</p>
<p>（2）只能出现一个，如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232842.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232842.png';" /></details>

<p>在默认情况之下maxOccurs的属性值为1，除非content的属性设置为mixed，如果content的属性被设置成了mixed，那么maxOccuu默认位为“*”。</p>
<p>（3）子标记可有可无，如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232857.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232857.png';" /></details>

<p>如果一个标记的子标记指定了上面的属性，表示该子标记是可选的。</p>
<p>（4）子标记最少出现的次数，该次数通常是0或1。如果minOccurs的值设置为1就表示该标记必须出现。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232915.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232915.png';" /></details>

<h5 id="标记的子标记出现的次序"><a href="#标记的子标记出现的次序" class="headerlink" title="标记的子标记出现的次序"></a>标记的子标记出现的次序</h5><p>一个标记的子标记出现次序由一个属性order来控制，通常情况下该属性有三种取值。</p>
<p>（1）order=”one”</p>
<p>如果一个标记设置了该属性，则表示此标记的子标记是它子标记列表中的任一个。</p>
<p>（2）order=”many”</p>
<p>如果一个标记设置了该属性，则表示该标记的所有子标记可以按任意的顺序出现任意的次数。</p>
<p>（3）order=”seq”</p>
<p>如果一个标记设置了该属性，则表示该标记的所有子标记必须按照定义好的次序出现。</p>
<p>4．元素的开放性和封闭性</p>
<p>元素的开放性和封闭性指的是元素能否包含定义以外子元素的问题，该方面的功能由属性model来描述，当该属件的值是open时，该元素是开放的，除了可以包含自己定义的子标记外，还可以包含其他的标记。当该属性的值为close时，元素除了包含自己定义时定义的子标记外，不能再包含别的标记。下面通过一个例子程序来演示该属性的应用。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233004.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233004.png';" /></details>

<h3 id="可扩展样式表语言"><a href="#可扩展样式表语言" class="headerlink" title="可扩展样式表语言"></a>可扩展样式表语言</h3><h4 id="可扩展样式表语言概述"><a href="#可扩展样式表语言概述" class="headerlink" title="可扩展样式表语言概述"></a>可扩展样式表语言概述</h4><p>eXtensible Stylesheet Language, XSL）是描述XML文档样式信息的一种语言，是由W3C制定的。</p>
<p>前面已经讲过，XML的一个优点就是形式与内容相分离，这使得XML文档具有简洁、易读的特点。它的样式信息都包含在称为样式单的样式文件中。而XSL就是它的两种样式单的其中之一。另一种是上一节介绍过的已经运用在HTML中的层叠样式单（CSS），是一种静态的样式描述格式，其本身不遵从XML的语法规范。而XSL不同，它本身就是一个XML文档，系统可以使用同一个XML分析器对XML文档及其相关的XSL文档进行分析处理。</p>
<p>XSL是通过XML进行定义的，遵从XML语法规范，是XML的一种具体应用。它由两大部分组成：第一部分描述了如何将一个XML文档进行转换、转换为可浏览或可输出的格式；第二部分则定义了格式对象（Fomatted Object, FO）。在输出时，首先根据XML文档构造源树，然后根据给定的XSL将这个源树转换为可以显示的结果树，这个过程称为树转换，最后再按照FO分析结果树，产生一个可以在屏幕上、纸上、语音设备或其他媒体中输出的结果，这个过程称为格式化。</p>
<p>到目前为止，W3C还未能出台一个得到多方认可的FO，但是描述树转换的这一部分协议却日趋成熟，已从XSL中分离出来，另取名为XSLT（XSL Transformations），其正式推荐标准于1999年11月16日推出，现在一般所说的XSL大多指的是XSLT。与XSLT—同推出的还有其配套标准Xpath（XML Path Language, XML路径语言），这个标准用来描述如何识别、选择、匹配XML文档中的各个构成元件，包括元素、属性和文字内容等。</p>
<p>使用XSL显示XML的基本思想是通过定义模板将XML源文档转换为带样式信息的可浏览文档。最终的可浏览文档可以是HTML格式、带CSS的XML格式及FO格式。</p>
<p>XSL最初是由Microsoft公司提出来的，因此它对XSL的支持也比较好，Microsoft IE 5已经部分支持XSL。</p>
<p>在XML中使用如下语句声明XSL样式单：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233032.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233032.png';" /></details>

<p>如前所述，XSLT主要的功能就是转换，它将一个没有形式表现的XML内容文档作为一个源树，将其转换为一个有样式信息的结果树。在XSLT文档中定义了与XML文档中各个逻辑成分相匹配的模板，以及模板匹配和转换方式。值得一提的是，尽管制定XSLT规范的初衷只是利用它来进行XML文档与可格式化对象之间的转换，但它的巨大潜力却表现在它可以很好地描述从XML文档向任何一个其他格式的文档作转换的方法，例如转换为另一个逻辑结构的XML文档、HTML文档、XHTML（The Extensible HyperText Markup Language）文档、VRML（Virtual Reality Modeling Language）文档甚至SVG（Scalable Vector Graphics）文档。</p>
<p>XSL在网络中的应用大体分为两种模式。</p>
<h5 id="服务器端转换模式"><a href="#服务器端转换模式" class="headerlink" title="服务器端转换模式"></a>服务器端转换模式</h5><p>在这种模式下，XML文件下载到浏览器前先转换成HTML，然后再将HTML文件送往客户端进行浏览。有两种方式：</p>
<p>（1）动态方式。即当服务器接到转换请求时再进行实时转换．这种方式无疑对服务器要求较高。</p>
<p>（2）批量方式。事先用XSL将一批XML文档转换为HTML文件，接到转换请求后直接调用转换好的HTML文件即可。</p>
<h5 id="客户端转换模式"><a href="#客户端转换模式" class="headerlink" title="客户端转换模式"></a>客户端转换模式</h5><p>这种方式将XML和XSL文件都传送到客户端，需要浏览时由浏览器实时进行转换，前提是浏览器必须支持XML+XSL的工作方式。</p>
<p>本节将着重介绍XSLT对XML文档的显示转换功能，并将XPath作为XSLT的基础予以介绍。对于FO，在此只用少量的篇幅介绍一下，使读者对其有一个概括性的了解。</p>
<h4 id="XSLT的常用句法和函数"><a href="#XSLT的常用句法和函数" class="headerlink" title="XSLT的常用句法和函数"></a>XSLT的常用句法和函数</h4><h5 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h5><p>前面说过，XSLT文档本身是XML文档，因此文档的第一句自然是：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233142.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233142.png';" /></details>

<p>接下来是样式单部分：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233159.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233159.png';" /></details>

<p>也可以写作：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233212.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233212.png';" /></details>

<p>xsl:transform与xsl:stylesheet具有相同的含义，都表示元素所包含的内容为样式单。xsl:stylesheet元素必须包含有version属性，用以指示该XSL文档遵从哪一个版本的XSL标准。另外，xmlns:xsl指示了XSL的命名空间，在XSLT标准中，定义了XSLT的命名空间为<a target="_blank" rel="noopener" href="http://www.w3.org/1999/XSL/Transform%E3%80%82">http://www.w3.org/1999/XSL/Transform。</a></p>
<p>xsl:stylesheet又可包含以下几种元素：</p>
<p>xsl:import    xsl:output    xsl:attribute-set    xsl:include    xsl:key<br>xsl:variable　    xsl:strip-space　    xsl:decimal-format　    xsl:param　    xsl:preserve-space　<br>xsl:namcspace-alias        xsl:template</p>
<p>由此，一个样式单可以写成如下形式：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233246.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233246.png';" /></details>

<p>通常把xsl:stylesheet的子元总称为顶级元素（top-level），顶级元素在xsl:stylesheet元素中出现的次序可以是任意的，没有固定的先后次序。每个样式单都包含有零个或多个顶级元素，有关各顶级元素的具体含义我们将在以后的小节中逐步介绍。</p>
<p>XSLT在进行转换时，首先遍历XML源文档树，找到要处理的节点，然后将定义好的模板信息施加到该节点中。</p>
<h5 id="模板与应用"><a href="#模板与应用" class="headerlink" title="模板与应用"></a>模板与应用</h5><p>xsl:template是模板元素，通常每个xsl:template有一个节点匹配属性，由“match=”指定。在对模板进行匹配时使用xsl:apply templates，选择要匹配的模板，相当于一个调用的过程。对节点的匹配规则遵照XPath的标准定义。</p>
<p>XSLT对文档树的匹配总是从根节点“/”开始。<code>&lt;xsl:template match=&quot;/&quot;&gt;</code>就是匹配根节点，然后把定义好的包含HTML文档的开始部分的模板施加给根节点。</p>
<p>在该例子中，定义了一个roster模板：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233312.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233312.png';" /></details>

<p>并在根节点的模板中调用了该模板：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233325.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233325.png';" /></details>

<p>不向的模板的设计，可以导致同一个文档有不同的输出效果的输出样式主要有以下两种方法。</p>
<p>1）定义不同的样式</p>
<p>例如，CAPTION (font-size:l5pt;font-weight:bold:co1or:red)</p>
<p>2）利用mode属性</p>
<p>xsl:template元素还有一个mode属性，利用这个属性可以根据需要去匹配不同模式的模板。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233338.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233338.png';" /></details>

<p>那么，如果要将表格标题输出为蓝色字，要用下面语句匹配：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233349.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233349.png';" /></details>

<p>如果要将表格标题输出为红色字，则应写为：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233403.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233403.png';" /></details>


<p>以上介绍了利用模板达到不同输出效果的两种方法，第一种方法采取的是直接修改模板中内容，从而达到得到另外一种输出效果的目的。而第二种方法则是利用了xsl:template元素本身的mode属性，相对于第一种方法而言，具有更强的灵活性。</p>
<p>模板总是与节点相对应的，一个节点可能对应于不同的模板，那么在进行模板匹配时如何确定各模板匹配的先后次序呢？</p>
<p>在XSLT中，允许为xsl:template设置优先级，写法是：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233431.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233431.png';" /></details>

<p>n为优先级数。</p>
<h5 id="计算节点值"><a href="#计算节点值" class="headerlink" title="计算节点值"></a>计算节点值</h5><p>在使用XSLT进行转换时，常常需要获取节点值，使用xsl:value-of元素可达到这个目的，如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233454.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233454.png';" /></details>

<p>得到的是学生原籍的值，select属性指定要获取的是哪一个节点的节点值。</p>
<h5 id="元素与属性创建"><a href="#元素与属性创建" class="headerlink" title="元素与属性创建"></a>元素与属性创建</h5><p>XSLT是一个动态的样式单，在处理过程中可产生新的元素或元素属性。</p>
<h6 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h6><p>xsl:element元素可在XSLT对文档转换时动态地生成新元素，如下例子中的CAPTION标记就可以用动态生成的方法来生成。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233520.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233520.png';" /></details>

<p>XSLT处理此句时，将生成下面的元素：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233534.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233534.png';" /></details>

<h6 id="创建属性"><a href="#创建属性" class="headerlink" title="创建属性"></a>创建属性</h6><p>xsl:attribute元素可在XSLT对文档转换时动态地生成元素属性，如下面的例中CAPTION标记可以用动态生成的方法加入属性。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233548.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233548.png';" /></details>

<p>经XSLT转换后，将生成下面的元素：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233559.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233559.png';" /></details>

<h6 id="创建文本"><a href="#创建文本" class="headerlink" title="创建文本"></a>创建文本</h6><p>xsl:text元素可实现在样式单转换时动态创建文本，例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233632.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233632.png';" /></details>

<p>在XSLT进行转换时，匹配到roster节点后，将输出文字：</p>
<p>这是学生花名册</p>
<p>从上面的例子中似乎看不出使用xsl:text的必要性，事实上xsl:text的优势在于它可以保护文本中的空白字符。对于处理特殊类型的文本是很有用处的。</p>
<h6 id="创建处理指令"><a href="#创建处理指令" class="headerlink" title="创建处理指令"></a>创建处理指令</h6><p>xsl:processing-instruction元素可以实现在XSLT进行转换时自动生成处理指令，例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233709.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233709.png';" /></details>

<p>将创建如下处理指令：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233800.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233800.png';" /></details>

<h6 id="创建注释"><a href="#创建注释" class="headerlink" title="创建注释"></a>创建注释</h6><p>xsl:comment元素可在XSLT结果树中创建一个注释节点，例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233811.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233811.png';" /></details>

<p>经XSLT转换后生成注释：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233901.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233901.png';" /></details>

<h5 id="节点拷贝"><a href="#节点拷贝" class="headerlink" title="节点拷贝"></a>节点拷贝</h5><p>在对XML文档进行处理时，XSLT还可以通过拷贝的方式复制节点，方法是利用xsl:copy和xsl:copy-of。</p>
<p>xsl:copy只拷贝当前节点，不包括子节点和属性。而xsl:copy-of的拷贝内容则包括当前节点、子节点和属性。</p>
<h5 id="循环处理"><a href="#循环处理" class="headerlink" title="循环处理"></a>循环处理</h5><p>使用xsl:for-each可对所选节点依次进行处理，如在生成表格处理中利用循环将各个学生的信息取出放入表格中的，写法如下。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233933.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233933.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233946.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233946.png';" /></details>

<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>用xsl:for-each或xsl:apply-templates匹配的节点可使用xsl:sort将所选节点内容进行排序，如下所示。</p>
<p>1）按大小写排序</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234012.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234012.png';" /></details>

<p>将以id为关键字按大写优先排序，而</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234024.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234024.png';" /></details>

<p>将以id为关键字按小写优先排序。</p>
<h6 id="按字母顺序排序"><a href="#按字母顺序排序" class="headerlink" title="按字母顺序排序"></a>按字母顺序排序</h6><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234046.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234046.png';" /></details>

<p>将以id为关键字按字母升序排序，而</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234103.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234103.png';" /></details>

<p>将以id为关键字按字母降序排序。</p>
<h6 id="按数据类型排序"><a href="#按数据类型排序" class="headerlink" title="按数据类型排序"></a>按数据类型排序</h6><p>在有文本和数字混合的内容排序时，可指定按哪种数据类型排序。</p>
<p>对于一组id数据101, 2, 44, 305来说，如果写为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234126.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234126.png';" /></details>

<p>排序结果是101, 2, 305, 44。而写成</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234139.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234139.png';" /></details>

<p>排序结果是2, 44, 101, 305。</p>
<p>另外，还有一种排序方式，就是在前面学生花名册例中所使用的order-by:</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234223.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234223.png';" /></details>


<p>也可使得输出学生时按名字排序。</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>XSLT是一个转换语言，它的目的是将XML源文档转换为另一种格式文档，它的输出结果可以是HTML文档，也可以是带css的XML文档。具体的输出格式由xsl:output指定。如果要输出为HTML文档，则写为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234251.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234251.png';" /></details>

<p>同样，要输出XML文档写为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234305.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234305.png';" /></details>

<p>另外method”text”用来输出文本节点的内容，例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234315.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234315.png';" /></details>

<p>如果文档中不出现xsl:output，将默认输出为XML文档，但如果在匹配模板时使用了<HTML>标记，则输出为HTML文档。输出为HTML文档时系统都会自动加上下面语句：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234328.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234328.png';" /></details>

<h3 id="其他相关规范"><a href="#其他相关规范" class="headerlink" title="其他相关规范"></a>其他相关规范</h3><h4 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h4><p>当W3C首次开始开发一种XML查询语言时，他们意识到XPointer和XSLT组正在尝试完成访问一个XML文档的特定段的功能。因此，Xpointer，XSLT和XPath组进行了合作，指定为XML使用一种查询语言。XPath给XSLT和XPointer提供一个共同、整合的定位语法，用来定位XML文档中各个部位。在XSLT和XPointer之间，使用一种通用的语法——XPath来实现功能的共享。</p>
<p>XPath采用简洁的、非XML的语法，它基于XML文档的逻辑结构，在该结构中进行导航。XPath表达式通常出现在URL和XML属性值里。除了用于定位，XPath自身还有一个子集能用于进行匹配，它能验证一个节点是否匹配某个模式。XPath将XML文档描绘为树或节点的模型，节点的类型有根节点、元素节点、属性节点、文本节点、注释节点、名称空间节点和处理指令节点7种。</p>
<p>XPath规范定义了两个主要部分：一部分是表达式语法，另一部分是一组名为XPath核心库的基本函数。</p>
<p>指向某个XML文档中一个特定节点的路径由三部分信息构成：一个轴类型、一个节点测试和谓词。轴类型有多种，用来指定所选节点和环境之间的关系。节点测试用来指定根据上下文节点要查找什么类型的节点，除元素和属性节点外，可能使用的其他节点测试包括通配符“*”、text()、node()、comment()、processing-instruction()等。谓词以“<code>[</code>”开始，以“<code>]</code>”结束。谓词可以通过使用内置的函数来过滤不需要的节点，从而到达所需节点。将轴、节点测试和谓词信息类型放到一起，会生成下面的位置步语法结构。</p>
<p><code>&lt;轴&gt;::&lt;节点测试&gt;[&lt;谓词表达式&gt;]</code></p>
<p>例如，<code>child::sibling[position()=3]</code>，这个XPath语句使用一个谓词来选择上下文节点的第3个sibling子节点。</p>
<p>位置步首先利用轴和节点测试计算，得到初始结果集，然后依次利用谓词进行过滤；初始结果集中满足所有谓词的就是返回结果。</p>
<p>位置步总结了XPath语言实际上是如何工作的。要到达一个特定节点的位置，必须使用一个XPath表达式或模式来列出到达那步骤，这个过程的每一步都被一个“/”字符分开，这些位置步和“/”字符组成位置路径。位置路径是XPath中最普通的表达式类型。</p>
<p>XPath是用作XSLT和XPointer的对XML文档各部分进行定位的语言。但是，XPath不是作为一种独立语言设计的，它只在与另一种语言（例如XPointer或XSLT）一起使用时才有用。</p>
<h4 id="XLink和XPointer"><a href="#XLink和XPointer" class="headerlink" title="XLink和XPointer"></a>XLink和XPointer</h4><p>XLink指定一个文档如何链接到另一个文档，XPointer指定文档内部的位置，它们都是基于XPath推荐标准。现在对它们进行一下简要的介绍。</p>
<p>XLink规范是W3C在2000年2月21日发布的工作草案。在<a target="_blank" rel="noopener" href="http://www.w3.org/TR/xlink%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E8%A7%84%E8%8C%83%E7%9A%84%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E3%80%82XLink%E7%94%A8%E4%BA%8E%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3%E9%93%BE%E6%8E%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E6%96%87%E6%A1%A3%E3%80%82%E4%B8%8B%E9%9D%A2%E6%98%AFW3C%E5%9C%A8%E5%B7%A5%E4%BD%9C%E8%8D%89%E6%A1%88%E4%B8%AD%E6%8F%8F%E8%BF%B0%E7%9A%84%EF%BC%9A">www.w3.org/TR/xlink可以找到这个规范的最新版本。XLink用于从一个文档链接到另一文档。下面是W3C在工作草案中描述的：</a></p>
<p>此规范定义了3CML链接语言（XML Linking Language, XLink），它允许为创建和描述资源间的链接而在XML文档中插入元素。它使用XML语法创建结构对象，能够描述现在的HTML简单的单向超链接，也能描述更复杂的链接。</p>
<p>这里有一个例子用来了解一下XLink大概是什么样子。不像HTML超链接，在XML中任何元素都可以是一个链接。用xlink:type属性来指定一个元素成为链接，在这里创建了一个简单的Xlink。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234428.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234428.png';" /></details>

<p>在本例中，通过设置xlink:type属性为simple创建了一个简单的XLink，很像HTML中的超链接。将xlink:show属性设置为new，这意味着兼容XLink的软件应当在新的窗口或其他显示上下文中打开链接到的文档。另外，将xlink:href属性设置为新文档的URIURI更为通用，并且链接不一定使用在这里使用的URL形式。</p>
<p>出于熟悉的缘故，以一个简单的XLink开始，因为它与HTML链接非常相似。除了基本的单向链接，也就是在这里创建的简单链接，也可以创建双向链接和多文档间的链接，甚至是文档集间的链接。另外，还可以做更多的事情，包括在被称为链接库的链接数据库中对的链接排序。</p>
<p>XLink使能链接到一个指定的文档，但是经常需要更为精确的定位。XPointer允许在文档内部定位，而不必改变文档嵌入特殊的标记。</p>
<p>在文档内部指定位置，XPointer规范是基于XPath规范的。</p>
<p>它允许识别文档中指定结点，举例如下。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234442.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234442.png';" /></details>

<p>下面是W3C关于XPointer的描述：</p>
<p>此规范定义了XML指针语言（XML Pointer Language, XPointer），为任何URI引用用作段标识符，URI引用是用于定位Internet媒体类型text/xml或application/xml资源的。基于XML路径语言的XPointer支持在XML文档内部结构中寻址。它允许遍历文档树和选择其中的一部分，并且是基于各种特性的，例如元素类型、属性值、字符内容、相对位置等。</p>
<p>尽管XPointer基于xPath规范，但是XPointer规范在许多方面扩展了XPath。</p>
<p>如何将XPointer加入文档的URI来识别文档中的指定位置？只需加上符号“#”，（遵从HTML对URL的用法，URL指明链接的目标），然后是xpointer()，并将想使用的表达式放入圆括号中。举例如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234453.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234453.png';" /></details>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/index/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/index/">1</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/index/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/32/">32</a><a class="extend next" rel="next" href="/index/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">317</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


</body>
</html>
