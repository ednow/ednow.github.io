<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ednow">
<meta property="og:url" content="http://ednow.github.io/index/page/9/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ednow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ednow.github.io/index/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch14-%E5%9F%BA%E4%BA%8EODP%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch14-%E5%9F%BA%E4%BA%8EODP%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch14-基于ODP的架构师设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:56:12" itemprop="dateCreated datePublished" datetime="2021-07-19T12:56:12+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 16:57:13" itemprop="dateModified" datetime="2021-09-26T16:57:13+08:00">2021-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="基于ODP的架构师设计"><a href="#基于ODP的架构师设计" class="headerlink" title="基于ODP的架构师设计"></a>基于ODP的架构师设计</h2><p>软件系统架构设计方法是一个实践性大于理论性的工作。从软件有模块概念那天起，就有了总体设计，研究模块、构件与它们之间的关系。架构设计虽然可以归集到几种风格，但面对复杂的应用环境，不同应用领域对架构的理解差异非常大，用事实说话是最基本的研究方法。本章在RM-ODP多视点架构模型上，探讨应用于分布式信息系统的软件架构开发，对软件生命周期其他阶段的影响，特别是架构师在开发过程中的任务与作用。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/caolaosanahnu/article/details/10998099">软件体系架构：RM-ODP参考模型简介</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/seacean2000/article/details/102473736">基于ODP的架构师实践问答</a></li>
<li><a target="_blank" rel="noopener" href="http://www.rm-odp.net/">官网</a></li>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ODP/68318?fr=aladdin">Open Distributed Processing</a></li>
</ul>
<h3 id="基于ODP的架构开发过程"><a href="#基于ODP的架构开发过程" class="headerlink" title="基于ODP的架构开发过程"></a>基于ODP的架构开发过程</h3><p>系统架构反映了功能在系统构件中的分布、基础设施相关技术和架构设计模式等，它包含了架构的原则和方法、构件关系与约束，并能支持迭加或增量开发。以软件架构为中心的开发过程是以质量和风险驱动的，最终提供一个稳定、低风险的系统架构，并满足客户的需求（包含潜在需求）。</p>
<p>开放分布进程的参考模型（RM-ODP）是一个ISO标准，它为分布式计算进程提供了一个框架。RM-ODP定义了分布式系统的重要性质：开放性、整体性、灵活性、可塑性、联合性、可操作管理性、优质服务、安全性和透明性，并定义了一组视点。RM-ODP视点定义大体对应于IEEE 1471定义，RM-ODP定义的5个视点如下。</p>
<p>（1）企业视点：在如下因素的环境中分析系统，商业需求和策略、以及系统的范围和目的。RM-ODP处理可能会影响系统中的与企业相关的信息，如组织结构等。</p>
<p>（2）信息视点：指信息的结构，它的变化、流程以及在不同功能间的逻辑划分。</p>
<p>（3）计算视点：重点在于把系统分解为实体和实体间的接口。</p>
<p>（4）工程视点：处理分布式系统对象之间的交互，以及交互是如何得到支持的。</p>
<p>（5）技术视点：定义构成系统的硬件和软件构件。</p>
<p>体系结构视点是把抽象的符号或图表（如UML）运用到具体的体系结构开发任务中。每一个视点有具体的建模目标和系统相关者。例如，环境视图提供了对系统边界及与系统发生交互的外部实体集合的概述。分析视图提供了一个以建模问题而不是答案为中心的实体的抽象集合。</p>
<p>以描述软件设计为目的的视点包括构件、构件交互及构件状态。视图提供了一个对于逻辑运行结构及其功能，以及它们之间通信的映射。子系统接口依赖视图提供了一个子系统依赖关系和接口的图形表示；分层子系统视图提供了一个所有子系统高度抽象的视图；逻辑数据视图提供了构件共有的数据模型描述。</p>
<p>不同视图解决不同方面的问题，这是应对复杂问题的基本研究方法（分治）。采用ODP从5个视点描述信息系统架构，对整个系统开发过程有一定指导意义。除了架构设计阶段，其他阶段对架构师也提出不同的任务与要求。图14-1展示了整个系统及架构开发的10个过程。</p>
<details><summary>图14-1　系统架构开发的10个过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135503.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135503.png';" /></details>

<p>本章按图14-1的次序，探讨架构师的任务与设计工作。</p>
<h3 id="系统构想"><a href="#系统构想" class="headerlink" title="系统构想"></a>系统构想</h3><h4 id="系统构想的定义"><a href="#系统构想的定义" class="headerlink" title="系统构想的定义"></a>系统构想的定义</h4><p>系统构想是指一个系统开发人员与系统用户之间共同的协议。按照该协议，系统开发人员需在特定的时间内完成系统用户的需求。系统构想必须简短而切中要点，给人以清晰的感觉。它不是一成不变的，必须根据系统的不同而不同。</p>
<p>构想描述建立了从需求分析开始的所有项目活动的语境，它高度概括了企业业务架构的核心内容。</p>
<h4 id="架构师的作用"><a href="#架构师的作用" class="headerlink" title="架构师的作用"></a>架构师的作用</h4><p>讨论建模的时候，我们曾提到关键词有目的、关注点、假设和优先级，它们都是系统级的“构想描述（Vision Statement）”的基本元素。如果它们在系统开发过程中改变，项目就有被抛弃的危险。因此，以架构为中心的开发的第一步就是建立一个构想描述，且假定构想描述在系统的各个开发阶段不会改变。所有的改变必须在关键的项目计划中有所反映，特别是在系统架构中。</p>
<p>系统构想包括为客户、为软件系统开发团队等受益人创建的，有助于各方明了系统的目标和范围。对开发者而言，从宏观层面上显示系统架构的需求，为待开发系统提供一个结构清晰的概要，确保系统开发的计划、设计等阶段能依次有序地展开。</p>
<p>系统构想阶段，架构师合理的介入，有以下好处。</p>
<p>（1）有利于使系统架构师本身对系统的看法更加全面、准确。</p>
<p>（2）有利于统一系统开发人员对系统的看法。</p>
<p>（3）有利于正确确定需求的优先次序。</p>
<p>（4）通过系统构想，可以在最大程度上提高客户对设计等过程的参与程度，更好地与客户沟通。</p>
<h4 id="系统构想面临的挑战"><a href="#系统构想面临的挑战" class="headerlink" title="系统构想面临的挑战"></a>系统构想面临的挑战</h4><p>建立和共享架构构想要面临着很多的挑战：架构师对其控制能力之外的因素（例如组织等）通常无能为力；当产品线由一个架构来支撑时，构想就会受更多的因素制约。此外，如果共享的架构构想有问题时，不易马上觉察到。不过，可以通过有效地评估，以及高级经理和架构师之间保持紧密的联系来克服这些困难。</p>
<p>除了以上介绍的挑战外，在系统构想阶段，还必须面对以下几种情况。</p>
<p>（1）很多架构师把架构看成是他们独自的创造，而且只要他们认为合适的就进行修改。</p>
<p>（2）有些人不是拥有产品线构想的高级经理，却总是由这些人来决定雇佣谁来做架构师。由于没有参与架构师的招聘工作，高级经理们将无法评估架构师的能力以及理解并实现其构想。</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="架构师的工作"><a href="#架构师的工作" class="headerlink" title="架构师的工作"></a>架构师的工作</h4><p>需求一般定义系统的外部行为和外观及用户信息，而不用设计系统的内部结构。外部行为包括了用来保证外部行为能够完成而所需的内部行为（例如持续性或计算）。外观包括用户界面的布局和导航，用户信息包含用户概念数据结构及关系模型。</p>
<p>架构师对需求分析通常考察以下6个方面的内容。</p>
<p>（1）系统范围对象关系图。主要用于定义系统与系统外部实体间的界限和接口的简单模型，它可以为需求确定一个范围。</p>
<p>（2）用户接口原型。可将其看作为用户操作的一个雏形，通过该接口界面用户能够用一系列的操作完成它想达到的效果。</p>
<p>（3）需求的适用性。即这个需求应该用什么技术解决，它实现后的性能怎么样，是否与其他需求相重合或是矛盾。需求分析应注重需求本身的实用或适用，而不必考虑其实现。</p>
<p>（4）确定需求的优先级。可采用迭代周期来说明何时完成。</p>
<p>（5）为需求建立功能结构模型。可以用UML创建组件图和实体数据对象图，概述系统原型。</p>
<p>（6）使用质量功能分配（Quality Function Deployment, QFD）。根据需求的理解发现隐藏质量需求，建立相关质量场景和易变需求场景，先期预测需求风险。</p>
<p>架构师的一个有效地捕捉行为需求的方法是分析用例（use case）。一个用例包含一个顶层的图和扩展的文字描述。用例符号简单、抽象，非常适合于用来保证在表述顶层需求概念时的简单性和清晰度。</p>
<h4 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h4><h5 id="需求分析的目的"><a href="#需求分析的目的" class="headerlink" title="需求分析的目的"></a>需求分析的目的</h5><p>需求分析的目的是完整、准确地描述用户对系统的需求，跟踪用户需求的变化。将用户的需求准确地反映到系统的架构和设计中，设计和用户的需求保持一致。需求分析具有决策性、方向性和策略性的作用，它在软件开发的过程中具有举足轻重的地位。</p>
<h5 id="需求分析的特点"><a href="#需求分析的特点" class="headerlink" title="需求分析的特点"></a>需求分析的特点</h5><p>一般来说，需求分析特点的共同点都是追求系统需求的完整性、一致性和验证性。</p>
<p>（1）完整性：是准确、全面地描述用户对系统架构的需求。</p>
<p>（2）一致性：是通过分析整理，剔除用户需求矛盾的方面，规范用户需求。</p>
<p>（3）验证性：是需求的一致性表现形式，主要包含以下几个方面的含义。</p>
<p>① 保持和用户要求的同步。</p>
<p>② 保持需求分析各侧面之间的一致。</p>
<p>③ 保持需求和系统设计间的同步。</p>
<p>因此，在对系统架构需求分析之前必须建立需求分析技术层面的基本框架，从技术上保证需求分析的要求，在此基础上进行的架构需求分析才能满足项目对需求分析的要求。</p>
<h4 id="需求文档与架构"><a href="#需求文档与架构" class="headerlink" title="需求文档与架构"></a>需求文档与架构</h4><p>每个用例都有一个相关需求的文字描述。这种方法采用了包含一系列活动的列表形式，用特定领域的平铺直叙的文字来描述。定义用例应该和领域专家一起进行，如果没有领域专家的长期参与，这种活动只能是一种“伪分析”。</p>
<p>用例为定义架构提供了一个系统的领域行为模型。在开发的第7个过程中，用例被特定系统的场景所扩展，最后这些场景会在软件测试中得到运用。</p>
<p>用户界面的外观、功能和导航同用例紧密相联。一个有效定义屏幕的方法叫做低保真度原型（Low-fidelity Prototyping）。在这种方法中，屏幕是用纸和笔先画出来的。同样，最终用户领域专家也始终参与到屏幕定义中去。</p>
<p>有了用例和定义的用户界面以及领域概念模型，我们建立了架构规划的环境。在产生文档之外（包括纸、笔的草图），架构小组得到最终用户领域中需求功能的更深刻理解。需求分析的项目词汇表，也将在架构规划中被扩展。</p>
<h3 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h3><p>系统架构沟通了需求和软件之间巨大的语义上的鸿沟。需求是模糊的、直观的，而软件则具有相反的性质。系统架构的第一个任务就是定义这两个极端之间的映射，架构用一种更为技术性的方式来捕捉直觉的决定，它在设计和编码之前定义了内部的系统结构。架构设计同时为项目计划服务，它允许系统构建用适应变化的方法来控制复杂性，同时指导建立软件项目与架构对应的组织。</p>
<p>开放分布式处理（Open Distributed Processing, ODP）从5个标准的视点组织分析了系统的架构，描述了同一系统的重要方面。如图14-2所示，这些视点包括企业、逻辑信息、计算接口、分布式工程和技术选择。对于每个视点，确认架构需求的一致性是非常重要的。ODP促进了这个过程，因为它内嵌了一个普遍的一致性方法，简单的一致性清单包含识别架构中一致点所需的全部内容。</p>
<details><summary>图14-2　ODP视点</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135801.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135801.png';" /></details>

<h4 id="企业业务架构"><a href="#企业业务架构" class="headerlink" title="企业业务架构"></a>企业业务架构</h4><p>企业业务架构从IT的角度，对企业的业务结构、企业机构与业务的关系、企业内部的关系以及企业与外部机构的关系进行整理定义。企业业务架构包含如下内容。</p>
<p>（1）企业的业务和战略目标。描述企业的目标，包含近期目标、中期目标和长远的战略目标。</p>
<p>（2）企业的组织机构。明确描述企业的组织机构和职能，以及与企业相关的机构和个体，如客户、合作伙伴和供应商等。</p>
<p>（3）业务的分类。对企业的产品、服务和资源体系进行分类。这种分类包含了对相关产品、服务和资源的共性提取和总结。</p>
<p>（4）各类业务之间的关系。对产品、服务和资源的相互关联进行总结。业务之间的关系体现为跨业务的流程及资源共享等。</p>
<p>（5）组织机构与业务的关系。业务的执行是由机构来完成的，但是机构与业务并不一定是一一对应的关系。清楚地找出机构与业务的关系，将为应用与集成架构奠定可靠的基础。</p>
<p>（6）企业与外部机构的关系。对与企业相关的外部机构或个人就其类型、业务类别和业务往来模式等进行分类。</p>
<p>企业业务架构（企业视点）也是用高层企业对象来定义业务目的和系统策略。这些业务对象模型标识出系统的关键性约束，其中包括系统目标和重要的系统策略。</p>
<p>策略包含如下三类明确的表达方式。</p>
<p>●　责任：业务对象必须做什么。</p>
<p>●　许可：业务对象可以做什么。</p>
<p>●　禁止：业务对象不可以作什么。</p>
<p>在对业务问题进行分析时，不仅要考虑企业目前业务的情况，而且要考虑企业业务的发展，如新的服务或产品的推出、考虑组织机构的改变等，企业的业务流程的变化也是要考虑的因素。所有这些可能的变化（易变场景）都应该体现在企业的业务架构中。</p>
<p>企业业务架构在明确了企业的业务和战略目标之后，从业务和机构两个基本点出发进行基础性的分类组织工作，然后根据业务的分工和业务流程与组织机构实现映射，从而形成对企业业务的完整描述。一个典型的企业业务架构包含一系列逻辑对象图（通常用UML表示）和对象语义的平铺直叙的文字描述。</p>
<p>通过对企业业务架构的定义，就可以很清楚地知道由于企业业务特点、业务流程的特点和企业的组织机构等原因对IT系统所带来的自然分块和各个分块之间的边界关系，从而就可以知道怎样从技术架构上来满足和支持企业的业务架构。</p>
<p>企业业务架构的维护也是一个长期而反复的工作。企业业务架构的变化可以通过技术架构反映出来，技术架构的正确与否可以通过业务架构来检验，这样才能通过架构来保证IT服务于企业的业务和战略。</p>
<p>下面以一个测试结果报告系统（Test Results Reporting System, TRRS）为例，介绍一下它的企业业务架构。</p>
<p>TRRS的企业视点由一些UML用例组成，这些用例确定了TRRS社区的参与者以及他们之间策略上的联系。图14-3展示了这些来自应用软件开发者视点的UML用例。这三个在UML图中的用例表明，软件开发者可以通过多种途径使用TRRS，以决定软件产品的兼容性。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135833.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135833.png';" /></details>


<p>重要的企业策略关系到TRRS数据库中产品描述的完整性和责任。在TRRS处理中，可以使用UML对象约束语言（Object Constraint Language, OCL）来定义企业活动者的这些策略（如许可、禁止和义务等）。</p>
<h4 id="逻辑信息架构"><a href="#逻辑信息架构" class="headerlink" title="逻辑信息架构"></a>逻辑信息架构</h4><p>逻辑信息架构（信息视点）标识出系统必须知道什么。这种架构通过一个对象模型来表达，强调定义系统状态的属性。因为开放分布式处理是一种面向对象的方法，模型包含了关键信息的处理，如传统的对象概念。</p>
<p>软件架构对象并不是编程的对象，它表示对系统的约束和依赖。这些约束能够消除在把需求翻译成软件过程中的许多猜测性工作。架构师应该把他们的建模集中于系统中有高风险、高复杂性和模糊性的关键方面，而把直接的细节放在开发的环节中去。</p>
<p>下面以测试结果报告系统为例，介绍一下它的逻辑信息架构。</p>
<details><summary>图14-5　供应商信息的UML表示</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904135921.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904135921.png';" /></details>

<p>TRRS信息视点是由一组UML类模型组成，该信息视点定义了一些核心的概念，这些概念组成了TRRS系统的持久状态。图14-4是一个UML图，它展示了产品之间的互操作关系。一致性声明（Conformance Statements，如图14-5所示）提供了产品兼容性标准的保证。互操作性声明（Interoperability Statements）是一个类似的概念，和兼容性不同之处在于它不包含供应商对相互之间产品兼容性的保证。互操作性测试报告（Interoperability Test Report）包括了多产品互操作测试所得出的测试结果。互操作性产品（Interoperability Product）是特定的源于多供应商兼容性的解决方案。经验报告（Experience Report）是实例研究的文档，它记载了产品集成的成功经验。合起来，上述各个部分组成了TRRS数据库要储存的关键文档类型。</p>
<h4 id="计算接口架构"><a href="#计算接口架构" class="headerlink" title="计算接口架构"></a>计算接口架构</h4><p>计算接口对系统架构非常有帮助，但是它常常被架构师所忽略。它定义了顶层的应用程序接口，这些是完全工程化的子系统边界的接口。在实现时，开发者将对他们的模型在这些边界上进行编程，以消除多个开发者和小组的主要设计争端。这些接口的架构控制对于一个支持变化和控制复杂性的稳定的系统结构来说，是非常重要的。</p>
<p>开放分布式处理体系结构的一个ISO标准采用的是CORBA接口定义语言（IDL），IDL是一种基本记法，它完全独立于编程语言和操作系统。IDL可以被编译器自动翻译成Java、C++和C#等大多数流行的编程语言。</p>
<h4 id="分布式工程架构"><a href="#分布式工程架构" class="headerlink" title="分布式工程架构"></a>分布式工程架构</h4><p>分布式工程架构定义了底层结构的需求，而独立于所选择的技术。它很好地解决了一些最复杂的系统策略，其中包括物理位置、系统规模可变性和通信服务质量。</p>
<p>ODP的一个最大好处是关注点分离，幸运的是，前面的视点解决了许多其他的复杂问题，那些是分布式很少关注的，如API、系统策略和信息纲要。相反，这些其他的视点能够解决它们各自的设计要点，而独立于分布式的考虑。</p>
<p>在进行分布式工程架构建模时，必须考虑系统的各个方面，如对象复制、多线程和系统拓扑等。</p>
<h4 id="技术选择架构"><a href="#技术选择架构" class="headerlink" title="技术选择架构"></a>技术选择架构</h4><p>技术选择架构（技术视点）确定了实际的技术选择，所有其他视点都独立于这些决定。因为大多数架构设计是独立的，商业技术的发展可以很容易地适应。</p>
<p>一个系统的选择过程包括初始的概念性机制的确认，如持久性或者通信。概念性机制的特定属性可以从其他视点得到。具体的机制被标识出来，如DBMS、OODBMS。这些特定的参选产品是从可得到的技术中选出来的。基于对候选者的初始选择，这个过程根据产品价格、培训要求和维护风险之类的项目因素而反复进行。</p>
<p>架构师选择的原因是非常重要的，因为所有这些观点可以作为以后架构约束的理由。记录可以放在一个由架构小组维护的非正式项目记事本上，可以用于以后进行参考。</p>
<p>以测试结果报告系统为例，介绍一下它的技术选择架构。</p>
<p>TRRS技术视点包括了原型规划的三种方式（如图14-6所示）。我们经常选用这些原型来支持渐进的系统演化和可扩展性。而从一种方式到另一种方式的演化之所以能够发生，是由在实现时选用不同的技术和提供多层结构间互操作机制所造成的。</p>
<details><summary>图14-6　原型规划的三种方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140022.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140022.png';" /></details>

<p>阶段1是一种快速的原型，它由一个独立的Java应用程序以及一个平面文件数据库配置而成。阶段2使用分布式基础设施中的RMI或者IIOP技术，支持局域网上的多客户系统。阶段3支持数据库的可扩展性，这是通过把平面文件替换为JDBC接口及其操作的后端数据库来实现的。</p>
<p>在阶段3之外，TRRS还需要对数据库表项、数据库集成和适应因特网环境下的安全性等功能提供支持。其他的开发挑战包括提供体系结构的设计工具以及利用TRRS数据进行管理等，例如向软件开发者报告相关的TRRS产品表项。这些为软件体系结构引入了一个新的动态层面。</p>
<h3 id="实现模型"><a href="#实现模型" class="headerlink" title="实现模型"></a>实现模型</h3><p>最终用户和架构师应在一起审查并贯穿于用例（业务场景、质量场景、易变场景）始终来证实需求的有效。通常这个交流会出现新的或者需要修改的需求，对于需求的任何修改都要标注并结合到随后的其他架构活动中去。通过模型，管理层能够看到可视化的进展。</p>
<p>大多数系统可以采用快速原型技术生成模型。快速原型技术有利于快速获取产品设计的反馈信息，并对产品设计的可行性做出准确的评估、论证。</p>
<h3 id="架构原型"><a href="#架构原型" class="headerlink" title="架构原型"></a>架构原型</h3><p>在完成上述任务之后，从构建的草图进而发展成产品原型。架构原型是很好的需求验证工具，它能够帮助利益相关人检测系统锲合用户操作的程度。可以使用各种各样的办法构建架构原型，而非编码一种。例如，可以使用故事板来可视化地展现用户使用产品的过程，也可以使用原型工具来模拟过程，以此说明产品是如何运行的。架构原型只是快速构建，作为改进设计的手段，如果在构建架构原型过程中使用了编码，也要尽量避免在最终产品中使用这些代码。</p>
<p>架构框架（Framework）是对系统架构的一种可运行验证工具，通过对系统的API定义的编译以及编写小程序来模拟运行的系统。架构框架用于正式计算和工程体系架构，这包括穿越分布式边界的控制和定时。</p>
<p>使用CORBA技术，一个架构的规范能够被自动地编译成带有分布式stub和框架程序的一系列程序的头文件。通过在框架程序中插入虚拟代码来模拟处理过程，编写简单的客户程序用虚拟的数据来穿越边界发送请求。一些关键的，比如说：高风险的用例被替换的客户程序所模拟。原型的执行被计时以确保与工程约束相一致。</p>
<p>下面是一些架构师可以在架构原型中寻求解答的具体问题。</p>
<p>（1）主要组件的责任是否得到了良好定义？是否适当？</p>
<p>（2）主要组件间的协作是否得到了良好定义？</p>
<p>（3）耦合是否得以最小化？</p>
<p>（4）我们能否确定重用的潜在来源？</p>
<p>（5）接口定义和各项约束是否可接受？</p>
<p>（6）每个模块在执行过程中是否能访问到其所需的数据？是否能在需要时进行访问？</p>
<p>为了构建实际的系统，初始的架构原型需要进行演化。较好的情况是在经过2次或3次迭代之后，架构变得稳定。主要的抽象对象都已被找到；子系统和过程都已经完成；所有的接口都已经明确定义。</p>
<p>在系统架构开发过程中，利用架构原型，至少有下面的几个好处。</p>
<p>（1）在架构落实之前，让团队成员能自由发表他们自己的看法，并进行讨论，提出建议，对在架构原型中存在的问题进行及时改正。</p>
<p>（2）可以在系统的整体性能上，把握得更好。统一团队成员之间的思想看法和提高系统开发的成功率。</p>
<p>（3）它对系统内部的结构分析与设计也有帮助。</p>
<h3 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h3><p>无论什么项目，其最终目标都是要按期、按预算开发出满足用户需求的、高可靠、高性能的产品。在实现这个目标的过程中，项目规划起着至关重要的作用。项目规划是一份已通过批准的正式文档，它根据项目的目标，对项目实施进行的各项活动作出规定，以它为基准跟踪和控制项目，确定未来的行动方案和资源分配，引导项目的实施。项目规划的主要作用是将制定规划的假设和决定以及批准的范围、成本、进度的基线等用正式的文档记录保存。规划的复杂性取决于项目的复杂性，它体现了对客户需求的理解，便于高层管理、项目经理、项目组成员及项目相关人等之间进行交流沟通。</p>
<p>项目规划是基于当前已有的信息，包括过去的经验，当前的目标、范围、组织结构、资源等，工作活动、里程碑、质量目标和风险管理等，其中估算是项目规划的核心。随着项目的进展，信息的增多和理解的深入，估算会不断校正并逐渐地接近实际。项目计划是在规划基础上建立的一组实现任务的活动表，如进度计划、质量活动计划和配置管理计划等。项目管理者通过计划与规划的差异，不断优化和更新计划策略，使项目按规划的要求得以实现，计划的变更是可管理和可受控的。</p>
<p>项目规划是项目工作的纲领，要以此去指导项目的技术和管理活动。项目规划包括如下内容。</p>
<p>（1）项目的目的、范围、目标和对象。</p>
<p>（2）软件生存周期的选择。</p>
<p>（3）精选的供开发和维护软件用的规程、方法和标准。</p>
<p>（4）待开发的软件工作产品。</p>
<p>（5）软件工作产品的规模估计、软件项目的工作量和成本的估计。</p>
<p>（6）关键计算机资源的估计；项目的里程碑。</p>
<p>（7）风险的识别和评估。</p>
<p>（8）工程设施和支持工具计划。</p>
<p>软件项目计划的目标有：软件估计被文档化，以供跟踪软件项目使用。软件项目的活动和约定是有计划的，并形成文档，受影响的组和个人认同与软件项目规划的约定。</p>
<h3 id="并行开发"><a href="#并行开发" class="headerlink" title="并行开发"></a>并行开发</h3><h4 id="软件并行开发的内容及意义"><a href="#软件并行开发的内容及意义" class="headerlink" title="软件并行开发的内容及意义"></a>软件并行开发的内容及意义</h4><p>并行开发的意义在于提高软件生产率和改善软件质量。软件并行开发有效地组织可以重复的资源，并附加额外的控制管理技术，使软件开发尽量并行进行，从而达到加快软件开发速度、提高软件生产率、缩短软件开发周期的目的。同时，软件并行开发通过改善软件过程，达到提高软件质量的目的。软件并行开发以提高软件生产率为目的，对实现软件并行开发的各个方面做了必要的分析，并且给出了可行的解决方案，直接面对软件工程的实施，因此具有重要的应用价值。</p>
<p>软件并行开发研究的内容主要如下。</p>
<p>（1）软件过程及其模型。</p>
<p>（2）并行成分划分。</p>
<p>（3）并行控制。</p>
<p>（4）支持环境。</p>
<p>（5）交互机制与集成技术。</p>
<h4 id="并行开发的过程"><a href="#并行开发的过程" class="headerlink" title="并行开发的过程"></a>并行开发的过程</h4><p>要讨论软件并行开发的软件生存周期模型，需要把视野集中到软件开发过程中。把软件系统的开发过程划分为若干个可以并行的成分，这个成分称之为子开发过程。子开发过程是一个动态概念，和操作系统中的进程概念有类似之处。子开发过程可以定义为：子开发过程＝开发小组＋软件对象＋对软件对象的开发活动。或者说，子开发过程是一个开发小组对一个相对独立的软件对象的动态开发过程。</p>
<p>在此，我们把整个并行开发活动看作是一个并行系统，称为并行开发系统。子开发过程是对并行开发系统的一种动态描述，此系统中的实体是开发小组，实体属性是被开发的软件对象，行为是开发软件对象的活动。每个子开发过程完成一个子系统或一个模块的开发任务，当各个子开发过程都完成之后，进行系统集成和测试，最终完成整个系统的开发，如图14-7所示。</p>
<details><summary>图14-7　并行开发中的生命周期模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140149.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140149.png';" /></details>

<p>并行模块的划分是并行开发中的核心问题，模块独立性是衡量软件设计质量的关键。根据并行开发的特征，一个开发小组负责一个模块的开发，如果各模块之间的耦合度低，那么各并行开发过程之间交互作用将减少，为并行开发控制带来方便。有如下两种系统划分的方法。</p>
<p>（1）基于Petri网系统模型的动态划分方法。</p>
<p>（2）基于脚本的系统划分方法。</p>
<p>在软件并行开发中，软件过程并行控制（以下简称并行控制）是一个非常重要的问题。所谓并行控制，就是要用正确的方式调度并行操作，避免造成不一致性，使一个操作的执行不受其他操作的干扰。为保证开发出的系统内部各成分间的一致性、相容性，保证系统的正确性和可靠性，就要进行并行控制。通常的并行控制手段有加锁、时间戳、管程、Petri网和PV操作等手段。并行控制模型描述被控制对象的并行行为以及它们之间的关系，是并行控制的依据。</p>
<p>当各个产品开发过程分别完成后，应通过集成技术，把各子开发过程所开发的软件对象集成起来，作为一个统一的应用系统。在软件并行开发的软件生存周期模型中，系统集成和系统测试被分为两个阶段，如果不考虑硬件或系统软件的集成，两个阶段并没有明显的界限。所以，就应用软件系统而言，软件集成的主要问题是集成测试技术。通过集成测试技术，在现实可行的时间内，运用工具尽量去发现尽可能多的软件错误，以保证软件的质量。</p>
<h3 id="系统转换"><a href="#系统转换" class="headerlink" title="系统转换"></a>系统转换</h3><p>系统转换是指运用某一种方式由新的系统代替旧的系统的过程，也就是系统设备、系统数据和人员等方面的转换。</p>
<h4 id="系统转换的准备"><a href="#系统转换的准备" class="headerlink" title="系统转换的准备"></a>系统转换的准备</h4><p>在系统转换前，必须认真做好系统设备、数据、人员以及有关文件（如程序说明书、系统操作说明书等）的准备。</p>
<p>除此之外，还需要系统试运行这项准备工作。系统试运行是指在系统没有正式转换之前，选择一些子项目进行的实验运行。需要注意如下两方面的问题。</p>
<p>（1）系统试运行工作的代表性。指在系统试运行工作中所选择的子功能和数据应该尽量接近实际系统运行的需要。</p>
<p>（2）系统试运行中错误的修正。系统试运行过程中用户发现的一些问题，对待这些问题应该以系统分析中确定的系统目标为标准，认真分析产生问题的原因和类型，决定对系统的问题是否修订和如何进行修订。</p>
<h5 id="系统转换的方式"><a href="#系统转换的方式" class="headerlink" title="系统转换的方式"></a>系统转换的方式</h5><p>系统转换可分为直接转换、平行转换、分段转换和分批转换。</p>
<p>（1）直接转换。直接转换是当新系统安装完毕能够进行工作后，立即停止旧系统的运行，让新系统投入运行的转换方式。</p>
<p>（2）平行转换。平行转换是新旧系统共同工作一段时间，当证实新系统有较高的可靠性后，再停止旧系统工作的转换方式。</p>
<p>（3）分段转换。分段转换时一次只用新系统的部分功能去替换旧系统的相应部分，逐步完成新系统替换旧系统的转换方式。</p>
<p>（4）分批转换。分批转换是把新系统在小范围内使用，然后再全部推广的转换方式。</p>
<p>以上几种系统转换方式各有各的特点，应根据系统规模的大小、难易和复杂的程度以及企业的具体情况决定系统转换时采用哪种方式。</p>
<h4 id="系统转换的注意事项"><a href="#系统转换的注意事项" class="headerlink" title="系统转换的注意事项"></a>系统转换的注意事项</h4><p>在系统的转换过程中，无论采取哪种转换方式，都要注意以下问题。</p>
<p>（1）新系统的运行需要大量的基础数据，这些数据的整理与录入工作量很大，应及早准备，尽快完成。</p>
<p>（2）系统的转换不仅仅是机器的转换、程序的转换，更难的是人员的转换，应提前做好人员的培训工作。</p>
<p>（3）系统运行时会出现一些局部性的问题，这是正常现象。系统工作人员对此应有足够的准备，并做好记录。系统只出现局部性问题，说明系统是成功的；反之，如果出现致命问题，说明系统设计质量不好，整个系统甚至要重新设计。</p>
<h3 id="操作与维护"><a href="#操作与维护" class="headerlink" title="操作与维护"></a>操作与维护</h3><h4 id="操作与维护的内容"><a href="#操作与维护的内容" class="headerlink" title="操作与维护的内容"></a>操作与维护的内容</h4><p>一个系统交付使用后，系统的开发就结束了，系统转入正常的运行操作时期。从系统的生命周期看，只有系统投入正常的操作和维护后，才真正实现了系统。因此，可以说操作维护是系统过程的后阶段。</p>
<p>系统操作与维护的内容有数据管理与维护，包括数据收集、数据整理、数据录入以及数据的分发、数据库管理工作；机器设备的管理与维护，包括硬件维护、机器日常行政管理、系统操作记录和用户服务等；系统软件的管理与维护工作，应用软件的管理与维护工作，代码维护。</p>
<h4 id="系统维护与架构"><a href="#系统维护与架构" class="headerlink" title="系统维护与架构"></a>系统维护与架构</h4><p>系统架构的好坏，可维护性是一个重要方面，维护人员应参与架构的评审。系统的可维护性可以定性地定义为：维护人员理解、改正、改动和改进这个软件的难易程度，提高可维护性时开发管理系统所有步骤的关键目的。系统能否被很好地维护，可用系统的可维护性这一指标来衡量。系统的可维护性有如下几个评价指标。</p>
<p>●　可理解性</p>
<p>●　可测试性</p>
<p>●　可修改性</p>
<p>依据信息系统需要维护的原因不同，系统维护工作可以分为以下4种类型。</p>
<p>●　 $\color{green}{\text{更正性维护}}$ </p>
<p>●　 $\color{green}{\text{适应性维护}}$ </p>
<p>●　 $\color{green}{\text{完善性维护}}$ </p>
<p>●　 $\color{green}{\text{预防性维护}}$ </p>
<p>某个维护目标确定以后，维护人员必须先理解要维护的系统，然后建立一个维护方案。由于程序的修改涉及面较广，某处修改很可能会影响其他模块程序，所以建立维护方案后要加以考虑的重要问题是修改的影响范围和波及面的大小。然后按预定维护方案修改程序，若测试发现重大问题，则要重复上述步骤。若通过，则修改相应文档并交付使用，结束本次维护工作。必须强调的是，维护是对整个系统而言的。因此，除了修改程序、数据和代码等部分以外，必须同时修改涉及的所有文档。系统维护的步骤如图14-8所示。</p>
<details><summary>图14-8　系统维护步骤</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904140406.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904140406.png';" /></details>

<h3 id="系统移植"><a href="#系统移植" class="headerlink" title="系统移植"></a>系统移植</h3><h4 id="系统移植的形式"><a href="#系统移植的形式" class="headerlink" title="系统移植的形式"></a>系统移植的形式</h4><p>系统移植的方法有三种：第一种是不修改已有的软件，可以使用的方法有高位互换、仿真功能和虚拟机（Virtual Machine）功能；第二种是修改软件，就是把已有软件资源，即程序、数据、计算机应用方法及各种说明书转换为与新机器具有匹配性的软件；第三种是重编软件，有从逻辑设计开始、从程序设计开始和从编程开始三种开发方式。</p>
<h4 id="color-red-text-系统移植的工作阶段划分"><a href="#color-red-text-系统移植的工作阶段划分" class="headerlink" title="$\color{red}{\text{系统移植的工作阶段划分}}$"></a>$\color{red}{\text{系统移植的工作阶段划分}}$</h4><p>移植工作大体上分为计划阶段、准备阶段、转换阶段、测试阶段和验证阶段。为了有效地进行系统移植，就得使系统移植工作标准化；配备软件工具实现自动化；还要简化各阶段的工作。下面简要介绍一下系统移植的各阶段工作。</p>
<p>（1） $\color{green}{\text{计划阶段}}$ 。在计划阶段，要进行现有系统的调查整理，从移植技术、系统内容（是否进行系统提炼等）和系统运行三个方面，探讨如何转换成新系统，决定移植方法，确立移植工作体制及移植日程。</p>
<p>（2） $\color{green}{\text{准备阶段}}$ 。在准备阶段要进行移植方面的研究，准备转换所需的资料。该阶段的作业质量将对以后的生产效率产生很大的影响。</p>
<p>（3） $\color{green}{\text{转换阶段}}$ 。这一阶段是将程序设计和数据转换成新机器能根据需要工作的阶段。提高转换工作的精度，减轻下一阶段的测试负担是提高移植工作效率的基本内容。</p>
<p>（4） $\color{green}{\text{测试阶段}}$ 。这一阶段是进行程序单元、工作单元测试的阶段。在本阶段要核实程序能否在新系统中准确地工作。所以，当有不能准确工作的程序时，就要回到转换阶段重新工作。</p>
<p>（5） $\color{green}{\text{验证阶段}}$ 。这是测试完的程序使新系统工作，最后核实系统，准备正式运行的阶段。</p>
<h4 id="系统移植工具"><a href="#系统移植工具" class="headerlink" title="系统移植工具"></a>系统移植工具</h4><p>数据不能互换的系统移植时，完整的数据转换工具是必需的。主要有以下几种软件工具。</p>
<p>（1）分析工具：是分析现有软件资源，得到探讨移植方法有用信息的工具。</p>
<p>（2）生成工具：是编制作业控制语言、测试数据、转换工作所需文档的工具。</p>
<p>（3）转换工具：包括程序转换、数据转换和作业控制语言转换。</p>
<p>（4）数据应用工具：使用这种工具不用编文件就可以简便地存取磁带上的数据。</p>
<p>（5）测试、验证工具：作为可分类的工具包括静态、动态跟踪。</p>
<p>（6）管理工具：是管理资源及作业的工具。</p>
<p>系统移植工作需要的软件工具有很多种，配备工具最主要的是在决定移植的工作方法之后，配备移植所需的工具并明确工具的界限。即选出移植工作中的作业项目，使项目系列化、标准化。配备、开发移植所需的工具；对于那些用工具转换的项目，采取相应的措施，进行文档化，使任何人都能以相同的顺序开展工作。这样，就不必制作大量的工具，只将有效的工具组合起来，就可以提高效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch13-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch13-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch13-系统的可靠性设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:54" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:54+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-21 14:58:22" itemprop="dateModified" datetime="2021-10-21T14:58:22+08:00">2021-10-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="系统的可靠性设计"><a href="#系统的可靠性设计" class="headerlink" title="系统的可靠性设计"></a>系统的可靠性设计</h2><p>随着软件复杂度的增加，软件设计的正确性验证成本也越来越高。可靠和可信的计算模型首先在军事和高要求的商业系统中开始研究，可靠性和其他质量属性一样是衡量软件架构的重要指标。实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制。本章探讨软件可靠性的概念、建模与管理方法。</p>
<h3 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h3><h4 id="软件可靠性概述"><a href="#软件可靠性概述" class="headerlink" title="软件可靠性概述"></a>软件可靠性概述</h4><p>在现代军事和商用系统中，以软件为核心的产品得到了广泛的应用。随着系统中软件成分的不断增加，使得系统对软件的依赖性越来越强，对软件可靠性的要求也越来越高。目前，硬件可靠性测试技术和评估手段日趋成熟，硬件可靠性评估模型经过长期的实践积累，已经得到了业界的认可。但是，由于软件和硬件存在着巨大的差异性，硬件的可靠性测试和评估技术，并不能完全应用于对软件的可靠性的测试和评估中。因此，软件可靠性技术研究成为当今可靠性工程研究领域中一个重要领域。</p>
<p>国外从20世纪60年代后期开始加强对软件可靠性的研究工作，经过40多年的研究，推出了各种可靠性模型和预测方法，于1990年前后形成了较为系统的软件可靠性工程体系。同时，从20世纪80年代中期开始，西方各主要工业强国均确立了专门的研究计划和课题，如英国的AIVEY（软件可靠性和度量标准）计划、欧洲的ESPRIT（欧洲信息技术研究与发展战略）计划、SPMMS（软件生产和维护管理保障）课题和Eureka（尤里卡）计划等。每年，都有大量的人力物力投入到软件可靠性研究项目中，并取得了一定的成果。</p>
<p>国内对于软件可靠性的研究工作起步较晚，在软件可靠性量化理论、度量标准（指标体系）、建模技术、设计方法和测试技术等方面与国外差距较大。</p>
<p>目前，软件可靠性管理方面还没有建立起具有权威性的管理体系和规范。例如，如何描述软件可靠性，如何测试、评估、设计和提高等。由于目前国内外对于软件可靠性模型的研究多集中在软件的开发阶段及测试与评估阶段的可靠性模型，而且现有的模型也多来源于硬件可靠性评估，与软件可靠性评估存在较大的差距，所以从事软件可靠性测试与评估研究是一个有理论价值和实际意义的工作。总的来说，软件可靠性工程研究虽然得到了普遍的重视，但仍然不是很成熟，还处于发展阶段。</p>
<h4 id="软件可靠性的定义"><a href="#软件可靠性的定义" class="headerlink" title="软件可靠性的定义"></a>软件可靠性的定义</h4><p>可靠性（Reliability）是指产品在规定的条件下和规定的时间内完成规定功能的能力。</p>
<p>按照产品可靠性的形成，可靠性可分为固有可靠性和使用可靠性。固有可靠性是通过设计、制造赋予产品的可靠性；使用可靠性既受设计、制造的影响，又受使用条件的影响。一般使用可靠性总低于固有可靠性。</p>
<p>软件与硬件有很多不同点，但从可靠性的角度来看，它们主要有如下4个不同点。</p>
<p>（1）复杂性。软件内部逻辑高度复杂，硬件则相对简单，这就在很大程度上决定了设计错误是导致软件失效的主要原因，而导致硬件失效的可能性则很小。</p>
<p>（2）物理退化。软件不存在物理退化现象，硬件失效则主要是由于物理退化所致。这就决定了软件正确性与软件可靠性密切相关，一个正确的软件任何时刻均可靠。然而，一个正确的硬件元器件或系统，则可能在某个时刻失效。</p>
<p>（3）唯一性。软件是唯一的，软件复制不改变软件本身，而任何两个硬件不可能绝对相同。这就是为什么概率方法在硬件可靠性领域取得巨大成功，而在软件可靠性领域不令人满意的原因。</p>
<p>（4）版本更新较快。硬件的更新周期通常较慢，硬件产品一旦定型一般就不会更改，而软件产品通常受需求变更、软件缺陷修复的需要，造成软件版本更新较快，这也给软件可靠性评估带来较大的难度。</p>
<p>尽管这样，软件仍然是一种具有特殊属性的产品，因此，也可以按照上面的产品可靠性定义来框架性地描述软件的可靠性。</p>
<p>1983年，美国IEEE计算机学会对“软件可靠性”做出了更为明确的定义，随后，此定义经美国标准化研究所批准为美国的国家标准。在1989年，我国国家标准GB/T-11457也采用了这个定义。这个定义就是：在规定的条件下，在规定的时间内，软件不引起系统失效的概率，该概率是系统输入和系统使用的函数，也是软件中存在的缺陷函数；系统输入将确定是否会遇到已存在的缺陷（如果缺陷存在的话）。</p>
<p>简言之，就是在规定的时间周期内，在所述条件下程序执行所要求的功能的能力。显而易见，美国IEEE计算机学会关于“软件可靠性”的定义仍然沿用了“产品可靠性”的定义，但有了更具体的定位和更深入的描述。</p>
<p>下面来分析一下软件可靠性的框架性定义。</p>
<p>（1）规定的时间。</p>
<p>软件可靠性只是体现在其运行阶段，所以将“运行时间”作为“规定的时间”的度量。“运行时间”包括软件系统运行后工作与挂起（开启但空闲）的累计时间。由于软件运行的环境与程序路径选取的随机性，软件的失效为随机事件，所以运行时间属于随机变量。</p>
<p>（2）规定的条件。</p>
<p>规定的条件主要指软件的运行环境。它涉及软件系统运行时所需的各种支持要素，如支持硬件平台（服务器、台式机和网络平台等）、操作系统、数据库管理系统、中间件，以及其他支持软件、输入数据格式和范围及操作规程等。不同的环境条件下软件的可靠性是不同的，具体地说，规定的环境条件主要是描述软件系统运行时计算机的配置情况及对输入数据的要求，并假定其他一切因素都是理想的。有了明确规定的环境条件，还可以有效地判断软件失效的责任在用户方还是开发方。</p>
<p>（3）所要求的功能。</p>
<p>软件可靠性还与规定的任务和功能有关。由于要完成的任务不同，软件的运行情况会有所区别，则调用的子模块就不同（包括程序选择路径不同），其可靠性也就可能不同。所以，要准确度量软件系统的可靠性，必须先明确它的任务和功能。</p>
<p>（4）“软件可靠性”定义具有以下特点。</p>
<p>① 用内在的“缺陷”和外在的“失效”关系来描述可靠性，更能深刻地体现软件的本质特点。</p>
<p>② 定义使人们对软件可靠性进行量化评估成为可能。对于软件的可靠性这样一个质量特性，很难用一个明确直观的数值去体现。而依据这个定义，我们有可能通过分析影响可靠性的因素，用函数的形式，按照不同的目的建立各种数学模型去分析软件可靠性。</p>
<p>③ 用概率的方法去描述可靠性是比较科学的。前面讲到，软件失效是随机的外部表现，完全是一个随机事件，而软件缺陷是软件固有的没有损耗的内在特点。定义用规定时间内其操作不出现软件失效的概率，也就是输入未碰到软件缺陷的概率来描述可靠性，这种方法就是用概率来描述纯粹的随机事件，是比较合理的，也是可行的。</p>
<h4 id="软件可靠性的定量描述"><a href="#软件可靠性的定量描述" class="headerlink" title="软件可靠性的定量描述"></a>软件可靠性的定量描述</h4><p>从软件可靠性的定义可以看到，软件的可靠性可以基于使用条件、规定时间、系统输入、系统使用和软件缺陷等变量构建的数学表达式。下面从可靠性定义中的术语“规定时间”、“失效概率”开始，探讨软件可靠性的定量描述，并相应地引入一些概念。</p>
<h5 id="规定时间"><a href="#规定时间" class="headerlink" title="规定时间"></a>规定时间</h5><p>对于“规定时间”有三种概念：一种是自然时间，也就是日历时间，指我们日常计时用的年、月、周、日等自然流逝的时间段；一种是运行时间，指软件从启动开始，到运行结束的时间段；最后一种是执行时间，指软件运行过程中，中央处理器（CPU）执行程序指令所用的时间总和。</p>
<p>例如，某单位有一套供会计人员使用的财务软件，我们来关注一整天的时间，上午9:00上班开机运行，下午5:00下班退出程序。在这里，自然时间是一天，也就是24小时，运行时间是8个小时，而CPU处理程序的执行时间可能不到2小时，这要视会计的业务繁忙状况、使用软件的频度和软件本身的设计而定。</p>
<p>很明显，在这三种时间中，我们使用执行时间来度量软件的可靠性最为准确，效果也最好。如果运行的软件系统处于一种相对稳定的工作状态，可以根据一定的经验值，按一定的换算比例，对这三种时间进行折算。</p>
<h5 id="失效概率"><a href="#失效概率" class="headerlink" title="失效概率"></a>失效概率</h5><p>我们把软件从运行开始，到某一时刻t为止，出现失效的概率看作关于软件运行时间的一个随机函数，用F（t）表示。根据我们对软件可靠性的分析，函数F（t）有如下特征。</p>
<p>（1）F（0）＝0，即软件运行初始时刻失效概率为0。</p>
<p>（2）F（t）在时间域（0，+∞）上是单调递增的。</p>
<p>（3）F（+∞）＝1，即失效概率在运行时间不断增长时趋向于1，这也和“任何软件都存在缺陷”的思想相吻合。</p>
<p>为了简化分析，把F（t）看作关于时间t的一个连续函数，并且可导。</p>
<p>3．可靠度</p>
<p>我们用来表示可靠性最为直接的方式就是可靠度，根据可靠性的定义，可靠度就是软件系统在规定的条件下、规定的时间内不发生失效的概率。如果用F（t）来表示到t时刻止，软件不出现失效的概率，则可靠度的公式为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093411.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093411.png';" /></details>

<p>同样，我们知道R（0）＝1，R（+∞）＝0。</p>
<h5 id="失效强度"><a href="#失效强度" class="headerlink" title="失效强度"></a>失效强度</h5><p>失效强度（Failure Intensity）的物理解释就是单位时间软件系统出现失效的概率。在t时刻到t＋Δt时刻之间软件系统出现失效的平均概率为（F（t＋Δt）－F（t））/Δt，当Δt趋于很小时，就表现为t时刻的失效强度。用f（t）表示失效强度函数，则</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093437.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093437.png';" /></details>

<h5 id="失效率"><a href="#失效率" class="headerlink" title="失效率"></a>失效率</h5><p>失效率（Failure Rate）又称风险函数（Hazard Function），也可以称为条件失效强度，物理解释就是在运行至此软件系统未出现失效的情况下，单位时间软件系统出现失效的概率。具体用数学用语来描述，就是当软件在0～t时刻内没有发生失效的条件下，t时刻软件系统的失效强度。用λ（t）表示失效率，则</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093509.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093509.png';" /></details>

<h5 id="失效率-1"><a href="#失效率-1" class="headerlink" title="失效率"></a>失效率</h5><p>失效率（Failure Rate）又称风险函数（Hazard Function），也可以称为条件失效强度，物理解释就是在运行至此软件系统未出现失效的情况下，单位时间软件系统出现失效的概率。具体用数学用语来描述，就是当软件在0～t时刻内没有发生失效的条件下，t时刻软件系统的失效强度。用λ（t）表示失效率，则</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093530.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093530.png';" /></details>

<p>代入公式（13-1）可得从可靠度到失效率的转换表达式</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093547.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093547.png';" /></details>

<h5 id="可靠度与失效率之间的换算"><a href="#可靠度与失效率之间的换算" class="headerlink" title="可靠度与失效率之间的换算"></a>可靠度与失效率之间的换算</h5><p>我们知道，在0时刻，可靠度R（0）为1，对公式（13-4）一阶常微分方程求解可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093617.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093617.png';" /></details>

<p>假设软件系统的失效率为常数时，由公式13-5可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093632.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093632.png';" /></details>

<p>当失效率λ（t）与时间t之积，也就是tλ（t）＜0.05时，公式（13-6）可简化为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093702.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093702.png';" /></details>

<p>这样计算，误差在2.5％之内。</p>
<p>由公式（13-6）可得，从可靠度到失效强度的转换公式</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093747.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093747.png';" /></details>

<p>当可靠度R（t）＞0.95时，公式（13-6）可简化为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093808.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093808.png';" /></details>

<p>这样计算，误差在2.5％之内。</p>
<h5 id="平均无失效时间"><a href="#平均无失效时间" class="headerlink" title="平均无失效时间"></a>平均无失效时间</h5><p>平均无失效时间（Mean Time to Failure, MTTF）就是软件运行后，到下一次出现失效的平均时间。通常平均无失效时间更能直观地表明一个软件的可靠程度。用θ表示平均无失效时间MTTF，则可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093919.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093919.png';" /></details>

<p>代入关于失效率的换算公式，可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093934.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093934.png';" /></details>

<p>当失效率为一个常数时，可得</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904093946.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904093946.png';" /></details>

<p>当讨论完对软件可靠性的定量描述问题之后，需要对软件可靠度这个直接反映软件可靠性的度量指标作下列补充说明。</p>
<p>（1）描述的软件对象必须明确，即需指明它与其他软件的界限。</p>
<p>（2）软件失效必须明确定义。</p>
<p>（3）必须假设硬件无故障（失效）和软件有关变量的输入值正确。</p>
<p>（4）运行环境包括硬件环境、软件支持环境和确定的软件输入域。</p>
<p>（5）规定的时间必须指明时间基准，可以是自然时间（日历时间）、运行时间、执行时间（CPU时间）或其他时间基准。</p>
<p>（6）软件无失效运行的机会通常以概率度量，但也可以模糊数学中的可能性加以度量。</p>
<p>（7）上述定义是在时间域上进行的，这时软件可靠度是一种动态度量。也可以是在数据域上将软件可靠度定义为一种表态度量，表示软件成功执行一个回合的概率。软件回合（Run）是指软件在规定环境下的一个基本执行过程，如给定一组输入数据，到软件给定相应的输出数据这一过程。软件回合是软件运行最小的、不可分的执行单位，软件的运行过程由一系列软件回合组成。</p>
<p>（8）有时将软件运行环境简单地理解为软件运行剖面（Operational Profile）。欧空局（ESA）标准PSS-01-21（1991）“ESA软件产品保证要求”中，定义“软件运行剖面”为：“对系统使用条件的定义。系统的输入值都用其按时间的分布或按它们在可能输入范围内的出现概率的分布来定义”。简单来说，运行剖面定义了关于软件可靠性描述中的“规定条件”，也就是相当于可靠性测试中需要考虑的测试环境、测试数据等一系列问题。</p>
<h4 id="可靠性目标"><a href="#可靠性目标" class="headerlink" title="可靠性目标"></a>可靠性目标</h4><p>前面定量分析软件的可靠性时，使用失效强度来表示软件缺陷对软件运行的影响程度。然而在实际情况中，对软件运行的影响程度不仅取决于软件失效发生的概率，还和软件失效的严重程度有很大关系。这里引出另外一个概念——失效严重程度类（Failure Severity Class）。</p>
<p>失效严重程度类就是对用户具有相同程度影响的失效集合。</p>
<p>对失效严重程度的分级可以按照不同的标准进行，最为常见的是按对成本影响、对系统能力的影响等标准划分软件失效的严重程度类。</p>
<p>对成本的影响可能包括失效引起的额外运行成本、修复和恢复成本、现有或潜在的业务机会的损失等。由于失效严重程度类的影响分布很广泛，为了按照一定数量的等级去定义失效严重程度类，通常用数量级去划分等级。</p>
<p>表13-1给出了一个按照对成本的影响划分失效严重程度类的例子，这个例子涉及到的软件系统是某电子商务运营系统。</p>
<details><summary>表13-1　按照对成本的影响划分失效严重程度类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094025.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094025.png';" /></details>

<p>对系统能力的影响常常表现为关键数据的损失、系统异常退出、系统崩溃、导致用户操作无效等。对于不同性质的软件系统，相同的表现可能造成的失效严重程度是不同的，例如对可用性要求较高的系统，导致长时间停机的失效常常会划分到较高的严重级别中去。</p>
<p>表13-2给出了一个按照对系统能力的影响划分失效严重程度类的例子，这个例子涉及到的软件系统是某电信实时计费系统。</p>
<details><summary>表13-2　按照对系统能力的影响划分失效严重程度类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094046.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094046.png';" /></details>

<p>有了失效严重程度的划分，现在可以结合失效强度来定量地表示一个软件系统的可靠性目标了。</p>
<p>可靠性目标是指客户对软件性能满意程度的期望。通常用可靠度、故障强度和平均失效时间（MTTF）等指标来描述，根据不同项目的不同需要而定。建立定量的可靠性指标需要对可靠性、交付时间和成本进行平衡。为了定义系统的可靠性指标，必须确定系统的运行模式，定义故障的严重性等级，确定故障强度目标。</p>
<p>例如，对于表13-2的例子，可以根据经验和用户的需求确定软件系统需要达到的可靠程度，按照前面的公式，换算成失效强度和平均无失效时间，如表13-3所示。</p>
<details><summary>表13-3　可靠性目标参考表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094121.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094121.png';" /></details>

<h4 id="可靠性测试的意义"><a href="#可靠性测试的意义" class="headerlink" title="可靠性测试的意义"></a>可靠性测试的意义</h4><p>软件可靠性问题已被越来越多的软件工程专家所重视，人们已开始投入大量的人力、物力去研究软件可靠性的设计、评估和测试等课题。以下多个方面可以反映出软件可靠性问题对软件工程实践、乃至对生产活动和社会活动产生的深远影响。</p>
<p>（1）软件失效可能造成灾难性的后果。一个最显著的例子就是由于控制系统的Fortran程序中少了个逗点，致使控制系统未能发出正确的指令，最终使美国的一次宇宙飞行失败。而目前由于计算机和软件在各行各业中应用的日益广泛和深入，例如军用作战系统、民航指挥系统、银行支付系统和交通调控系统等，一旦发生严重级别的软件失效，轻则造成经济损失，重则危及人们的生命安全，危害国家安全。</p>
<p>（2）软件的失效在整个计算机系统失效中的比例较高。某研究机构曾经作过统计，在计算机系统的失效中，有80％和软件有关。原因是软件系统的内容结构太复杂了，一个较简单的程序，其所有的路径数就可能是一个天文数字。在软件开发的过程中，很难用全路径覆盖方式的测试去发现软件系统中隐藏的所有缺陷，也就是说，很难完全排除软件缺陷。</p>
<p>（3）相比硬件可靠性技术，软件可靠性技术很不成熟，这就加剧了软件可靠性问题的重要性。例如在硬件可靠性领域，故障树分析（Fault Tree Analysis, FTA）、失效模式与效应分析（Failure Made And Effect Analysis, FMEA）技术等比较成熟，容错技术也有广泛应用，但在软件可靠性领域，这些技术似乎尚未定型。</p>
<p>（4）与硬件元器件成本急剧下降形成鲜明对比的是，软件费用呈有增无减的势头，而软件可靠性问题是造成费用增长的主要原因之一。</p>
<p>（5）计算机技术获得日益广泛的应用，随着计算机应用系统中软件成分的不断增加，使得系统对于软件的依赖性越来越强，软件对生产活动和社会生活的影响越来越大，从而增加了软件可靠性问题在软件工程领域乃至整个计算机工程领域的重要性。</p>
<p>软件可靠性问题的重要性凸显了发展以发现软件可靠性缺陷为目的的可靠性设计与测试技术的迫切性。</p>
<h4 id="广义的可靠性测试与狭义的可靠性测试"><a href="#广义的可靠性测试与狭义的可靠性测试" class="headerlink" title="广义的可靠性测试与狭义的可靠性测试"></a>广义的可靠性测试与狭义的可靠性测试</h4><p>广义的软件可靠性测试是指为了最终评价软件系统的可靠性而运用建模、统计、试验、分析和评价等一系列手段对软件系统实施的一种测试。一个完整的软件可靠性测试包括图13-1所示的过程。</p>
<details><summary>图13-1　广义的软件可靠性测试</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904094355.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904094355.png';" /></details>

<p>狭义的软件可靠性测试是指为了获取可靠性数据，按预先确定的测试用例，在软件的预期使用环境中，对软件实施的一种测试。狭义的软件可靠性测试也叫“软件可靠性试验（Software Reliability Test）”，它是面向缺陷的测试，以用户将要使用的方式来测试软件，每一次测试代表用户将要完成的一组操作，使测试成为最终产品使用的预演。这就使得所获得的测试数据与软件的实际运行数据比较接近，可用于软件可靠性评价。</p>
<p>其实，软件可靠性测试是软件测试的一种形式，和易用性测试、性能测试、标准符合性测试等前面介绍的测试类型一样，是针对软件的某个重要质量特性，使用一定的测试用例对软件进行测试的过程。</p>
<p>可靠性测试是对软件产品的可靠性进行调查、分析和评价的一种手段。它不仅仅是为了用测试数据确定软件产品是否达到可靠性目标，还要对检测出的失效的分布、原因及后果进行分析，并给出纠正建议。总的来说，可靠性测试的目的可归纳为以下三个方面。</p>
<p>（1）发现软件系统在需求、设计、编码、测试和实施等方面的各种缺陷。</p>
<p>（2）为软件的使用和维护提供可靠性数据。</p>
<p>（3）确认软件是否达到可靠性的定量要求。</p>
<h3 id="软件可靠性建模"><a href="#软件可靠性建模" class="headerlink" title="软件可靠性建模"></a>软件可靠性建模</h3><h4 id="影响软件可靠性的因素"><a href="#影响软件可靠性的因素" class="headerlink" title="影响软件可靠性的因素"></a>影响软件可靠性的因素</h4><p>在讲到软件可靠性评估的时候，我们不得不提到软件可靠性模型。软件可靠性模型（Software Reliability Model）是指为预计或估算软件的可靠性所建立的可靠性框图和数学模型。建立可靠性模型是为了将复杂系统的可靠性逐级分解为简单系统的可靠性，以便于定量预计、分配、估算和评价复杂系统的可靠性。</p>
<p>为了构建软件的可靠性模型，首先要来分析一下影响软件可靠性的因素。影响软件可靠性的因素是纷杂而众多的，甚至包括技术以外的许多因素。首先必须考虑影响软件可靠性的主要因素：缺陷的引入、发现和清除。缺陷的引入主要取决于软件产品的特性和软件的开发过程特性。软件产品的特性指软件本身的性质，开发过程特性包括开发技术、开发工具、开发人员的水平、需求的变化频度等。缺陷的发现依靠用户对软件的操作方式、运行环境等，也就是运行剖面。缺陷的清除依赖于失效的发现和修复活动及可靠性方面的投入。</p>
<p>从技术的角度来看，影响软件可靠性的主要因素如下。</p>
<p>（1）运行剖面（环境）。软件可靠性的定义是相对运行环境而言的，一样的软件在不同的运行剖面下，其可靠性的表现是不一样的。</p>
<p>（2）软件规模。也就是软件的大小，一个只有数十行代码的软件和几千万行代码的软件是不能相提并论的。</p>
<p>（3）软件内部结构。结构对软件可靠性的影响主要取决于软件结构的复杂程度，一般来说，内部结构越复杂的软件，所包含的软件缺陷数就可能越多。</p>
<p>（4）软件的开发方法和开发环境。软件工程表明，软件的开发方法对软件的可靠性有显著影响。例如，与非结构方法相比，结构化方法可以明显减少软件的缺陷数。</p>
<p>（5）软件的可靠性投入。软件在生命周期中可靠性的投入包括开发者在可靠性设计、可靠性管理、可靠性测试和可靠性评价等方面投入的人力、资金、资源和时间等。经验表明，在早期重视软件可靠性并采取措施开发出来的软件，可靠性有明显的提高。</p>
<p>总之，有许许多多的因素影响着软件的可靠性，有些至今也无法确定它们与软件可靠性之间的定量关系，甚至定性关系也不甚清楚。</p>
<h4 id="软件可靠性建模方法"><a href="#软件可靠性建模方法" class="headerlink" title="软件可靠性建模方法"></a>软件可靠性建模方法</h4><p>一个软件可靠性模型通常（但不是绝对）由以下几部分组成。</p>
<p>（1）模型假设。模型是实际情况的简化或规范化，总要包含若干假设，例如测试的选取代表实际运行剖面，不同软件失效独立发生等。</p>
<p>（2）性能度量。软件可靠性模型的输出量就是性能度量，如失效强度、残留缺陷数等。在软件可靠性模型中性能度量通常以数学表达式给出。</p>
<p>（3）参数估计方法。某些可靠性度量的实际值无法直接获得，例如残留缺陷数，这时需通过一定的方法估计参数的值，从而间接确定可靠性度量的值。当然，对于可直接获得实际值的可靠性度量，就无需参数估计了。</p>
<p>（4）数据要求。一个软件可靠性模型要求一定的输入数据，即软件可靠性数据。不同类型的软件可靠性模型可能要求不同类型的软件可靠性数据。</p>
<p>绝大多数的模型包含三个共同假设。这些假设至今主宰着软件可靠性建模的研究发展，人们尚未找到克服这些假设局限性的有效方法。</p>
<p>（1）代表性假设。此假设认为软件测试用例的选取代表软件实际的运行剖面，甚至认为测试用例是独立随机地选取。此假设实质上是指可以用测试产生的软件可靠性数据预测运行阶段的软件可靠性行为。</p>
<p>（2）独立性假设。此假设认为软件失效是独立发生于不同时刻，一个软件失效的发生不影响另一个软件失效的发生。例如在概率范畴，假设相邻软件失效间隔构成一组独立随机变量，或假设一定时间内软件失效次数构成一个独立增量过程。在模糊数学范畴，则相邻软件失效间隔构成一组不相关的模糊变量。</p>
<p>（3）相同性假设。此假设认为所有软件失效的后果（等级）相同，即建模过程只考虑软件失效的具体发生时刻，不区分软件的失效严重等级。</p>
<p>软件可靠性模型要描述失效过程对上一节所分析的因素的一般依赖形式。由于这些因素大多数在本质上是概率性的，并且表现与时间相关联，所以通过失效数据的概率分布和随机过程随时间的变化的特性来整体区分软件可靠性模型。</p>
<p>我们常常通过下面估计或预测的方法来确定模型的参数。估计是通过收集到的失效数据进行统计分析，利用一定的推导过程归纳出模型的参数；预测则是使用软件产品自身的属性和开发过程来确定模型的参数，这种方法可以在开始执行程序前完成。</p>
<p>确定了模型的参数后，就可以来表示失效过程的很多不同的特性。例如，大多数模型都会对如下的内容进行解析表达。</p>
<p>（1）任何时间点所经历的平均失效数。</p>
<p>（2）一段时间间隔内的平均失效数。</p>
<p>（3）任何时间点的失效强度。</p>
<p>（4）失效区间的概率分布。</p>
<p>在对将来的故障行为进行预测时，应保证模型参数的值不发生变化。如果在进行预测时发现引入了新的错误，或修复行为使新的故障不断发生，就应停止预测，并等足够多的故障出现后，再重新进行模型参数的估计。否则，这样的变化会因为增加问题的复杂程度而使模型的实用性降低。</p>
<p>一般来说，软件可靠性模型是以在固定不变的运行环境中运行的不变的程序作为估测实体的。这也就是说，程序的代码和运行剖面都不发生变化，但它们往往总要发生变化的，于是在这种情况之下，就应采取分段处理的方式来进行工作。因此，模型主要集中注意力于排错。但是，也有的模型具有能处理缓慢地引进错误情况的能力。</p>
<p>对于一个已发行并正在运行的程序，应暂缓安装新的功能和对下一次发行的版本的修复。如果能保持一个不变的运行剖面，则程序的故障密度将显示为一个常数。</p>
<p>一般来说，一个好的软件可靠性模型增加了关于开发项目的交流，并对了解软件开发过程提供了一个共同的工作基础。它也增加了管理的透明度和其他令人感兴趣的东西。即使在特殊的情况之下，通过模型做出的预测并不是很精确的话，上面的这些优点也仍然是明显而有价值的。</p>
<p>要建立一个有用的软件可靠性模型必须有坚实的理论研究工作、有关工具的建造和实际工作经验的积累。通常这些工作要许多人一年的工作量。相反，要应用一个好的软件可靠性模型，则要求以极少的项目资源就可以在实际工作中产生好的效益。</p>
<p>一个好的软件可靠性模型应该具有如下重要特性。</p>
<p>（1）基于可靠的假设。</p>
<p>（2）简单。</p>
<p>（3）计算一些有用的量。</p>
<p>（4）给出未来失效行为的好的映射。</p>
<p>（5）可广泛应用。</p>
<h4 id="软件的可靠性模型分类"><a href="#软件的可靠性模型分类" class="headerlink" title="软件的可靠性模型分类"></a>软件的可靠性模型分类</h4><p>一个有效的软件可靠性模型应尽可能地将上面所述的因素在软件可靠性建模时加以考虑，尽可能简明地反映出来。自1972年第一个软件可靠性分析模型发表的30多年来，见之于文献的软件可靠性统计分析模型将近百种。这些可靠性模型大致可分为如下10类。</p>
<p>●　种子法模型。</p>
<p>●　失效率类模型。</p>
<p>●　曲线拟合类模型。</p>
<p>●　可靠性增长模型。</p>
<p>●　程序结构分析模型。</p>
<p>●　输入域分类模型。</p>
<p>●　执行路径分析方法模型。</p>
<p>●　非齐次泊松过程模型。</p>
<p>●　马尔可夫过程模型。</p>
<p>●　贝叶斯分析模型。</p>
<p>下面分别对这些模型进行简单介绍。</p>
<h5 id="种子法模型"><a href="#种子法模型" class="headerlink" title="种子法模型"></a>种子法模型</h5><p>这类模型利用捕获一再捕获抽样技术估计程序中的错误数，在程序中预先有意“播种”一些设定的错误“种子”，然后根据测试出的原始错误数和发现的诱导错误的比例，来估计程序中残留的错误数。其优点是简便易行，缺点是诱导错误的“种子”与实际的原始错误之间的类比性估量困难。</p>
<h5 id="失效率类模型"><a href="#失效率类模型" class="headerlink" title="失效率类模型"></a>失效率类模型</h5><p>这类模型用来研究程序的失效率，主要有下列内容。</p>
<p>●　Jelinski-Moranda的De-eutrophication模型。</p>
<p>●　Jelinski-Moranda的几何De-eutrophication模型。</p>
<p>●　Schick-Wolverton模型。</p>
<p>●　改进的Schick-Wolverton模型。</p>
<p>●　Moranda的几何泊松模型。</p>
<p>●　Goal和Okumoto不完全排错模型。</p>
<h5 id="曲线拟合类模型"><a href="#曲线拟合类模型" class="headerlink" title="曲线拟合类模型"></a>曲线拟合类模型</h5><p>这类模型用回归分析的方法研究软件复杂性、程序中的缺陷数、失效率、失效间隔时间，包括参数方法和非参数方法两种。</p>
<h5 id="可靠性增长模型"><a href="#可靠性增长模型" class="headerlink" title="可靠性增长模型"></a>可靠性增长模型</h5><p>这类模型预测软件在检错过程中的可靠性改进，用增长函数来描述软件的改进过程。这类模型如下。</p>
<p>●　Duane模型。</p>
<p>●　Weibull模型。</p>
<p>●　Wagoner的Weibull改进模型。</p>
<p>●　Yamada和Osaki的逻辑增长曲线。</p>
<p>●　Gompertz的增长曲线。</p>
<h5 id="程序结构分析模型"><a href="#程序结构分析模型" class="headerlink" title="程序结构分析模型"></a>程序结构分析模型</h5><p>程序结构模型是根据程序、子程序及其相互间的调用关系，形成一个可靠性分析网络。网络中的每一结点代表一个子程序或一个模块，网络中的每一有向弧代表模块间的程序执行顺序。假定各结点的可靠性是相互独立的，通过对每一个结点可靠性、结点间转换的可靠性和网络在结点间的转换概率，得出该持续程序的整体可靠性。这类模型如下。</p>
<p>●　Littewood马尔可夫结构模型。</p>
<p>●　Cheung的面向用户的马尔可夫模型。</p>
<h5 id="输入域分类模型"><a href="#输入域分类模型" class="headerlink" title="输入域分类模型"></a>输入域分类模型</h5><p>这类模型选取软件输入域中的某些样本“点”运行程序，根据这些样本点在“实际”使用环境中的使用概率的测试运行时的成功/失效率，推断软件的使用可靠性。这类模型的重点（亦是难点）是输入域的概率分布的确定及对软件运行剖面的正确描述。这类模型如下。</p>
<p>●　Nelson模型。</p>
<p>●　Bastani的基于输入域的随机过程模型。</p>
<h5 id="执行路径分析方法模型"><a href="#执行路径分析方法模型" class="headerlink" title="执行路径分析方法模型"></a>执行路径分析方法模型</h5><p>这类模型的分析方法与上面的模型相似，先计算程序各逻辑路径的执行概率和程序中错误路径的执行概率，再综合出该软件的使用可靠性。Shooman分解模型属于此类。</p>
<h5 id="非齐次泊松过程模型"><a href="#非齐次泊松过程模型" class="headerlink" title="非齐次泊松过程模型"></a>非齐次泊松过程模型</h5><p>非齐次泊松过程模型，即NHPP，是以软件测试过程中单位时间的失效次数为独立泊松随机变量，来预测在今后软件的某使用时间点的累计失效数。这类模型如下。</p>
<p>●　Musa的指数模型。</p>
<p>●　Goel和Okumoto的NHPP模型。</p>
<p>●　S型可靠性增长模型。</p>
<p>●　超指数增长模型。</p>
<p>●　Pham改进的NHPP模型。</p>
<h5 id="马尔可夫过程模型"><a href="#马尔可夫过程模型" class="headerlink" title="马尔可夫过程模型"></a>马尔可夫过程模型</h5><p>这类模型如下。</p>
<p>●　完全改错的线性死亡模型。</p>
<p>●　不完全改错的线性死亡模型。</p>
<p>●　完全改错的非静态线性死亡模型。</p>
<h5 id="贝叶斯模型"><a href="#贝叶斯模型" class="headerlink" title="贝叶斯模型"></a>贝叶斯模型</h5><p>这是利用失效率的试验前分布和当前的测试失效信息，来评估软件的可靠性。这是一类当软件可靠性工程师对软件的开发过程有充分的了解，软件的继承性比较好时具有良好效果的可靠性分析模型。这类模型如下。</p>
<p>●　连续时间的离散型马尔可夫链。</p>
<p>●　Shock模型。</p>
<p>另外，Musa和Okumoto依据模型的不同属性对可靠性模型进行以下分类。</p>
<p>●　时间域：有两种，自然或日历时间与执行（CPU）时间。</p>
<p>●　失效数类：取决于无限时间内发生的失效数是有限的还是无限的。</p>
<p>●　失效数分布：相对于时间系统失效数的统计分布形式，主要的两类是泊松分布型和二项分布型。</p>
<p>●　有限类：对有限失效数的类别适用，用时间表示的失效强度的函数形式。</p>
<p>●　无限类：对无限失效数的类别适用，用经验期望失效数表示的失效强度的函数形式。</p>
<h4 id="软件可靠性模型举例"><a href="#软件可靠性模型举例" class="headerlink" title="软件可靠性模型举例"></a>软件可靠性模型举例</h4><p>迄今已有数十种模型是根据上一小节中关于模型的分类方法进行的分类，下面将介绍Jelinski-Moranda模型的基本思想及其相关的历史背景。</p>
<p>Jelinski-Moranda模型（JM模型）是Z.Jelinski和P.Moranda于1972年提出的软件可靠性数学模型，是最具代表性的早期软件可靠性马尔可夫过程的数学模型。随后的许多工作都是在它的基础上对其中与软件开发实际不相适合的地方进行改进而提出来的，所以，JM模型是具有广泛影响的模型之一。</p>
<h5 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h5><p>M模型的基本假设如下。</p>
<p>（1）软件系统中的初始错误个数为一个未知的常数，用N0表示。</p>
<p>（2）可靠性测试中发现的错误立即被完全排除，并且排除过程不引入新的错误，排除时间忽略不计。因此，每次排错之后，N0就要减去1。</p>
<p>（3）在任何一个失效间隔区间，软件系统的失效率与系统中剩余的错误个数成正比，比例常数用φ表示。</p>
<p>其实，最初Jehnski和Moranda提出的模型假设只有最后一条，前面两个假设是后人根据使用过程中出现的问题归纳总结而来的。</p>
<h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><p>根据假设，每发生1次失效，错误数都要减去1，如果用t1，t2，…，ti表示从0时刻开始的每次失效间隔时间，那第i-1次失效到第i次失效之间的失效率为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134009.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134009.png';" /></details>

<p>根据在可靠性定量描述一节的讨论，知道失效强度函数为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134022.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134022.png';" /></details>

<p>可靠度函数为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134043.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134043.png';" /></details>

<p>失效概率分布函数为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134106.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134106.png';" /></details>

<h5 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h5><p>在可靠度函数表达式中含有两个未知参数φ和N0，下面运用统计学中的最大似然法来对参数φ和N0进行估算。</p>
<p>由公式（13-15）可得似然函数</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134146.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134146.png';" /></details>

<p>对公式（13-17）取对数，得到对数似然函数</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134202.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134202.png';" /></details>

<p>对公式（13-18）中的N0和φ求偏导，并令结果为0</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134228.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134228.png';" /></details>

<p>公式（13-19）可以写成</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134249.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134249.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134325.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134325.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134334.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134334.png';" /></details>

<p>再来解出另一个参数φ的估计值，令</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134348.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134348.png';" /></details>

<p>则从（13-20）中可解出</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134404.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134404.png';" /></details>

<p>代入N0的估计值，可解出φ的估计值</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134417.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134417.png';" /></details>

<p>需要说明的是，软件可靠性是一门正在发展中的分支学科，许多来源于硬件可靠性的理论在软件可靠性研究中并不适用，有关软件可靠性的模型并不成熟，并且应用范围也非常有限，软件可靠性的定量分析方法和数学模型要在实践中不断加以验证和修正，对于不同类型的软件，模型的假设、表示公式及应用方式也有很大的区别。</p>
<h4 id="软件可靠性测试概述"><a href="#软件可靠性测试概述" class="headerlink" title="软件可靠性测试概述"></a>软件可靠性测试概述</h4><p>软件测试者可以使用很多方法进行软件测试，如按行为或结构来划分输入域的划分测试，纯粹随机选择输入的随机测试，基于功能、路径、数据流或控制流的覆盖测试等。对于给定的软件，每种测试方法都局限于暴露一定数量和一些类别的缺陷。通过这些测试能够查找、定位、改正和消除某些缺陷，实现一定意义上的软件可靠性增长。但是，由于它们都是面向错误的测试，测试所得的结果数据不能直接用于软件可靠性评价，必须经过一定的分析处理后方可使用可靠性模型进行可靠性评价。</p>
<p>软件可靠性测试由可靠性目标的确定、运行剖面的开发、测试用例的设计、测试实施、测试结果的分析等主要活动组成。</p>
<p>软件可靠性测试还必须考虑对软件开发进度和成本的影响，最好是在受控的自动测试环境下，由专业测试机构完成。</p>
<p>软件可靠性测试是一种有效的软件测试和软件可靠性评价技术。尽管软件可靠性测试也不能保证软件中残存的缺陷数最少，但经过软件可靠性测试可以保证软件的可靠性达到较高的要求，对于开发高可靠性与高安全性软件系统很有帮助。</p>
<p>软件可靠性测试要在工程上获得广泛应用，还有许多实际问题需要解决。</p>
<h4 id="定义软件运行剖面"><a href="#定义软件运行剖面" class="headerlink" title="定义软件运行剖面"></a>定义软件运行剖面</h4><p>定义运行剖面首先需要为软件的使用行为建模，建模可以采用马尔可夫链来完成。用马尔可夫链将输入域编码为一个代表用户观点的软件使用的状态集。弧用来连接状态并表示由各种激励导致的转换，这些激励可能由硬件、人机接口或其他软件等产生。将转换概率分配给每个弧，用来代表一个典型用户最有可能施加给系统的激励。这种类型的马尔可夫链是一个离散的有限状态集，这类模型可以用有向图或转换矩阵表示。</p>
<p>定义运行剖面的下一步是开发使用模型，明确需要测试的内容。软件系统可能会有许多用户和用户类别，每类用户都可能以不同的方式使用系统。开发使用模型涉及到将输入域分层，有两种类型的分层形式：用户级分层和用法级分层。用户级分层依赖于谁或什么能激励系统；用法级分层依赖于在测试状态下系统能做什么。换句话说，用户级分层考虑各种类型的用户以及他们如何使用系统；用法级分层则要求考虑系统能够提供的所有功能。一旦用户和用法模型被开发出来，弧上的概率将被分配。这些概率估计主要是基于如下几个方面。</p>
<p>（1）从现有系统收集到的数据。</p>
<p>（2）与用户的交谈或对用户进行观察获得的信息。</p>
<p>（3）原型使用与测试分析的结果。</p>
<p>（4）相关领域专家的意见。</p>
<p>定义使用概率的最佳方法是使用实际的用户数据，如来自系统原型、前一版本的使用数据；其次是由该软件应用领域的用户和专家提供的预期使用数据；在没有任何数据可用的情况下，只能是将每个状态现有的弧分配相同的概率，这是最差的一种方法。</p>
<p>由于软件可靠性行为是相对于软件实际的运行剖面而言的，同一软件在不同运行剖面下其可靠性表现可能大不相同，所以用于可靠性测试准备的运行剖面的开发与定义必须充分分析和考虑软件的实际运行情况。</p>
<p>软件可靠性测试假设每个操作的数据输入都有同样的发生错误的概率，这样最频繁出现的操作和输入将表现出最高的故障率。对于特定的操作环境这是正确的，但无法贯穿系统的全部操作集合。典型的例子是飞机的飞行控制软件，在正常飞行、起飞、降落、地面运动和地面等待这5个状态中，尽管起飞和降落在运行剖面上只占有很小的百分比，但是它们却占有很大的故障比例。对于高安全性要求的软件，一个看起来很少使用的代码路径也可能带来灾难性的后果。因此，对于边界、跃迁情况和关键功能不应该用简单的运行剖面来对待，应该构造专门的运行剖面，补充统计模型之外的测试用例。在覆盖率水平不够时，可根据具体空白，进行适当的补充测试。如果补充测试发现了错误，就可分析这些错误，估计其对可靠性产生的影响。</p>
<p>一个产品有可能需要开发多个运行剖面，这取决于它所包含的运行模式和关键操作，通常需要为关键操作单独定义运行剖面。</p>
<h4 id="可靠性测试用例设计"><a href="#可靠性测试用例设计" class="headerlink" title="可靠性测试用例设计"></a>可靠性测试用例设计</h4><p>为了对软件可靠性进行良好的预计，必须在软件的运行域上对其进行测试。首先定义一个相应的剖面来镜像运行域，然后使用这个剖面驱动测试，这样可以使测试真实地反映软件的使用情况。</p>
<p>由于可能的输入几乎是无限的，测试必须从中选择出一些样本，即测试用例。测试用例要能够反映实际的使用情况，反映系统的运行剖面。将统计方法运用到运行剖面开发和测试用例生成中去，并为在运行剖面中的每个元素都定量地赋予一个发生概率值和关键因子，然后根据这些因素分配测试资源，挑选和生成测试用例。</p>
<p>在这种测试中，优先测试那些最重要或最频繁使用的功能，释放和缓解最高级别的风险，有助于尽早发现那些对可靠性有最大影响的故障，以保证软件的按期交付。</p>
<p>设计测试用例就是针对特定功能或组合功能设计测试方案，并编写成文档。测试用例的选择既要有一般情况，也应有极限情况以及最大和最小的边界值情况。因为测试的目的是暴露应用软件中隐藏的缺陷，所以在设计选取测试用例和数据时要考虑那些易于发现缺陷的测试用例和数据，结合复杂的运行环境，在所有可能的输入条件和输出条件中确定测试数据，来检查应用软件是否都能产生正确的输出。</p>
<p>一个典型的测试用例应该包括下列组成部分。</p>
<p>（1）测试用例标识。</p>
<p>（2）被测对象。</p>
<p>（3）测试环境及条件。</p>
<p>（4）测试输入。</p>
<p>（5）操作步骤。</p>
<p>（6）预期输出。</p>
<p>（7）判断输出结果是否符合标准。</p>
<p>（8）测试对象的特殊需求。</p>
<p>由于可靠性测试的主要目的是评估软件系统的可靠性，因此，除了常规的测试用例集仍然适用外，还要着重考虑和可靠性密切相关的一些特殊情况。在测试中，可以考虑进行“强化输入”，即比正常输入更恶劣（合理程度的恶劣）的输入。</p>
<p>表13-4给出了一些参考例子。</p>
<details><summary>表13-4　可靠性测试用例设计时重点考虑的一些特殊情况</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904134610.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904134610.png';" /></details>

<h4 id="可靠性测试的实施"><a href="#可靠性测试的实施" class="headerlink" title="可靠性测试的实施"></a>可靠性测试的实施</h4><p>在进行应用软件的可靠性测试前有必要检查软件需求与设计文档是否一致，检查软件开发过程中形成的文档的准确性、完整性以及与程序的一致性，检查所交付程序和数据以及相应的软件支持环境是否符合要求。</p>
<p>这些检查虽然增加了工作量，但对于在测试早期发现错误和提高软件的质量是非常必要的。</p>
<p>软件可靠性测试必须是受控测试，在运行此类测试时，为了保证统计数据的有效性，测试过程中的每个测试用例必须用相同的软件版本，新的软件版本意味着新测试的开始。</p>
<p>在有些情况下，不能进行纯粹的可靠性测试。因为客户的要求、合同的规定或者标准的约束，需要补充其他形式的非统计测试。这时的最佳选择是既执行可靠性测试，也执行非统计测试（如覆盖测试）。如果非统计测试在可靠性测试之前完成，由统计测试产生的统计数据仍然有效。但是在可靠性测试之后执行非统计测试，可能会影响软件可靠性评估的准确性。</p>
<p>软件可靠性测试同样依赖于软件的可测试性。可靠性测试的难点就在于判断测试用例的运行是成功还是失败。在控制系统及类似的软件中，失效由详细说明、时间（通常是CPU时间或时钟时间）来客观地定义。而在一般应用系统中，失效的定义更主观些，它不仅依赖于程序是否符合规格说明的要求，也取决于指定的性能是否能够达到用户的期望，但是否达到期望没有确定的标准。在一些科学计算中，计算结果只能由计算机给出，在这种情况下，如果软件只是输出了错误的结果而不是整个系统发生失效，错误就不可能被发现。此时可以将测试分成两个阶段进行。第一阶段运行较少量的测试用例，并对照规范进行仔细检查。第二阶段再运行大量测试用例。第二阶段不用人工检查输出的每项内容，而是找失效现象，包括错误信息、断电、崩溃和死机。也可把输出记录到文件中，采用搜索或过滤方法进行处理。如果软件有足够的可测试性，这种方法不会漏掉很多的严重失效。如果计算的正确性无法验证，就需要对软件进行一些形式化的证明。</p>
<p>开发方交付的任何软件文档中与可靠性质量特性有关的部分、程序以及数据都应当按照需求说明和质量需求进行测试。在项目合同、需求说明书和用户文档中规定的所有配置情况下，程序和数据都必须进行测试。</p>
<p>软件可靠性数据是可靠性评价的基础。为了获得更多的可靠性数据，应该使用多台计算机同时运行软件，以增加累计运行时间。应该建立软件错误报告、分析与纠正措施系统。按照相关标准的要求，制定和实施软件错误报告和可靠性数据收集、保存、分析和处理的规程，完整、准确地记录软件测试阶段的软件错误报告和收集可靠性数据。</p>
<p>用时间定义的软件可靠性数据可以分为4类，具体内容如下。</p>
<p>（1）失效时间数据。记录发生一次失效所累积经历的时间。</p>
<p>（2）失效间隔时间数据。记录本次失效与上一次失效间的间隔时间。</p>
<p>（3）分组时间内的失效数。记录某个时间区内发生了多少次失效。</p>
<p>（4）分组时间的累积失效数。记录到某个区间的累积失效数。</p>
<p>这4类数据可以互相转化。</p>
<p>在测试过程中必须真实地进行记录，每个测试记录必须包含如下信息。</p>
<p>（1）测试时间。</p>
<p>（2）含有测试用例的测试说明或标识。</p>
<p>（3）所有与测试有关的测试结果，包括失效数据。</p>
<p>（4）测试人员。</p>
<p>测试活动结束后要编写《软件可靠性测试报告》，对测试用例及测试结果在测试报告中加以总结归纳。编写时可以参考GJB 438A-97中提供的《软件测试报告》格式，并应根据情况进行剪裁。测试报告应具备如下内容。</p>
<p>（1）软件产品标识。</p>
<p>（2）测试环境配置（硬件和软件）。</p>
<p>（3）测试依据。</p>
<p>（4）测试结果。</p>
<p>（5）测试问题。</p>
<p>（6）测试时间。</p>
<p>把可靠性测试过程进行规范化，有利于获得真实有效的数据，为最终得到客观的可靠性评价结果奠定基础。</p>
<h3 id="软件可靠性评价"><a href="#软件可靠性评价" class="headerlink" title="软件可靠性评价"></a>软件可靠性评价</h3><h4 id="软件可靠性评价概述"><a href="#软件可靠性评价概述" class="headerlink" title="软件可靠性评价概述"></a>软件可靠性评价概述</h4><p>软件可靠性评价是软件可靠性活动的重要组成部分，既适用于软件开发过程，也可针对最终软件系统。在软件开发过程中使用软件可靠性评价，可以使用软件可靠性模型，估计软件当前的可靠性，以确认是否可以终止测试并发布软件，同时还可以预计软件要达到相应的可靠性水平所需要的时间和工作量，评价提交软件时的软件可靠性水平。对于最终软件产品，软件可靠性评价结合可靠性验证测试，确认软件的执行与需求的一致性，确定最终软件产品所达到的可靠性水平。</p>
<p>这一节阐述的软件可靠性评价工作是指选用或建立合适的可靠性数学模型，运用统计技术和其他手段，对软件可靠性测试和系统运行期间收集的软件失效数据进行处理，并评估和预测软件可靠性的过程。这个过程包含如下三个方面。</p>
<p>（1）选择可靠性模型。</p>
<p>（2）收集可靠性数据。</p>
<p>（3）可靠性评估和预测。</p>
<h4 id="怎样选择可靠性模型"><a href="#怎样选择可靠性模型" class="headerlink" title="怎样选择可靠性模型"></a>怎样选择可靠性模型</h4><p>在前面讨论了软件的可靠性模型以及一个举例，一些可靠性研究者试图寻找一个最好的模型，能适用于所有的软件系统，但这样的工作是徒劳的。因为对于不同的软件系统，出于不同的可靠性分析目的，模型的适用性是不一样的。但究竟怎样来为可靠性评价选用不同的模型，却又是一个不小的难题。</p>
<p>针对可靠性模型的构成以及使用模型来进行可靠性评价的目的，可以从以下几个方面进行比较和选择。</p>
<h5 id="模型假设的适用性"><a href="#模型假设的适用性" class="headerlink" title="模型假设的适用性"></a>模型假设的适用性</h5><p>模型假设是可靠性模型的基础，模型假设要符合软件系统的现有状况，或与假设冲突的因素在软件系统中应该是可忽略的。例如，有的模型假定检测或发现的软件缺陷是立即排除掉的，而且排除时间忽略不计，如果现有的软件系统对于严重程度类较低的软件缺陷不进行立即排错，那么这个模型显然是不适用的。</p>
<p>往往一个模型的假设有许多条，我们需要在选用模型的时候对每一条假设进行细致的分析，评估现有的软件系统中不符合假设的因素对可靠性评价的影响如何，以确定模型是否适合软件系统的可靠性评价工作。</p>
<h5 id="预测的能力与质量"><a href="#预测的能力与质量" class="headerlink" title="预测的能力与质量"></a>预测的能力与质量</h5><p>预测的能力与质量是指模型根据现在和历史的可靠性数据，预测将来的可靠性和失效概率的能力，以及预测结果的准确程度。显然，模型预测的能力与质量是比较难于评价的，但任何一个模型只有在实践中加以实验和不断改善，才能得到认可。所以，在满足其他条件的前提下，应尽量选用比较成熟、应用较广的模型作为分析模型。</p>
<h5 id="模型输出值能否满足可靠性评价需求"><a href="#模型输出值能否满足可靠性评价需求" class="headerlink" title="模型输出值能否满足可靠性评价需求"></a>模型输出值能否满足可靠性评价需求</h5><p>使用模型进行可靠性评价的最终目的，是想得到软件系统当前的可靠性定量数据，以及预测一定时间后的可靠性数据，可以根据可靠性测试目的来确定哪些模型的输出值满足可靠性评价需求。一般来说，最重要的几个需要精确估计的可靠性定量指标包括如下内容。</p>
<p>（1）当前的可靠度。</p>
<p>（2）平均无失效时间。</p>
<p>（3）故障密度。</p>
<p>（4）期望达到规定可靠性目标的日期。</p>
<p>（5）达到规定的可靠性目标的成本要求。</p>
<h5 id="模型使用的简便性"><a href="#模型使用的简便性" class="headerlink" title="模型使用的简便性"></a>模型使用的简便性</h5><p>模型使用的简便性一般包含如下三层含义。</p>
<p>（1）模型需要的数据在软件系统中应该易于收集，而且收集需要投入的成本不能超过可靠性计划的预算。</p>
<p>（2）模型应该简单易懂，进行可靠性分析的软件测试人员不会花费太多的时间去研究专业的数学理论，他们只需要知道哪些假设适用，需要收集哪些数据，能够得到哪些分析结果就可以了。</p>
<p>（3）模型应该便于使用，最好能用工具实现数据的输入。也就是说，测试人员除了输入可靠性数据外，不需要深入模型内部进行一些额外的工作。</p>
<p>尽管这样，由于可靠性研究理论在软件工程领域发展的限制，可供选择的可靠性模型极其有限，这已在相当大的程度上制约了可靠性测试的开展。</p>
<h4 id="可靠性数据的收集"><a href="#可靠性数据的收集" class="headerlink" title="可靠性数据的收集"></a>可靠性数据的收集</h4><p>面向缺陷的可靠性测试产生的测试数据经过分析后，可以得到非常有价值的可靠性数据，是可靠性评价所用数据的一个重要来源，这部分数据取决于定义的运行剖面和选取的测试用例集。可靠性数据主要是指软件失效数据，是软件可靠性评价的基础，主要是在软件测试、实施阶段收集的。在软件工程的需求、设计和开发阶段的可靠性活动，也会产生影响较大的其他可靠性数据。因此，可靠性数据的收集工作是贯穿于整个软件生命周期的。</p>
<p>由于软件开发过程中的特殊复杂性及许多潜在因素的影响，可靠性数据收集工作会极为困难。目前，关于数据的收集工作，存在许多有待解决的问题。</p>
<p>（1）可靠性数据的规范不统一，对软件进行度量的定义混乱不清。例如，时间、缺陷、失效和模型结构等的定义，就相当含糊，缺乏统一的标准。这样就使得在进行软件可靠性数据的收集时，目标不明确，甚至无从下手。</p>
<p>（2）数据收集工作的连续性不能保证。可靠性数据的收集是连续的、长期的过程，而且需要投入一定的资金、人力、时间，往往这些投入会在软件的开发计划中被忽略，以至于不能保证可靠性数据收集工作的正常进行。</p>
<p>（3）缺乏有效的数据收集手段。进行数据收集同样需要方便实用的工具，然而除了在可靠性测试方面有了一些可用的数据收集工具外，其他方面的工具还十分缺乏。</p>
<p>（4）数据的完整性不能保证。即使可靠性活动计划做得再周密，收集到的数据仍有可能是不完全的，而且遗漏的数据往往会影响到可靠性评价的结果。</p>
<p>（5）数据质量和准确性不能保证。不完全的排错及诊断，使收集的数据中含有不少虚假的成分，它们不能正确反映软件的真实状况。使用不准确的可靠性数据进行的可靠性评价，误差有可能会比利用可靠性模型进行预测产生的误差大一个数量级，这说明数据质量的重要性。</p>
<p>为了给软件可靠性评价提供一套准确、有效的可靠性数据，有必要在软件工程中重视软件可靠性数据的收集工作，采取一些措施尽量解决上述问题。在现有条件下，可行的一些办法如下。</p>
<p>（1）及早确定所采用的可靠性模型，以确定需要收集的可靠性数据，并明确定义可靠性数据规范中的一些术语和记录方法，如时间、失效、失效严重程度类的定义，制定标准的可靠性数据记录和统计表格等。</p>
<p>（2）制定可实施性较强的可靠性数据收集计划，指定专人负责，抽取部分开发人员、质量保证人员、测试人员、用户业务人员参加，按照统一的规范收集记录可靠性数据。</p>
<p>（3）重视软件测试特别是可靠性测试产生的测试数据的整理和分析，因为这部分数据是用模拟软件实际运行环境的方法、模拟用户实际操作的测试用例测试软件系统产生的数据，对软件可靠性评价和预测有较高的实用价值。</p>
<p>（4）充分利用数据库来完成可靠性数据的存储和统计分析。一方面减少数据管理的混乱，一方面提高数据处理的效率。</p>
<h4 id="软件可靠性的评估和预测"><a href="#软件可靠性的评估和预测" class="headerlink" title="软件可靠性的评估和预测"></a>软件可靠性的评估和预测</h4><p>软件可靠性的评估和预测的主要目的，是为了评估软件系统的可靠性状况和预测将来一段时间的可靠性水平。下面是一些常见的需要利用软件可靠性评价进行解答的问题。</p>
<p>（1）判断是否达到了可靠性目标，是否达到了软件付诸使用的条件，是否达到了中止测试的条件。</p>
<p>（2）如未能达到，要再投入多少时间、多少人力和多少资金，才能达到可靠性目标或投入使用。</p>
<p>（3）在软件系统投入实际运行一年或若干时间后，经过维护、升级、修改，软件能否达到交付或部分交付用户使用的可靠性水平。</p>
<p>目前有不少支持软件可靠性估计的软件工具，只要将收集的失效数据分类并录入，选择合适的可靠性模型就可以获得软件可靠性的评价结果。</p>
<p>然而，对于那些可靠性要求很高的系统，必须进行很多测试才能预计出高置信度的可靠性结果。即便如此，仍然可能没有任何失效发生。没有失效就无法估计可靠性，不能认为程序的可靠度是1.0。除非已经进行了完全的测试，否则程序不失效就无法做出估计，而完全的测试几乎总是不可能的。如果在测试期间没有失效发生，可以简单地假设测试是基于二项式分布的，这样就可以对可靠性作保守估计。也可以凭经验，根据无故障运行的测试用例的数量，在一定的置信度水平上，估计可靠性的等级。</p>
<p>软件可靠性评价技术和方法主要依据选用的软件可靠性模型，其来源于统计理论。软件可靠性评估和预测以软件可靠性模型分析为主，但也要在模型之外运用一些统计技术和手段对可靠性数据进行分析，作为可靠性模型的补充、完善和修正。这些辅助方法如下。</p>
<p>（1）失效数据的图形分析法。运行图形处理软件失效数据，可以直观地帮助我们进行分析。图形指标如下。</p>
<p>①累积失效个数图形。</p>
<p>②单位时间段内的失效数的图形。</p>
<p>③失效间隔时间图形。</p>
<p>（2）试探性数据分析技术（Exploratory Data Analysis, EDA）。对于失效数据图形进行一定的数字化分析，能发现和揭示出数据中的异常。对可靠性分析有用的信息如下。</p>
<p>①循环相关。</p>
<p>②短期内失效数的急剧上升。</p>
<p>③失效数集中的时间段。</p>
<p>这种分析方法常可以发现因排错引入新的缺陷、数据收集的质量问题及时间域的错误定义等问题。</p>
<p>还有其他一些分析方法，这里就不一一赘述了。</p>
<h3 id="软件的可靠性设计与管理"><a href="#软件的可靠性设计与管理" class="headerlink" title="软件的可靠性设计与管理"></a>软件的可靠性设计与管理</h3><h4 id="软件可靠性设计"><a href="#软件可靠性设计" class="headerlink" title="软件可靠性设计"></a>软件可靠性设计</h4><p>在测试阶段，利用测试手段收集测试数据，并利用软件可靠性模型，可以评估或预测软件的可靠性。这些软件可靠性测试活动虽然能通过查错—排错活动有限地改善软件可靠性，但不能从根本上提高软件的可靠性，也难以保证软件可靠性，并且修改由于设计导致的软件缺陷，有可能付出比较昂贵的代价。实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制。为了从根本上提高软件的可靠性，降低软件后期修改的成本和难度，人们提出了可靠性设计的概念。</p>
<p>可靠性设计其实就是在常规的软件设计中，应用各种方法和技术，使程序设计在兼顾用户的功能和性能需求的同时，全面满足软件的可靠性要求，即采用一些技术手段，把可靠性“设计”到软件中去。软件可靠性设计技术就是以提高和保障软件的可靠性为目的，在软件设计阶段运用的一种特殊的设计技术。</p>
<p>在软件工程中已有很多比较成熟的设计技术，如结构化设计、模块化设计、自顶向下设计及自底向上设计等，这些技术是为了保障软件的整体质量而采用的。在此基础上，为了进一步提高软件的可靠性，通常会采用一些特殊设计技术。虽然软件可靠性设计技术与普通的软件设计技术没有明显的界限，但软件可靠性设计仍要遵循一些自己的原则。</p>
<p>（1）软件可靠性设计是软件设计的一部分，必须在软件的总体设计框架中使用，并且不能与其他设计原则相冲突。</p>
<p>（2）软件可靠性设计在满足提高软件质量要求的前提下，以提高和保障软件可靠性为最终目标。</p>
<p>（3）软件可靠性设计应确定软件的可靠性目标，不能无限扩大化，并且排在功能度、用户需求和开发费用之后考虑。</p>
<p>可靠性设计概念被广为引用，但并没有多少人能提出非常实用并且广泛运用的可靠性设计技术。一般来说，被认可的且具有应用前景的软件可靠性设计技术主要有容错设计、检错设计和降低复杂度设计等技术。</p>
<h5 id="容错设计技术"><a href="#容错设计技术" class="headerlink" title="容错设计技术"></a>容错设计技术</h5><p>对于软件失效后果特别严重的场合，如飞机的飞行控制系统、空中交通管制系统及核反应堆安全控制系统等，可采用容错设计方法。常用的软件容错技术主要有恢复块设计、N版本程序设计和冗余设计三种方法。</p>
<p>（1） $\color{green}{\text{恢复块设计}}$ 。</p>
<p>程序的执行过程可以看成是由一系列操作构成的，这些操作又可由更小的操作构成。恢复块设计就是选择一组操作作为容错设计单元，从而把普通的程序块变成恢复块。被选择用来构造恢复块的程序块可以是模块、过程、子程序和程序段等。</p>
<p>一个恢复块包含有若干个功能相同、设计差异的程序块文本，每一时刻有一个文本处于运行状态。一旦该文本出现故障，则用备份文本加以替换，从而构成“动态冗余”。软件容错的恢复块方法就是使软件包含有一系列恢复块。</p>
<p>（2） $\color{green}{\text{N版本程序设计}}$ 。</p>
<p>N版本程序的核心是通过设计出多个模块或不同版本，对于相同初始条件和相同输入的操作结果，实行多数表决，防止其中某一软件模块/版本的故障提供错误的服务，以实现软件容错。为使此种容错技术具有良好的结果，必须注意以下两个方面。</p>
<p>①使软件的需求说明具有完全性和精确性。这是保证软件设计错误不相关的前提，因为软件的需求说明是不同设计组织和人员的唯一共同出发点。</p>
<p>②设计全过程的不相关性。它要求各个不同的软件设计人员彼此不交流，程序设计使用不同的算法、不同的编程语言、不同的编译程序、不同的设计工具、不同的实现方法和不同的测试方法。为了彻底保证软件设计的不相关性，甚至提出设计人员应具有不同的受教育背景，来自不同的地域、不同的国家。</p>
<p>（3） $\color{green}{\text{冗余设计}}$ 。</p>
<p>改善软件可靠性的一个重要技术是冗余设计。在硬件系统中，在主运行的系统之外备用额外的元件或系统，如果出现一个元件故障或系统故障，则立即更换冗余的元件或切换到冗余的系统，则该硬件系统仍可以维持运行。在软件系统中，冗余技术的运用有所区别。如果采用相同两套软件系统作为互为备份，其意义不大，因为在相同的运行环境中，一套软件出故障的地方，另外一套也一定会出现故障。软件的冗余设计技术实现的原理是在一套完整的软件系统之外，设计一种不同路径、不同算法或不同实现方法的模块或系统作为备份，在出现故障时可以使用冗余的部分进行替换，从而维持软件系统的正常运行。</p>
<p>从表面上看，设计开发完成同样功能但实现方法完全不同的两套软件系统，需要的费用可能接近于单个版本软件开发费用的两倍，但采用冗余技术设计软件所增加的额外费用肯定远低于重新设计一个版本软件的费用。这是因为大多数设计花费，例如文档、测试以及人力都是有可能复用的。冗余设计还有可能导致软件运行时所花费的存储空间、内存消耗以及运行时间有所增加，这就需要在可靠性要求和额外付出代价之间作出折衷。</p>
<h5 id="检错技术"><a href="#检错技术" class="headerlink" title="检错技术"></a>检错技术</h5><p>在软件系统中，对无需在线容错的地方、或不能采用冗余设计技术的部分，如果对可靠性要求较高，故障有可能导致严重的后果。一般采用检错技术，在软件出现故障后能及时发现并报警，提醒维护人员进行处理。检错技术实现的代价一般低于容错技术和冗余技术，但它有一个明显的缺点，就是不能自动解决故障，出现故障后如果不进行人工干预，将最终导致软件系统不能正常运行。</p>
<p>采用检错设计技术要着重考虑几个要素：检测对象、检测延时、实现方式和处理方式。</p>
<p>（1）检测对象：包含两个层次的含义，即检测点和检测内容。在设计时应考虑把检测点放在容易出错的地方和出错对软件系统影响较大的地方；检测内容选取那些有代表性的、易于判断的指标。</p>
<p>（2）检测延时：从软件发生故障到被自检出来是有一定延时的，这段延时的长短对故障的处理是非常重要的。因此，在软件检错设计时要充分考虑到检测延时。如果延时长到影响故障的及时报警，则需要更换检测对象或检测方式。</p>
<p>（3）实现方式：最直接的一种实现方式是判断返回结果，如果返回结果超出正常范围，则进行异常处理。计算运行时间也是一种常用的技术，如果某个模块或函数运行超过预期的时间，可以判断出现故障。另外，还有置状态标志位等多种方法，自检的实现方式要根据实际情况来选用。</p>
<p>（4）处理方式：大多数检错采用“查出故障—停止软件系统运行—报警”的处理方式，但也有采用不停止或部分停止软件系统运行的情况，这一般由故障是否需要实时处理来决定。</p>
<h5 id="降低复杂度设计"><a href="#降低复杂度设计" class="headerlink" title="降低复杂度设计"></a>降低复杂度设计</h5><p>前面讲到，软件和硬件最大的区别之一就是软件的内部结构比硬件复杂得多，我们用软件复杂度来定量描述软件的复杂程度。软件复杂性常分为模块复杂性和结构复杂性。模块复杂性主要包含模块内部数据流向和程序长度两个方面，结构复杂性用不同模块之间的关联程度来表示。软件复杂度可用涉及到模块复杂性和结构复杂性的一些统计指标来进行定量描述，在这里就不进行详细叙述了。</p>
<p>软件的复杂性与软件可靠性有着密切的关系，软件复杂性是产生软件缺陷的重要根源。有研究表明，当软件的复杂度超过一定界限时，软件缺陷数会急剧上升，软件的可靠性急剧下降。因此，在设计时就应考虑降低软件的复杂性，使之处于一个合理的阀值之内，这是提高软件可靠性的有效方法。</p>
<p>降低复杂度设计的思想就是在保证实现软件功能的基础上，简化软件结构，缩短程序代码长度，优化软件数据流向，降低软件复杂度，从而提高软件可靠性。</p>
<p>除了容错设计、检错设计和降低复杂度设计技术外，人们尝试着把硬件可靠性设计中比较成熟的技术，如故障树分析（FTA）、失效模式与效应分析（FMEA）等运用到软件可靠性设计领域，这些技术大多是运用一些分析、预测技术，在软件设计时就充分考虑影响软件可靠性的因素，并采取一些措施进行优化。由于软件与硬件内部性质的巨大差异，这些技术在软件可靠性设计领域的应用效果和范围极其有限。</p>
<h4 id="软件可靠性管理"><a href="#软件可靠性管理" class="headerlink" title="软件可靠性管理"></a>软件可靠性管理</h4><p>为了进一步提高软件可靠性，人们又提出了软件可靠性管理的概念，把软件可靠性活动贯穿于软件开发的全过程。</p>
<p>软件可靠性管理是软件工程管理的一部分，它以全面提高和保证软件可靠性为目标，以软件可靠性活动为主要对象，是把现代管理理论用于软件生命周期中的可靠性保障活动的一种管理形式。</p>
<p>软件可靠性管理的内容包括软件工程各个阶段的可靠性活动的目标、计划、进度、任务和修正措施等。</p>
<p>软件工程各个阶段可能进行的主要的软件可靠性活动如下所述。由于软件之间的差异较大，并且人们对可靠性的期望不同，对可靠性的投入不同，所以下面的每项活动并不是每一个软件系统的可靠性管理的必须内容，也不是软件可靠性管理的全部内容。</p>
<h5 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h5><p>（1）确定软件的可靠性目标。</p>
<p>（2）分析可能影响可靠性的因素。</p>
<p>（3）确定可靠性的验收标准。</p>
<p>（4）制定可靠性管理框架。</p>
<p>（5）制定可靠性文档编写规范。</p>
<p>（6）制定可靠性活动初步计划。</p>
<p>（7）确定可靠性数据收集规范。</p>
<h5 id="概要设计阶段"><a href="#概要设计阶段" class="headerlink" title="概要设计阶段"></a>概要设计阶段</h5><p>（1）确定可靠性度量。</p>
<p>（2）制定详细的可靠性验收方案。</p>
<p>（3）可靠性设计。</p>
<p>（4）收集可靠性数据。</p>
<p>（5）调整可靠性活动计划。</p>
<p>（6）明确后续阶段的可靠性活动的详细计划。</p>
<p>（7）编制可靠性文档。</p>
<h5 id="详细设计阶段"><a href="#详细设计阶段" class="headerlink" title="详细设计阶段"></a>详细设计阶段</h5><p>（1）可靠性设计。</p>
<p>（2）可靠性预测（确定可靠性度量估计值）。</p>
<p>（3）调整可靠性活动计划。</p>
<p>（4）收集可靠性数据。</p>
<p>（5）明确后续阶段的可靠性活动的详细计划。</p>
<p>（6）编制可靠性文档。</p>
<h5 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h5><p>（1）可靠性测试（含于单元测试）。</p>
<p>（2）排错。</p>
<p>（3）调整可靠性活动计划。</p>
<p>（4）收集可靠性数据。</p>
<p>（5）明确后续阶段的可靠性活动的详细计划。</p>
<p>（6）编制可靠性文档。</p>
<h5 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h5><p>（1）可靠性测试〔含于集成测试、系统测试〕。</p>
<p>（2）排错。</p>
<p>（3）可靠性建模。</p>
<p>（4）可靠性评价。</p>
<p>（5）调整可靠性活动计划。</p>
<p>（6）收集可靠性数据。</p>
<p>（7）明确后续阶段的可靠性活动的详细计划。</p>
<p>（8）编制可靠性文档。</p>
<h5 id="实施阶段"><a href="#实施阶段" class="headerlink" title="实施阶段"></a>实施阶段</h5><p>（1）可靠性测试（含于验收测试）。</p>
<p>（2）排错。</p>
<p>（3）收集可靠性数据。</p>
<p>（4）调整可靠性模型。</p>
<p>（5）可靠性评价。</p>
<p>（6）编制可靠性文档。</p>
<p>可靠性管理目前还停留在定性描述的水平上，很难用量化的指标来进行可靠性管理。可靠性管理规范的制定水平和实施效果也有待提高。怎样利用有限的可靠性投入，达到预期的可靠性目标是软件项目管理者常常要面对的难题。因此，可靠性管理研究是一个长期的课题。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><h4 id="系统故障模型"><a href="#系统故障模型" class="headerlink" title="系统故障模型"></a>系统故障模型</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090958.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090958.png';" /></details>


<h4 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907091247.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907091247.png';" /></details>

<h5 id="可靠性vs可用性"><a href="#可靠性vs可用性" class="headerlink" title="可靠性vs可用性"></a>可靠性vs可用性</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907091440.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907091440.png';" /></details>

<h4 id="串联系统与并联系统可靠度计算"><a href="#串联系统与并联系统可靠度计算" class="headerlink" title="串联系统与并联系统可靠度计算"></a>串联系统与并联系统可靠度计算</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142225.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142225.png';" /></details>

<p>可靠度：是相乘的可靠度</p>
<h5 id="模冗余系统与混合系统"><a href="#模冗余系统与混合系统" class="headerlink" title="模冗余系统与混合系统"></a>模冗余系统与混合系统</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142301.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142301.png';" /></details>


<h4 id="系统容错技术"><a href="#系统容错技术" class="headerlink" title="系统容错技术"></a>系统容错技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142422.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142422.png';" /></details>

<p>架构来说可靠性是很重要的</p>
<h5 id="容错系统"><a href="#容错系统" class="headerlink" title="容错系统"></a>容错系统</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142738.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142738.png';" /></details>

<h4 id="N版本程序设计-恢复块方法-防卫式程序设计"><a href="#N版本程序设计-恢复块方法-防卫式程序设计" class="headerlink" title="N版本程序设计_恢复块方法_防卫式程序设计"></a>N版本程序设计_恢复块方法_防卫式程序设计</h4><h5 id="N版本程序设计"><a href="#N版本程序设计" class="headerlink" title="N版本程序设计"></a>N版本程序设计</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142829.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142829.png';" /></details>

<ul>
<li>与通常软件开发过程不同的是，N版本程序设计增加了三个新的阶段:相异成份规范评审、相异性确认、背对背测试</li>
<li>N版本程序的同步、N版本程序之间的通信、表决算法(全等表决、非精确表决、Cosmetie表决)、一致比较问题、数据相异性</li>
<li>各版本的需求说明说不一致</li>
</ul>
<h5 id="恢复块方法"><a href="#恢复块方法" class="headerlink" title="恢复块方法"></a>恢复块方法</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142912.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142912.png';" /></details>

<ul>
<li>设计时应保证实现主块和后备块之间的独立性,避免相关错误的产生,使主块和备份块之间的共性错误降到最低程度。</li>
<li>必须保证验证测试程序的正确性。</li>
</ul>
<h5 id="防卫式程序设计"><a href="#防卫式程序设计" class="headerlink" title="防卫式程序设计"></a>防卫式程序设计</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907142954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907142954.png';" /></details>
try-catch

<ul>
<li>对于程序中存在的错误和不一致性，通过在程序中包含错误检查代码和错误恢复代码，使得一旦错误发生，程序能撤消错误状态,恢复到一个已知的正确状态中去</li>
<li>实现策略:错误检测、破坏估计、错误恢复</li>
</ul>
<h4 id="双机容错与集群技术"><a href="#双机容错与集群技术" class="headerlink" title="双机容错与集群技术"></a>双机容错与集群技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143115.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143115.png';" /></details>


<p>互备：出现故障接管另一台服务器的业务</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143322.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143322.png';" /></details>



<h4 id="集群技术"><a href="#集群技术" class="headerlink" title="集群技术"></a>集群技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143447.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143447.png';" /></details>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch12-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch12-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch12-系统安全架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:37" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:37+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-04 09:29:38" itemprop="dateModified" datetime="2021-09-04T09:29:38+08:00">2021-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="系统安全架构设计"><a href="#系统安全架构设计" class="headerlink" title="系统安全架构设计"></a>系统安全架构设计</h2><h3 id="信息系统安全架构的简单描述"><a href="#信息系统安全架构的简单描述" class="headerlink" title="信息系统安全架构的简单描述"></a>信息系统安全架构的简单描述</h3><p>信息安全的特征是为了保证信息的机密性、完整性、可用性、可控性和不可抵赖性。信息系统的安全保障是以风险和策略为基础，在信息系统的整个生命周期中提供包括技术、管理、人员和工程过程的整体安全，在信息系统中保障信息的这些安全特征，并实现组织机构的使命。许多信息系统的用户需要提供一种方法和内容对信息系统的技术框架、工程过程能力和管理能力提出安全性要求，并进行可比性的评估、设计和实施。</p>
<h4 id="信息安全的现状及其威胁"><a href="#信息安全的现状及其威胁" class="headerlink" title="信息安全的现状及其威胁"></a>信息安全的现状及其威胁</h4><p>随着社会信息化进程的加快，计算机及网络已经在各行各业中得到了广泛的应用，同时一些重要单位如政府机关、部队、企业财务和人事部门已经越来越依赖于计算机。毫无疑问，在不远的将来，计算机和网络的普及程度会比现在有更大的提高，这种普及将会产生两方面的效应：其一，各行各业的业务运转几乎完全依赖于计算机和网络，各种重要数据如政府文件、工资档案、财务账目和人事资料等将全部依托计算机和网络存储、传输；其二，大多数人对计算机的了解更加全面，有更多的计算机技术水平较高的人可以采用种种手段对信息资源进行攻击。目前，信息安全主要可能会受到的威胁可以总结为以下几个方面，如图12-1所示。</p>
<details><summary>图12-1　网络与信息安全风险</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085527.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085527.png';" /></details>

<p>对于信息系统来说，威胁可以是针对物理环境、通信链路、网络系统、操作系统、应用系统以及管理系统等方面。物理安全威胁，是指对系统所用设备的威胁，自然灾害、电源故障、操作系统引导失败或数据库信息丢失、设备被盗/被毁造成数据丢失或信息泄露。通信链路安全威胁，是指在传输线路上安装窃听装置或对通信链路进行干扰。网络安全威胁，互联网的开放性、国际性与无安全管理性，对内部网络形成严重的安全威胁。操作系统安全威胁，对系统平台最危险的威胁是在系统软件或硬件芯片中植入威胁，如“木马”和“陷阱门”、BIOS有万能密码。应用系统安全威胁，是指对于网络服务或用户业务系统安全的威胁，也受到“木马”和“陷阱门”的威胁。管理系统安全威胁，必须从人员管理上杜绝安全漏洞。</p>
<p>具体来讲，常见的安全威胁有如下几种。</p>
<p>（1）信息泄露：信息被泄露或透露给某个非授权的实体。</p>
<p>（2）破坏信息的完整性：数据被非授权地进行增删、修改或破坏而受到损失。</p>
<p>（3）拒绝服务：对信息或其他资源的合法访问被无条件地阻止。</p>
<p>（4）非法使用（非授权访问）：某一资源被某个非授权的人、或以非授权的方式使用。</p>
<p>（5）窃听：用各种可能的合法或非法的手段窃取系统中的信息资源和敏感信息。例如对通信线路中传输的信号进行搭线监听，或者利用通信设备在工作过程中产生的电磁泄露截取有用信息等。</p>
<p>（6）业务流分析：通过对系统进行长期监听，利用统计分析方法对诸如通信频度、通信的信息流向、通信总量的变化等参数进行研究，从而发现有价值的信息和规律。</p>
<p>（7）假冒：通过欺骗通信系统（或用户）达到非法用户冒充成为合法用户，或者特权小的用户冒充成为特权大的用户的目的。黑客大多是采用假冒进行攻击。</p>
<p>（8）旁路控制：攻击者利用系统的安全缺陷或安全性上的脆弱之处获得非授权的权利或特权。例如，攻击者通过各种攻击手段发现原本应保密，但是却又暴露出来的一些系统“特性”。利用这些“特性”，攻击者可以绕过防线守卫者侵入系统的内部。</p>
<p>（9）授权侵犯：被授权以某一目的使用某一系统或资源的某个人，却将此权限用于其他非授权的目的，也称作“内部攻击”。</p>
<p>（10）特洛伊木马：软件中含有一个察觉不出的或者无害的程序段，当它被执行时，会破坏用户的安全。这种应用程序称为特洛伊木马（Trojan Horse）。</p>
<p>（11）陷阱门：在某个系统或某个部件中设置了“机关”，使得当提供特定的输入数据时，允许违反安全策略。</p>
<p>（12）抵赖：这是一种来自用户的攻击，例如，否认自己曾经发布过的某条消息、伪造一份对方来信等。</p>
<p>（13）重放：所截获的某次合法的通信数据备份，出于非法的目的而被重新发送。</p>
<p>（14）计算机病毒：所谓计算机病毒，是一种在计算机系统运行过程中能够实现传染和侵害的功能程序。一种病毒通常含有两个功能：一种功能是对其他程序产生“感染”；另外一种或者是引发损坏功能、或者是一种植入攻击的能力。</p>
<p>（15）人员不慎：一个授权的人为了钱或利益、或由于粗心，将信息泄露给一个非授权的人。</p>
<p>（16）媒体废弃：信息被从废弃的磁盘或打印过的存储介质中获得。</p>
<p>（17）物理侵入：侵入者通过绕过物理控制而获得对系统的访问。</p>
<p>（18）窃取：重要的安全物品，如令牌或身份卡被盗。</p>
<p>（19）业务欺骗：某一伪系统或系统部件欺骗合法的用户或系统自愿地放弃敏感信息。</p>
<p>通过对网络面临的安全风险威胁和实施相应控制措施的支出进行合理的评价，提出有效合理的安全技术，形成提升网络信息的安全性质的安全方案，是安全架构设计的根本目标。在实际应用中，可以从安全技术的角度提取出5个方面的内容：认证鉴别、访问控制、内容安全、冗余恢复和审计响应。</p>
<h4 id="国内外影响较大的标准和组织"><a href="#国内外影响较大的标准和组织" class="headerlink" title="国内外影响较大的标准和组织"></a>国内外影响较大的标准和组织</h4><h5 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h5><p>有如下标准。</p>
<p>（1）可信计算机标准评估规则橘皮书（TCSEC，美国）</p>
<p>（2）欧洲ITSEC标准</p>
<p>（3）加拿大CTCPEC标准</p>
<p>（4）美国联邦准则（FC）</p>
<p>（5）美国信息技术安全评价通用准则（CC）</p>
<p>（6）ISO安全体系结构标准（IS07498-2-1989）〈信息处理系统开放系统互连基本参考模型第二部分安全体系结构〉</p>
<p>（7）美国国家安全局：信息保障技术框架（IATF）</p>
<p>2）我国的标准</p>
<p>（1）主管部门：公安部、信息产业部和国家技术标准局等</p>
<p>（2）主要技术标准如下。</p>
<p>●　GA163-1997（计算机信息系统安全专用产品分类原则）</p>
<p>●　GB17895-1999（计算机信息系统安全保护等级划分准则）</p>
<p>●　GB/T9387.2-1995（信息处理系统开放系统互连基本参考模型第二部分安全体系结构）</p>
<p>●　GB 15834.1-1995（信息处理数据加密实体鉴别机制第一部分：一般模型）</p>
<p>●　GB 4943-1995（信息技术设备的安全）</p>
<h5 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h5><p>1）国际标准化组织（ISO）</p>
<p>ISO的信息技术标准化委员会TC97在1984年1月，专门组织了一个分技术委员会SC20，负责制定数据加密技术的国际标准；之后在1987年，ISO的TC97和IEC的TCs47B/83合并成为ISO/IEC联合技术委员会（JTC1）；1990年4月，ISO将原来的数据加密分技术委员会SC20，更名为安全技术分技术委员会SC27，专门从事信息技术安全一般方法和技术的标准化工作。而ISO/TC68负责银行业务应用范围内有关信息安全标准的制定，它主要制定行业应用标准，在组织上和标准之间与SC27有着密切的联系。</p>
<p>由于信息技术的发展，开放系统互连的网络体系结构的广泛应用，信息技术安全标准化越来越受到人们的重视。在信息技术安全分委会的成立会上，研究了信息技术安全标准化的发展规划，明确了指导思想，确定了工作目标，制定了实施计划，提出了具体的措施，正在为建立完整的信息技术安全标准体系而积极组织开展研究工作和标准制定工作。</p>
<p>2）信息技术安全分技术委员会</p>
<p>1984年7月，在我国的全国计算机与信息处理标准化技术委员会下，建立了相应的数据加密分技术委员会，在国家技术监督局和原电子工业部的领导下，归口国内外的信息技术数据加密的标准化工作。随着信息技术的发展和工作范围的扩大，在原数据加密分委员会的基础上，于1997年8月改组成了信息技术安全分技术委员会（与ISO/IECJTC1/SC27信息技术的安全技术分委会对应）。它是一个具有广泛代表性、权威性和军民结合的信息安全标准化组织。其工作范围是负责信息和通信安全的通用框架、方法、技术和机制的标准化，归口管理国内外对应的标准化工作。其技术安全包括开放式安全体系结构、各种安全信息交换的语义规则、在有关的应用程序接口和协议引用安全功能接口等。</p>
<h3 id="系统安全体系架构规划框架及其方法"><a href="#系统安全体系架构规划框架及其方法" class="headerlink" title="系统安全体系架构规划框架及其方法"></a>系统安全体系架构规划框架及其方法</h3><p>安全技术体系架构是对组织机构信息技术系统的安全体系结构的整体描述。安全技术体系架构能力是拥有信息技术系统的组织机构根据其策略的要求和风险评估的结果，参考相关技术体系构架的标准和最佳实践，结合组织机构信息技术系统的具体现状和需求，建立的符合组织机构信息技术系统战略发展规划的信息技术系统整体体系框架；它是组织机构信息技术系统战略管理的具体体现。技术体系架构能力是组织机构执行安全技术整体能力的体现，它反映了组织机构在执行信息安全技术体系框架管理达到预定的成本、功能和质量目标上的度量。</p>
<p>安全技术体系架构过程的目标是建立可持续改进的安全技术体系架构的能力，信息技术系统千变万化，有各种各样的分类方式，为从技术角度建立一个通用的对象分析模型，在本书中将信息系统抽象成一个基本完备的信息系统分析模型，如图12-2所示。从信息技术系统分析模型出发，建立整个信息技术系统的安全架构。</p>
<details><summary>图12-2　信息技术系统分析模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085724.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085724.png';" /></details>

<p>一般来说，OSI参考模型将网络划分为物理、数据链路、网络、传输、会话、表示和应用7层，Andrew S.Tanenbau综合OSI参考模型和TCP/IP参考模型将网络划分为物理、数据链路、网络、传输、应用5层。在本模型中，首先需要做的就是对网络结构层次进行划分，考虑到安全评估是以安全风险威胁分析入手的，而且在实际的网络安全评估中会发现，主机和存储系统占据了大量的评估考察工作，虽然主机和存储系统都属于应用层，但本模型由于其重要性，特将其单列为一个层次，因此根据网络中风险威胁的存在实体划分出5个层次的实体对象：应用、存储、主机、网络和物理。</p>
<p>信息系统安全规划是一个非常细致和非常重要的工作，首先需要对企业信息化发展的历史情况进行深入和全面的调研，知道家底、掌握情况，针对信息系统安全的主要内容进行整体的发展规划工作。下面用图12-3表示信息系统安全体系的框架。</p>
<p>从图12-3可以看出，信息系统安全体系主要是由技术体系、组织机构体系和管理体系三部分共同构成的。技术体系是全面提供信息系统安全保护的技术保障系统，该体系由物理安全技术和系统安全技术两大类构成。组织体系是信息系统的组织保障系统，由机构、岗位和人事三个模块构成。机构分为领导决策层、日常管理层和具体执行层；岗位是信息系统安全管理部门根据系统安全需要设定的负责某一个或某几个安全事务的职位；人事是根据管理机构设定的岗位，对岗位上在职、待职和离职的员工进行素质教育、业绩考核和安全监管的机构。管理体系由法律管理、制度管理和培训管理三部分组成。</p>
<details><summary>图12-3　信息系统安全体系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085744.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085744.png';" /></details>

<p>信息系统安全体系清楚了之后，就可以针对以上描述的内容进行全面的规划。信息系统安全规划的层次方法与步骤可以有不同，但是规划内容与层次应该是相同。规划的具体环节、相互之间的关系和具体方法如图12-4所示。</p>
<details><summary>图12-4　信息系统安全规划框架图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085800.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085800.png';" /></details>


<h5 id="信息系统安全规划依托企业信息化战略规划"><a href="#信息系统安全规划依托企业信息化战略规划" class="headerlink" title="信息系统安全规划依托企业信息化战略规划"></a>信息系统安全规划依托企业信息化战略规划</h5><p>信息化战略规划是以整个企业的发展目标、发展战略和企业各部门的业务需求为基础，结合行业信息化方面的需求分析、环境分析和对信息技术发展趋势的掌握，定义出企业信息化建设的远景、使命、目标和战略，规划出企业信息化建设的未来架构，为信息化建设的实施提供一副完整的蓝图，全面系统地指导企业信息化建设的进程。信息系统安全规划依托企业信息化战略规划，对信息化战略的实施起到保驾护航的作用。信息系统安全规划的目标应该与企业信息化的目标是一致的，而且应该比企业信息化的目标更具体明确、更贴近安全。信息系统安全规划的一切论述都要围绕着这个目标展开和部署。</p>
<h5 id="信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑"><a href="#信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑" class="headerlink" title="信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑"></a>信息系统安全规划需要围绕技术安全、管理安全、组织安全考虑</h5><p>信息系统安全规划的方法可以不同、侧重点可以不同，但都需要围绕技术安全、管理安全、组织安全进行全面的考虑。规划的内容基本上应该涵盖：确定信息系统安全的任务、目标、战略以及战略部门和战略人员，并在此基础上制定出物理安全、网络安全、系统安全、运营安全、人员安全的信息系统安全的总体规划。物理安全包括环境设备安全、信息设备安全、网络设备安全、信息资产设备的物理分布安全等。网络安全包括网络拓扑结构安全、网络的物理线路安全、网络访问安全（防火墙、入侵检测系统和VPN等）等。系统安全包括操作系统安全、应用软件安全和应用策略安全等。运营安全应在控制层面和管理层面保障，包括备份与恢复系统安全、入侵检测功能、加密认证功能、漏洞检查及系统补丁功能、口令管理等。人员安全包括安全管理的组织机构、人员安全教育与意识机制、人员招聘及离职管理、第三方人员安全管理等。</p>
<h5 id="信息系统安全规划以信息系统与信息资源的安全保护为核心"><a href="#信息系统安全规划以信息系统与信息资源的安全保护为核心" class="headerlink" title="信息系统安全规划以信息系统与信息资源的安全保护为核心"></a>信息系统安全规划以信息系统与信息资源的安全保护为核心</h5><p>信息系统安全规划的最终效果应该体现在对信息系统与信息资源的安全保护上，因此规划工作需要围绕着信息系统与信息资源的开发、利用和保护工作进行，要包括蓝图、现状、需求和措施4个方面。</p>
<p>（1）对信息系统与信息资源的规划需要从信息化建设的蓝图入手，知道企业信息化发展策略的总体目标和各阶段的实施目标，制定出信息系统安全的发展目标。</p>
<p>（2）对企业的信息化工作现状进行整体的、综合、全面的分析，找出过去工作中的优势与不足。</p>
<p>（3）根据信息化建设的目标提出未来几年的需求，这个需求最好可以分解成若干个小的方面，以便于今后的落实与实施。</p>
<p>（4）要写明在实施工作阶段的具体措施与办法，提高规划工作的执行力度。信息系统安全规划服务于企业信息化战略目标，信息系统安全规划做得好，企业信息化工作的实现就有了保障。信息系统安全规划是企业信息化发展战略的基础性工作，不是可有可无而是非常重要。由于企业信息化的任务与目标不同，所以信息系统安全规划包括的内容就不同，建设的规模就有很大的差异，因此信息系统安全规划无法从专业书籍或研究资料中找到非常有针对性的、有帮助的适用法则，也不可能给出一个规范化的信息系统安全规划的模板。在这里提出信息系统安全规划框架与方法，给出了信息系统安全规划工作的一种建设原则、建设内容、建设思路，具体规划还需要深入细致地进行本地化的调查与研究。</p>
<h3 id="网络安全体系架构设计"><a href="#网络安全体系架构设计" class="headerlink" title="网络安全体系架构设计"></a>网络安全体系架构设计</h3><p>介绍信息系统安全体系的目的，就是将普遍性安全原理与信息系统的实际相结合，形成满足信息系统安全需求的安全体系结构。</p>
<h4 id="OSI的安全体系架构概述"><a href="#OSI的安全体系架构概述" class="headerlink" title="OSI的安全体系架构概述"></a>OSI的安全体系架构概述</h4><p>国家标准《信息处理系统工程开放系统互联基本参考模型—第二部分：安全体系结构》（GB/T 9387.2-1995）（等同于ISO 7498-2），以及互联网安全体系结构（RFC 2401），是两个普遍适用的安全体系结构，目的在于保证开放系统进程与进程之间远距离安全交换信息。这些标准在参考模型的框架内，建立起一些指导原则与约束条件，从而提供了解决开放互联系统中安全问题的一致性方法。</p>
<p>OSI安全体系结构提供以下内容。</p>
<p>（1）提供安全服务与有关安全机制在体系结构下的一般描述，这些服务和机制必须是为体系结构所配备的。</p>
<p>（2）确定体系结构内部可以提供这些服务的位置。</p>
<p>（3）保证安全服务完全准确地得以配置，并且在信息系统的安全周期中一直维持，安全功能务必达到一定强度的要求。</p>
<p>国家标准《信息处理系统工程开放系统互联基本参考模型—第二部分：安全体系结构》（GB/T 9387.2-1995）（等同于ISO 7498-2），给出了基于OSI参考模型的7层协议之上的信息安全体系结构。其核心内容是：为了保证异构计算机进程与进程之间远距离交换信息的安全，它定义了该系统5大类安全服务，以及提供这些服务的8类安全机制及相应的OSI安全管理，并可根据具体系统适当地配置于OSI模型的7层协议中。图12-5所示的三维安全空间解释了这一体系结构。</p>
<p>在OSI 7层协议中除第5层（会话层）外，每一层均能提供相应的安全服务。实际上，最适合配置安全服务的是在物理层、网络层、运输层及应用层上，其他层都不宜配置安全服务。</p>
<p>ISO开放系统互联安全体系的5类安全服务包括鉴别、访问控制、数据机密性、数据完整性和抗抵赖性。</p>
<p>分层多点安全技术体系架构，也称为深度防御安全技术体系架构，它通过以下方式将防御能力分布至整个信息系统中。</p>
<details><summary>图12-5　信息安全体系结构示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904085956.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904085956.png';" /></details>

<p>（1）多点技术防御。在对手可以从内部或外部多点攻击一个目标的前提下，多点技术防御通过对以下多个防御核心区域的防御达到抵御所有方式的攻击的目的。</p>
<p>①网络和基础设施。为了确保可用性，局域网和广域网需要进行保护以抵抗各种攻击，如拒绝服务攻击等。为了确保机密性和完整性，需要保护在这些网络上传送的信息以及流量的特征以防止非故意的泄露。</p>
<p>②边界。为了抵御主动的网络攻击，边界需要提供更强的边界防御，例如流量过滤和控制以及入侵检测。</p>
<p>③计算环境。为了抵御内部、近距离的分布攻击，主机和工作站需要提供足够的访问控制。</p>
<p>（2）分层技术防御。即使最好的可得到的信息保障产品也有弱点，其最终结果将使对手能找到一个可探查的脆弱性，一个有效的措施是在对手和目标间使用多个防御机制。为了减少这些攻击成功的可能性和对成功攻击的可承担性，每种机制应代表一种唯一的障碍并同时包括保护和检测方法。例如，在外部和内部边界同时使用嵌套的防火墙并配合以入侵检测就是分层技术防御的一个实例。</p>
<p>支撑性基础设施为网络、边界和计算环境中信息保障机制运行基础的支撑性基础设施，包括公钥基础设施以及检测和响应基础设施。</p>
<p>（1）公钥基础设施。提供一种通用的联合处理方式，以便安全地创建、分发和管理公钥证书和传统的对称密钥，使它们能够为网络、边界和计算环境提供安全服务。这些服务能够对发送者和接收者的完整性进行可靠验证，并可以避免在未获授权的情况下泄露和更改信息。公钥基础设施必须支持受控的互操作性，并与各用户团体所建立的安全策略保持一致。</p>
<p>（2）检测和响应基础设施。检测和响应基础设施能够迅速检测并响应入侵行为。它也提供便于结合其他相关事件观察某个事件的“汇总”性能。另外，它也允许分析员识别潜在的行为模式或新的发展趋势。</p>
<p>必须提醒的是，信息系统的安全保障不仅仅依赖于技术，还需要集成的技术和非技术防御手段。一个可接受级别的信息保障依赖于人员、管理、技术和过程的综合。</p>
<p>图12-6描述了分层多点安全技术体系架构。</p>
<details><summary>图12-6　分层多点安全技术体系架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090039.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090039.png';" /></details>

<p>分层多点安全技术体系架构为信息系统安全保障提供了框架和进一步分析所需的重点区域划分。在具体的技术方案实践中，应从使命和需求的实际情况出发制定适合组织机构要求的技术体系和方案。</p>
<h4 id="鉴别框架"><a href="#鉴别框架" class="headerlink" title="鉴别框架"></a>鉴别框架</h4><p>鉴别（Authentication）的基本目的，就是防止其他实体占用和独立操作被鉴别实体的身份。鉴别提供了实体声称其身份的保证，只有在主体和验证者的关系背景下，鉴别才是有意义的。鉴别有两种重要的关系背景：一是实体由申请者来代表，申请者与验证者之间存在着特定的通信关系（如实体鉴别）；二是实体为验证者提供数据项来源。</p>
<p>鉴别的方式主要基于以下5种。</p>
<p>（1）已知的，如一个秘密的口令。</p>
<p>（2）拥有的，如IC卡、令牌等。</p>
<p>（3）不改变的特性，如生物特征。</p>
<p>（4）相信可靠的第三方建立的鉴别（递推）。</p>
<p>（5）环境（如主机地址等）。</p>
<p>鉴别信息（Artificial Intelligence, AI）是指申请者要求鉴别到鉴别过程结束所生成、使用和交换的信息。鉴别信息的类型有交换鉴别信息（交换AI）、申请鉴别信息（申请AI）和验证鉴别信息（验证AI）。</p>
<details><summary>图12-7　申请者、验证者、可信第三方之间的关系及三种鉴别信息类型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090111.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090111.png';" /></details>


<p>注意：在某些特定的情况下，可以不涉及可信任的第三方。</p>
<p>验证AI可以是主体的，也可以是可信任第三方的。</p>
<p>在某些情况下，为了产生交换AI，申请者需要与可信第三方进行交互。类似的，为了验证交换AI，验证者也需要同可信第三方进行交互。在这种情况下，可信第三方持有相关实体的验证AI，也可能使用可信第三方来传递交换AI。实体也可能需要持有鉴别可信第三方中所使用的鉴别信息。</p>
<p>鉴别服务分为以下阶段：安装阶段；修改鉴别信息阶段；分发阶段；获取阶段；传送阶段；验证阶段；停活阶段；重新激活阶段；取消安装阶段。</p>
<p>在安装阶段，定义申请AI和验证AI。修改鉴别信息阶段，实体或管理者申请AI和验证AI变更（如修改口令）。在分发阶段，为了验证交换AI，把验证AI分发到各实体（如申请者或验证者）以供使用。在获取阶段，申请者或验证者可得到为鉴别实例生成特定交换AI所需的信息，通过与可信第三方进行交互或鉴别实体间的信息交换可得到交换AI。例如，当使用联机密钥分配中心时，申请者或验证者可从密钥分配中心得到一些信息，如鉴别证书。在传送阶段，在申请者与验证者之间传送交换AI。在验证阶段，用验证AI核对交换AI。在停活阶段，将建立一种状态，使得以前能被鉴别的实体暂时不能被鉴别。在重新激活阶段，使在停活阶段建立的状态将被终止。在取消安装阶段，实体从实体集合中被拆除。</p>
<h4 id="访问控制框架"><a href="#访问控制框架" class="headerlink" title="访问控制框架"></a>访问控制框架</h4><p>访问控制（Access Control）决定开放系统环境中允许使用哪些资源、在什么地方适合阻止未授权访问的过程。在访问控制实例中，访问可以是对一个系统（即对一个系统通信部分的一个实体）或对一个系统内部进行的。</p>
<p>图12-8和图12-9说明了访问控制的基础性功能。</p>
<details><summary>图12-9　ADF示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090214.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090214.png';" /></details>

<p>ACI（访问控制信息）是用于访问控制目的的任何信息，其中包括上下文信息。ADI（访问控制判决信息）是在做出一个特定的访问控制判决时可供ADF使用的部分（或全部）ACI。ADF（访问控制判决功能）是一种特定功能，它通过对访问请求、ADI以及该访问请求的上下文使用访问控制策略规则而做出访问控制判决。AEF（访问控制实施功能）确保只有对目标允许的访问才由发起者执行。</p>
<p>涉及访问控制的有发起者、AEF、ADF和目标。发起者代表访问或试图访问目标的人和基于计算机的实体。目标代表被试图访问或由发起者访问的，基于计算机或通信的实体。例如，目标可能是OSI实体、文件或者系统。访问请求代表构成试图访问部分的操作和操作数。</p>
<p>当发起者请求对目标进行特殊访问时，AEF就通知ADF需要一个判决来做出决定。为了作出判决，给ADF提供了访问请求（作为判决请求的一部分）和下列几种访问控制判决信息（ADI）。</p>
<p>（1）发起者ADI（ADI由绑定到发起者的ACI导出）。</p>
<p>（2）目标ADI（ADI由绑定到目标的ACI导出）。</p>
<p>（3）访问请求ADI（ADI由绑定到访问请求的ACI导出）。</p>
<p>ADF的其他输入是访问控制策略规则（来自ADF的安全域权威机构）和用于解释ADI或策略的必要上下文信息。上下文信息包括发起者的位置、访问时间或使用中的特殊通信路径。基于这些输入，以及可能还有以前判决中保留下来的ADI信息，ADF可以做出允许或禁止发起者试图对目标进行访问的判决。该判决传递给AEF，然后AEF允许将访问请求传给目标或采取其他合适的行动。</p>
<p>在许多情况下，由发起者对目标的逐次访问请求是相关的。应用中的一个典型例子是在打开与同层目标的连接应用进程后，试图用相同（保留）的ADI执行几个访问。对一些随后通过连接进行通信的访问请求，可能需要给ADF提供附加的ADI以允许访问请求。在另一些情况中，安全策略可能要求对一个或多个发起者与一个或多个目标之间的某种相关访问请求进行限制。这时，ADF可能使用与多个发起者和目标有关的先前判决中所保留的ADI来对特殊访问请求作出判决。</p>
<p>如果得到AEF的允许，访问请求只涉及发起者与目标的单一交互。尽管发起者和目标之间的一些访问请求是完全与其他访问请求无关的，但常常是两个实体进入一个相关的访问请求集合中，如质询应答模式。在这种情况下，实体根据需要同时或交替地变更发起者和目标角色，可以由分离的AEF组件、ADF组件和访问控制策略对每一个访问请求执行访问控制功能。</p>
<h4 id="机密性框架"><a href="#机密性框架" class="headerlink" title="机密性框架"></a>机密性框架</h4><p>机密性（Confidentiality）服务的目的是确保信息仅仅是对被授权者可用。由于信息是通过数据表示的，而且数据可能导致关系的变化（如文件操作可能导致目录改变或可用存储区域的改变），因此信息能通过许多不同的方式从数据中导出。例如，通过理解数据的含义（如数据的值）导出；通过使用数据相关的属性（如存在性、创建的数据、数据大小、最后一次更新的日期等）进行推导；通过研究数据的上下文关系，即那些与之相关的其他数据实体导出；通过观察数据表达式的动态变化导出。</p>
<p>信息的保护通过确保数据被限制于授权者获得，或通过特定方式表示数据来获得，这种保护方式的语义是，数据只对那些拥有某种关键信息的人才是可访问的。有效的机密性保护要求必要的控制信息（如密钥和RCI等）是受到保护的，这种保护机制和用来保护数据的机制是不同的（如密钥可以通过物理手段保护等）。</p>
<p>在机密性框架中用到被保护的环境和被交叠保护的环境两个概念。在被保护环境中的数据，通过使用特别的安全机制（或多个机制）保护。在一个被保护环境中的所有数据以类似方法受到保护。当两个或更多的环境交叠的时候，交叠中的数据能被多重保护。可以推断，从一个环境移到另一个环境的数据的连续保护必然涉及到交叠保护环境。</p>
<p>机密性机制</p>
<p>数据的机密性可以依赖于所驻留和传输的媒体。因此，存储数据的机密性能通过使用隐藏数据语义（如加密）或将数据分片的机制来保证。数据在传输中的机密性能通过禁止访问的机制、通过隐藏数据语义的机制或通过分散数据的机制得以保证（如跳频等）。这些机制类型能被单独使用或者组合使用。</p>
<p>1）通过禁止访问提供机密性</p>
<p>通过禁止访问的机密性能通过在ITU-T Rec. 812或ISO/IEC 10181-3中描述的访问控制获得，以及通过物理媒体保护和路由选择控制获得。通过物理媒体保护的机密性保护可以采取物理方法保证媒体中的数据只能通过特殊的有限设备才能检测到。数据机密性通过确保只有授权的实体才能使这些机制本身有效的方式来实现。通过路由选择控制的机密性保护机制的目的，是防止被传输数据项表示的信息未授权泄露。在这一机制下只有可信和安全的设施才能路由数据，以达到支持机密性服务的目的。</p>
<p>2）通过加密提供机密性</p>
<p>这些机制的目的是防止数据泄露在传输或存储中。加密机制分为基于对称的加密机制和基于非对称加密的机密机制。</p>
<p>除了以下两种机密性机制外，还可以通过数据填充、通过虚假事件（如把在不可信链路上交换的信息流总量隐藏起来）、通过保护PDU头和通过时间可变域提供机密性。</p>
<h4 id="完整性框架"><a href="#完整性框架" class="headerlink" title="完整性框架"></a>完整性框架</h4><p>完整性（Integrity）框架的目的是通过阻止威胁或探测威胁，保护可能遭到不同方式危害的数据完整性和数据相关属性完整性。所谓完整性，就是数据不以未经授权方式进行改变或损毁的特征。</p>
<p>完整性服务有几种分类方式：根据防范的违规分类违规操作分为未授权的数据修改、未授权的数据创建、未授权的数据删除、未授权的数据插入和未授权的数据重放。依据提供的保护方法分为阻止完整性损坏和检测完整性损坏。依据是否包括恢复机制分为具有恢复机制的和不具有恢复机制的。</p>
<p>完整性机制的类型</p>
<p>由于保护数据的能力与正在使用的媒体有关。完整性机制是有区别的，包括如下类型。</p>
<p>（1）阻止对媒体访问的机制。包括物理隔离的、不受干扰的信道；路由控制；访问控制。</p>
<p>（2）用以探测对数据或数据项序列的非授权修改的机制。未授权修改包括未授权数据创建、数据删除以及数据重复。而相应的完整性机制包括密封、数字签名、数据重复（作为对抗其他类型违规的手段）、与密码变换相结合的数字指纹和消息序列号。</p>
<p>按照保护强度，完整性机制可分为不作保护；对修改和创建的探测；对修改、创建、删除和重复的探测；对修改和创建的探测并带恢复功能；对修改、创建、删除和重复的探测并带恢复功能。</p>
<h4 id="抗抵赖框架"><a href="#抗抵赖框架" class="headerlink" title="抗抵赖框架"></a>抗抵赖框架</h4><p>抗抵赖（Non-repudiation）服务包括证据的生成、验证和记录，以及在解决纠纷时随即进行的证据恢复和再次验证。</p>
<p>框架所描述的抗抵赖服务的目的是提供有关特定事件或行为的证据。事件或行为本身以外的其他实体可以请求抗抵赖服务。抗抵赖服务可以保护的行为实例有发送X.400消息；在数据库中插入记录、请求远程操作等。</p>
<p>当涉及消息内容的抗抵赖服务时，为提供原发证明，必须确认数据原发者身份和数据完整性。为提供递交证明，必须确认接收者身份和数据完整性。在某些情况下，还可能需要涉及上下文关系（如日期、时间、原发者/接收者的地点等）的证据。</p>
<p>抗抵赖服务提供下列可在试图抵赖的事件中使用的设备：证据生成、证据记录、验证生成的证据、证据的恢复和重验。</p>
<p>纠纷可以在纠纷两方之间直接通过检查证据解决。但是，纠纷也可能不得不通过仲裁者解决，该仲裁者评估并确定是否发生过有纠纷的行为或事件。</p>
<p>抗抵赖由4个独立的阶段组成：证据生成；证据传输、存储和恢复；证据验证；解决纠纷，如图12-10所示。</p>
<p>1）证据生成</p>
<p>在这个阶段中，证据生成请求者请求证据生成者为事件或行为生成证据。卷入事件或行为中的实体，称为证据实体，其卷入关系由证据建立。根据抗抵赖服务的类型，证据可由证据实体、或可能与可信第三方的服务一起生成、或者单独由可信第三方生成。</p>
<p>2）证据传输、存储和恢复</p>
<p>在这个阶段，证据在实体间传输或从存储器取出来或传到存储器。</p>
<details><summary>图12-10　参与生成、传输、存储/恢复和证实阶段的实体(注：本图是示意图，并非定义)</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904090400.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904090400.png';" /></details>

<p>3）证据验证</p>
<p>在这个阶段，证据在证据使用者的请求下被证据验证者验证。本阶段的目的是在出现纠纷的事件中，让证据使用者确信被提供的证据确实是充分的。可信第三方服务也可参与，以提供验证该证据的信息。</p>
<p>4）解决纠纷</p>
<p>在解决纠纷阶段，仲裁者有解决双方纠纷的责任。图12-11描述了纠纷解决阶段。</p>
<details><summary>图12-11　抗抵赖过程的纠纷解决阶段</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904092122.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904092122.png';" /></details>

<h3 id="数据库系统的安全设计"><a href="#数据库系统的安全设计" class="headerlink" title="数据库系统的安全设计"></a>数据库系统的安全设计</h3><p>在数据库系统中， 由于数据的集中管理，随之而来的是多用户存取，以及近年来跨网络的分布系统的急速发展。数据库的安全问题可以说已经构成信息系统最为关键的环节，而电子政务中所涉及的数据库密级更高、实时性更强。因此，有必要根据其特殊性完善安全策略，这些安全策略应该能保证数据库中的数据不会被有意地攻击或无意地破坏。不会发生数据的外泄、丢失和毁损，即实现了数据库系统安全的完整性、保密性和可用性。从数据库管理系统的角度而言，要采取的安全策略一般为用户管理、存取控制、数据加密、审计跟踪和攻击检测，从而解决数据库系统的运行安全和信息安全。</p>
<p>下面分别从数据库安全设计的评估标准和完整性设计两方面进行讨论。</p>
<h4 id="数据库安全设计的评估标准"><a href="#数据库安全设计的评估标准" class="headerlink" title="数据库安全设计的评估标准"></a>数据库安全设计的评估标准</h4><p>随着人们对安全问题的认识和对安全产品的要求不断提高，在计算机安全技术方面逐步建立了一套安全评估标准，以规范和指导安全信息的建立、安全产品的生产，并能较准确地评测产品的安全性能指标。在当前各国制定和采用的标准中，最重要的是1985年美国国防部颁布的“可信计算机系统评估标准（Trusted Computer System Evaluation Criteria, TCSEC）”桔皮书（简称为DoD85）。1991年，美国国家计算机安全中心（The National Computer Seaurity Center, NCSC）又颁布了“可信计算机评估标准关于可信数据库管理系统的解释（Trusted Database Interpretation, TDI）”。我国也于1994年2月发布了“中华人民共和国计算机信息系统安全保护条例”。在TCSEC中，将安全系统分为4大类7个等级。</p>
<p>TDI是TCSEC在数据库管理系统方面的扩充和解释，并从安全策略、责任、保护和文档4个方面进一步描述了每级的安全标准。按照TCSEC标准，D类产品是基本没有安全保护措施的产品，C类产品只提供了安全保护措施，一般不称为安全产品。B类以上产品是实行强制存取控制的产品，也是真正意义上的安全产品。所谓安全产品均是指安全级别在B1以上的产品，而安全数据库研究原型一般是指安全级别在B1级以上的以科研为目的，尚未产品化的数据库管理系统原型。</p>
<h4 id="数据库的完整性设计"><a href="#数据库的完整性设计" class="headerlink" title="数据库的完整性设计"></a>数据库的完整性设计</h4><p>数据库完整性是指数据库中数据的正确性和相容性。数据库完整性由各种各样的完整性约束来保证，因此可以说数据库完整性设计就是数据库完整性约束的设计。数据库完整性约束可以通过DBMS或应用程序来实现，基于DBMS的完整性约束作为模式的一部分存入数据库中。通过DBMS实现的数据库完整性按照数据库设计步骤进行设计，而由应用软件实现的数据库完整性则纳入应用软件设计。</p>
<h5 id="数据库完整性设计原则"><a href="#数据库完整性设计原则" class="headerlink" title="数据库完整性设计原则"></a>数据库完整性设计原则</h5><p>在实施数据库完整性设计时，需要把握以下基本原则。</p>
<p>（1）根据数据库完整性约束的类型确定其实现的系统层次和方式，并提前考虑对系统性能的影响。一般情况下，静态约束应尽量包含在数据库模式中，而动态约束由应用程序实现。</p>
<p>（2）实体完整性约束、参照完整性约束是关系数据库最重要的完整性约束，在不影响系统关键性能的前提下需尽量应用。用一定的时间和空间来换取系统的易用性是值得的。</p>
<p>（3）要慎用目前主流DBMS都支持的触发器功能，一方面由于触发器的性能开销较大；另一方面，触发器的多级触发不好控制，容易发生错误，非用不可时，最好使用Before型语句级触发器。</p>
<p>（4）在需求分析阶段就必须制定完整性约束的命名规范，尽量使用有意义的英文单词、缩写词、表名、列名及下划线等组合，使其易于识别和记忆，如CKC EMP REAL INCOME EMPLOYEE、PK EMPLOYEE、CKT EMPLOYEE。如果使用CASE工具，一般有默认的规则，可在此基础上修改使用。</p>
<p>（5）要根据业务规则对数据库完整性进行细致的测试，以尽早排除隐含的完整性约束间的冲突和对性能的影响。</p>
<p>（6）要有专职的数据库设计小组，自始至终负责数据库的分析、设计、测试、实施及早期维护。数据库设计人员不仅负责基于DBMS的数据库完整性约束的设计实现，还要负责对应用软件实现的数据库完整性约束进行审核。</p>
<p>（7）应采用合适的CASE工具来降低数据库设计各阶段的工作量。好的CASE工具能够支持整个数据库的生命周期，这将使数据库设计人员的工作效率得到很大提高，同时也容易与用户沟通。</p>
<h5 id="数据库完整性的作用"><a href="#数据库完整性的作用" class="headerlink" title="数据库完整性的作用"></a>数据库完整性的作用</h5><p>数据库完整性对于数据库应用系统非常关键，其作用主要体现在以下几个方面。</p>
<p>（1）数据库完整性约束能够防止合法用户使用数据库时向数据库中添加不合语义的数据。</p>
<p>（2）利用基于DBMS的完整性控制机制来实现业务规则，易于定义，容易理解，而且可以降低应用程序的复杂性，提高应用程序的运行效率。同时，基于DBMS的完整性控制机制是集中管理的，因此比应用程序更容易实现数据库的完整性。</p>
<p>（3）合理的数据库完整性设计，能够同时兼顾数据库的完整性和系统的效能。例如装载大量数据时，只要在装载之前临时使基于DBMS的数据库完整性约束失效，此后再使其生效，就能保证既不影响数据装载的效率又能保证数据库的完整性。</p>
<p>（4）在应用软件的功能测试中，完善的数据库完整性有助于尽早发现应用软件的错误。</p>
<p>（5）数据库完整性约束可分为6类：列级静态约束、元组级静态约束、关系级静态约束、列级动态约束、元组级动态约束和关系级动态约束。动态约束通常由应用软件来实现。不同DBMS支持的数据库完整性基本相同，Oracle支持的基于DBMS的完整性约束如表12-1所示。</p>
<details><summary>表12-1　Oracle支持的基于DBMS的完整性约束</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904092311.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904092311.png';" /></details>

<h5 id="数据库完整性设计示例"><a href="#数据库完整性设计示例" class="headerlink" title="数据库完整性设计示例"></a>数据库完整性设计示例</h5><p>一个好的数据库完整性设计，首先需要在需求分析阶段确定要通过数据库完整性约束实现的业务规则。然后在充分了解特定DBMS提供的完整性控制机制的基础上，依据整个系统的体系结构和性能要求，遵照数据库设计方法和应用软件设计方法，合理选择每个业务规则的实现方式。最后，认真测试，排除隐含的约束冲突和性能问题。基于DBMS的数据库完整性设计大体分为以下几个阶段。</p>
<p>1）需求分析阶段</p>
<p>经过系统分析员、数据库分析员和用户的共同努力，确定系统模型中应该包含的对象，如人事及工资管理系统中的部门、员工和经理等，以及各种业务规则。</p>
<p>在完成寻找业务规则的工作之后，确定要作为数据库完整性的业务规则，并对业务规则进行分类。其中作为数据库模式一部分的完整性设计按下面的过程进行，而由应用软件来实现的数据库完整性设计将按照软件工程的方法进行。</p>
<p>2）概念结构设计阶段</p>
<p>概念结构设计阶段是将依据需求分析的结果转换成一个独立于具体DBMS的概念模型，即实体关系图（Entity-Relationship Diagram, ERD）。在概念结构设计阶段就要开始数据库完整性设计的实质阶段，因为此阶段的实体关系将在逻辑结构设计阶段转化为实体完整性约束和参照完整性约束，到逻辑结构设计阶段将完成设计的主要工作。</p>
<p>3）逻辑结构设计阶段</p>
<p>此阶段就是将概念结构转换为某个DBMS所支持的数据模型，并对其进行优化，包括对关系模型的规范化。此时，依据DBMS提供的完整性约束机制，对尚未加入逻辑结构中的完整性约束列表，逐条选择合适的方式加以实现。</p>
<p>在逻辑结构设计阶段结束时，作为数据库模式一部分的完整性设计也就基本完成了。每种业务规则都可能有好几种实现方式，应该选择对数据库性能影响最小的一种，有时需通过实际测试来决定。</p>
<h4 id="案例：电子商务系统的安全性设计"><a href="#案例：电子商务系统的安全性设计" class="headerlink" title="案例：电子商务系统的安全性设计"></a>案例：电子商务系统的安全性设计</h4><p>本节以一个具体的电子商务系统——高性能的RADIUS，来阐明电子商务系统的安全设计的基本原理和设计方法。</p>
<h5 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h5><p>AAA（Authentication Authorization and Accounting，验证、授权和审记）是运行于宽带网络接入服务器上的客户端程序。AAA提供了一个用来对验证、授权和审记三种安全功能进行配置的一致的框架，实际上是对网络安全的一种管理。这里的网络安全主要指访问控制，包括哪些用户可以访问网络服务器？如何对正在使用网络资源的用户进行记账？下面简单介绍验证、授权和记账的作用。</p>
<p>（1）验证（Authentication）：验证用户是否可以获得访问权，认证信息包括用户名、用户密码和认证结果等。</p>
<p>（2）授权（Authorization）：授权用户可以使用哪些服务，授权包括服务类型及服务相关信息等。</p>
<p>（3）审记（Accounting）：记录用户使用网络资源的情况，用户IP地址、MAC地址掩码等。</p>
<p>RADIUS服务器负责接收用户的连接请求，完成验证并把用户所需的配置信息返回给BAS建立连接，从而可以获得访问其他网络的权限时，BAS就起到了认证用户的作用。BAS负责把用户之间的验证信息传递通过密钥的参与来完成。用户的密码加密以后才能在网上传递，以避免用户的密码在不安全的网络上被窃取。</p>
<p>例如，用户A请求得到某些服务（如PPP、Telnet和Rlogin等），但必须通过BAS，由BAS依据某种顺序与所连接服务器通信从而进行验证。用户A通过拨号进入BAS，然后BAS按配置好的验证方式（如PPP、PAP和CHAP等）要求用户A输入用户名和密码等信息。用户A终端出现提示，用户按提示输入。通过与BAS的连接，BAS得到这些信息。而后BAS把这些信息传递给响应验证或记账的服务器，并根据服务器的响应来决定用户是否可以获得他所请求的服务。</p>
<p>一个网络允许外部用户通过宽带网对其进行访问，这样用户在地理上可以分散。大量分散用户可以通过DSL Modem等从不同的地方对这个网络进行随机的访问，用户可以把自己的信息传递给这个网络，也可以从这个网络得到自己想要的信息。由于存在内外的双向数据流动，网络安全就成为很重要的问题，因此对信息进行有效管理是必要的。管理的内容包括用户是否可以获得访问权、用户可以允许使用哪些服务，以及如何对使用网络资源的用户进行计费。AAA很好地完成了这3项任务。</p>
<h5 id="软件架构设计"><a href="#软件架构设计" class="headerlink" title="软件架构设计"></a>软件架构设计</h5><p>RADIUS软件主要应用于宽带业务运营的支撑管理，是一个需要可靠运行且高安全级别的软件支撑系统。RADIUS软件的设计还需要考虑一个重要的问题，即系统高性能与可扩展性。</p>
<p>电信数据业务的开展随着我国宽带业务的开展，在宽带接入方式、宽带业务管理等诸多方面均会发生变化，以适应市场的发展。业务的发展对RADIUS软件架构的设计就是重中之重了，其设计将会直接影响系统可持续建设的质量与成本。通过深入分析，高性能的RADIUS软件架构核心如图12-12所示。</p>
<details><summary>图12-12　RADIUS软件架构核心逻辑性</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904092916.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904092916.png';" /></details>

<p>RADIUS软件架构分为三个层面：协议逻辑层、业务逻辑层和数据逻辑层。</p>
<p>协议逻辑层主要实现RFC框架中的内容，处理网络通信协议的建立、通信和停止方面的工作。在软件功能上，这个部分主要相当于一个转发引擎，起到分发处理的内容分发到不同的协议处理过程中，这一层的功能起到了协议与业务处理的分层处理的作用。</p>
<p>业务逻辑层的设计是RADIUS软件架构设计的核心部分，架构设计的好坏将直接关系到应用过程中能否适应RADIUS协议扩展部分的实现，更重要的是会直接影响到用户单位的业务能否顺利开展。协议处理进程主要是对转发引擎发来的包进行初步分析，并根据包的内容进一步分发到不同的业务逻辑处理进程。协议处理进程可以根据项目的情况，配置不同的协议进程数，提高包转发与处理的速度。业务逻辑进程分为认证、计费和授权三种类型，不同的业务逻辑进程可以接收不同协议进程之间的信息并进行处理。转发进程与协议进程之间采用共享内存的方法，实现进程之间的通信。协议进程与业务逻辑处理进程之间采用进程加线程的实现方法，这样实现的好处在于不需要对业务处理线程进行应用软件层面的管理，而由UNIX系统进行管理，进一步提高应用系统处理的效率与质量。</p>
<p>数据逻辑层需要对来自业务逻辑处理线程统一管理与处理数据库代理池的数据，由数据库代理池统一连接数据库，以减少对数据库系统的压力。同时减小了系统对数据库的依赖性，增强了系统适应数据库系统的能力。</p>
<p>RADIUS软件分层架构的实现，一是对软件风险进行了深入的分析，并且在软件实现的过程中得到更多的体现；二是可以构建一个或多个重用的构件单元，同时也可以继承原来的成果。BAS和RADIUS之间验证信息的传递是通过密钥的参与来完成的。从原来的窄带拨号上网到现在的宽带接入、无线接入，在信息加密方面从传统的MD5、PAP和CHAP方式增加了EAP-tls、P-ttls和EAP-sim等多种格式。基于分层架构的协议处理进程有自然的灵活性，可快速适应RFC指南中增加的内容。</p>
<p>RADIUS的功能，一是实际处理大量用户并发的能力，二是软件架构的可扩展性。负载均衡是提高RADIUS软件性能的有效方法，它主要完成以下任务。</p>
<p>（1）解决网络拥塞问题，就近提供服务，实现地理位置无关性。</p>
<p>（2）为用户提供更好的访问质量。</p>
<p>（3）提高服务器响应速度。</p>
<p>（4）提高服务器及其他资源的利用效率。</p>
<p>（5）避免了网络关键部位出现单点失效。</p>
<p>当同时在线的宽带用户量巨大时，BAS发送给后台RADIUS的用户数据更新包的数量会急剧增加，RADIUS服务器的处理能力就成为性能瓶颈。当包的数量大于RADIUS服务器的处理能力时，就会出现丢包，造成用户数据的丢失或不完整。</p>
<p>通过代理转发的方式，把从BAS发送过来的数据包平均转发到其他RADIUS服务器中进行处理，实现RADIUS服务器之间的负载均衡。</p>
<p>RADIUS高性能还体现在自我管理的功能，该功能包括UNIX守护管理监控和进程管理监控。在有故障时，服务进程能内部调度进程，以协调进程的工作情况。同时对RADIUS报文进行SNMP的代理管理，向综合网络管理平台实时发送信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch11-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch11-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch11-信息安全技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:20" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:20+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-15 19:01:58" itemprop="dateModified" datetime="2021-10-15T19:01:58+08:00">2021-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="信息安全技术"><a href="#信息安全技术" class="headerlink" title="信息安全技术"></a>信息安全技术</h2><h3 id="信息安全关键技术"><a href="#信息安全关键技术" class="headerlink" title="信息安全关键技术"></a>信息安全关键技术</h3><h4 id="加密和解密技术"><a href="#加密和解密技术" class="headerlink" title="加密和解密技术"></a>加密和解密技术</h4><p>计算机网络的广泛应用，产生了大量的电子数据，这些电子数据需要传输到网络的许多地方，并存储起来。对于这些数据，有意的计算机犯罪和无意的数据破坏成为最大的威胁。原则上来说，对电子数据的攻击有两种形式：一种称为 $\color{red}{\text{被动攻击}}$ ，就是非法地 $\color{green}{\text{从传输信道上截取信息}}$ ，或 $\color{green}{\text{从存储载体上偷窃}}$ 、 $\color{green}{\text{复制信息}}$ 。另一种称为 $\color{red}{\text{主动进攻}}$ ，就是对传输或存储的数据进行恶意的 $\color{green}{\text{删除}}$ 、 $\color{green}{\text{篡改}}$ 等。实践证明，密码技术是防止数据攻击的一种有效而经济的方法。</p>
<p>我们把消息的发送者称为信源；消息的目的地称为信宿；没有加密的消息称为明文；加密后的消息称为密文；用来传输消息的通道称为信道。通信时，明文M通过变换E得到密文C，即C＝E（u, v, …，W; m）。这个过程称为加密，参数u, v, …, w称为密钥。这里所说的变换E，就是加密算法。从密文C恢复到明文M，这个过程称为解密。解密算法D是加密算法E的逆运算。</p>
<p>加密密钥与解密密钥相同，或者加密密钥与解密密钥可以简单相互推导的密码体制称为对称密码体制。现代密码学修正了密钥的对称性，加密、解密密钥是不同的，也是不能（在有效的时间内）相互推导的，称为非对称密码体制。</p>
<h5 id="对称密钥密码体制及典型算法"><a href="#对称密钥密码体制及典型算法" class="headerlink" title="对称密钥密码体制及典型算法"></a>对称密钥密码体制及典型算法</h5><p>对称算法（Symmetric Algorithm），有时又称为传统密码算法，在大多数对称算法中，加密密钥和解密密钥是相同的，所以也称秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。</p>
<p>对称加密的优点在于算法实现的效率高、速度快。对称加密的缺点在于密钥的管理过于复杂。常用的对称加密算法有DES、IDEA等。</p>
<p>1）DES算法简介</p>
<p>DES （Data Encryption Standard，数据加密标准）是由IBM公司研制的一种加密算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准。二十年来，它一直活跃在国际保密通信的舞台上，扮演了十分重要的角色。</p>
<p>DES是一个分组加密算法，它以64位为分组对数据加密；同时DES也是一个对称算法。它的密匙长度是56位（因为每个第8位都用作奇偶校验），密匙可以是任意56位的数，而且可以任意时候改变。其保密性依赖于密钥。</p>
<p>DES算法分如下3个步骤进行。</p>
<p>（1）对给定的64位的明文x，通过一个初始置换函数IP来排列x，从而构造出长为64位的串X0，记X0为IP（X）＝L0R0，L0表示X0的前32位，R0表示X0的后32位。</p>
<p>（2）计算16次迭代，设前i－1次迭代结果为Xi－1＝Li－1Ri－1，则第i轮迭代运算为：</p>
<p>Li＝Ri－1　　Ri＝Li－1⊕f（Ri－1, ki）</p>
<p>其中，Li－1表示Xi－1的前32位，Ri－1表示Xi－1的后32位，⊕表示两位串的“异或”运算，f主要是由一个称为S盒的置换构成。Ki是一些由初始的56位经过密钥编排函数产生的48位长的块。</p>
<p>（3）对位串L16R16作逆置换IP-1得密文y，y＝IP-1（R16L16），置换IP-1是IP的逆置换。</p>
<p>DES算法的示意图如图11-1所示。</p>
<details><summary>图11-1　DES算法示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904083750.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904083750.png';" /></details>

<p>2）IDEA算法简介</p>
<p>国际数据加密算法（International Data Encryption Algorithm, IDEA）是1992年来学嘉等人设计的算法。该算法的前身是1990年公布的推荐加密标准（Proposed Encryption Standard, PES）算法。</p>
<p>IDEA分组长度为64b，密钥长度为128b。其使用的运算非常简单，只需要异或，模216加和模（216＋1）乘，这些算法都很容易使用硬件或者软件实现（而DES算法便于用硬件实现，难以用软件实现），所有运算都是使用基于16b数运行，很容易在现在的16b、32b、64b CPU上实现。由于这一特性，使用软件实现的IDEA算法的运算速度比DES算法要快。由于IDEA算法使用的密钥长度为128b，远远大于DES算法的56b，对于128b密钥来说，使用穷举法攻击的方法是不现实的。</p>
<h5 id="不对称密码加密算法"><a href="#不对称密码加密算法" class="headerlink" title="不对称密码加密算法"></a>不对称密码加密算法</h5><p>不对称密码体制又称为双密钥和公钥密码体制，是于1976年由Diffie和Hellman提出的。与对称密码体制相比，非对称密码体制有两个不同的密钥，其中一个密钥称为私钥，该密钥被秘密保存；另一个密钥公开，不需要保密。</p>
<p>公钥密码系统的工作方式为：任何人都可以将自己加密的公钥公布在网络或其他可以公开的地方。其他人欲传送信息给该接收方时，可使用该接收方所公布的公钥将信息加密之后传送给接收方。接收方收到加密后的信息时，就可以利用拥有的与此公钥相对应的私钥，将该加密信息解出来。所以公开密钥密码系统的通信双方，不需要事先通过安全秘密管道交换密钥，即可进行通信。</p>
<p>RSA密码体制是一个常用的非对称的密码体制，它是一个既能用于数据加密也能用于数字签名的算法。</p>
<p>RSA的安全性依赖于大素数分解。公钥和私钥都是两个大素数（大于100个十进制位）的函数。据猜测，从一个密钥和密文推断出明文的难度等同于分解两个大素数的积。</p>
<p>1）密钥对的产生</p>
<p>（1）选择两个大素数，p和q。</p>
<p>（2）计算n＝p*q。</p>
<p>（3）随机选择加密密钥e，e必须满足以下条件：</p>
<p>GCD（e, φ（N））＝1</p>
<p>其中，φ为Euler’s Function，φ（N）为小于N、且与N互质的整数的个数。在此，φ（N）＝（p－1）<em>（q－1）（也有些做法是取LCM（（p－1）</em>（q－1）））。</p>
<p>（4）利用Euclid算法计算解密密钥d，满足d＝e-1modφ（N）。</p>
<p>产生出加密公钥e、N与解密密钥d之后，使用者将e及N公开，就可以使用它们来执行加解密的工作了。</p>
<p>2）加密程序</p>
<p>使用者将其欲加密的信息M，在取得对方的公钥e及N之后，执行模（mod，即同余的运算，C＝MmodN，C等于M除以N的余数）指数运算，就可获得密文C。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904083931.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904083931.png';" /></details>

<p>3）解密程序</p>
<p>对方在收到密文C后，以自己的私钥执行下面的解密程序，解密时作如下计算：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904083947.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904083947.png';" /></details>

<p>即可获得明文M。</p>
<p>RSA可用于数字签名，方案是用（b）签名，用（a）验证。具体操作时考虑到安全性和M信息量较大等因素，一般是先作HASH运算。</p>
<p>RSA的安全性依赖于大数分解，由于进行的都是大数计算，使得RSA最快的情况也是DES百分之一。无论是软件还是硬件实现，速度慢一直是RSA的缺陷，因此一般来说，RSA只用于少量数据加密。</p>
<h4 id="散列函数与数字签名"><a href="#散列函数与数字签名" class="headerlink" title="散列函数与数字签名"></a>散列函数与数字签名</h4><h5 id="MD5散列算法"><a href="#MD5散列算法" class="headerlink" title="MD5散列算法"></a>MD5散列算法</h5><p>散列函数是一种公开的数学函数。散列函数运算的输入信息叫做报文，运算后所得到的结果叫做散列码或者叫做消息摘要。散列函数h＝H（M）具有如下一些特点。</p>
<p>（1）不同内容的报文具有不同的散列码，给定M，要找到另一消息M，使H（M）＝H（M′）很难。</p>
<p>（2）散列函数是单向的，给出M，容易计算出h。给定h，根据h＝H（M）反推M却很难。</p>
<p>（3）对于任何一个报文，无法预知它的散列码。</p>
<p>（4）散列码具有固定的长度，不管原始报文的长度如何，通过散列函数运算后的散列码都具有一样的长度。</p>
<p>由于散列函数具有这些特征，因此散列函数可以用来检测报文的可靠性。接收者对收到的报文用与发送者相同的散列函数进行运算，如果得到与发送者相同的散列码，则可以认为报文没有被篡改，否则报文就是不可信的。</p>
<p>常见的散列函数有MD5、SHA和HMAC等。</p>
<p>MD5（Message Digest 5）是一种非常著名的散列算法，已经成为国际标准。它是在MD4的基础上改进的算法，是具有更好的安全性能的散列算法。MD5散列算法对输入的任意长度消息产生128位（16字节）长度的散列值（或称消息摘要）。MD5算法包括以下4个步骤。</p>
<p>（1）附加填充位。首先对输入的报文进行填位补充，使填充后的数据长度模512后余448。如果数据长度正好模512余448，则需增加512个填充位，也就是说填充的个数为1～512位。填充位第一个位为1，其余全部为0。</p>
<p>（2）补足长度。将数据长度表示为二进制，如果长度超过64位，则截取其低64位；如果长度不足64位，则在其高位补0。将这个64位的报文长度补在经过填充的报文后面，使得最后的数据为512位的整数倍。</p>
<p>（3）初始化MD缓存器。MD5运算要用到一个128位的MD5缓存器，用来保存中间变量和最终结果。该缓存器又可看成是4个32位的寄存器A、B、C、D，初始化为：</p>
<p>A:01 23 45 67　B: 89 ab cd ef　C: fe dc ba 98　D: 76 54 32 10</p>
<p>（4）处理数据段。首先定义4个非线性函数F、G、H、I，对输入的报文运算以512位数据段为单位进行处理。对每一个数据段都要进行4轮的逻辑处理，在4轮中分别使用4个不同的函数F、G、H、I。每一轮以ABCD和当前的512位的块为输入，处理后送入ABCD（128位）。</p>
<h5 id="数字签名与数字水印"><a href="#数字签名与数字水印" class="headerlink" title="数字签名与数字水印"></a>数字签名与数字水印</h5><h6 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h6><p>数字签名可以解决否认、伪造、篡改及冒充等问题。具体要求：发送者事后不能否认发送的报文签名、接收者能够核实发送者发送的报文签名、接收者不能伪造发送者的报文签名、接收者不能对发送者的报文进行部分篡改、网络中的某一用户不能冒充另一用户作为发送者或接收者。凡是需要对用户的身份进行判断的情况都可以使用数字签名，例如加密信件、商务信函、订货购买系统、远程金融交易和自动模式处理等。</p>
<p>数字签名方案一般包括三个过程：系统的初始化过程、签名产生过程和签名验证过程。在签名产生的过程中，用户利用给定的算法对消息产生签名；在签名验证过程中，验证者利用公开验证方法对给定消息的签名进行验证，得出签名的有效性。</p>
<p>实现数字签名的方法有很多，目前采用得比较多的是非对称加密技术和对称加密技术。虽然这两种技术的实施步骤不尽相同，但大体的工作程序是一样的。用户首先可以下载或者购买数字签名软件，然后安装在个人计算机上。在产生密钥对后，软件自动向外界传送公开密钥。由于公共密钥的存储需要，所以需要建立一个鉴定中心（Certification Authority, CA）完成个人信息及其密钥的确定工作。用户在获取公开密钥时，首先向鉴定中心请求数字确认，鉴定中心确认用户身份后，发出数字确认，同时鉴定中心向数据库发送确认信息。然后用户使用私有密钥对所传信息签名，保证信息的完整性、真实性，也使发送方无法否认信息的发送，之后发向接收方；接收方接收到信息后，使用公开密钥确认数字签名，在使用这种技术时，签名者必须注意保护好私有密钥，因为它是公开密钥体系安全的重要基础。如果密钥丢失，应该立即报告鉴定中心取消认证，将其列入确认取消列表之中。其次，鉴定中心必须能够迅速确认用户的身份及其密钥的关系。一旦接收到用户请求，鉴定中心要立即认证信息的安全性并返回信息。</p>
<p>目前已经有大量的数字签名算法，如RSA、E1Gama1、Fiat-Shamir、美国的数字签名标准/算法（DSS/DSA）、椭圆曲线等多种。</p>
<h6 id="数字水印"><a href="#数字水印" class="headerlink" title="数字水印"></a>数字水印</h6><p>随着数字技术和因特网的发展，各种形式的多媒体数字作品（如图像、视频和音频等）纷纷以网络形式发表，其版权保护成为一个迫切需要解决的问题。数字水印（Digital Watermarking）是实现版权保护的有效办法，如今已成为多媒体信息安全研究领域的一个热点，也是信息隐藏技术研究领域的重要分支。该技术是通过在原始数据中嵌入秘密信息——水印（Watermark）来证实该数据的所有权。这种被嵌入的水印可以是一段文字、标识或序列号等，而且这种水印通常是不可见或不可察的，它与原始数据（如图像、音频和视频数据）紧密结合并隐藏其中，在经过一些不破坏源数据使用价值或商用价值的操作后仍能保存下来。数字水印技术必须具有较强的鲁棒性、安全性和透明性。</p>
<p>（1）典型数字水印系统模型。</p>
<p>图11-2为水印信号嵌入模型，其功能是将水印信号加入原始数据中；图11-3为水印信号检测模型，用来判断某一数据中是否含有指定的水印信号。</p>
<details><summary>图11-3　水印信号检测模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904084113.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904084113.png';" /></details>

<h6 id="数字水印主要应用领域。"><a href="#数字水印主要应用领域。" class="headerlink" title="数字水印主要应用领域。"></a>数字水印主要应用领域。</h6><p>①版权保护。即数字作品的所有者可用密钥产生一个水印，并将其嵌入原始数据，然后公开发布他的水印版本作品。当该作品被盗版或出现版权纠纷时，所有者即可利用图11-2或图11-3的方法从盗版作品或水印版作品中获取水印信号作为依据，从而保护所有者的权益。</p>
<p>②加指纹。为避免未经授权的复制制作和发行，出品人可以将不同用户的ID或序列号作为不同的水印（指纹）嵌入作品的合法备份中。一旦发现未经授权的备份，就可以根据此备份所恢复出的指纹来确定它的来源。</p>
<p>③标题与注释。即将作品的标题、注释等内容（如一张照片的拍摄时间和地点等）以水印形式嵌入该作品中，这种隐式注释不需要额外的带宽，且不易丢失。</p>
<p>④篡改提示。当数字作品被用于法庭、医学、新闻及商业时，常需确定它们的内容是否被修改、伪造或特殊处理过。为实现该目的，通常可将原始图像分成多个独立块，再将每个块加入不同的水印。同时可通过检测每个数据块中的水印信号，来确定作品的完整性。与其他水印不同的是，这类水印必须是脆弱的，并且检测水印信号时，不需要原始数据。</p>
<p>⑤使用控制。这种应用的一个典型例子是DVD防复制系统，即将水印信息加入DVD数据中，这样DVD播放机即可通过检测DVD数据中的水印信息而判断其合法性和可复制性。从而保护制造商的商业利益。</p>
<p>典型数字水印算法有空域算法、变换域算法、压缩域算法、NEC算法和生理模型算法等。</p>
<h4 id="密钥分配中心与公钥基础设施"><a href="#密钥分配中心与公钥基础设施" class="headerlink" title="密钥分配中心与公钥基础设施"></a>密钥分配中心与公钥基础设施</h4><p>在现代密码系统中，算法本身的保密已经不重要了，对于数据的保密在很大程度上、甚至完全依赖于对密钥的保密。只要密钥能够保密，即使加密算法公开，甚至加密设备丢失，也不会对加密系统的坚固性和正常使用产生多大影响。相反，如果密钥丢失，则不但非法用户可以窃取机密数据，而且合法用户面对密文却如读天书，无法提取有效的信息。因此，在密码系统中，如何高效地分配密钥、安全地管理密钥对保证数据安全来说至关重要。</p>
<h5 id="密钥分配中心"><a href="#密钥分配中心" class="headerlink" title="密钥分配中心"></a>密钥分配中心</h5><p>一个信息系统中任意两个用户之间都可以自己协商来选择不同的密钥，显然，对于总共有N个用户的系统，每个用户都要保存N×（N－1）个密钥。在用户数量较少时，这样来分配密钥还是比较简单、易用的，但是一旦用户数量多起来，系统中要保存的密钥会急剧增多，让每个用户自己高效、安全地管理数量庞大的密钥实际上是不可能的。</p>
<p>有一种非常有效的密钥自动分配方案是密钥分配中心（Key Distribution Center, KDC）技术。</p>
<p>在KDC方案中，每一个用户都只保存自己的私钥SK和KDC的公钥PKKDC，而在通信时再从KDC获得其他用户的公钥或者仅仅在某一次通信中可以使用的对称密钥加密算法的临时密钥K。</p>
<p>假设A和B都是KDC的注册用户，他们分别拥有私钥SKA、SKB。设用对称密钥来加密他们之间的这次对话，那么密钥的分配过程如下。</p>
<p>首先，A向密钥分配中心发送SKA（A, B），表示自己想与B会话。该请求用自己的私钥SKA加密，KDC收到A的请求，用A的公钥来验证请求是由A发出的后，根据某种算法来生成供A、B之间会话使用的对称密钥K。KDC向A返回PKA（K, PKB（A, K）），该应答是用A的公钥加密的，只有A能解读。A用自己的私钥解密应答，得到密钥K，并将PKB（A, K）发送给B，表明A欲与B进行会话。B用自己的私钥解密得到会话密钥K。</p>
<p>至此，完成一次密钥分配。</p>
<p>2．数字证书和公开密钥基础设施</p>
<p>数字签名和公钥加密都是基于不对称加密技术的，存在的问题有：如何保证公开密钥的持有者是真实的；大规模信息系统环境下公开密钥如何产生、分发和管理。</p>
<p>要解决以上问题，就要用到数字证书和PKI。</p>
<p>1）数字证书</p>
<p>数字证书提供了一个在公钥和拥有相应私钥的实体之间建立关系的机制。目前最常用的数字证书格式是由国际标准ITU-T X.509 V3版本定义的。</p>
<p>数字证书中采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己保存私钥，用它进行解密和签名；同时设定一个公钥，并由本人公开，为一组用户所共享，用于加密和验证签名。</p>
<p>数字证书是用户在系统中作为确认身份的证据。在通信的各个环节中，参与通信的各方通过验证对方数字证书，从而确认对方身份的真实性和有效性，从而解决相互间的信任问题。</p>
<p>数字证书的内容一般包括：唯一标识证书所有者的名称、唯一标识证书签发者的名称、证书所有者的公开密钥、证书签发者的数字签名、证书的有效期及证书的序列号等。</p>
<p>2）公钥基础设施</p>
<p>PKI（Public Key Infrastructure，公钥基础设施）的目标是向广大的信息系统用户和应用程序提供公开密钥的管理服务。</p>
<p>PKI的结构模型中有三类实体：管理实体、端实体和证书库。管理实体是PKI的核心，是服务的提供者；端实体是PKI的用户，是服务的使用者；证书库是一个分布式的数据库，用于证书和CRL的存放和检索。</p>
<p>CA和RA是两种管理实体。CA是框架中唯一能够发布和撤销证书的实体，维护证书的生命周期；RA负责处理用户请求，在验证了请求的有效性后，代替用户向CA提交。RA可以单独实现，也可以合并在CA中实现。作为管理实体，CA和RA以证书方式向端实体提供公开密钥的分发服务。</p>
<p>持有者和验证者是两种端实体。持有者是证书的拥有者，是证书所声明的事实上的主体。持有者向管理实体申请并获得证书，也可以在需要时请求撤销或更新证书。持有者使用证书声明自己的身份，从而获得相应的权力。验证者确认持有者所提供的证书的有效性和对方是否为该证书的真正拥有者，只有在成功鉴别之后才可与对方进行更进一步的交互。</p>
<p>由于证书库的存取对象为证书和CRL，其完整性由数字签名来保证，因此不需要额外的安全机制。</p>
<p>不同的实体间通过PKI操作完成证书的请求、确认、发布、撤销、更新和获取等过程。PKI操作分为存取操作和管理操作两类。其中，存取操作包括管理实体或端实体把证书和CRL存放到证书库、从证书库中读取证书和CRL；管理操作则是管理实体与端实体之间或管理实体与管理实体之间的交互，是为了完成证书的各项管理任务和建立证书链。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>访问控制是通过某种途径限制和允许对资源的访问能力以及范围的一种方法。它是针对越权使用系统资源的保护措施，通过限制对文件等资源的访问，防止非法用户的侵入或者合法用户的不当操作造成的破坏，从而保证信息系统资源的合法使用。</p>
<p>访问控制技术可以通过对计算机系统的控制，自动、有效地防止对系统资源进行非法访问或者不当的使用，检测出一部分安全侵害，同时可以支持应用和数据的安全需求。</p>
<p>访问控制技术并不能取代身份认证，它是建立在身份认证的基础之上的。</p>
<h5 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h5><p>在网络通信中，需要确定通信双方的身份，这就需要身份认证技术。在有安全需求的应用系统中，识别用户的身份是系统的基本要求，认证是安全系统中不可缺少的一部分。识别用户的身份有两种不同的形式：一种是身份认证，要求对用户所有的权限角色或自身的身份进行认证；一种是身份鉴定，要求对使用者本身的身份进行检查。</p>
<p>认证的方法多种多样，其安全强度也不相同。具体方法可归结为3大类：根据用户知道什么、拥有什么、是什么来进行认证。用户知道什么，一般就是口令；用户拥有什么，通常为私钥或令牌：用户是什么，这是一种基于生物识别技术的认证。</p>
<p>1）用户名和口令认证</p>
<p>简单认证方式主要是通过一个客户与服务器共知的口令（或与口令相关的数据，如散列、密文等）进行验证。根据处理形式的不同，有3种简单认证的方式：验证数据的明文传送、利用单向散列函数处理验证数据、利用单向散列函数和随机数处理验证数据，这3种方式的安全强度依次增加，处理复杂度也依次增高。</p>
<p>2）使用令牌认证</p>
<p>在使用令牌进行认证的系统中，进行验证的密钥存储于令牌中。对密钥的访问用口令进行控制。令牌是一个像IC卡一样可以加密存储并运行相应加密算法的设备，这种简单认证可以快速、方便地实现用户身份认证，但是认证的安全强度不高。通过令牌可以完成对用户必须拥有某物的验证。令牌的实现分为质询响应令牌和时间戳令牌，其中使用较多的是时间戳令牌。</p>
<p>质询响应令牌的工作原理是：在进行身份认证时，认证服务器首先发送一个随机数到客户机的登录程序。用户将这个随机数读出，输入令牌，并输入令牌的PIN码（实际就是口令），得以访问令牌。令牌对输入的随机数用存储的私钥进行签名，并把结果用Base64编码输出。用户把令牌的输出填入客户机的验证程序中，数据传输到认证的服务器端，在服务器端将使用用户的公钥对签名进行验证，以确定是否允许客户通过登录认证。在该方案中，由于使用数字签名进行登录认证，系统的安全强度大大增加：私钥采用令牌存储的方式解决了私钥自身的安全问题。令牌是一个可移动的设备，可以随身携带，而且令牌有PIN码保护，对令牌的非法访问超过一定的次数后，令牌会死锁。</p>
<p>时间戳令牌解决了质询响应令牌中随机数的问题，时间戳令牌利用时间代替上面的随机数。时间戳令牌每时每刻都在工作，一般每分钟产生一个登录数据，用户只需输入PIN码。登录数据被传送到认证的服务器端，服务器利用当前时间对登录数据进行验证，完成用户的登录过程。使用时间戳令牌需要重点考虑时间同步问题，由于令牌的时钟和认证服务器的时钟不同步，产生的验证码并不会通过验证。解决方法是在验证服务器上进行多次试探验证，在一个时间范围内试探，如果成功则在服务器上存储令牌时钟与服务器时钟的偏移量，以便下次登录时使用。目前，在安全性要求较高的认证系统中，多是采用这种方案。</p>
<p>采用PIN码与令牌实现了双因素验证，根据用户知道什么、拥有什么进行认证，也提供了一个保密认证密钥的方法。但是实现双因素验证需要用户输入数据，给用户的操作增加了麻烦。</p>
<p>3）生物识别与三因素认证</p>
<p>现在兴起了一种基于生物识别技术的认证，主要是根据认证者的图像、指纹、气味和声音等作为认证数据。基于用户知道什么（口令）、拥有什么（私钥和令牌）、是什么（生物特征）的3因素认证是目前强认证中使用最多的手段。在安全性要求较高的系统中，认证必须能对用户进行身份鉴定。要将用户知道什么、拥有什么、是什么结合起来，同时对认证用的密钥进行保护。</p>
<h5 id="访问控制技术"><a href="#访问控制技术" class="headerlink" title="访问控制技术"></a>访问控制技术</h5><p>根据控制手段和具体目的的不同，通常将访问控制技术划分为如下几个方面：入网访问控制、网络权限控制、目录级安全控制、属性安全控制以及网络服务器的安全控制等。</p>
<p>入网访问控制为网络访问提供了第一层访问控制。它控制哪些用户能够登录到服务器并获取网络资源，控制准许用户入网的时间和准许入网的工作站等。基于用户名和口令的用户的入网访问控制可分为三个步骤：用户名的识别与验证、用户口令的识别与验证、用户账号的默认限制检查。三个步骤中只要任何一个未通过校验，该用户便不能进入该网络。可以说，对网络用户的用户名和口令进行验证是防止非法访问的第一道防线。但由于用户名口令验证方式容易被攻破，目前很多网络都开始采用基于数字证书的验证方式。</p>
<p>网络权限控制是针对网络非法操作所提出的一种安全保护措施。能够访问网络的合法用户被划分为不同的用户组，用户和用户组被赋予一定的权限。访问控制机制明确了用户和用户组可以访问哪些目录、子目录、文件和其他资源；以及指定用户对这些文件、目录、设备能够执行哪些操作。它有两种实现方式，“受托者指派”和“继承权限屏蔽”。“受托者指派”控制用户和用户组如何使用网络服务器的目录、文件和设备；“继承权限屏蔽”相当于一个过滤器，可以限制子目录从父目录那里继承哪些权限。可以根据访问权限将用户分为以下几类：特殊用户（即系统管理员）；一般用户，系统管理员根据他们的实际需要为他们分配操作权限；审计用户，负责网络的安全控制与资源使用情况的审计。用户对网络资源的访问权限可以用访问控制表来描述。</p>
<p>目录级安全控制是针对用户设置的访问控制，控制用户对目录、文件、设备的访问。用户在目录一级指定的权限对所有文件和子目录有效，用户还可以进一步指定对目录下的子目录和文件的权限。对目录和文件的访问权限一般有8种：系统管理员权限、读权限、写权限、创建权限、删除权限、修改权限、文件查找权限和访问控制权限。8种访问权限的有效组合可以让用户有效地完成工作，同时又能有效地控制用户对服务器资源的访问，从而加强了网络和服务器的安全性。</p>
<p>属性安全控制在权限安全控制的基础上提供更进一步的安全性。当用户访问文件、目录和网络设备时，网络系统管理员应该给出文件、目录的访问属性，网络上的资源都应预先标出安全属性，用户对网络资源的访问权限对应一张访问控制表，用以表明用户对网络资源的访问能力。属性设置可以覆盖已经指定的任何受托者指派和有效权限。属性能够控制以下几个方面的权限：向某个文件写数据、复制文件、删除目录或文件、查看目录和文件、执行文件、隐含文件、共享、系统属性等，避免发生非法访问的现象。</p>
<p>因为网络允许用户在服务器控制台上执行一系列操作，所以用户使用控制台就可以执行装载和卸载模块、安装和删除软件等操作，这就需要网络服务器有安全控制。网络服务器的安全控制包括可以设置口令锁定服务器控制台，从而防止非法用户修改、删除重要信息或破坏数据。具体包括设定服务器登录时间限制、非法访问者检测和关闭的时间间隔等。</p>
<h4 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h4><h5 id="IPSec协议简述"><a href="#IPSec协议简述" class="headerlink" title="IPSec协议简述"></a>IPSec协议简述</h5><p>为了满足Internet的安全需求，因特网工程任务组（ $\color{green}{\text{IETF}}$ ）于1998年11月颁布IP层安全标准IP SECURITY协议（IPSec），IPSec在IP层上对数据包进行高强度的安全处理提供数据源验证、无连接数据完整性、数据机密性、抗重播和有限通信流机密性等安全服务。</p>
<p>1）IPSec协议工作原理</p>
<p>IPSec通过使用两种通信安全协议来为数据报提供高质量的安全性：认证头（AH）协议和封装安全载荷（ESP）协议，以及像Internet密钥交换（Internet Key Exchange, IKE）协议这样的密钥管理过程和协议。其中AH协议提供数据源认证、无连接的完整性以及一个可选的抗重放服务。ESP协议提供数据保密性、有限的数据流保密性、数据源验证、无连接的完整性以及抗重放服务。IPSec允许系统或网络用户控制安全服务提供的粒度。IPSec的安全服务是由通信双方建立的安全关联（Security Association, SA）来提供的，SA为通信提供了安全协议、模式、算法和应用于单向IP流的密钥等安全信息。每一个IPSec节点包含一个局部的安全策略库（Security Polioy Database, SPD），系统在处理输入、输出IP流时必须参考该策略库，并根据从SPD中提取的策略对IP流进行不同的处理：拒绝、绕过、进行IPSec保护。如果策略决定IP流需要经过IPSec处理，则根据SPD与SAD的对应关系，找到相应的SA，并对IP包进行指定的IPSec处理。SA由一个三元组唯一地标识，该三元组包含一个安全参数索引（Security Parameter Index, SPI），一个用于输出处理SA的目的IP地址或者一个用于输入处理SA的源IP地址以及一个特定的协议（例如AH或者ESP）。SPI是为了唯一标识SA而生成的一个32位整数。它在AH和ESP头中传输，IPSec数据报的接收方易于识别SPI并利用它连同源或者目的IP地址和协议来搜索SAD，以确定与该数据报相关联的SA或者SA束。SA中所选用的安全协议、SA模式、SA的两端及安全协议内所要求的服务等具体地决定了怎样为通信流提供安全服务。但是，最终安全服务的具体实施是通过使用AH和ESP协议。</p>
<p>2）IPSec协议实现模式</p>
<p>IPSec协议既可用来保护一个完整的IP载荷，也可用来保护某个IP载荷的上层协议。这两方面第11章　信息安全技术</p>
<p>11.1　信息安全关键技术</p>
<p>11.1.1　加密和解密技术</p>
<p>计算机网络的广泛应用，产生了大量的电子数据，这些电子数据需要传输到网络的许多地方，并存储起来。对于这些数据，有意的计算机犯罪和无意的数据破坏成为最大的威胁。原则上来说，对电子数据的攻击有两种形式：一种称为被动攻击，就是非法地从传输信道上截取信息，或从存储载体上偷窃、复制信息。另一种称为主动进攻，就是对传输或存储的数据进行恶意的删除、篡改等。实践证明，密码技术是防止数据攻击的一种有效而经济的方法。</p>
<p>我们把消息的发送者称为信源；消息的目的地称为信宿；没有加密的消息称为明文；加密后的消息称为密文；用来传输消息的通道称为信道。通信时，明文M通过变换E得到密文C，即C＝E（u, v, …，W; m）。这个过程称为加密，参数u, v, …, w称为密钥。这里所说的变换E，就是加密算法。从密文C恢复到明文M，这个过程称为解密。解密算法D是加密算法E的逆运算。</p>
<p>加密密钥与解密密钥相同，或者加密密钥与解密密钥可以简单相互推导的密码体制称为对称密码体制。现代密码学修正了密钥的对称性，加密、解密密钥是不同的，也是不能（在有效的时间内）相互推导的，称为非对称密码体制。</p>
<p>1．对称密钥密码体制及典型算法</p>
<p>对称算法（Symmetric Algorithm），有时又称为传统密码算法，在大多数对称算法中，加密密钥和解密密钥是相同的，所以也称秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。</p>
<p>对称加密的优点在于算法实现的效率高、速度快。对称加密的缺点在于密钥的管理过于复杂。常用的对称加密算法有DES、IDEA等。</p>
<p>1）DES算法简介</p>
<p>DES （Data Encryption Standard，数据加密标准）是由IBM公司研制的一种加密算法，美国国家标准局于1977年公布把它作为非机要部门使用的数据加密标准。二十年来，它一直活跃在国际保密通信的舞台上，扮演了十分重要的角色。</p>
<p>DES是一个分组加密算法，它以64位为分组对数据加密；同时DES也是一个对称算法。它的密匙长度是56位（因为每个第8位都用作奇偶校验），密匙可以是任意56位的数，而且可以任意时候改变。其保密性依赖于密钥。</p>
<p>DES算法分如下3个步骤进行。</p>
<p>（1）对给定的64位的明文x，通过一个初始置换函数IP来排列x，从而构造出长为64位的串X0，记X0为IP（X）＝L0R0，L0表示X0的前32位，R0表示X0的后32位。</p>
<p>（2）计算16次迭代，设前i－1次迭代结果为Xi－1＝Li－1Ri－1，则第i轮迭代运算为：</p>
<p>Li＝Ri－1　　Ri＝Li－1⊕f（Ri－1, ki）</p>
<p>其中，Li－1表示Xi－1的前32位，Ri－1表示Xi－1的后32位，⊕表示两位串的“异或”运算，f主要是由一个称为S盒的置换构成。Ki是一些由初始的56位经过密钥编排函数产生的48位长的块。</p>
<p>（3）对位串L16R16作逆置换IP-1得密文y，y＝IP-1（R16L16），置换IP-1是IP的逆置换。</p>
<p>DES算法的示意图如图11-1所示。</p>
<p>alt</p>
<p>图11-1　DES算法示意图</p>
<p>2）IDEA算法简介</p>
<p>国际数据加密算法（International Data Encryption Algorithm, IDEA）是1992年来学嘉等人设计的算法。该算法的前身是1990年公布的推荐加密标准（Proposed Encryption Standard, PES）算法。</p>
<p>IDEA分组长度为64b，密钥长度为128b。其使用的运算非常简单，只需要异或，模216加和模（216＋1）乘，这些算法都很容易使用硬件或者软件实现（而DES算法便于用硬件实现，难以用软件实现），所有运算都是使用基于16b数运行，很容易在现在的16b、32b、64b CPU上实现。由于这一特性，使用软件实现的IDEA算法的运算速度比DES算法要快。由于IDEA算法使用的密钥长度为128b，远远大于DES算法的56b，对于128b密钥来说，使用穷举法攻击的方法是不现实的。</p>
<p>2．不对称密码加密算法</p>
<p>不对称密码体制又称为双密钥和公钥密码体制，是于1976年由Diffie和Hellman提出的。与对称密码体制相比，非对称密码体制有两个不同的密钥，其中一个密钥称为私钥，该密钥被秘密保存；另一个密钥公开，不需要保密。</p>
<p>公钥密码系统的工作方式为：任何人都可以将自己加密的公钥公布在网络或其他可以公开的地方。其他人欲传送信息给该接收方时，可使用该接收方所公布的公钥将信息加密之后传送给接收方。接收方收到加密后的信息时，就可以利用拥有的与此公钥相对应的私钥，将该加密信息解出来。所以公开密钥密码系统的通信双方，不需要事先通过安全秘密管道交换密钥，即可进行通信。</p>
<p>RSA密码体制是一个常用的非对称的密码体制，它是一个既能用于数据加密也能用于数字签名的算法。</p>
<p>RSA的安全性依赖于大素数分解。公钥和私钥都是两个大素数（大于100个十进制位）的函数。据猜测，从一个密钥和密文推断出明文的难度等同于分解两个大素数的积。</p>
<p>1）密钥对的产生</p>
<p>（1）选择两个大素数，p和q。</p>
<p>（2）计算n＝p*q。</p>
<p>（3）随机选择加密密钥e，e必须满足以下条件：</p>
<p>GCD（e, φ（N））＝1</p>
<p>其中，φ为Euler’s Function，φ（N）为小于N、且与N互质的整数的个数。在此，φ（N）＝（p－1）<em>（q－1）（也有些做法是取LCM（（p－1）</em>（q－1）））。</p>
<p>（4）利用Euclid算法计算解密密钥d，满足d＝e-1modφ（N）。</p>
<p>产生出加密公钥e、N与解密密钥d之后，使用者将e及N公开，就可以使用它们来执行加解密的工作了。</p>
<p>2）加密程序</p>
<p>使用者将其欲加密的信息M，在取得对方的公钥e及N之后，执行模（mod，即同余的运算，C＝MmodN，C等于M除以N的余数）指数运算，就可获得密文C。</p>
<p>alt</p>
<p>然后通过网络传送至通信的对方。</p>
<p>3）解密程序</p>
<p>对方在收到密文C后，以自己的私钥执行下面的解密程序，解密时作如下计算：</p>
<p>alt</p>
<p>即可获得明文M。</p>
<p>RSA可用于数字签名，方案是用（b）签名，用（a）验证。具体操作时考虑到安全性和M信息量较大等因素，一般是先作HASH运算。</p>
<p>RSA的安全性依赖于大数分解，由于进行的都是大数计算，使得RSA最快的情况也是DES百分之一。无论是软件还是硬件实现，速度慢一直是RSA的缺陷，因此一般来说，RSA只用于少量数据加密。</p>
<p>11.1.2　散列函数与数字签名</p>
<p>1．MD5散列算法</p>
<p>散列函数是一种公开的数学函数。散列函数运算的输入信息叫做报文，运算后所得到的结果叫做散列码或者叫做消息摘要。散列函数h＝H（M）具有如下一些特点。</p>
<p>（1）不同内容的报文具有不同的散列码，给定M，要找到另一消息M，使H（M）＝H（M′）很难。</p>
<p>（2）散列函数是单向的，给出M，容易计算出h。给定h，根据h＝H（M）反推M却很难。</p>
<p>（3）对于任何一个报文，无法预知它的散列码。</p>
<p>（4）散列码具有固定的长度，不管原始报文的长度如何，通过散列函数运算后的散列码都具有一样的长度。</p>
<p>由于散列函数具有这些特征，因此散列函数可以用来检测报文的可靠性。接收者对收到的报文用与发送者相同的散列函数进行运算，如果得到与发送者相同的散列码，则可以认为报文没有被篡改，否则报文就是不可信的。</p>
<p>常见的散列函数有MD5、SHA和HMAC等。</p>
<p>MD5（Message Digest 5）是一种非常著名的散列算法，已经成为国际标准。它是在MD4的基础上改进的算法，是具有更好的安全性能的散列算法。MD5散列算法对输入的任意长度消息产生128位（16字节）长度的散列值（或称消息摘要）。MD5算法包括以下4个步骤。</p>
<p>（1）附加填充位。首先对输入的报文进行填位补充，使填充后的数据长度模512后余448。如果数据长度正好模512余448，则需增加512个填充位，也就是说填充的个数为1～512位。填充位第一个位为1，其余全部为0。</p>
<p>（2）补足长度。将数据长度表示为二进制，如果长度超过64位，则截取其低64位；如果长度不足64位，则在其高位补0。将这个64位的报文长度补在经过填充的报文后面，使得最后的数据为512位的整数倍。</p>
<p>（3）初始化MD缓存器。MD5运算要用到一个128位的MD5缓存器，用来保存中间变量和最终结果。该缓存器又可看成是4个32位的寄存器A、B、C、D，初始化为：</p>
<p>A:01 23 45 67　B: 89 ab cd ef　C: fe dc ba 98　D: 76 54 32 10</p>
<p>（4）处理数据段。首先定义4个非线性函数F、G、H、I，对输入的报文运算以512位数据段为单位进行处理。对每一个数据段都要进行4轮的逻辑处理，在4轮中分别使用4个不同的函数F、G、H、I。每一轮以ABCD和当前的512位的块为输入，处理后送入ABCD（128位）。</p>
<p>2．数字签名与数字水印</p>
<p>1）数字签名</p>
<p>数字签名可以解决否认、伪造、篡改及冒充等问题。具体要求：发送者事后不能否认发送的报文签名、接收者能够核实发送者发送的报文签名、接收者不能伪造发送者的报文签名、接收者不能对发送者的报文进行部分篡改、网络中的某一用户不能冒充另一用户作为发送者或接收者。凡是需要对用户的身份进行判断的情况都可以使用数字签名，例如加密信件、商务信函、订货购买系统、远程金融交易和自动模式处理等。</p>
<p>数字签名方案一般包括三个过程：系统的初始化过程、签名产生过程和签名验证过程。在签名产生的过程中，用户利用给定的算法对消息产生签名；在签名验证过程中，验证者利用公开验证方法对给定消息的签名进行验证，得出签名的有效性。</p>
<p>实现数字签名的方法有很多，目前采用得比较多的是非对称加密技术和对称加密技术。虽然这两种技术的实施步骤不尽相同，但大体的工作程序是一样的。用户首先可以下载或者购买数字签名软件，然后安装在个人计算机上。在产生密钥对后，软件自动向外界传送公开密钥。由于公共密钥的存储需要，所以需要建立一个鉴定中心（Certification Authority, CA）完成个人信息及其密钥的确定工作。用户在获取公开密钥时，首先向鉴定中心请求数字确认，鉴定中心确认用户身份后，发出数字确认，同时鉴定中心向数据库发送确认信息。然后用户使用私有密钥对所传信息签名，保证信息的完整性、真实性，也使发送方无法否认信息的发送，之后发向接收方；接收方接收到信息后，使用公开密钥确认数字签名，在使用这种技术时，签名者必须注意保护好私有密钥，因为它是公开密钥体系安全的重要基础。如果密钥丢失，应该立即报告鉴定中心取消认证，将其列入确认取消列表之中。其次，鉴定中心必须能够迅速确认用户的身份及其密钥的关系。一旦接收到用户请求，鉴定中心要立即认证信息的安全性并返回信息。</p>
<p>目前已经有大量的数字签名算法，如RSA、E1Gama1、Fiat-Shamir、美国的数字签名标准/算法（DSS/DSA）、椭圆曲线等多种。</p>
<p>2）数字水印</p>
<p>随着数字技术和因特网的发展，各种形式的多媒体数字作品（如图像、视频和音频等）纷纷以网络形式发表，其版权保护成为一个迫切需要解决的问题。数字水印（Digital Watermarking）是实现版权保护的有效办法，如今已成为多媒体信息安全研究领域的一个热点，也是信息隐藏技术研究领域的重要分支。该技术是通过在原始数据中嵌入秘密信息——水印（Watermark）来证实该数据的所有权。这种被嵌入的水印可以是一段文字、标识或序列号等，而且这种水印通常是不可见或不可察的，它与原始数据（如图像、音频和视频数据）紧密结合并隐藏其中，在经过一些不破坏源数据使用价值或商用价值的操作后仍能保存下来。数字水印技术必须具有较强的鲁棒性、安全性和透明性。</p>
<p>（1）典型数字水印系统模型。</p>
<p>图11-2为水印信号嵌入模型，其功能是将水印信号加入原始数据中；图11-3为水印信号检测模型，用来判断某一数据中是否含有指定的水印信号。</p>
<p>alt</p>
<p>图11-3　水印信号检测模型</p>
<p>（2）数字水印主要应用领域。</p>
<p>①版权保护。即数字作品的所有者可用密钥产生一个水印，并将其嵌入原始数据，然后公开发布他的水印版本作品。当该作品被盗版或出现版权纠纷时，所有者即可利用图11-2或图11-3的方法从盗版作品或水印版作品中获取水印信号作为依据，从而保护所有者的权益。</p>
<p>②加指纹。为避免未经授权的复制制作和发行，出品人可以将不同用户的ID或序列号作为不同的水印（指纹）嵌入作品的合法备份中。一旦发现未经授权的备份，就可以根据此备份所恢复出的指纹来确定它的来源。</p>
<p>③标题与注释。即将作品的标题、注释等内容（如一张照片的拍摄时间和地点等）以水印形式嵌入该作品中，这种隐式注释不需要额外的带宽，且不易丢失。</p>
<p>④篡改提示。当数字作品被用于法庭、医学、新闻及商业时，常需确定它们的内容是否被修改、伪造或特殊处理过。为实现该目的，通常可将原始图像分成多个独立块，再将每个块加入不同的水印。同时可通过检测每个数据块中的水印信号，来确定作品的完整性。与其他水印不同的是，这类水印必须是脆弱的，并且检测水印信号时，不需要原始数据。</p>
<p>⑤使用控制。这种应用的一个典型例子是DVD防复制系统，即将水印信息加入DVD数据中，这样DVD播放机即可通过检测DVD数据中的水印信息而判断其合法性和可复制性。从而保护制造商的商业利益。</p>
<p>典型数字水印算法有空域算法、变换域算法、压缩域算法、NEC算法和生理模型算法等。</p>
<p>11.1.3　密钥分配中心与公钥基础设施</p>
<p>在现代密码系统中，算法本身的保密已经不重要了，对于数据的保密在很大程度上、甚至完全依赖于对密钥的保密。只要密钥能够保密，即使加密算法公开，甚至加密设备丢失，也不会对加密系统的坚固性和正常使用产生多大影响。相反，如果密钥丢失，则不但非法用户可以窃取机密数据，而且合法用户面对密文却如读天书，无法提取有效的信息。因此，在密码系统中，如何高效地分配密钥、安全地管理密钥对保证数据安全来说至关重要。</p>
<p>1．密钥分配中心</p>
<p>一个信息系统中任意两个用户之间都可以自己协商来选择不同的密钥，显然，对于总共有N个用户的系统，每个用户都要保存N×（N－1）个密钥。在用户数量较少时，这样来分配密钥还是比较简单、易用的，但是一旦用户数量多起来，系统中要保存的密钥会急剧增多，让每个用户自己高效、安全地管理数量庞大的密钥实际上是不可能的。</p>
<p>有一种非常有效的密钥自动分配方案是密钥分配中心（Key Distribution Center, KDC）技术。</p>
<p>在KDC方案中，每一个用户都只保存自己的私钥SK和KDC的公钥PKKDC，而在通信时再从KDC获得其他用户的公钥或者仅仅在某一次通信中可以使用的对称密钥加密算法的临时密钥K。</p>
<p>假设A和B都是KDC的注册用户，他们分别拥有私钥SKA、SKB。设用对称密钥来加密他们之间的这次对话，那么密钥的分配过程如下。</p>
<p>首先，A向密钥分配中心发送SKA（A, B），表示自己想与B会话。该请求用自己的私钥SKA加密，KDC收到A的请求，用A的公钥来验证请求是由A发出的后，根据某种算法来生成供A、B之间会话使用的对称密钥K。KDC向A返回PKA（K, PKB（A, K）），该应答是用A的公钥加密的，只有A能解读。A用自己的私钥解密应答，得到密钥K，并将PKB（A, K）发送给B，表明A欲与B进行会话。B用自己的私钥解密得到会话密钥K。</p>
<p>至此，完成一次密钥分配。</p>
<p>2．数字证书和公开密钥基础设施</p>
<p>数字签名和公钥加密都是基于不对称加密技术的，存在的问题有：如何保证公开密钥的持有者是真实的；大规模信息系统环境下公开密钥如何产生、分发和管理。</p>
<p>要解决以上问题，就要用到数字证书和PKI。</p>
<p>1）数字证书</p>
<p>数字证书提供了一个在公钥和拥有相应私钥的实体之间建立关系的机制。目前最常用的数字证书格式是由国际标准ITU-T X.509 V3版本定义的。</p>
<p>数字证书中采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己保存私钥，用它进行解密和签名；同时设定一个公钥，并由本人公开，为一组用户所共享，用于加密和验证签名。</p>
<p>数字证书是用户在系统中作为确认身份的证据。在通信的各个环节中，参与通信的各方通过验证对方数字证书，从而确认对方身份的真实性和有效性，从而解决相互间的信任问题。</p>
<p>数字证书的内容一般包括：唯一标识证书所有者的名称、唯一标识证书签发者的名称、证书所有者的公开密钥、证书签发者的数字签名、证书的有效期及证书的序列号等。</p>
<p>2）公钥基础设施</p>
<p>PKI（Public Key Infrastructure，公钥基础设施）的目标是向广大的信息系统用户和应用程序提供公开密钥的管理服务。</p>
<p>PKI的结构模型中有三类实体：管理实体、端实体和证书库。管理实体是PKI的核心，是服务的提供者；端实体是PKI的用户，是服务的使用者；证书库是一个分布式的数据库，用于证书和CRL的存放和检索。</p>
<p>CA和RA是两种管理实体。CA是框架中唯一能够发布和撤销证书的实体，维护证书的生命周期；RA负责处理用户请求，在验证了请求的有效性后，代替用户向CA提交。RA可以单独实现，也可以合并在CA中实现。作为管理实体，CA和RA以证书方式向端实体提供公开密钥的分发服务。</p>
<p>持有者和验证者是两种端实体。持有者是证书的拥有者，是证书所声明的事实上的主体。持有者向管理实体申请并获得证书，也可以在需要时请求撤销或更新证书。持有者使用证书声明自己的身份，从而获得相应的权力。验证者确认持有者所提供的证书的有效性和对方是否为该证书的真正拥有者，只有在成功鉴别之后才可与对方进行更进一步的交互。</p>
<p>由于证书库的存取对象为证书和CRL，其完整性由数字签名来保证，因此不需要额外的安全机制。</p>
<p>不同的实体间通过PKI操作完成证书的请求、确认、发布、撤销、更新和获取等过程。PKI操作分为存取操作和管理操作两类。其中，存取操作包括管理实体或端实体把证书和CRL存放到证书库、从证书库中读取证书和CRL；管理操作则是管理实体与端实体之间或管理实体与管理实体之间的交互，是为了完成证书的各项管理任务和建立证书链。</p>
<p>11.1.4　访问控制</p>
<p>访问控制是通过某种途径限制和允许对资源的访问能力以及范围的一种方法。它是针对越权使用系统资源的保护措施，通过限制对文件等资源的访问，防止非法用户的侵入或者合法用户的不当操作造成的破坏，从而保证信息系统资源的合法使用。</p>
<p>访问控制技术可以通过对计算机系统的控制，自动、有效地防止对系统资源进行非法访问或者不当的使用，检测出一部分安全侵害，同时可以支持应用和数据的安全需求。</p>
<p>访问控制技术并不能取代身份认证，它是建立在身份认证的基础之上的。</p>
<p>1．身份认证技术</p>
<p>在网络通信中，需要确定通信双方的身份，这就需要身份认证技术。在有安全需求的应用系统中，识别用户的身份是系统的基本要求，认证是安全系统中不可缺少的一部分。识别用户的身份有两种不同的形式：一种是身份认证，要求对用户所有的权限角色或自身的身份进行认证；一种是身份鉴定，要求对使用者本身的身份进行检查。</p>
<p>认证的方法多种多样，其安全强度也不相同。具体方法可归结为3大类：根据用户知道什么、拥有什么、是什么来进行认证。用户知道什么，一般就是口令；用户拥有什么，通常为私钥或令牌：用户是什么，这是一种基于生物识别技术的认证。</p>
<p>1）用户名和口令认证</p>
<p>简单认证方式主要是通过一个客户与服务器共知的口令（或与口令相关的数据，如散列、密文等）进行验证。根据处理形式的不同，有3种简单认证的方式：验证数据的明文传送、利用单向散列函数处理验证数据、利用单向散列函数和随机数处理验证数据，这3种方式的安全强度依次增加，处理复杂度也依次增高。</p>
<p>2）使用令牌认证</p>
<p>在使用令牌进行认证的系统中，进行验证的密钥存储于令牌中。对密钥的访问用口令进行控制。令牌是一个像IC卡一样可以加密存储并运行相应加密算法的设备，这种简单认证可以快速、方便地实现用户身份认证，但是认证的安全强度不高。通过令牌可以完成对用户必须拥有某物的验证。令牌的实现分为质询响应令牌和时间戳令牌，其中使用较多的是时间戳令牌。</p>
<p>质询响应令牌的工作原理是：在进行身份认证时，认证服务器首先发送一个随机数到客户机的登录程序。用户将这个随机数读出，输入令牌，并输入令牌的PIN码（实际就是口令），得以访问令牌。令牌对输入的随机数用存储的私钥进行签名，并把结果用Base64编码输出。用户把令牌的输出填入客户机的验证程序中，数据传输到认证的服务器端，在服务器端将使用用户的公钥对签名进行验证，以确定是否允许客户通过登录认证。在该方案中，由于使用数字签名进行登录认证，系统的安全强度大大增加：私钥采用令牌存储的方式解决了私钥自身的安全问题。令牌是一个可移动的设备，可以随身携带，而且令牌有PIN码保护，对令牌的非法访问超过一定的次数后，令牌会死锁。</p>
<p>时间戳令牌解决了质询响应令牌中随机数的问题，时间戳令牌利用时间代替上面的随机数。时间戳令牌每时每刻都在工作，一般每分钟产生一个登录数据，用户只需输入PIN码。登录数据被传送到认证的服务器端，服务器利用当前时间对登录数据进行验证，完成用户的登录过程。使用时间戳令牌需要重点考虑时间同步问题，由于令牌的时钟和认证服务器的时钟不同步，产生的验证码并不会通过验证。解决方法是在验证服务器上进行多次试探验证，在一个时间范围内试探，如果成功则在服务器上存储令牌时钟与服务器时钟的偏移量，以便下次登录时使用。目前，在安全性要求较高的认证系统中，多是采用这种方案。</p>
<p>采用PIN码与令牌实现了双因素验证，根据用户知道什么、拥有什么进行认证，也提供了一个保密认证密钥的方法。但是实现双因素验证需要用户输入数据，给用户的操作增加了麻烦。</p>
<p>3）生物识别与三因素认证</p>
<p>现在兴起了一种基于生物识别技术的认证，主要是根据认证者的图像、指纹、气味和声音等作为认证数据。基于用户知道什么（口令）、拥有什么（私钥和令牌）、是什么（生物特征）的3因素认证是目前强认证中使用最多的手段。在安全性要求较高的系统中，认证必须能对用户进行身份鉴定。要将用户知道什么、拥有什么、是什么结合起来，同时对认证用的密钥进行保护。</p>
<p>2．访问控制技术</p>
<p>根据控制手段和具体目的的不同，通常将访问控制技术划分为如下几个方面：入网访问控制、网络权限控制、目录级安全控制、属性安全控制以及网络服务器的安全控制等。</p>
<p>入网访问控制为网络访问提供了第一层访问控制。它控制哪些用户能够登录到服务器并获取网络资源，控制准许用户入网的时间和准许入网的工作站等。基于用户名和口令的用户的入网访问控制可分为三个步骤：用户名的识别与验证、用户口令的识别与验证、用户账号的默认限制检查。三个步骤中只要任何一个未通过校验，该用户便不能进入该网络。可以说，对网络用户的用户名和口令进行验证是防止非法访问的第一道防线。但由于用户名口令验证方式容易被攻破，目前很多网络都开始采用基于数字证书的验证方式。</p>
<p>网络权限控制是针对网络非法操作所提出的一种安全保护措施。能够访问网络的合法用户被划分为不同的用户组，用户和用户组被赋予一定的权限。访问控制机制明确了用户和用户组可以访问哪些目录、子目录、文件和其他资源；以及指定用户对这些文件、目录、设备能够执行哪些操作。它有两种实现方式，“受托者指派”和“继承权限屏蔽”。“受托者指派”控制用户和用户组如何使用网络服务器的目录、文件和设备；“继承权限屏蔽”相当于一个过滤器，可以限制子目录从父目录那里继承哪些权限。可以根据访问权限将用户分为以下几类：特殊用户（即系统管理员）；一般用户，系统管理员根据他们的实际需要为他们分配操作权限；审计用户，负责网络的安全控制与资源使用情况的审计。用户对网络资源的访问权限可以用访问控制表来描述。</p>
<p>目录级安全控制是针对用户设置的访问控制，控制用户对目录、文件、设备的访问。用户在目录一级指定的权限对所有文件和子目录有效，用户还可以进一步指定对目录下的子目录和文件的权限。对目录和文件的访问权限一般有8种：系统管理员权限、读权限、写权限、创建权限、删除权限、修改权限、文件查找权限和访问控制权限。8种访问权限的有效组合可以让用户有效地完成工作，同时又能有效地控制用户对服务器资源的访问，从而加强了网络和服务器的安全性。</p>
<p>属性安全控制在权限安全控制的基础上提供更进一步的安全性。当用户访问文件、目录和网络设备时，网络系统管理员应该给出文件、目录的访问属性，网络上的资源都应预先标出安全属性，用户对网络资源的访问权限对应一张访问控制表，用以表明用户对网络资源的访问能力。属性设置可以覆盖已经指定的任何受托者指派和有效权限。属性能够控制以下几个方面的权限：向某个文件写数据、复制文件、删除目录或文件、查看目录和文件、执行文件、隐含文件、共享、系统属性等，避免发生非法访问的现象。</p>
<p>因为网络允许用户在服务器控制台上执行一系列操作，所以用户使用控制台就可以执行装载和卸载模块、安装和删除软件等操作，这就需要网络服务器有安全控制。网络服务器的安全控制包括可以设置口令锁定服务器控制台，从而防止非法用户修改、删除重要信息或破坏数据。具体包括设定服务器登录时间限制、非法访问者检测和关闭的时间间隔等。</p>
<p>11.1.5　安全协议</p>
<p>1．IPSec协议简述</p>
<p>为了满足Internet的安全需求，因特网工程任务组（IETF）于1998年11月颁布IP层安全标准IP SECURITY协议（IPSec），IPSec在IP层上对数据包进行高强度的安全处理提供数据源验证、无连接数据完整性、数据机密性、抗重播和有限通信流机密性等安全服务。</p>
<p>1）IPSec协议工作原理</p>
<p>IPSec通过使用两种通信安全协议来为数据报提供高质量的安全性：认证头（AH）协议和封装安全载荷（ESP）协议，以及像Internet密钥交换（Internet Key Exchange, IKE）协议这样的密钥管理过程和协议。其中AH协议提供数据源认证、无连接的完整性以及一个可选的抗重放服务。ESP协议提供数据保密性、有限的数据流保密性、数据源验证、无连接的完整性以及抗重放服务。IPSec允许系统或网络用户控制安全服务提供的粒度。IPSec的安全服务是由通信双方建立的安全关联（Security Association, SA）来提供的，SA为通信提供了安全协议、模式、算法和应用于单向IP流的密钥等安全信息。每一个IPSec节点包含一个局部的安全策略库（Security Polioy Database, SPD），系统在处理输入、输出IP流时必须参考该策略库，并根据从SPD中提取的策略对IP流进行不同的处理：拒绝、绕过、进行IPSec保护。如果策略决定IP流需要经过IPSec处理，则根据SPD与SAD的对应关系，找到相应的SA，并对IP包进行指定的IPSec处理。SA由一个三元组唯一地标识，该三元组包含一个安全参数索引（Security Parameter Index, SPI），一个用于输出处理SA的目的IP地址或者一个用于输入处理SA的源IP地址以及一个特定的协议（例如AH或者ESP）。SPI是为了唯一标识SA而生成的一个32位整数。它在AH和ESP头中传输，IPSec数据报的接收方易于识别SPI并利用它连同源或者目的IP地址和协议来搜索SAD，以确定与该数据报相关联的SA或者SA束。SA中所选用的安全协议、SA模式、SA的两端及安全协议内所要求的服务等具体地决定了怎样为通信流提供安全服务。但是，最终安全服务的具体实施是通过使用AH和ESP协议。</p>
<p>2）IPSec协议实现模式</p>
<p>IPSec协议既可用来保护一个完整的IP载荷，也可用来保护某个IP载荷的上层协议。这两方面的保护分别由IPSec的两种不同“模式”来提供，如图11-4所示。</p>
<details><summary>图11-4　IPSec数据报结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904084355.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904084355.png';" /></details>

<p>其中，传输模式用来保护上层协议，而隧道模式用来保护整个IP数据报。在传输模式中，IP头与上层协议头之间需插入一个特殊的IPSec头：而在隧道模式中，要保护的整个IP包都需封装到另一个IP数据包里，同时在外部与内部IP头之间插入一个IPSec头。两种IPSec协议（AH和ESP）均能同时以传输模式或隧道模式工作。由构建方法所决定，对传输模式所保护的数据包而言，其通信终点必须是一个加密的终点。在后一种情况下，通信终点便是由受保护的内部头指定的地点，而加密终点则是那些由外部IP头指定的地点。在IPSec处理结束的时候，安全网关会剥离出内部IP包，再将那个包转发到它最终的目的地。</p>
<p>3）IPsec协议安全性分析</p>
<p>IPSec的安全性可以归纳为如下方面。</p>
<p>（1）当IPSec在路由器或防火墙中实现时，它提供很强的安全保证，可以应用于所有跨越网络边界的通信。一个实体内部的通信量不会引起与安全处理相关的开销。</p>
<p>（2）如果所有来自外部的通信必须使用IP，且防火墙是Internet与组织的唯一入口，则IPSec是不能被绕过的。</p>
<p>（3）IPSec位于传输层（TCP、UDP）之下，因此对应用程序是透明的。当IPSec在防火墙或是路由器上实现时，没有必要在用户或是服务器上更改软件。即使IPSec在末端系统、更高层软件（包括应用程序）上运行，也不会受到影响。</p>
<p>（4）IPSec对最终用户是透明的。没有必要培训用户掌握安全机制，也没有必要基于每个用户来发行关键资料，在用户离开组织时再撤回关键资料。</p>
<p>如果需要，IPSec可以为单个用户提供安全保证。这适用于站点外的工作人员，并适用于在组织内设置保密的专用子网，以用于敏感的应用程序。</p>
<h5 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h5><p>SSL协议（Secure Socket Layer）是Natscape推出的一种网络安全协议，是在传输过程通信协议（TCP/IP）上实现的一种安全协议。在SSL中，采用了公开密钥和私有密钥两种加密方式，它对计算机之间的整个会话进行加密。SSL的安全服务位于TCP和应用层之间，可为应用层，如HTTP、FPT、SMTP提供安全业务，服务对象主要是Web应用，即客户浏览器和服务器。它的基本目标是在通信双方之间建立安全的连接，可运行在任何可靠的通信协议之上、应用层协议之下。</p>
<p>1）SSL协议工作原理</p>
<p>在SSL中，所有数据被封装在记录中，记录层把从上层获得的数据分成可管理的块、可选的压缩数据、应用MAC（Message Authentication Code）、加密、增加SSL首部、在TCP报文段中传输结果单元。被接收的数据被解密、验证、解压和重新装配，然后交付给更高级的用户。SSL中两个重要的概念是SSL连接和SSL会话。</p>
<p>连接是提供恰当类型服务的传输。对于SSL，这样的连接是点到点的关系。连接是短暂的，每个连接与一个会话相联系。连接状态由服务器和客户的随机数、服务器写MAC密码、客户写MAC密码、服务器写密钥、客户写密钥、初始化向量、序号等参数来定义。</p>
<p>SSL的会话是客户和服务器之间的关联，会话通过握手协议来创建。会话定义了加密安全参数的一个集合，该集合可以被多个连接所共享。会话可以用来避免为每个连接进行昂贵的新安全参数的协商。每个会话由会话标识符、对方的证书、压缩方法、密文规约、主密钥和可重用标志等参数来定义。</p>
<p>2）SSL协议工作过程</p>
<p>SSL客户和服务器首次开始通信时，它们就协议版本、加密算法、是否验证及密钥等进行协商，这一过程由握手协议完成。握手过程结束后，客户端与服务器端开始交换应用层数据。握手协商过程主要包括以下几个阶段：</p>
<p>（1）建立安全能力</p>
<p>（2）服务器身份验证和密钥交换</p>
<p>（3）客户机验证和密钥交换</p>
<p>（4）完成</p>
<p>该阶段完成安全连接的建立。</p>
<p>3）SSL协议安全性分析</p>
<p>（1）防止窃听及中间人攻击。</p>
<p>（2）防止剪贴攻击。</p>
<p>（3）防止重放攻击及短包攻击。</p>
<h5 id="PGP协议"><a href="#PGP协议" class="headerlink" title="PGP协议"></a>PGP协议</h5><p>PGP（Pretty Good Privacy）是由Hil Zimmermann提出的方案，是针对电子邮件在Internet上通信的安全问题而设计的一种混合加密系统。PGP包含4个密码单元，即单钥密码（IDEA）、双钥密码（RSA）、单向杂凑算法（MD-5）和一个随机数生成算法。该协议规定公钥密码和分组密码是在同一个系统中。PGP的用户拥有一张公钥列表，列出了所需要通信的用户及其公钥。PGP应用程序具有很多优点，如速度快、效率高，同时具有很好的可移植性。</p>
<p>2）PGP协议的加密过程</p>
<p>PGP的加密过程是：先根据一些随机的环境数据（例如键盘的敲击间隔）产生一个密钥，用IDEA算法对明文加密。接着用接收者的RSA公钥对这个IDEA密钥进行加密，然后把这两种加密的结果作为密文发送出去。接收方接到密文后，先用自己的RSA私钥解密得到IDEA密钥，再用这个IDEA密钥对密文进行解密。也就是说，PGP没有用RSA算法直接对明文加密，而是对IDEA密钥进行加密。</p>
<p>对于数字签名，PGP先根据明文的内容利用Hash函数（散列算法）计算出一个128位的摘要，这个摘要就像是明文的一个精华，明文中任何改变都会导致这个精华的改变，并且从这个精华无法推导出明文的内容。发送者用自己的私钥对这个精华进行签名。因此在邮件传送过程中，任何对明文内容的改变都会导致摘要内容与签名的摘要内容不相符，以至签名的内容无效。由于IDEA算法的速度很快，所以不会因为邮件的数据量大而耽误时间；而IDEA的密钥位数较少，所以对它使用RSA算法在速度上也不会有太大影响。又因为IDEA的密码是以RSA加密的形式传送的，使得PGP既避免了IDEA的密钥管理缺陷，又避免了RSA的大量运算。 $\color{green}{\text{PGP}}$ 的这些优点使其在 $\color{green}{\text{邮件发送领域}}$ 具有广泛的应用。</p>
<p>使用PGP传递公钥的过程如下：假设用户A拥有用户B和用户C的公钥，用户B只拥有用户A的公钥，用户C也只拥有用户A的公钥。因为用户A和用户B、用户A和用户C都拥有对方的公钥，所以他们之间可以安全通信。但是用户B和用户C是不能直接通信的。用户B和用户C都知道用户A拥有对方的公钥，如果他们都同时信任用户A，可以从用户A处获得对方的公钥。即用户A利用自己的私钥分别对用户B和用户C的公钥签名，然后分别发给用户B和用户C，这样用户B和用户C就可以安全通信了。这是一个比较简单的情况，如果用户B和用户C要经过多个用户才能获得对方的公钥，这就给用户B和用户C的正常通信带来了麻烦。同时，安全也会随着链式信任网的扩大而急速下降。</p>
<h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><h5 id="备份的类型"><a href="#备份的类型" class="headerlink" title="备份的类型"></a>备份的类型</h5><p>随着计算机的日益普及以及信息技术的飞速发展，人们已经逐渐认识到信息安全的重要性。但是作为信息安全的重要成员——数据备份却常常被人们遗忘，这样导致的后果就是大量的有用信息被丢失，造成的后果有时是毁灭性的。</p>
<p>导致数据被破坏、丢失的原因很多，如硬盘的损坏、病毒的侵入等。而作为一名合格的系统管理员，关键要做到的就是保证数据的完整性以及准确性。如何才能真正做到这一点呢，这是一项非常艰巨但又非常重要的工作。一般情况下，采取的措施包括安装防火墙、杀毒软件等。但是，事情总不像人们想象的那么完美，数据的安全性和准确性一直都面临着极大的考验。因此，数据备份就显得十分有必要，同时它也是防止“主动攻击”的最重要一道防线。</p>
<p>数据备份包括以下几种类型，在不同的情况下，应该根据具体情况，选出最合适的方法。</p>
<p>（1）完全备份。是指备份全部选中的文件夹，并不依赖文件的存档属性来确定备份哪些文件（在备份过程中，任何现有的标记都被清除，每个文件都被标记为已备份。换言之，即清除存档属性）。完全备份的特点是备份所需时间最长，但恢复时间最短，操作最方便可靠。</p>
<p>（2）差异备份。也称差分备份，它是针对完全备份的，即备份上一次的完全备份后发生变化的所有文件。换句话说，没有发生变化的就不需要备份（差异备份过程中，只备份有标记的那些选中的文件和文件夹。它不清除标记，即备份后不标记为已备份文件。换言之，不清除存档属性）。差异备份的特点是备份时间较长，占用空间较多，但恢复时间较短。</p>
<p>（3）增量备份。是针对上一次备份（无论是哪种备份，这也是与差分备份不同的），即上一次备份后，所有发生变化的文件（增量备份过程中，只备份有标记的选中的文件和文件夹，它清除标记，即备份后标记文件。换言之，清除存档属性）。增量备份的特点是备份时间较短，占用空间较少，但恢复时间较长。</p>
<p>（4）按需备份。也就是说，它是根据需要有选择地进行数据备份。很明显，它的特点就是有很好的选择性。</p>
<h5 id="异地备份"><a href="#异地备份" class="headerlink" title="异地备份"></a>异地备份</h5><p>数据异地备份是容灾系统的核心技术，它不同于上述介绍的备份方法，它的特点是具有异地性。它对于保证数据的一致性、可靠性及系统的可扩展性具有举足轻重的作用，通过有效的数据复制，实现远程的业务数据与本地业务数据的同步，确保一旦本地系统出现故障，远程的容灾中心能够迅速进行完整的业务接管。</p>
<p>异地备份在金融业中有着典型的应用，它为保证金融业的正常运行做出了巨大的贡献。在“9.11”期间，美国的金融业虽然遭受了巨大的损失，但是还能够正常运行，为什么这么巨大的灾难也没有给美国金融业带来致命的打击呢？就是因为他们对数据的异地备份做得非常好，才没有导致金融业的全面崩溃。</p>
<p>在进行异地备份时，要注意以下几个问题。</p>
<p>（1）在进行异地备份前，要集中精力进行杀毒查毒工作，避免让备份带上病毒。</p>
<p>（2）对于软盘，要保证磁片质量，非常有必要定期对其进行质量检查。</p>
<p>（3）对于CD-RW光盘，它的一个最大的缺点就是兼容性不好，因此最好就是由哪台刻录机刻录的盘片，就在哪台刻录机上继续刻录、改写等操作。</p>
<p>（4）对于移动硬盘，要做磁盘检查，保证其性能良好。</p>
<h5 id="自动备份软件"><a href="#自动备份软件" class="headerlink" title="自动备份软件"></a>自动备份软件</h5><p>随着人们对数据备份意识的逐渐增强，各种自动备份软件也应运而生，给我们提供了很多数据备份的选择方案，下面主要介绍几种。</p>
<p>1）自动备份精灵</p>
<p>自动备份精灵是为方便我们的备份工作而特别设计开发的软件，其最大的优点是支持网络自动备份和本机自动备份。一方面，自动备份精灵可以帮助我们定时备份数据，可以设置关机备份数据，也可以手动备份。另一方面，它也允许我们自由地选择需要备份文件的源路径和目的路径，可以查看备份日志等。</p>
<p>2）利用GHOST实现自动备份</p>
<p>Ghost是最著名的硬盘复制备份工具，因为它可以将一个硬盘中的数据完全相同地复制到另一个硬盘中，因此大家就将Ghost这个软件称为“硬盘克隆”。Ghost不但有硬盘到硬盘的克隆功能，还有硬盘分区、硬盘备份、系统安装、网络安装和升级系统等功能。1998年6月，出品Ghost的Binary公司被著名的Symantec公司并购，因此该软件的后续版本就改称为Norton Ghost，成为Norton系列工具软件中的一员。</p>
<p>3）使用DiskWin实现自动备份</p>
<p>DiskWin主要是针对企业的备份软件。它很好地解决了企业数据备份问题。将所有员工机的文件自动备份到服务器；管理员定义每一员工机强制备份的工作文件类型和备份时间。可规定公司不同的部门备份不同的文件类型，如公司销售部备份Word文件和电子邮件，公司软件开发部备份程序代码文件，设计部备份PhotoShop设计图片等；全盘搜索每一员工机变化的文件，保证每天新增或者变化的工作文件一个不多，一个不少，全部压缩打包，自动上传到服务器。具备多个备份的文件无论怎样重命名都只备份一个；客户端可以设置隐藏运行，无论是搜索文件还是上传备份可以不出现任何提示，对员工正常工作无任何干扰，就好像这个软件根本不存在一样。</p>
<h5 id="几种新型的备份解决方案"><a href="#几种新型的备份解决方案" class="headerlink" title="几种新型的备份解决方案"></a>几种新型的备份解决方案</h5><p>对重要数据进行备份，就是为了在发生意外时能够及时进行恢复，使损失降低到最低。但是，如果备份文件存放不好，或者是备份策略不恰当，所付出的努力将付之东流。为了避免发生这种情况，我们就应该采取正确的备份方案。</p>
<p>一个优秀的备份解决方案应该做到以下几点。</p>
<p>（1）最大限度地降低对应用数据流量的影响，从而保证通信性能。</p>
<p>（2）最大限度地降低服务器的负载，保证服务器的性能；</p>
<p>（3）优化备份资源的使用，包括服务器、驱动器等。</p>
<p>在现代化的企业环境中，随着应用系统负载的增加，服务器的数量也在增加。但是由于磁带设备的分散特性，并且它们相互独立、不能执行全局统一的备份策略；需要的磁带机数量与应用服务器的数量成正比，所以要花费很高的维护成本。</p>
<p>下面介绍几种新型的备份解决方案。</p>
<p>1）网络备份模式</p>
<p>网络备份模式的原理是把一个磁带设备放置在LAN上，供多个服务器共享。由于网络设备模式对磁带进行统一的调度和使用，因此可以提高磁带的利用率和可管理性。需要管理的磁带驱动器的大幅度减少有助于降低成本，网络备份是一种非常好的企业备份模式。</p>
<p>如果普通备份的时间比较长，则可以安装一套独立的局域网，并在每套要备份的系统中连接一网卡，从而可以使备份数据与生产数据相互独立，互不影响。</p>
<p>在一个典型的基于LAN的备份模式中，生产数据和备份数据都是通过相同的LAN进行传输，这样需要备份的海量数据就会增加LAN上的流量，导致应用性能的降低。备份通常是在下班的时间进行，这样可以最大限度地减少对生产流量的影响。然而不断增长的数据量会导致备份时间的延长，而且随着企业业务的全球化，对系统的正常运行的要求也越来越高，可以用来备份的时间也越来越短。</p>
<p>为了在一个共同的LAN中消除这些潜在的冲突，可以将应用和备份隔离开来，这就是利用存储网络的方法。</p>
<p>另外，备份需要增加服务器的操作。服务器通常忙于处理大量对延迟和性能非常敏感的数据，数据的移动和调度需要占用额外的CPU周期，而进行备份通常会对应用本身的性能造成很大的影响，因此可以采用SCSI扩展复制命令的备份方法加以解决。</p>
<p>2）用存储网络备份</p>
<p>这个方案是让每个应用服务器都可以通过一个专用的存储网络，直接将数据备份到某个磁带设备，而不需要经过专门的备份服务器。利用通用的共享存储设备，每个应用服务器都可以充当一个介质服务器，因为它们可以直接将数据发送到磁带。每个服务器确定一个专门的磁带驱动器，并在备份过程中独自占有该磁带驱动器。用户还可以利用对磁带库中磁带驱动器的专有访问权限对应用服务器进行配置，而不是使用共享过程。</p>
<p>经过存储网络传输的数据可以隔离备份数据和应用数据，从而减少LAN上的流量。一个磁带也可以被多个应用共享，并且可以将多个备份流量合并到所管理的磁带库和驱动器中。此时，LAN仍可以用于在备份的服务器和客户端之间传输元数据和跟踪数据备份的状态，但是实际的备份数据将通过存储网络传输。利用网络存储备份可以隔离应用数据和备份数据，但是不能减轻服务器的CPU负载，因为它们仍然需要从磁带读取备份数据。</p>
<p>3）磁带和磁带之间直接传输数据的备份</p>
<p>为了减轻服务器在备份时的CPU负载，需要在数据不经过服务器本身的情况下，将备份数据从磁盘发送到磁带，这是通过在磁盘和磁带之间直接传输数据的机制（即SCSI扩展复制命令的方法）来实现的。在这种方式中，执行SCSI扩展复制命令的组件可能位于存储网络的交换阵列或者是服务器软件中，数据的副本会智能地从磁盘发送到磁带，而不需要经过服务器。复制并传输所要备份的数据对服务器CPU的负载影响非常小，这是因为服务器并不需要参与备份数据的任何具体操作，可以大大地减轻服务器的负担，保证服务器的性能不会受到备份的影响。</p>
<h4 id="计算机病毒与免疫"><a href="#计算机病毒与免疫" class="headerlink" title="计算机病毒与免疫"></a>计算机病毒与免疫</h4><h5 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h5><p>从计算机病毒刚诞生之际，它就给人们带来了麻烦，随着网络的发展，其破坏力越来越强，计算机病毒已成为危害个人系统及网络安全的一大隐患，正如生物学上的病毒能够使我们生病一样，计算机病毒会破坏计算机的正常工作。计算机病毒的一些典型破坏包括影响用户的工作（如妨碍鼠标、键盘的操作，间隔性地在用户的屏幕上显示一段文字或播放一段音乐），破坏用户系统上的一些程序（如使得Microsoft Word不能正常运行），大量占用系统的资源，使系统无法正常工作（蠕虫病毒的典型做法），破坏用户的数据（如删除用户的文件，格式化硬盘），有时也会破坏系统的硬件。</p>
<p>1）计算机病毒的定义</p>
<p>提到病毒，人们通常就会想到一些恶意的、时常破坏机器上的程序、数据的小程序。但如何给病毒下一个科学的、精确的定义呢？病毒的定义最早由F.B.Cohen于1984年提出，在他的经典文章Computer Viruses-Theory and Experiments（计算机病毒一理论与实践）中，描述如下：</p>
<p>“计算机病毒是这样的一种程序，它通过修改其他程序使之含有该程序本身或它的一个变体。病毒具有感染力，它可借助其使用者的权限感染他们的程序，在一个计算机系统中或网络中得以繁殖、传播。每个被感染的程序也像病毒一样可以感染其他程序，从而使更多的程序受到感染。”</p>
<p>2）病毒的基本特征</p>
<p>●　感染性</p>
<p>●　潜伏性</p>
<p>●　可触发性</p>
<p>●　破坏性</p>
<p>●　人为性</p>
<p>●　衍生性</p>
<p>3）计算机病毒的分类</p>
<p>分类的方式、角度是多种多样的，从病毒的工作机制角度主要分为以下5类。</p>
<p>●　引导区病毒（boot sector virus）</p>
<p>●　文件感染病毒（file infector virus）</p>
<p>●　宏病毒（Marco virus）</p>
<p>●　特洛伊木马（Trojan/Trojan Horse）</p>
<p>●　蠕虫病毒（Worm）</p>
<h5 id="计算机病毒免疫的原理"><a href="#计算机病毒免疫的原理" class="headerlink" title="计算机病毒免疫的原理"></a>计算机病毒免疫的原理</h5><p>我们知道，计算机病毒的传染模块一般包括传染条件判断和实施传染两个部分，在病毒被激活的状态下，病毒程序通过判断传染条件的满足与否，以决定是否对目标对象进行传染。一般情况下，病毒程序在传染完一个对象后，都要给被传染对象加上传染标识，传染条件的判断就是检测被攻击对象是否存在这种标识，若存在这种标识，则病毒程序不对该对象进行传染；若不存在这种标识，则病毒程序就对该对象实施传染。由于这种原因，人们自然会想到是否能在正常对象中加上这种标识，就可以不受病毒的传染，起到免疫的作用呢？</p>
<p>从实现计算机病毒免疫的角度看病毒的传染，可以将病毒的传染分成两种。第一种是像香港病毒、1575病毒这样，在传染前先检查待传染的扇区或程序里是否含有病毒代码，如果没有找到则进行传染，如果找到了则不再进行传染。这种用作判断是否为病毒自身的病毒代码被称作传染标志或免疫标志。第二种是在传染时不判断是否存在免疫标志，病毒只要找到一个可传染对象就进行一次传染。就像黑色星期五那样，一个文件可能被黑色星期五反复传染多次，滚雪球一样越滚越大（需要说明的是，黑色星期五病毒的程序中具有判别传染标志的代码，由于程序设计错误，使判断失败，形成现在的情况，对文件会反复感染，传染标志形同虚设）。</p>
<p>目前常用的免疫方法有如下两种。</p>
<p>1）针对某一种病毒进行的计算机病毒免疫</p>
<p>例如对小球病毒，在DOS引导扇区的1FCH处填上1357H，小球病毒一旦检查到这个标志就不再对它进行传染了。对于1575文件型病毒，免疫标志是文件尾的内容为0CH和OAH的两个字节，1575病毒若发现文件尾含有这两个字节，则不进行传染。这种方法的优点是可以有效地防止某一种特定病毒的传染。但缺点很严重，主要有以下几点。</p>
<p>（1）对于没有设感染标识的病毒不能达到免疫的目的。有的病毒只要在激活的状态下，会无条件的把病毒传染给被攻击对象，而不论这种对象是否已经被感染过或者是否具有某种标识。</p>
<p>（2）当出现这种病毒的变种不再使用这个免疫标志时或出现新病毒时，免疫标志发挥不了作用。</p>
<p>（3）某些病毒的免疫标志不容易仿制，非要加上这种标志不可，则对原来的文件要做大的改动。例如对大麻病毒就不容易做免疫标志。</p>
<p>（4）由于病毒的种类较多，又由于技术上的原因，不可能对一个对象加上各种病毒的免疫标识，这就使得该对象不能对所有的病毒具有免疫作用。</p>
<p>（5）这种方法能阻止传染，却不能阻止病毒的破坏行为，仍然放任病毒驻留在内存中。目前使用这种免疫方法的商品化反病毒软件已不多见了。</p>
<p>2）基于自我完整性检查的计算机病毒的免疫方法</p>
<p>目前这种方法只能用于文件而不能用于引导扇区。这种方法的原理是：为可执行程序增加一个免疫外壳，同时在免疫外壳中记录有关用于恢复自身的信息。免疫外壳占1～3KB。执行具有这种免疫功能的程序时，免疫外壳首先得到运行，检查自身的程序大小、校验生成日期和时间等情况，没有发现异常时才转去执行受保护的程序。</p>
<p>但是，它仍存在如下一些缺点和不足。</p>
<p>（1）每个受到保护的文件都要增加1～3KB，需要额外的存储空间。</p>
<p>（2）现在使用中的一些校验码算法不能满足防病毒的需要，被某些种类的病毒感染的文件不能被检查出来。</p>
<p>（3）无法对付覆盖方式的文件型病毒。</p>
<p>（4）有些类型的文件不能使用外加免疫外壳的防护方法，这样将使那些文件不能正常执行。</p>
<p>当某些尚不能被病毒检测软件检查出来的病毒感染了文件，而该文件又被免疫外壳包在里面时，这个病毒就像穿了“保护盔甲”，使查毒软件查不到它，而它却能在得到运行机会时跑出来继续传染扩散。</p>
<h3 id="信息安全管理和评估"><a href="#信息安全管理和评估" class="headerlink" title="信息安全管理和评估"></a>信息安全管理和评估</h3><h4 id="安全管理技术"><a href="#安全管理技术" class="headerlink" title="安全管理技术"></a>安全管理技术</h4><p>由于数据在网络上进行传输时，可能会存在各种攻击，因此，必须加强对网络安全的管理。概括性地说，安全管理技术就是监督、组织和控制网络通信服务以及信息处理所必需的各种技术手段和措施的总称。其目标是确保计算机网络的持续正常运行，并在计算机网络运行出现异常时能及时响应和排除故障。</p>
<h5 id="安全管理的发展现状"><a href="#安全管理的发展现状" class="headerlink" title="安全管理的发展现状"></a>安全管理的发展现状</h5><p>在20世纪90年代中后期，随着因特网的发展以及社会信息化程度越来越高，各种安全设备在网络中的应用也越来越多，市场上开始出现了独立的安全管理产品。</p>
<p>相对而言，国外计算机网络安全管理的需求多样，起步较早，已经形成了较大规模的市场，有一部分产品逐渐在市场上获得了用户的认可。近年来，国内厂商也开始推出网络安全管理产品，但一般受技术实力限制，大多是针对自己的安全设备开发的集中管理软件、安全审计系统等。</p>
<p>由于各种网络安全产品的作用体现在网络中的不同方面，统一的网络安全管理平台必然要求对网络中部署的安全设备进行协同管理，这是统一安全管理平台的最高追求目标。</p>
<h5 id="网络安全管理技术简介"><a href="#网络安全管理技术简介" class="headerlink" title="网络安全管理技术简介"></a>网络安全管理技术简介</h5><p>安全管理（Security Management, SM），不管是对于个人管理，还是对企业管理（Enterprise　Management），都是十分重要的。从信息管理的角度看，安全管理涉及到策略与规程、安全缺陷以及保护所需的资源、防火墙、密码加密问题、鉴别与授权、客户机/服务器认证系统、报文传输安全以及对病毒攻击的保护等。</p>
<p>实际上，安全管理不是一个简单的软件系统，它包括的内容非常多，主要涵盖了安全设备的管理、安全策略管理、安全风险控制和安全审计等几个方面。</p>
<p>（1）安全设备管理：是指对网络中所有的安全产品，如防火墙、VPN、防病毒、入侵检测（网络、主机）和漏洞扫描等产品实现统一管理、统一监控。</p>
<p>（2）安全策略管理：是指管理、保护及自动分发全局性的安全策略，包括对安全设备、操作系统及应用系统的安全策略的管理。</p>
<p>（3）安全分析控制：确定、控制并消除或缩减系统资源的不定事件的总过程，包括风险分析、选择、实现与测试、安全评估及所有的安全检查（含系统补丁程序检查）。</p>
<p>（4）安全审计：对网络中的安全设备、操作系统及应用系统的日志信息收集汇总，实现对这些信息的查询和统计；并通过对这些集中信息的进一步分析，可以得出更深层次的安全分析结果。</p>
<h5 id="安全管理主要解决以下问题"><a href="#安全管理主要解决以下问题" class="headerlink" title="安全管理主要解决以下问题"></a>安全管理主要解决以下问题</h5><p>1）集中化的安全策略管理（Centralized Security Policy Management, CSPM）</p>
<p>企业的安全保障需要自上而下地制定安全策略，这些安全策略会被传送并装配到不同的执行点（Enforcement Point）中。</p>
<p>2）实时安全监视（Real-Time Security Awareness, RTSA）</p>
<p>企业用户实时了解企业网络内的安全状况。</p>
<p>3）安全联动机制（Contain Mechanism, CM）</p>
<p>安全设备之间需要具备有中心控制或无中心控制的安全联动机制，即当IDS发现在某网段有入侵动作时，它需要通知防火墙阻断此攻击。</p>
<p>4）配置与补丁管理（Configuration and Patching Management）</p>
<p>企业用户可以通过对已发现的安全缺陷快速反应，大大提高自己抵抗风险的能力。</p>
<p>5）统一的权限管理（Privilege Management across the Enterprise）</p>
<p>通过完善的权限管理和身份认证实现对网络资源使用的有效控制和审计。</p>
<h4 id="安全性规章"><a href="#安全性规章" class="headerlink" title="安全性规章"></a>安全性规章</h4><h5 id="信息系统安全制度"><a href="#信息系统安全制度" class="headerlink" title="信息系统安全制度"></a>信息系统安全制度</h5><p>一段时间以来，国际和国内一些著名网站被“黑”的事件引起了社会多方的关注。计算机信息系统的安全问题越来越受到重视，因为安全问题将影响到电子商务、国家信息甚至是国防等各个方面。针对大幅度上升的黑客攻击、病毒传播和有害信息传播等计算机违法犯罪活动，有关部门出台了一系列的信息系统安全法规与制度，从而进一步保证了信息系统的安全运行。</p>
<p>1）计算机信息系统安全保护等级划分标准</p>
<p>《计算机信息系统安全保护等级划分标准》规定，从2001年1月1日起对计算机信息系统安全保护实行等级划分，此举标志着我国计算机信息系统安全保护纳入了等级管理的轨道。</p>
<p>由公安部提出并组织制定、国家质量技术监督局发布的强制性国家标准《计算机信息系统安全保护等级划分准则》，将计算机信息系统的安全保护等级划分为用户自主保护级、系统审计保护级、安全标记保护级、结构化保护级和访问验证保护级5个级别。用户可以根据自己计算机信息系统的重要程度确定相应的安全保护级别，并针对相应级别进行建设。</p>
<p>实行安全等级保护制度后，公安机关能够通过规范、科学、公正的评定和监督管理，全面、及时地预防和发现计算机信息系统建设和使用中存在的安全风险和安全漏洞，有利于提高公安机关对计算机信息系统安全保护的监督管理水平。此外，实行这一制度还有利于提高信息安全产业化发展水平，为安全产品的普及使用提供广阔的市场和发展空间。</p>
<p>2）计算机信息安全保护条例</p>
<p>根据公安部的有关规定，计算机信息系统安全保护包括以下几个方面。</p>
<p>（1）实体安全：包括周围危险建筑与设施、监控系统、防火措施、防水措施、机房环境、防雷措施、备用电源、防静电措施、用电质量和防盗措施等。</p>
<p>（2）网络通信安全：包括通信设备的场所标志、重要的通信线路及通信控制装置备份、加密措施、网络运行状态安全审计跟踪措施、网络系统访问控制措施和工作站身份识别措施等。</p>
<p>（3）软件与信息安全：包括操作系统及数据库访问控制措施、应用软件、系统信息能防止恶意攻击和非法存取、数据库及系统状态监控、防护措施、用户身份识别措施、系统用户信息异地备份等。</p>
<p>（4）管理组织与制度安全：包括专门的安全防范组织和计算机安全员、健全的安全管理规章制度、详尽的工作手册和完整的工作记录、定期进行风险分析，制定灾难处理对策、建立安全培训制度、制定人员的安全管理制度等。</p>
<p>（5）安全技术措施：包括灾难恢复的技术措施、开发工作与业务工作分离的措施、应用业务、系统安全审计功能、系统操作日志、服务器备份措施、计算机防病毒措施等。</p>
<h5 id="计算机防毒制度"><a href="#计算机防毒制度" class="headerlink" title="计算机防毒制度"></a>计算机防毒制度</h5><p>为了加强计算机病毒的防治管理工作，2000年公安部发布了《计算机病毒防治管理办法》，规定各级公安机关负责本行政区域内的计算机病毒防治管理工作。</p>
<p>规定禁止制作、传播计算机病毒，向社会发布虚假计算机病毒疫情，承担计算机病毒的认定工作的机构应由公安部公共信息网络安全监察部门批准，计算机信息系统的使用单位应当履行防治计算机病毒的职责。</p>
<h3 id="信息安全保障体系"><a href="#信息安全保障体系" class="headerlink" title="信息安全保障体系"></a>信息安全保障体系</h3><p>对一个信息网络，必须从总体上规划，建立一个科学全面的信息安全保障体系，从而实现信息系统的整体安全。一个全面的信息安全保障体系，应该能够解决信息系统存在的大部分安全威胁。目前的信息安全威胁主要有：针对系统稳定性和可靠性的破坏行为，包括从外部网络针对内部网络的攻击入侵行为和病毒破坏等；大量信息设备的使用、维护和管理问题，包括违反规定的计算机、打印机和其他信息基础设施的滥用，以及信息系统违规使用软件和硬件的行为；知识产权和内部机密材料等有价值信息存储、使用和传输的保密性、完整性和可靠性存在可能的威胁，其中尤其以信息的保密性存在威胁的可能性最大。</p>
<p>针对这些复杂且技术手段各异的信息安全威胁，要建立一个完整的信息安全保障体系，包含以下几个方面的内容。</p>
<p>1）建立统一的身份认证体系</p>
<p>身份认证是信息交换最基础的要素，如果不能确认交换双方的实体身份，那么信息的安全就根本无从得到保证。身份认证的含义是广泛的，其泛指一切实体的身份，包括人、计算机、设备和应用程序等，只有确认了所有这些信息在存储、使用和传输中可能涉及的实体，信息的安全性才有可能得到基本保证。</p>
<p>2）建立统一的信息安全管理体系</p>
<p>建立对所有信息实体有效的信息安全管理体系，对信息网络系统中的所有计算机、输出端口、存储设备、网络、应用程序和其他设备进行有效集中的管理，从而有效管理和控制信息网络中存在的安全风险。信息安全管理体系的建立主要集中在技术性系统的建立上，同时，也应该建立相应的管理制度，才能使信息安全管理系统得到有效实施。</p>
<p>3）建立规范的信息安全保密体系</p>
<p>信息的保密性是一个大型信息应用网络不可缺少的需求，所以，必须建立符合规范的信息安全保密体系。这个体系不仅仅应该提供完善的技术解决方案，也应该建立相应的信息保密管理制度。</p>
<p>4）建立完善的网络边界防护体系</p>
<p>重要的信息网络一般会跟公共的互联网进行一定程度的分离，在内部信息网络和互联网之间存在一个网络边界。必须建立完善的网络边界防护体系，使得内部网络既能够与外部网络进行信息交流，同时也能防止从外网发起的对内部网络的攻击等安全威胁。</p>
<p>此外，要加快信息安全立法，建立信息安全法制体系，这样才能做到有法可依、有法必依。建立国家信息安全组织管理体系，加强国家信息安全机构及职能；建立高效能的、职责分工明确的行政管理和业务组织体系；建立信息安全标准和评估体系；建立国家信息安全技术保障体系，使用科学技术实施安全的防护保障。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><h4 id="信息系统安全属性"><a href="#信息系统安全属性" class="headerlink" title="信息系统安全属性"></a>信息系统安全属性</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231922.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231922.png';" /></details>

<p>不可抵赖性：数字签名</p>
<h4 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h4><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906232249.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906232249.png';" /></details>

<p>rar加密是对称加密，解密输入的密码和加密的密码一致</p>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906232302.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906232302.png';" /></details>

<p>加密速度慢，适合小数据</p>
<h4 id="信息摘要"><a href="#信息摘要" class="headerlink" title="信息摘要"></a>信息摘要</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906232904.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906232904.png';" /></details>

<p>原始信息发生变化，摘要也会发生变化</p>
<p>使用单向散列函数</p>
<h4 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906233235.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906233235.png';" /></details>

<p>用A的私钥加密，叫数字签名，A的公钥解密叫做验证过程</p>
<p>数字签名+信息摘要结合起来使用</p>
<h4 id="数字证书与PGP"><a href="#数字证书与PGP" class="headerlink" title="数字证书与PGP"></a>数字证书与PGP</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906233527.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906233527.png';" /></details> 

<p>传公钥的时候被截获</p>
<h4 id="设计邮件加密系统"><a href="#设计邮件加密系统" class="headerlink" title="设计邮件加密系统"></a>设计邮件加密系统</h4><p>要求邮件以加密方式传输，邮件最大附件内容可达50OMB，发送者不可抵赖，若邮件被第三方截获,第三方无法篡改。</p>
<p>信息摘要+数字签名+数据证书</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907083954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907083954.png';" /></details>

<h4 id="PKI公钥体系"><a href="#PKI公钥体系" class="headerlink" title="PKI公钥体系"></a>PKI公钥体系</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084024.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084024.png';" /></details>

<p>基于非对称，类似数字证书</p>
<ul>
<li>证书颁发机构（CA, Certificate Authority）</li>
</ul>
<h4 id="PKI公钥系分层情况"><a href="#PKI公钥系分层情况" class="headerlink" title="PKI公钥系分层情况"></a>PKI公钥系分层情况</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084245.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084245.png';" /></details>

<ul>
<li>密匙管理中心，（kmc，key management center）</li>
<li>公钥基础设施 （pki，Public Key Infrastructure ）</li>
<li>注册机构（RA，register Authority）</li>
</ul>
<h4 id="信息系统安全保证层次"><a href="#信息系统安全保证层次" class="headerlink" title="信息系统安全保证层次"></a>信息系统安全保证层次</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084347.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084347.png';" /></details>

<p>访问控制：权限这一层</p>
<p>强制访问控制：分层</p>
<p>基于任务的访问控制:OA</p>
<h4 id="安全审核与安全系统设计原则"><a href="#安全审核与安全系统设计原则" class="headerlink" title="安全审核与安全系统设计原则"></a>安全审核与安全系统设计原则</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084752.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084752.png';" /></details>

<p>安全审计:从日志了解</p>
<h4 id="各个网络层次的安全保障"><a href="#各个网络层次的安全保障" class="headerlink" title="各个网络层次的安全保障"></a>各个网络层次的安全保障</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907084954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907084954.png';" /></details>

<h4 id="网络威胁与共计"><a href="#网络威胁与共计" class="headerlink" title="网络威胁与共计"></a>网络威胁与共计</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907085356.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907085356.png';" /></details>

<p>业务流分析：跟窃听比有分析的成分</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907085530.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907085530.png';" /></details>


<h4 id="DOS和DDOS共计"><a href="#DOS和DDOS共计" class="headerlink" title="DOS和DDOS共计"></a>DOS和DDOS共计</h4><p>破坏可用性</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907085934.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907085934.png';" /></details>


<h4 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090013.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090013.png';" /></details>


<h4 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090340.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090340.png';" /></details>

<h4 id="计算机病毒与木马"><a href="#计算机病毒与木马" class="headerlink" title="计算机病毒与木马"></a>计算机病毒与木马</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907090736.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907090736.png';" /></details>



<h4 id="法律法规知识-保护年限"><a href="#法律法规知识-保护年限" class="headerlink" title="法律法规知识(保护年限)"></a>法律法规知识(保护年限)</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907143758.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907143758.png';" /></details>

<h4 id="法律法规知识-知识产权人确定"><a href="#法律法规知识-知识产权人确定" class="headerlink" title="法律法规知识(知识产权人确定)"></a>法律法规知识(知识产权人确定)</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144046.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144046.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144247.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144247.png';" /></details>

<h4 id="侵权判定"><a href="#侵权判定" class="headerlink" title="侵权判定"></a>侵权判定</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144431.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144431.png';" /></details>


<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144610.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144610.png';" /></details>


<h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144854.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144854.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210907144915.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210907144915.png';" /></details>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch10-%E6%9E%84%E5%BB%BA%E5%B9%B3%E5%8F%B0%E4%B8%8E%E5%85%B8%E5%9E%8B%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch10-%E6%9E%84%E5%BB%BA%E5%B9%B3%E5%8F%B0%E4%B8%8E%E5%85%B8%E5%9E%8B%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch10-构建平台与典型架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:55:07" itemprop="dateCreated datePublished" datetime="2021-07-19T12:55:07+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-19 15:35:43" itemprop="dateModified" datetime="2021-09-19T15:35:43+08:00">2021-09-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="构件平台与典型架构"><a href="#构件平台与典型架构" class="headerlink" title="构件平台与典型架构"></a>构件平台与典型架构</h2><p>几乎没有构件能独立的部署，它们大多数依赖于特定的基础设施平台。由于行业高度竞争，公用构建基础设施目前只有CORBA+Java和Microsoft COM+CLR两大阵营。尽管只有两大阵营，SOA技术也飞速发展，不同平台构件连接能力有了一定改善，但在设计、管理、规范等方面存在很大差异。因此，我们有必要了解这些平台特点和差异，为应用开发选择合适的构件开发平台。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wssiqi/article/details/49689447">Corba 学习笔记 (一)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/eunjungF/article/details/119306083">Corba执行过程</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wn084/article/details/80729230">JNDI</a></p>
</blockquote>
<h3 id="OMG方式"><a href="#OMG方式" class="headerlink" title="OMG方式"></a>OMG方式</h3><p>成立于1989年的对象管理组（OMG）是目前计算工业中最大的组织。作为一个非营利性组织，OMG旨在通过规范化对象开放市场的所有层次上的互操作性。至2002年，有近800成员加入OMG。</p>
<h4 id="对象请求代理"><a href="#对象请求代理" class="headerlink" title="对象请求代理"></a>对象请求代理</h4><p>CORBA的主要目标就是使不同语言、不同实现和不同平台间能进行交互。因此，OMG从没有停步在“二进制”标准上（可配置、可执行级的标准），而是保证每个细节都被标准化，使其能顾及不同的实现及CORBA兼容不同产品的独立供应商增值的需要。这一开放式方法的不利一面就是CORBA兼容产品不能在二进制级进行有效的互操作，只能以较高的代价在高层协议上协作。OMG的跨ORB（对象请求代理）协议——IIOP（Internet InterORB Protocol）互操作协议，在1995年7月的CORBA 2.0中被规范化。与ORB的互操作兼容则必须支持ⅡOP。在1996年7月的CORBA 2.0更新版本中，加入了一条关于相互作用的协议，该协议明确了基于CORBA的系统与基于微软COM系统之间的互操作细节。</p>
<p>CORBA包括三个基本部分：一套调用接口、对象请求代理（ORB）和一套对象适配器。面向对象操作的调用实现后期绑定。对象引用所指代的对象实现决定了被调用方法的最终实现。调用接口支持不同级别的后期绑定，同时编排调用参数，使ORB核心能定位接收对象，调用方法，以及传递参数。在接收端，一个对象适配器还原参数，调用接收对象相应的方法。图10-1简单地描述了基本的CORBA结构。</p>
<h4 id="公共对象服务规范"><a href="#公共对象服务规范" class="headerlink" title="公共对象服务规范"></a>公共对象服务规范</h4><p>现有的CORBA Service包含16种对象服务（CORBA服务），其中的通告服务是电信领域设施正式的组成部分。这些服务划分为两大类：一类服务应用于企业计算系统。这些系统往往将CORBA对象视为模块，并视CORBA为易用的通信中间件，此时的CORBA服务大多用来支持大规模的操作；另一类服务则应用于细粒度的对象操作，但目前这些服务的实用价值较差。CORBA 3.0中的持久状态服务（Persistent State Service, PSS）可能是一个例外，它替代了CORBA 2.0中的持久对象服务（POS）。PSS是CORBA构件模型的三个主要支撑服务之一，另两个是事务服务和通告服务。值得注意的是，大型基于CORBA系统往往只使用少量的CORBA服务，包括名字服务、安全服务、事务服务和交易服务。现有大部分ORB产品并不试图支持全部的CORBA服务也说明了这一点。</p>
<details><summary>图10-1　基于ORB系统的简化结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081201.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081201.png';" /></details>

<h5 id="支持企业分布式计算的服务"><a href="#支持企业分布式计算的服务" class="headerlink" title="支持企业分布式计算的服务"></a>支持企业分布式计算的服务</h5><p>许多大型企业系统只是将CORBA作为对象总线，依靠ORB与其他各种各样的系统进行互操作。名字服务是关键服务之一。</p>
<p>1）命名服务，交易器服务</p>
<p>每个对象内部都有唯一的标志符。命名服务则允许任意地给对象赋予一个名字，这个名字在其所属的命名语境中是唯一的。而命名语境所形成的层次结构，使得所有的名字形成名字树。</p>
<p>交易器服务允许给对象赋予一个复杂的描述，从而允许客户基于该描述来定位所需的对象。交易器通过交易语境来组织对象。客户则在指定的交易语境中根据对象描述的部分内容或关键字来搜寻对象，而搜寻结果往往是一个包含满足查询条件的一组对象的列表。OMG交易器服务规范同时被ISO（ISO/IEC 13235-1）和ITU（ITU-T推荐X.950）所采用。</p>
<p>2）事件服务，通告服务</p>
<p>事件服务允许定义那些从事件生产者被发送到事件消费者的事件对象。由于信息只能从生产者流向消费者，因而事件对象是不变的。事件必须通过事件通道传播，从而松散了生产者和消费者之间的耦合关系。事件可以具有类型（使用OMG IDL定义），而通道可以根据类型过滤事件。</p>
<p>事件通道支持“推”和“拉”两种方式的事件通告模型。在“推”模型中，事件生产者调用事件通道的“推”方法将事件上传给事件通道，事件通道进而调用所有注册的事件消费者的“推”方法将事件传给消费者。在“拉”模型中，事件消费者调用事件通道的“拉”方法，这将导致事件通道调用所有注册的事件生产者的“拉”方法，此时获得的新事件将返回给消费者。</p>
<p>1998年，通告服务为事件服务增加了几个重要的特征——服务质量（Quality of Service, QoS）规范和管理；标准的类型化和结构化事件；基于类型和QoS的动态事件过滤；作用于资源、通道、一组消费者或单个消费者的事件过滤；针对资源、通道和客户的事件发现。值得注意的是，通告服务本身并不是CORBA服务，而是电信领域工作组（Te1DTF）提交的CORBA设施。</p>
<p>3）对象事务服务</p>
<p>对象事务服务（Object Transaction Service, OTS）是建立分布式应用最重要的服务之一。OMG于1994年12月制定的OTS规范在大多数的ORB产品及若干J2EE服务器中得到支持。OTS实现必须支持平坦事务，而嵌套事务是可选的。遵循X/Open分布事务处理标准的其他事务服务可以与OTS集成。同样，多个异构ORB提供的事务也可集成。</p>
<p>在基于构件的系统中，嵌套事务似乎不可避免。因为一个构件的实现可能创建一个覆盖一系列操作的事务闭包，而这些事务属性无须在构件接口中声明。这种独立扩展性原则需要嵌套事务的支持。作为唯一的OTS实现必须支持的事务类型，平坦事务在构件系统中的价值有限。实际上，现有的主流事务中间件也不支持嵌套事务，这是它们共同的缺点。</p>
<p>OTS自动维护当前的事务语境，该语境将随请求在ORB系统中传递，也可传递给其他的非CORBA的事务系统。对于CORBA对象，事务语境可以传递给任何实现了Transactional Object的对象。当前的事务语境可从ORB获得，因此必须保证随时可用。事务操作，如begin, commit, rollback都在当前的语境中定义。</p>
<p>所有希望在一次事务中执行修改，或者需要执行事务控制的对象都必须向OTS协调器注册。该协调器可从当前语境中获得。一个资源可以指明它是否支持嵌套事务。任何资源都必须实现Resource接口，从而允许协调器执行两段提交协议（众所周知，两段提交协议在完全分布的环境下可能发生死锁，这只能通过特定的广播协议避免；三段提交协议能够避免死锁问题（Mullender, 1993），但开销太大。因此，OTS规定协调器在逻辑上必须是集中式的）。</p>
<p>OTS的设计目标之一是希望将事务控制作为一个独立的服务，但目前更普遍的是将事务和其他服务集成到应用服务器提供的语境或容器中。</p>
<p>4）安全服务</p>
<p>可靠的安全服务对于一个跨越多个相互信赖的组织的分布系统极为重要。安全服务必须得到普及。所有可互操作的ORB或可共同工作的系统必须协作，而这要求为所有的参与者建立统一的安全策略。</p>
<p>CORBA安全规范定义了一系列的服务，包括认证、安全通信、证书委托（也称为“替身”）及防抵赖等。目前仅有少数产品完全支持该规范，如BEA的WebLogic和IBM的WebSphere。很多产品仅仅依赖Netscape的安全套接字（Secure Socket Layer, SSL）实施安全保障，尤其采用独立ORB，而不是完全集成的应用服务器时。因为利用SSL可以很方便地实现简单的认证及安全的通信，但不能支持类似委托和防抵赖等较高级的安全机制。</p>
<p>5）支持细粒度对象互操作的服务</p>
<p>尽管有些服务，包括收集、外部化和查询服务，仍未被任何产品实现（原因很多，如查询服务的规范过于松散，收集服务的某些假设不切实际，本节仍将介绍余下的服务，以便读者对OMA涉及的对象服务有一个全面的认识。</p>
<p>6）并发控制服务</p>
<p>该服务支持对资源进行加锁和解锁。锁必须依赖于事务的语境或其他语境才能获得。依赖事务语境创建的锁将作为事务回滚的部分被释放。锁具有不同的模式，如读锁、写锁、升级锁。其中，读锁允许多个客户同时执行读操作；而写锁保证只有一个客户才能执行写操作；升级锁是可以升级为写锁的读锁，支持互斥的读操作。锁有多个锁集合。每个受保护的资源都拥有一个锁集合，该集合决定了可用的锁的种类及数量。一个锁集合的工厂接口支持创建新的锁集合。锁集合不是事务型就是非事务型的，并可与其他锁集合建立关联。锁协调器可以释放指定锁集合中所有的锁。</p>
<p>7）许可服务</p>
<p>组装构件的过程中需要获取所有非免费构件的使用许可。许可服务支持多种类型的许可模式。该服务定义了两个接口（抽象）——许可服务管理器和特定于厂商的许可服务。如果一个对象与一个许可协议绑定，那么它可以通过许可服务管理器检查其使用是否合法。</p>
<p>8）生命周期服务</p>
<p>这类服务支持创建、复制、移动和删除CORBA对象及其相关的对象组。下面将介绍如何利用关系服务提供的包含与引用关系来处理对象组。包含关系支持嵌套复制，即所有被包含的对象都会被复制。为了支持对象创建，生命周期服务支持注册与获取工厂对象。一旦获得所需的工厂对象，就能够用它来创建新的对象。</p>
<p>生命周期服务允许删除对象或对象组，但并不提示何时销毁该对象。这意味着分布式内存管理需要高层应用的参与，这被认为是CORBA较为明显的缺点。相比较而言，DCOM支持分布引用的计数，Java和CLR甚至支持基于租借的远程引用的分布式垃圾收集。</p>
<p>9）关系服务</p>
<p>关系服务指允许定义和维护对象之间的关系。不依赖语言级的指针或引用，该服务引入了一种关系模型，以支持在不影响相关对象的情况下创建对象间的关系。但是，关系服务基本上没有实际应用，甚至没有产品实现，极有可能被基于CCM的业务对象关系所取代。</p>
<p>10）持久状态服务</p>
<p>持久性是指对象在其创建程序终止后仍然存活。为此，CORBA 2.0制定了持久对象服务（POS），用来支持CORBA对象的持久性。尽管在1994年年初就被OMG标准化为关键服务，但直到1996年年中才出现一个beta版的实现。一些报告甚至指出该规范及其与其他对象服务的互操作存在严重的技术问题。另外，POS没有解决“正确性”的问题，尤其是它把存储的申请交给应用代码处理。POS规范最终在CORBA 3.0版本中被新的持久状态服务（PSS）所代替。</p>
<p>11）外部化服务</p>
<p>这项服务支持对象网和对象流之间的双向映射。对象网外部化后再内部化意味着创建该对象网的副本。外部化服务并不保证引用的完整性，仅保留同时外部化的对象之间的引用。外部化使得对象网的值复制成为可能。而外部化对象所需的其他对象的引用可保存为ORB为对象引用提供的字符串标志。</p>
<p>对象必须实现Streamable接口才能被外部化。为了外部化一个Streamable对象，必须首先调用实现了Stream接口的某个对象的外部化方法，该方法将调用流对象的externalize_to_stream方法，并传递一个实现StreamIO接口的对象。最后，流对象将任何OMG IDL定义的数据类型或实现写入streamIO对象。流对象也可以外部化由关系服务定义的整个对象图表。</p>
<p>12）属性服务</p>
<p>这种服务允许将任意的属性与对象关联起来，被关联对象必须实现PropertySet接口。属性可以独立地或成组地添加、获取和删除。如果一个对象还实现了PropertySetDef接口，则可按以下4种模式中的任一种进一步控制属性，这4种模式是：标准属性（可以修改和删除）、只读属性（能被删除但是不能修改）、强制标准属性（能被修改但不能删除）和强制只读属性。</p>
<p>属性服务并不说明属性的语义和内容。一般而言，对于程序有用的属性都需要由程序显式地赋予相应的信息。作为一个重要的例子，系统管理工具被赋予“粘贴”特性来有效地跟踪对象。</p>
<p>13）对象查询服务</p>
<p>该服务用来依靠属性定位对象。该服务类似于对象交易服务，但该服务定位对象实例而不是定位服务器。查询使用的属性由对象公布或者允许通过操作获得。有两种查询语言可供选择，面向对象数据库管理组的ODMG-93对象查询语言（Object Query Language, OQL）和扩展的SQL。一个更为普遍的查询语言正在建立。</p>
<p>查询服务定义了其自身的一个简单的集合服务——是通用集合服务的子集。查询结果集返回给用户时会用到集合。这些简单的集合提供了有序集的语义，包括增加或删除元素和元素集的操作。服务提供了一个Iterator接口来支持对集合元素的遍历。</p>
<p>14）对象集合服务</p>
<p>对象集合服务支持各种抽象拓扑集合，例如，包、集合、队列、表、树、角色模型是Smalltalk集合类库（Goldberg与Robson，1983，1989）。CORBA的集合服务（基于CORBA对象的相对重权模型）是否可与本地的对象集合库竞争是一个有争议的问题，另外，对象库可能更适于在ORB间传输各种形态与属性的集合。</p>
<p>15）时间服务</p>
<p>这一服务处理拥有众多异步时钟的分布式系统固有的误差问题。许多应用程序中，用实时信息将内部事件（如创建文件）与外部通用时间建立关联。一个时间服务必须在允许的误差范围内实现这种关联，并避免其他非因果的关联。例如，假设一个新对象的产生是对另一个对象触发某事件的反应，那么，如果给前一个对象赋予“生成日期”的时间戳，而该时间戳却先于后一个对象产生的时刻，此时就会产生一个非因果的时间信息——这恰恰是非因果时间服务的典型结果。</p>
<h4 id="CORBA构件模型"><a href="#CORBA构件模型" class="headerlink" title="CORBA构件模型"></a>CORBA构件模型</h4><p>CORBA 3.0是CORBA标准中最新的一个。尽管2002年6月左右该规范最后部分仍未定稿，但针对CORBA 2.0全面的改进已经获得了显著的进展。除了对象服务的全面修订，最主要的成就恐怕就是新的CORBA构件模型（CCM）——尽管最终的CCM规范的发布仍未定案。（有时，CCM也被称做CORBA构件。）</p>
<h5 id="可移植对象适配器"><a href="#可移植对象适配器" class="headerlink" title="可移植对象适配器"></a>可移植对象适配器</h5><p> $\color{red}{\text{CORBA对象适配器主要的作用}}$ 就是 $\color{green}{\text{在一个ORB和真正接收调用并且返回结果的对象实现之间进行协调}}$ 。目前采用的对象适配器的规范针对可移植的对象适配器，它代替了已过时的基本对象适配器。目前还没有其他的对象适配器规范。这种可移植对象适配器的一个实例为一组对象接收请求。任何ORB支持的服务器进程至少有一个POA（Portable Object Adapter）的实例，当然，该进程中的每个服务对象都可能有一个POA实例。</p>
<p>一个POA实例通过将收到的请求传递给一个“服务体”来对其进行处理。“服务体”是CORBA对象的实现。图10-2给出了一个典型的工具使用场景，从一个IDL定义开始，客户端的指代，服务器端的POA骨架，服务器端的“服务体”模板被一一建立。开发者可以通过完成该模板来补充实现细节。CORBA对象不强制使用面向对象语言，因而“服务体”也不一定为“类”。如果使用了面向对象语言，那么“服务体”就是类的实例。</p>
<h5 id="CCM构件"><a href="#CCM构件" class="headerlink" title="CCM构件"></a>CCM构件</h5><p>一个CCM应用程序是CCM构件的一个组装，其中构件可以是客户创建的或者是现成的、企业内部的或者是后来获得的。企业级JavaBean构件和CCM构件能够在一个应用程序中集成在一起。单个构件通过构件包发布，该构件包含有一个描述其内容的XML文档，还可以包含支持不同平台的二进制代码。CCM的装配包含一个描述它们所引用的构件包信息的XML文档，以及它们的部署配置。</p>
<details><summary>图10-2　根据IDL文件生成指代、POA骨架、服务体模板</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081435.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081435.png';" /></details>

<h5 id="CCM容器"><a href="#CCM容器" class="headerlink" title="CCM容器"></a>CCM容器</h5><p>CORBA 3.0定义了一个构件实现框架（Component Implementation Framework, CIF），其中包括接收CIDL（Component Implementation Definition Language，构件实现描述语言）输入并产生实现代码的生成器。另外，每个构件实例都放在一个CCM容器里。构件通过容器的接口与POA、事务、安全、持久化及通知服务相作用。一个容器同样也有插座接口来接收对构件实例的回调。</p>
<h4 id="CORBA设施"><a href="#CORBA设施" class="headerlink" title="CORBA设施"></a>CORBA设施</h4><p>CORBA设施可以分为水平的（普遍的）和垂直的（特定领域的）支持。不管是哪种支持，每个CORBA设施都定义了一个特定的构件框架，从而能够集成构件。最初，OMG试图标准化4个领域的水平设施：用户界面、信息管理、系统管理和任务管理。但是这些努力都失败了，而且水平设施在今天的OMA（Open Mobile Architecture）中的影响力很弱，之所以保留下来，是因为垂直设施的工作很可能产生并不特定于单个领域的设施。水平设施的例子，或者已经被标准化或者正在考虑之中，包括全球服务、移动代理、时间和打印设施。</p>
<p>领域任务组定义了垂直设施。在2002年年初，有10个这样的任务组：商业企业集成命令控制、计算机通信和集成、财政、卫生保健、生命科学研究、制造业、空间、电信、运输和共用设施建设。</p>
<h3 id="SUN公司的方式"><a href="#SUN公司的方式" class="headerlink" title="SUN公司的方式"></a>SUN公司的方式</h3><h4 id="Java构件技术的概述"><a href="#Java构件技术的概述" class="headerlink" title="Java构件技术的概述"></a>Java构件技术的概述</h4><p>就像上面说到的，Applet是Java中最初引起广泛关注并取得突破的地方。事实上，Java最初为了使不可靠的并可下载得到的Applet能够在客户端浏览器的进程中执行，在很多地方进行了特别设计，因而，不会造成无法接受的安全隐患。为实现这个目的，在Java中，编译器会检查Applet代码的安全性。这个做法的指导思想是：一个通过了编译器检查的Applet代码不会带来安全隐患。由于编译得到的字节码仍然可能被人修改，代码在装载时刻会被再次检查（称为“校验”）。通过校验的Applet是安全的，并受强制安全策略的约束。这一点对于现有的包括C++和对象Pascal在内的绝大多数编程语言来说都是不可能实现的。当然，安全策略可以在Smalltalk或者Visual Basic这些解释执行的语言中得到加强。然而Java是为允许编写在目标环境下有效执行的代码而设计的。这是通过所谓的“即时编译器（JIT）”实现的。</p>
<h5 id="Java与Java-2"><a href="#Java与Java-2" class="headerlink" title="Java与Java 2"></a>Java与Java 2</h5><p>虽然最初Java的规范集深受Applet思想的影响，Java 2平台（在1998年后期发布）打破原有框架，并将Applet改变成一个边缘的角色。Java 2引入了平台版本的概念，从Java规范集中选出，并共同服务于一组特定用户关心的问题。图10-3给出了Java 2的组织形式。更多的关于Java 2的内容将在下面的章节中介绍。作为Java标志性的平台版本，J2EE（Java 2平台企业版）最初于1999年年底发布，并获得了巨大成功。J2EE是一组以EJB为核心的规范，在这些规范之下是由许多不同厂商提供的应用服务器（其中最大的两个厂商是提供WebSphere产品的IBM公司和提供WebLogic产品的BEA公司；到2001年年底，在Flashline.com评测比较表中列出了40个左右的厂商，它们的产品的价格从免费/开放源码到每个CPU 75000美元不等）。微型版本J2ME也相当成功，特别是在用于移动电话的部分，企业版为构件化软件提供了丰富的环境。</p>
<p>除了版本之外，Java 2还区分了运行环境（Runtime Environent, RE）、软件开发工具包（Software Development Kit, SDK）和参考实现。运行环境是Java虚拟机和必须具有的J2SE API的实现。运行环境一般与一个SDK的版本相对应，SDK提供包括编译器和调试器在内的开发工具。容易混淆的是，按顺序为Java 1规范编号的1.x编号被继续用来给Java 2的运行环境和SDK编号。所以，运行环境可以这样提出“Java 2运行环境，标准版，v1.4”。</p>
<details><summary>图10-3　Java 2组织结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081659.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081659.png';" /></details>

<h5 id="运行环境和参考实现"><a href="#运行环境和参考实现" class="headerlink" title="运行环境和参考实现"></a>运行环境和参考实现</h5><p>Java运行环境（Java Runtime Environment, JRE）是J2SE平台的一部分，而J2SE本身又是J2EE平台的一个子集。JRE包括运行时刻、核心库和浏览器插件。Sun公司的JRE 1.4参考实现基于HotSpot运行时刻和提供对JIT编译的二进制代码进行在线再优化的HotSpot JIT编译器。单独的HotSpot编译器也有对应客户端和服务器端环境的版本。它们的区别在于根据内存占用历史信息、启动时刻、吞吐量和延时等不同而折中并对目标过程进行优化。Java SDK 1.4在包含Java编译器、调试器、平台调试体系结构API（JPDA）和用于生成文档（javadoc）的工具的同时，也包含了JRE 1.4。图10-4给出了J2SE平台1.4版本的主要结构。</p>
<p>J2EE体系结构概况通过使用专有的构件模型来区分了J2EE支持的范围。JavaBean和它的核心技术可以被用在图中几乎所有的层次。此外，请注意图中的箭头表示了控制流的典型情况，当然，并不完全。数据流一般也沿着同样的路径，但在两个方向都存在。一个底层的用于支持J2EE所有部分的系统是通过JNDI（Java Naming and Directory Interfoce，Java的命名与目录接口）访问的命名和目录的基础结构。另一个集成平台是通过JMS（Java Message Service，Java消息服务）可访问的消息基础结构。在EJB容器的消息驱动构件的帮助下，消息在到来的时候可以触发处理过程。消息和命名/目录是两个重要的集成的层次服务，但也有一些其他的部分，比如事务协作和安全服务。</p>
<details><summary>图10-4　Java 2平台标准版1.4的组织结构（资料来源：java.sun.com）</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081738.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081738.png';" /></details>

<details><summary>图10-5　J2EE体系结构概况</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904081801.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904081801.png';" /></details>

<h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>JavaBean填补了部分空白，成为一种新的可行的产品——Java构件，我们称之为Bean（Sun, 1996）。不幸的是，Java中类和对象之间明确的区别并没有被贯彻到JavaBean中。尽管一个Bean的确是一个构件（一系列类和其他资源），但是它的那些定制好的连接的实例仍然被称做Bean。这很让人迷惑。因此，我们用Bean来指代构件，用Bean实例来指代构件对象。“Bean对象”将会带来困扰，因为一个Bean通常包含了许多Java对象。</p>
<p>Bean模型主要包括以下几个方面。</p>
<p>（1）事件：Bean可以声明它们的实例是潜在的事件源或者特定类型事件的监听者。一个组装工具能够把事件源和监听者连接起来。</p>
<p>（2）属性：Bean通过成对的getter和setter方法暴露出一系列的属性。这些属性可以用来进行定制或者编程。属性的变化可以触发事件，也可以被事件强制修改。一个受限的属性只有在修改不被禁止的情况下才可以被修改。</p>
<p>（3）自检：一个组装工具能够检查一个Bean，发现这个Bean的属性、事件，以及所支持的方法。</p>
<p>（4）定制：使用组装工具，一个Bean实例能够通过设置它的各种属性来完成定制。</p>
<p>（5）持久化：定制好的、已经连接的Bean实例需要进行保存，以便在应用程序使用它的时候重新装载。</p>
<h4 id="基本的Java服务"><a href="#基本的Java服务" class="headerlink" title="基本的Java服务"></a>基本的Java服务</h4><p>经过这些年，Java已经添加了许多标准服务。这一节我们将看到反射、对象序列化，以及Java本地接口。</p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>Java的核心反射服务是一个集合体，包括原始Java语言的特性、一套支持类（在JDK 1.1中引入），以及支持类文字的语言特性。反射服务受到活动安全策略的约束，它允许我们：</p>
<p>（1）检查类和接口，包括它们的属性域和方法。</p>
<p>（2）构建新的类实例和新数组。</p>
<p>（3）对象和类的属性域的访问和修改。</p>
<p>（4）数组元素的访问和修改。</p>
<p>（5）对象和类的方法调用。</p>
<p>由此，反射服务涵盖了Java语言的所有特性。Java语言级的访问控制机制，比如域的私有性，被大大增强了（无限制的访问对于实现可信任的底层服务，例如便携式调试器，是很有用的。为了实现这些无限制的访问，Java平台的调试器体系结构提供了一个特别的接口——JPDA（Java Platform Debugger Architecture）。为了进行反射操作，反射服务引入了包java.lang.reflect。</p>
<p>类Field，Method，以及Constructor提供了关于属性域、方法和构造器的反射信息，这些信息由它们描述，并对这个域、方法和构造器进行类型安全的使用。这三个类都是最终的，没有公有的构造器。它们三个都实现了接口Member，这使得我们可以弄清楚成员如何被调用，确定成员的改动及该成员属于哪个类或者接口。</p>
<h5 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h5><p>在JDK 1.0.2以前，Java都不支持把对象序列化至字节流——仅仅支持基本类型。如果一个应用想把整个对象网写到输出流，它需要使用特别的编码方案来遍历和序列化对象自身。Java对象序列化服务解决了这个问题，它通过定义一个标准的连续编码方案来达到目标，同时提供编码和解码（“序列化”和“反序列化”）对象网的机制。</p>
<p>一个对象能够被序列化，它必须实现接口java.io.Serializable。另外，所有不应该被序列化的域需要用暂时修饰符标记。这一点很重要，因为域可能指向巨大的计算机结构（比如缓存）或者固有绑定到当前JVM的值（比如打开文件的描述符）。对实现Serializable接口的对象而言，足够的信息被写入一个流，以使得反序列化能继续进行，即使使用不同（但是兼容）的类版本。通过实现方法readObject和writeObject，可以进一步控制将哪些信息或者添加更多的信息写入流。如果这些方法没有实现，所有指向可序列化对象的非暂时域将自动被序列化。指向对象的共享引用被保存起来。</p>
<h5 id="Java本地接口"><a href="#Java本地接口" class="headerlink" title="Java本地接口"></a>Java本地接口</h5><p>Java本地接口（Java Native Interface, JNI）为每一个平台规定了本地调用方式，在Java虚拟机之外我们可以调用本地代码。JNI还规定了这些外部代码如何按照传递过去的引用来访问Java对象。这包括了调用Java方法的可能性。JNI并没有规定Java二进制对象模型——也就是说，它没有规定在一个特定的Java虚拟机中属性如何被访问及方法如何被调用。同一平台上不同Java虚拟机之间的互操作仍然是一个未解决的问题，比如实时编译器这样的边界服务。JNI允许本地方法：</p>
<p>（1）创建、检查和更新一个Java对象。</p>
<p>（2）调用Java方法。</p>
<p>（3）捕捉和抛出异常。</p>
<p>（4）装载类，获得类的信息。</p>
<p>（5）进行运行时刻类型检查。</p>
<h5 id="Java-AWT和JFC-Swing"><a href="#Java-AWT和JFC-Swing" class="headerlink" title="Java AWT和JFC/Swing"></a>Java AWT和JFC/Swing</h5><p>Java抽象窗口工具包（Abstract Windowing Toolkit, AWT）和Java基础类（Java Foundation Classes, JFC）提供了一个图形用户接口，这对于任何Java开发都具有重要意义。</p>
<p>基于委托的事件模型——这也许是在JDK 1.1中最富有戏剧性的改变。以前的事件模型基于从构件类的继承及事件管理方法的重载。“基于委托”有一点用词不当，因为它沿用了COM中的术语委托。JDK 1.1事实上提供了一个基于转发的事件模型。对象连接和组装被用来更好地实现继承。</p>
<p>●　数据传输和剪贴板支持：就像COM通用数据传输服务，AWT定义了可传输数据项的概念。Internet MIME（多用途Internet邮件扩展）类型被用来和非Java的应用程序相互作用。</p>
<p>Java应用程序之间的数据传输也可以直接使用Java类。</p>
<p>●　拖放：支持在Java和非Java应用程序之间进行拖放（通过连接底层系统的拖放协议，比如Windows中的OLE）。</p>
<p>●　Java 2D：新的2D图形和图片类。Java2D包含了线、文本和图片。支持的属性包括图片合成、Alpha合成（透明化）、精确颜色空间定义和转化，以及面向显示的图像操作。</p>
<p>●　打印：打印模型比较简单。非显式地处理打印的图形构件将使用它们的屏幕透视方法被打印出来。因此，对于简单的构件，打印可以随时进行。然而，打印模型并不处理打印那些需要在多个页面分布的嵌入内容（ActiveX打印模型对此提供了支持，它和容器合作，允许嵌入的内容跨业若干页进行打印。这个是一个复杂的模型，然而只有很少的ActiveX容器真正实现了这个高级打印模型）。</p>
<p>●　可访问性：允许所谓的辅助技术来和JFC及AWT构件交互的接口。辅助技术包括屏幕读取器、屏幕放大器和语音识别。</p>
<p>●　国际化：以Unicode 2.1字符编码为基础，提供了对文本、数字、日期、货币，以及用户自定义对象和当地习惯相适应的支持，使用语言和区域标志符来识别正确的格式。</p>
<h4 id="各种构件——Applet，Servlet，Bean和Enterprise-Bean"><a href="#各种构件——Applet，Servlet，Bean和Enterprise-Bean" class="headerlink" title="各种构件——Applet，Servlet，Bean和Enterprise Bean"></a>各种构件——Applet，Servlet，Bean和Enterprise Bean</h4><p>在Java领域中定义了5种不同的构件模型，而且将来可能会出现更多。这其中不仅包括了Applet和JavaBean模型（J2SE的一部分），还有Enterprise JavaBean，servlet和应用程序客户端构件（J2EE的一部分）。本节将对这些不同的构件模型进行简要地描述。</p>
<p>servlet/JSP和EJB是J2EE服务器端模型的两个关键元素，在下面的论述中将对它们进行更详细的介绍。在J2EE中，所有的构件将被打包成JAR文件，这样J2EE应用就可以将这些JAR文件包含进来。J2EE中的构件都有一个很重要的方面，就是它们都支持部署描述符（Deployment Descriptors）。部署描述符是一个XML文件，和相应的构件一起打包，用来描述这个构件应该怎样进行部署。部署是指根据实际的部署语境将一个构件进行准备的动作，这一步骤可以是，也经常是从安装软件的概念中分离出来的。部署描述符的详细内容依赖于特定的构件模型。例如，一个EJB实体Bean的描述符，就要有容器管理的持久性的描述，以及对EJB实体Bean中的属性到数据库中表的映射的详细描述。</p>
<p>Applet是第一个Java构件模型，用于轻量级的可下载的构件，以增强网站在浏览器中的视觉效果。最初的Applet安全模型非常严格，以致Applet不比eye candy发送得多。eye candy是指在通过别的技术捕捉一个区域，这些技术包括GIF动画、Macromedia Shockwave和Flash技术、JScript、对HTML的增强（包括DHTML（动态HTML）的引入）等。为了充分利用浏览器端技术，绝大多数的基于J2EE的应用均使用servlet和JSP来通过脚本生成HTML页面，而不是通过下载Applet来实现。</p>
<p>第二个Java构件模型是JavaBean。它主要用于支持基于连接的程序，比如同时用在客户端和服务器端的程序。从历史上来说，JavaBean在客户端占比重较大的应用中使用得更广泛，而在服务器端有时候还会被EJB所替代。但这种观点从技术角度上来说是错误的：EJB远远不只是它的名字看上去的那样，和JavaBean的相似之处也很少。当建造一个明确支持可视化应用设计模式的客户端应用时，JavaBean依然是有用的（就像J2SE 1.3中所述，一个Bean也可以是一个Applet。但无论如何，这种支持是有限的——BeanApplet所接受的总是空的Applet语境和存根）。</p>
<p>EJB是Java的第三个构件模型。它使用容器集成服务，用以支持EJB（构件）使用声明属性和部署描述符的方式来请求服务。在最新的修订版中，JavaBean也加入了容器模型，但它的容器模型与EJB容器有很大的不同。前者仅仅是一种容纳的机制，而后者则是一种声明型构造驱动的模式。因为JavaBean不需要在设计时之外与用户交互，所以也可以使用JavaBean来构造更复杂的EJB。（JavaBean和EJB与NET框架中的构件类及被服务的构件类大致对应。）</p>
<p>第四个Java构件模型是servlet。它跟Applet相似，但属于服务器端构件模型，而且是通常由Web服务器进程进行实例化的轻量级构件，Web页面就是一个典型的例子。Java Server Page（SP）是一种与之匹配的技术，能够声明式地定义要生成的页面，然后JSP会被编译成servlet。</p>
<p>J2EE引入的第五种Java构件模型为应用客户端构件。它本质上是在客户端的不受限制的Java程序。一个客户端构件通过用命名语境的JNDI企业来访问J2EE服务器中的环境属性、EJB和各种资源。这些资源可以包括对E-mail（通过JavaMail）或数据库（通过JDBC）的访问。</p>
<p>对Java构件模型不同种类的支持是不同的需求的反映。但无论如何，要在这些不同的领域实际地建立构件市场，还需要在基于领域的概念等方面建立更深入的标准化。现在，只有很少的EJB构件在需要开发它们的系统之外的其他系统中使用。</p>
<h4 id="高级Java服务"><a href="#高级Java服务" class="headerlink" title="高级Java服务"></a>高级Java服务</h4><p>本节将介绍Java如何在企业级范围支持分布式计算。实际上Java中有4种模式支持分布式计算——RMI，RMI over IIOP,CORBA和EJB容器（本身是建立在RMI或RMI over IIOP上的）。EJB在前面已经论述了。本章将论述其他的几种，以及一些最重要的支持分布式应用的服务。</p>
<h5 id="分布式对象模型和RMI"><a href="#分布式对象模型和RMI" class="headerlink" title="分布式对象模型和RMI"></a>分布式对象模型和RMI</h5><p>分布式计算主要由对象序列化服务和远程方法调用（Remote Method Invocation，RMI）服务支持。这两种服务都是在JDK 1.1引入的。下面的章节介绍RMI和RMI over IIOP，它们有细微的差别。</p>
<p>一个分布式对象的句柄为一个接口类型的引用——它不能指向一个remote对象类及其超类。能够远程访问的接口必须直接或间接从java.rmi.Remote继承下来。一个远程操作可以由于网络或远程硬件故障而失败。remote接口的所有方法都要声明检查java.rmi.Remote Exception异常。将参数传给远程操作很有意思，如果一个参数是remote接口类型，那么就是按引用来传，其他类型则按值来传——这就意味着，参数将在调用端序列化，在调用remote接口方法的时候反序列化。Java对象不需要序列化。如果企图传一个无法序列化的对象将会抛出运行时刻异常。如果语言规定使用Java RMI，那么编译器可以静态地规定只有可序列化对象可以通过值来传送，而且所有的方法都声明Remote Exception异常。</p>
<p>Java分布式模型扩展了垃圾回收。它将所有有远程引用指向它们的对象都记录下来，这样就可以支持分布式的垃圾回收了。回收器是基于Network Object（Birrel，1993）的工作的。分布式垃圾回收是RMI比当今其他模型出色的一点。唯一的另外一种基于Network Object的和有租用引用思想的就是CLI remoting，但这种方法的提出比JavaRMI晚了四年。</p>
<h5 id="Java和CORBA"><a href="#Java和CORBA" class="headerlink" title="Java和CORBA"></a>Java和CORBA</h5><p>一个OMG IDL到Java的绑定和OMG最先给出的Java到OMG IDL的绑定，是1998年在CORBA 2.2中定义的。将CORBA包含在Java项目的一个重要原因是能用ⅡOP和非Java系统通信。为了能访问CORBA服务，通常使用Java规范定义的接口会更方便，这些接口能够映射到兼容CORBA或其他服务。</p>
<h5 id="企业级服务接口"><a href="#企业级服务接口" class="headerlink" title="企业级服务接口"></a>企业级服务接口</h5><p>J2EE的重要部分就是一些适合于企业级服务的接口。这些服务接口也可以通过CORBA来建立。然而，Java-CORBA的集成必然会引起一些冲突。与此相反，在本节讨论的以Java为中心的接口，从客户和实现者的角度来减小这些不足。</p>
<p>1）Java命名和目录接口（JNDI）</p>
<p>在计算系统中的一个全局性问题就是通过名字或属性来定位服务的问题。命名服务针对前一个问题，目录服务针对后一个。命名服务的例子包括Internet域名服务（DNS）、RMI注册表和CORBA命名服务。目录服务的例子包括兼容LDAP的目录系统，比如Novell的eDirectory、微软的Active Directory和开放源码的OpenLDAP（<a target="_blank" rel="noopener" href="http://www.openldap.org)./">www.openldap.org）。</a></p>
<p>JNDI为命名服务（javax.naming）和目录服务（javax.naming.directory）提供了统一的API。Context这个最普遍使用的接口使命名语境对lookup方法有效，使用这个方法就可以根据名字来定位对象了。一个命名语境也可以用来对绑定在某个语境中的名字进行列表，或者是解除一个绑定，或是创建或删除一个子语境。</p>
<p>EJB的Bean的一个重要的命名语境就是EJB容器提供的环境命名语境（Environment Narning Context, ENC）。通过它可以访问环境属性、其他Bean和资源。接口DirContext扩展Context来提供目录功能，包括检查和更新与目录上列出的对象相关联的属性，以及通过值来搜索一个目录第10章　构件平台与典型架构</p>
<p>几乎没有构件能独立的部署，它们大多数依赖于特定的基础设施平台。由于行业高度竞争，公用构建基础设施目前只有CORBA+Java和Microsoft COM+CLR两大阵营。尽管只有两大阵营，SOA技术也飞速发展，不同平台构件连接能力有了一定改善，但在设计、管理、规范等方面存在很大差异。因此，我们有必要了解这些平台特点和差异，为应用开发选择合适的构件开发平台。</p>
<p>10.1　OMG方式</p>
<p>成立于1989年的对象管理组（OMG）是目前计算工业中最大的组织。作为一个非营利性组织，OMG旨在通过规范化对象开放市场的所有层次上的互操作性。至2002年，有近800成员加入OMG。</p>
<p>10.1.1　对象请求代理</p>
<p>CORBA的主要目标就是使不同语言、不同实现和不同平台间能进行交互。因此，OMG从没有停步在“二进制”标准上（可配置、可执行级的标准），而是保证每个细节都被标准化，使其能顾及不同的实现及CORBA兼容不同产品的独立供应商增值的需要。这一开放式方法的不利一面就是CORBA兼容产品不能在二进制级进行有效的互操作，只能以较高的代价在高层协议上协作。OMG的跨ORB（对象请求代理）协议——IIOP（Internet InterORB Protocol）互操作协议，在1995年7月的CORBA 2.0中被规范化。与ORB的互操作兼容则必须支持ⅡOP。在1996年7月的CORBA 2.0更新版本中，加入了一条关于相互作用的协议，该协议明确了基于CORBA的系统与基于微软COM系统之间的互操作细节。</p>
<p>CORBA包括三个基本部分：一套调用接口、对象请求代理（ORB）和一套对象适配器。面向对象操作的调用实现后期绑定。对象引用所指代的对象实现决定了被调用方法的最终实现。调用接口支持不同级别的后期绑定，同时编排调用参数，使ORB核心能定位接收对象，调用方法，以及传递参数。在接收端，一个对象适配器还原参数，调用接收对象相应的方法。图10-1简单地描述了基本的CORBA结构。</p>
<p>10.1.2　公共对象服务规范</p>
<p>现有的CORBA Service包含16种对象服务（CORBA服务），其中的通告服务是电信领域设施正式的组成部分。这些服务划分为两大类：一类服务应用于企业计算系统。这些系统往往将CORBA对象视为模块，并视CORBA为易用的通信中间件，此时的CORBA服务大多用来支持大规模的操作；另一类服务则应用于细粒度的对象操作，但目前这些服务的实用价值较差。CORBA 3.0中的持久状态服务（Persistent State Service, PSS）可能是一个例外，它替代了CORBA 2.0中的持久对象服务（POS）。PSS是CORBA构件模型的三个主要支撑服务之一，另两个是事务服务和通告服务。值得注意的是，大型基于CORBA系统往往只使用少量的CORBA服务，包括名字服务、安全服务、事务服务和交易服务。现有大部分ORB产品并不试图支持全部的CORBA服务也说明了这一点。</p>
<p>alt</p>
<p>图10-1　基于ORB系统的简化结构</p>
<p>1．支持企业分布式计算的服务</p>
<p>许多大型企业系统只是将CORBA作为对象总线，依靠ORB与其他各种各样的系统进行互操作。名字服务是关键服务之一。</p>
<p>1）命名服务，交易器服务</p>
<p>每个对象内部都有唯一的标志符。命名服务则允许任意地给对象赋予一个名字，这个名字在其所属的命名语境中是唯一的。而命名语境所形成的层次结构，使得所有的名字形成名字树。</p>
<p>交易器服务允许给对象赋予一个复杂的描述，从而允许客户基于该描述来定位所需的对象。交易器通过交易语境来组织对象。客户则在指定的交易语境中根据对象描述的部分内容或关键字来搜寻对象，而搜寻结果往往是一个包含满足查询条件的一组对象的列表。OMG交易器服务规范同时被ISO（ISO/IEC 13235-1）和ITU（ITU-T推荐X.950）所采用。</p>
<p>2）事件服务，通告服务</p>
<p>事件服务允许定义那些从事件生产者被发送到事件消费者的事件对象。由于信息只能从生产者流向消费者，因而事件对象是不变的。事件必须通过事件通道传播，从而松散了生产者和消费者之间的耦合关系。事件可以具有类型（使用OMG IDL定义），而通道可以根据类型过滤事件。</p>
<p>事件通道支持“推”和“拉”两种方式的事件通告模型。在“推”模型中，事件生产者调用事件通道的“推”方法将事件上传给事件通道，事件通道进而调用所有注册的事件消费者的“推”方法将事件传给消费者。在“拉”模型中，事件消费者调用事件通道的“拉”方法，这将导致事件通道调用所有注册的事件生产者的“拉”方法，此时获得的新事件将返回给消费者。</p>
<p>1998年，通告服务为事件服务增加了几个重要的特征——服务质量（Quality of Service, QoS）规范和管理；标准的类型化和结构化事件；基于类型和QoS的动态事件过滤；作用于资源、通道、一组消费者或单个消费者的事件过滤；针对资源、通道和客户的事件发现。值得注意的是，通告服务本身并不是CORBA服务，而是电信领域工作组（Te1DTF）提交的CORBA设施。</p>
<p>3）对象事务服务</p>
<p>对象事务服务（Object Transaction Service, OTS）是建立分布式应用最重要的服务之一。OMG于1994年12月制定的OTS规范在大多数的ORB产品及若干J2EE服务器中得到支持。OTS实现必须支持平坦事务，而嵌套事务是可选的。遵循X/Open分布事务处理标准的其他事务服务可以与OTS集成。同样，多个异构ORB提供的事务也可集成。</p>
<p>在基于构件的系统中，嵌套事务似乎不可避免。因为一个构件的实现可能创建一个覆盖一系列操作的事务闭包，而这些事务属性无须在构件接口中声明。这种独立扩展性原则需要嵌套事务的支持。作为唯一的OTS实现必须支持的事务类型，平坦事务在构件系统中的价值有限。实际上，现有的主流事务中间件也不支持嵌套事务，这是它们共同的缺点。</p>
<p>OTS自动维护当前的事务语境，该语境将随请求在ORB系统中传递，也可传递给其他的非CORBA的事务系统。对于CORBA对象，事务语境可以传递给任何实现了Transactional Object的对象。当前的事务语境可从ORB获得，因此必须保证随时可用。事务操作，如begin, commit, rollback都在当前的语境中定义。</p>
<p>所有希望在一次事务中执行修改，或者需要执行事务控制的对象都必须向OTS协调器注册。该协调器可从当前语境中获得。一个资源可以指明它是否支持嵌套事务。任何资源都必须实现Resource接口，从而允许协调器执行两段提交协议（众所周知，两段提交协议在完全分布的环境下可能发生死锁，这只能通过特定的广播协议避免；三段提交协议能够避免死锁问题（Mullender, 1993），但开销太大。因此，OTS规定协调器在逻辑上必须是集中式的）。</p>
<p>OTS的设计目标之一是希望将事务控制作为一个独立的服务，但目前更普遍的是将事务和其他服务集成到应用服务器提供的语境或容器中。</p>
<p>4）安全服务</p>
<p>可靠的安全服务对于一个跨越多个相互信赖的组织的分布系统极为重要。安全服务必须得到普及。所有可互操作的ORB或可共同工作的系统必须协作，而这要求为所有的参与者建立统一的安全策略。</p>
<p>CORBA安全规范定义了一系列的服务，包括认证、安全通信、证书委托（也称为“替身”）及防抵赖等。目前仅有少数产品完全支持该规范，如BEA的WebLogic和IBM的WebSphere。很多产品仅仅依赖Netscape的安全套接字（Secure Socket Layer, SSL）实施安全保障，尤其采用独立ORB，而不是完全集成的应用服务器时。因为利用SSL可以很方便地实现简单的认证及安全的通信，但不能支持类似委托和防抵赖等较高级的安全机制。</p>
<p>5）支持细粒度对象互操作的服务</p>
<p>尽管有些服务，包括收集、外部化和查询服务，仍未被任何产品实现（原因很多，如查询服务的规范过于松散，收集服务的某些假设不切实际，本节仍将介绍余下的服务，以便读者对OMA涉及的对象服务有一个全面的认识。</p>
<p>6）并发控制服务</p>
<p>该服务支持对资源进行加锁和解锁。锁必须依赖于事务的语境或其他语境才能获得。依赖事务语境创建的锁将作为事务回滚的部分被释放。锁具有不同的模式，如读锁、写锁、升级锁。其中，读锁允许多个客户同时执行读操作；而写锁保证只有一个客户才能执行写操作；升级锁是可以升级为写锁的读锁，支持互斥的读操作。锁有多个锁集合。每个受保护的资源都拥有一个锁集合，该集合决定了可用的锁的种类及数量。一个锁集合的工厂接口支持创建新的锁集合。锁集合不是事务型就是非事务型的，并可与其他锁集合建立关联。锁协调器可以释放指定锁集合中所有的锁。</p>
<p>7）许可服务</p>
<p>组装构件的过程中需要获取所有非免费构件的使用许可。许可服务支持多种类型的许可模式。该服务定义了两个接口（抽象）——许可服务管理器和特定于厂商的许可服务。如果一个对象与一个许可协议绑定，那么它可以通过许可服务管理器检查其使用是否合法。</p>
<p>8）生命周期服务</p>
<p>这类服务支持创建、复制、移动和删除CORBA对象及其相关的对象组。下面将介绍如何利用关系服务提供的包含与引用关系来处理对象组。包含关系支持嵌套复制，即所有被包含的对象都会被复制。为了支持对象创建，生命周期服务支持注册与获取工厂对象。一旦获得所需的工厂对象，就能够用它来创建新的对象。</p>
<p>生命周期服务允许删除对象或对象组，但并不提示何时销毁该对象。这意味着分布式内存管理需要高层应用的参与，这被认为是CORBA较为明显的缺点。相比较而言，DCOM支持分布引用的计数，Java和CLR甚至支持基于租借的远程引用的分布式垃圾收集。</p>
<p>9）关系服务</p>
<p>关系服务指允许定义和维护对象之间的关系。不依赖语言级的指针或引用，该服务引入了一种关系模型，以支持在不影响相关对象的情况下创建对象间的关系。但是，关系服务基本上没有实际应用，甚至没有产品实现，极有可能被基于CCM的业务对象关系所取代。</p>
<p>10）持久状态服务</p>
<p>持久性是指对象在其创建程序终止后仍然存活。为此，CORBA 2.0制定了持久对象服务（POS），用来支持CORBA对象的持久性。尽管在1994年年初就被OMG标准化为关键服务，但直到1996年年中才出现一个beta版的实现。一些报告甚至指出该规范及其与其他对象服务的互操作存在严重的技术问题。另外，POS没有解决“正确性”的问题，尤其是它把存储的申请交给应用代码处理。POS规范最终在CORBA 3.0版本中被新的持久状态服务（PSS）所代替。</p>
<p>11）外部化服务</p>
<p>这项服务支持对象网和对象流之间的双向映射。对象网外部化后再内部化意味着创建该对象网的副本。外部化服务并不保证引用的完整性，仅保留同时外部化的对象之间的引用。外部化使得对象网的值复制成为可能。而外部化对象所需的其他对象的引用可保存为ORB为对象引用提供的字符串标志。</p>
<p>对象必须实现Streamable接口才能被外部化。为了外部化一个Streamable对象，必须首先调用实现了Stream接口的某个对象的外部化方法，该方法将调用流对象的externalize_to_stream方法，并传递一个实现StreamIO接口的对象。最后，流对象将任何OMG IDL定义的数据类型或实现写入streamIO对象。流对象也可以外部化由关系服务定义的整个对象图表。</p>
<p>12）属性服务</p>
<p>这种服务允许将任意的属性与对象关联起来，被关联对象必须实现PropertySet接口。属性可以独立地或成组地添加、获取和删除。如果一个对象还实现了PropertySetDef接口，则可按以下4种模式中的任一种进一步控制属性，这4种模式是：标准属性（可以修改和删除）、只读属性（能被删除但是不能修改）、强制标准属性（能被修改但不能删除）和强制只读属性。</p>
<p>属性服务并不说明属性的语义和内容。一般而言，对于程序有用的属性都需要由程序显式地赋予相应的信息。作为一个重要的例子，系统管理工具被赋予“粘贴”特性来有效地跟踪对象。</p>
<p>13）对象查询服务</p>
<p>该服务用来依靠属性定位对象。该服务类似于对象交易服务，但该服务定位对象实例而不是定位服务器。查询使用的属性由对象公布或者允许通过操作获得。有两种查询语言可供选择，面向对象数据库管理组的ODMG-93对象查询语言（Object Query Language, OQL）和扩展的SQL。一个更为普遍的查询语言正在建立。</p>
<p>查询服务定义了其自身的一个简单的集合服务——是通用集合服务的子集。查询结果集返回给用户时会用到集合。这些简单的集合提供了有序集的语义，包括增加或删除元素和元素集的操作。服务提供了一个Iterator接口来支持对集合元素的遍历。</p>
<p>14）对象集合服务</p>
<p>对象集合服务支持各种抽象拓扑集合，例如，包、集合、队列、表、树、角色模型是Smalltalk集合类库（Goldberg与Robson，1983，1989）。CORBA的集合服务（基于CORBA对象的相对重权模型）是否可与本地的对象集合库竞争是一个有争议的问题，另外，对象库可能更适于在ORB间传输各种形态与属性的集合。</p>
<p>15）时间服务</p>
<p>这一服务处理拥有众多异步时钟的分布式系统固有的误差问题。许多应用程序中，用实时信息将内部事件（如创建文件）与外部通用时间建立关联。一个时间服务必须在允许的误差范围内实现这种关联，并避免其他非因果的关联。例如，假设一个新对象的产生是对另一个对象触发某事件的反应，那么，如果给前一个对象赋予“生成日期”的时间戳，而该时间戳却先于后一个对象产生的时刻，此时就会产生一个非因果的时间信息——这恰恰是非因果时间服务的典型结果。</p>
<p>10.1.3　CORBA构件模型</p>
<p>CORBA 3.0是CORBA标准中最新的一个。尽管2002年6月左右该规范最后部分仍未定稿，但针对CORBA 2.0全面的改进已经获得了显著的进展。除了对象服务的全面修订，最主要的成就恐怕就是新的CORBA构件模型（CCM）——尽管最终的CCM规范的发布仍未定案。（有时，CCM也被称做CORBA构件。）</p>
<p>1．可移植对象适配器</p>
<p>CORBA对象适配器主要的作用就是在一个ORB和真正接收调用并且返回结果的对象实现之间进行协调。目前采用的对象适配器的规范针对可移植的对象适配器，它代替了已过时的基本对象适配器。目前还没有其他的对象适配器规范。这种可移植对象适配器的一个实例为一组对象接收请求。任何ORB支持的服务器进程至少有一个POA（Portable Object Adapter）的实例，当然，该进程中的每个服务对象都可能有一个POA实例。</p>
<p>一个POA实例通过将收到的请求传递给一个“服务体”来对其进行处理。“服务体”是CORBA对象的实现。图10-2给出了一个典型的工具使用场景，从一个IDL定义开始，客户端的指代，服务器端的POA骨架，服务器端的“服务体”模板被一一建立。开发者可以通过完成该模板来补充实现细节。CORBA对象不强制使用面向对象语言，因而“服务体”也不一定为“类”。如果使用了面向对象语言，那么“服务体”就是类的实例。</p>
<p>2．CCM构件</p>
<p>一个CCM应用程序是CCM构件的一个组装，其中构件可以是客户创建的或者是现成的、企业内部的或者是后来获得的。企业级JavaBean构件和CCM构件能够在一个应用程序中集成在一起。单个构件通过构件包发布，该构件包含有一个描述其内容的XML文档，还可以包含支持不同平台的二进制代码。CCM的装配包含一个描述它们所引用的构件包信息的XML文档，以及它们的部署配置。</p>
<p>alt</p>
<p>图10-2　根据IDL文件生成指代、POA骨架、服务体模板</p>
<p>3．CCM容器</p>
<p>CORBA 3.0定义了一个构件实现框架（Component Implementation Framework, CIF），其中包括接收CIDL（Component Implementation Definition Language，构件实现描述语言）输入并产生实现代码的生成器。另外，每个构件实例都放在一个CCM容器里。构件通过容器的接口与POA、事务、安全、持久化及通知服务相作用。一个容器同样也有插座接口来接收对构件实例的回调。</p>
<p>10.1.4　CORBA设施</p>
<p>CORBA设施可以分为水平的（普遍的）和垂直的（特定领域的）支持。不管是哪种支持，每个CORBA设施都定义了一个特定的构件框架，从而能够集成构件。最初，OMG试图标准化4个领域的水平设施：用户界面、信息管理、系统管理和任务管理。但是这些努力都失败了，而且水平设施在今天的OMA（Open Mobile Architecture）中的影响力很弱，之所以保留下来，是因为垂直设施的工作很可能产生并不特定于单个领域的设施。水平设施的例子，或者已经被标准化或者正在考虑之中，包括全球服务、移动代理、时间和打印设施。</p>
<p>领域任务组定义了垂直设施。在2002年年初，有10个这样的任务组：商业企业集成命令控制、计算机通信和集成、财政、卫生保健、生命科学研究、制造业、空间、电信、运输和共用设施建设。</p>
<p>10.2　SUN公司的方式</p>
<p>10.2.1　Java构件技术的概述</p>
<p>就像上面说到的，Applet是Java中最初引起广泛关注并取得突破的地方。事实上，Java最初为了使不可靠的并可下载得到的Applet能够在客户端浏览器的进程中执行，在很多地方进行了特别设计，因而，不会造成无法接受的安全隐患。为实现这个目的，在Java中，编译器会检查Applet代码的安全性。这个做法的指导思想是：一个通过了编译器检查的Applet代码不会带来安全隐患。由于编译得到的字节码仍然可能被人修改，代码在装载时刻会被再次检查（称为“校验”）。通过校验的Applet是安全的，并受强制安全策略的约束。这一点对于现有的包括C++和对象Pascal在内的绝大多数编程语言来说都是不可能实现的。当然，安全策略可以在Smalltalk或者Visual Basic这些解释执行的语言中得到加强。然而Java是为允许编写在目标环境下有效执行的代码而设计的。这是通过所谓的“即时编译器（JIT）”实现的。</p>
<p>1．Java与Java 2</p>
<p>虽然最初Java的规范集深受Applet思想的影响，Java 2平台（在1998年后期发布）打破原有框架，并将Applet改变成一个边缘的角色。Java 2引入了平台版本的概念，从Java规范集中选出，并共同服务于一组特定用户关心的问题。图10-3给出了Java 2的组织形式。更多的关于Java 2的内容将在下面的章节中介绍。作为Java标志性的平台版本，J2EE（Java 2平台企业版）最初于1999年年底发布，并获得了巨大成功。J2EE是一组以EJB为核心的规范，在这些规范之下是由许多不同厂商提供的应用服务器（其中最大的两个厂商是提供WebSphere产品的IBM公司和提供WebLogic产品的BEA公司；到2001年年底，在Flashline.com评测比较表中列出了40个左右的厂商，它们的产品的价格从免费/开放源码到每个CPU 75000美元不等）。微型版本J2ME也相当成功，特别是在用于移动电话的部分，企业版为构件化软件提供了丰富的环境。</p>
<p>除了版本之外，Java 2还区分了运行环境（Runtime Environent, RE）、软件开发工具包（Software Development Kit, SDK）和参考实现。运行环境是Java虚拟机和必须具有的J2SE API的实现。运行环境一般与一个SDK的版本相对应，SDK提供包括编译器和调试器在内的开发工具。容易混淆的是，按顺序为Java 1规范编号的1.x编号被继续用来给Java 2的运行环境和SDK编号。所以，运行环境可以这样提出“Java 2运行环境，标准版，v1.4”。</p>
<p>alt</p>
<p>图10-3　Java 2组织结构</p>
<p>2．运行环境和参考实现</p>
<p>Java运行环境（Java Runtime Environment, JRE）是J2SE平台的一部分，而J2SE本身又是J2EE平台的一个子集。JRE包括运行时刻、核心库和浏览器插件。Sun公司的JRE 1.4参考实现基于HotSpot运行时刻和提供对JIT编译的二进制代码进行在线再优化的HotSpot JIT编译器。单独的HotSpot编译器也有对应客户端和服务器端环境的版本。它们的区别在于根据内存占用历史信息、启动时刻、吞吐量和延时等不同而折中并对目标过程进行优化。Java SDK 1.4在包含Java编译器、调试器、平台调试体系结构API（JPDA）和用于生成文档（javadoc）的工具的同时，也包含了JRE 1.4。图10-4给出了J2SE平台1.4版本的主要结构。</p>
<p>J2EE体系结构概况通过使用专有的构件模型来区分了J2EE支持的范围。JavaBean和它的核心技术可以被用在图中几乎所有的层次。此外，请注意图中的箭头表示了控制流的典型情况，当然，并不完全。数据流一般也沿着同样的路径，但在两个方向都存在。一个底层的用于支持J2EE所有部分的系统是通过JNDI（Java Naming and Directory Interfoce，Java的命名与目录接口）访问的命名和目录的基础结构。另一个集成平台是通过JMS（Java Message Service，Java消息服务）可访问的消息基础结构。在EJB容器的消息驱动构件的帮助下，消息在到来的时候可以触发处理过程。消息和命名/目录是两个重要的集成的层次服务，但也有一些其他的部分，比如事务协作和安全服务。</p>
<p>alt</p>
<p>图10-4　Java 2平台标准版1.4的组织结构（资料来源：java.sun.com）</p>
<p>alt</p>
<p>图10-5　J2EE体系结构概况</p>
<p>10.2.2　JavaBean</p>
<p>JavaBean填补了部分空白，成为一种新的可行的产品——Java构件，我们称之为Bean（Sun, 1996）。不幸的是，Java中类和对象之间明确的区别并没有被贯彻到JavaBean中。尽管一个Bean的确是一个构件（一系列类和其他资源），但是它的那些定制好的连接的实例仍然被称做Bean。这很让人迷惑。因此，我们用Bean来指代构件，用Bean实例来指代构件对象。“Bean对象”将会带来困扰，因为一个Bean通常包含了许多Java对象。</p>
<p>Bean模型主要包括以下几个方面。</p>
<p>（1）事件：Bean可以声明它们的实例是潜在的事件源或者特定类型事件的监听者。一个组装工具能够把事件源和监听者连接起来。</p>
<p>（2）属性：Bean通过成对的getter和setter方法暴露出一系列的属性。这些属性可以用来进行定制或者编程。属性的变化可以触发事件，也可以被事件强制修改。一个受限的属性只有在修改不被禁止的情况下才可以被修改。</p>
<p>（3）自检：一个组装工具能够检查一个Bean，发现这个Bean的属性、事件，以及所支持的方法。</p>
<p>（4）定制：使用组装工具，一个Bean实例能够通过设置它的各种属性来完成定制。</p>
<p>（5）持久化：定制好的、已经连接的Bean实例需要进行保存，以便在应用程序使用它的时候重新装载。</p>
<p>10.2.3　基本的Java服务</p>
<p>经过这些年，Java已经添加了许多标准服务。这一节我们将看到反射、对象序列化，以及Java本地接口。</p>
<p>1．反射</p>
<p>Java的核心反射服务是一个集合体，包括原始Java语言的特性、一套支持类（在JDK 1.1中引入），以及支持类文字的语言特性。反射服务受到活动安全策略的约束，它允许我们：</p>
<p>（1）检查类和接口，包括它们的属性域和方法。</p>
<p>（2）构建新的类实例和新数组。</p>
<p>（3）对象和类的属性域的访问和修改。</p>
<p>（4）数组元素的访问和修改。</p>
<p>（5）对象和类的方法调用。</p>
<p>由此，反射服务涵盖了Java语言的所有特性。Java语言级的访问控制机制，比如域的私有性，被大大增强了（无限制的访问对于实现可信任的底层服务，例如便携式调试器，是很有用的。为了实现这些无限制的访问，Java平台的调试器体系结构提供了一个特别的接口——JPDA（Java Platform Debugger Architecture）。为了进行反射操作，反射服务引入了包java.lang.reflect。</p>
<p>类Field，Method，以及Constructor提供了关于属性域、方法和构造器的反射信息，这些信息由它们描述，并对这个域、方法和构造器进行类型安全的使用。这三个类都是最终的，没有公有的构造器。它们三个都实现了接口Member，这使得我们可以弄清楚成员如何被调用，确定成员的改动及该成员属于哪个类或者接口。</p>
<p>2．对象序列化</p>
<p>在JDK 1.0.2以前，Java都不支持把对象序列化至字节流——仅仅支持基本类型。如果一个应用想把整个对象网写到输出流，它需要使用特别的编码方案来遍历和序列化对象自身。Java对象序列化服务解决了这个问题，它通过定义一个标准的连续编码方案来达到目标，同时提供编码和解码（“序列化”和“反序列化”）对象网的机制。</p>
<p>一个对象能够被序列化，它必须实现接口java.io.Serializable。另外，所有不应该被序列化的域需要用暂时修饰符标记。这一点很重要，因为域可能指向巨大的计算机结构（比如缓存）或者固有绑定到当前JVM的值（比如打开文件的描述符）。对实现Serializable接口的对象而言，足够的信息被写入一个流，以使得反序列化能继续进行，即使使用不同（但是兼容）的类版本。通过实现方法readObject和writeObject，可以进一步控制将哪些信息或者添加更多的信息写入流。如果这些方法没有实现，所有指向可序列化对象的非暂时域将自动被序列化。指向对象的共享引用被保存起来。</p>
<p>3．Java本地接口</p>
<p>Java本地接口（Java Native Interface, JNI）为每一个平台规定了本地调用方式，在Java虚拟机之外我们可以调用本地代码。JNI还规定了这些外部代码如何按照传递过去的引用来访问Java对象。这包括了调用Java方法的可能性。JNI并没有规定Java二进制对象模型——也就是说，它没有规定在一个特定的Java虚拟机中属性如何被访问及方法如何被调用。同一平台上不同Java虚拟机之间的互操作仍然是一个未解决的问题，比如实时编译器这样的边界服务。JNI允许本地方法：</p>
<p>（1）创建、检查和更新一个Java对象。</p>
<p>（2）调用Java方法。</p>
<p>（3）捕捉和抛出异常。</p>
<p>（4）装载类，获得类的信息。</p>
<p>（5）进行运行时刻类型检查。</p>
<p>4．Java AWT和JFC/Swing</p>
<p>Java抽象窗口工具包（Abstract Windowing Toolkit, AWT）和Java基础类（Java Foundation Classes, JFC）提供了一个图形用户接口，这对于任何Java开发都具有重要意义。</p>
<p>基于委托的事件模型——这也许是在JDK 1.1中最富有戏剧性的改变。以前的事件模型基于从构件类的继承及事件管理方法的重载。“基于委托”有一点用词不当，因为它沿用了COM中的术语委托。JDK 1.1事实上提供了一个基于转发的事件模型。对象连接和组装被用来更好地实现继承。</p>
<p>●　数据传输和剪贴板支持：就像COM通用数据传输服务，AWT定义了可传输数据项的概念。Internet MIME（多用途Internet邮件扩展）类型被用来和非Java的应用程序相互作用。Java应用程序之间的数据传输也可以直接使用Java类。</p>
<p>●　拖放：支持在Java和非Java应用程序之间进行拖放（通过连接底层系统的拖放协议，比如Windows中的OLE）。</p>
<p>●　Java 2D：新的2D图形和图片类。Java2D包含了线、文本和图片。支持的属性包括图片合成、Alpha合成（透明化）、精确颜色空间定义和转化，以及面向显示的图像操作。</p>
<p>●　打印：打印模型比较简单。非显式地处理打印的图形构件将使用它们的屏幕透视方法被打印出来。因此，对于简单的构件，打印可以随时进行。然而，打印模型并不处理打印那些需要在多个页面分布的嵌入内容（ActiveX打印模型对此提供了支持，它和容器合作，允许嵌入的内容跨业若干页进行打印。这个是一个复杂的模型，然而只有很少的ActiveX容器真正实现了这个高级打印模型）。</p>
<p>●　可访问性：允许所谓的辅助技术来和JFC及AWT构件交互的接口。辅助技术包括屏幕读取器、屏幕放大器和语音识别。</p>
<p>●　国际化：以Unicode 2.1字符编码为基础，提供了对文本、数字、日期、货币，以及用户自定义对象和当地习惯相适应的支持，使用语言和区域标志符来识别正确的格式。</p>
<p>10.2.4　各种构件——Applet，Servlet，Bean和Enterprise Bean</p>
<p>在Java领域中定义了5种不同的构件模型，而且将来可能会出现更多。这其中不仅包括了Applet和JavaBean模型（J2SE的一部分），还有Enterprise JavaBean，servlet和应用程序客户端构件（J2EE的一部分）。本节将对这些不同的构件模型进行简要地描述。</p>
<p>servlet/JSP和EJB是J2EE服务器端模型的两个关键元素，在下面的论述中将对它们进行更详细的介绍。在J2EE中，所有的构件将被打包成JAR文件，这样J2EE应用就可以将这些JAR文件包含进来。J2EE中的构件都有一个很重要的方面，就是它们都支持部署描述符（Deployment Descriptors）。部署描述符是一个XML文件，和相应的构件一起打包，用来描述这个构件应该怎样进行部署。部署是指根据实际的部署语境将一个构件进行准备的动作，这一步骤可以是，也经常是从安装软件的概念中分离出来的。部署描述符的详细内容依赖于特定的构件模型。例如，一个EJB实体Bean的描述符，就要有容器管理的持久性的描述，以及对EJB实体Bean中的属性到数据库中表的映射的详细描述。</p>
<p>Applet是第一个Java构件模型，用于轻量级的可下载的构件，以增强网站在浏览器中的视觉效果。最初的Applet安全模型非常严格，以致Applet不比eye candy发送得多。eye candy是指在通过别的技术捕捉一个区域，这些技术包括GIF动画、Macromedia Shockwave和Flash技术、JScript、对HTML的增强（包括DHTML（动态HTML）的引入）等。为了充分利用浏览器端技术，绝大多数的基于J2EE的应用均使用servlet和JSP来通过脚本生成HTML页面，而不是通过下载Applet来实现。</p>
<p>第二个Java构件模型是JavaBean。它主要用于支持基于连接的程序，比如同时用在客户端和服务器端的程序。从历史上来说，JavaBean在客户端占比重较大的应用中使用得更广泛，而在服务器端有时候还会被EJB所替代。但这种观点从技术角度上来说是错误的：EJB远远不只是它的名字看上去的那样，和JavaBean的相似之处也很少。当建造一个明确支持可视化应用设计模式的客户端应用时，JavaBean依然是有用的（就像J2SE 1.3中所述，一个Bean也可以是一个Applet。但无论如何，这种支持是有限的——BeanApplet所接受的总是空的Applet语境和存根）。</p>
<p>EJB是Java的第三个构件模型。它使用容器集成服务，用以支持EJB（构件）使用声明属性和部署描述符的方式来请求服务。在最新的修订版中，JavaBean也加入了容器模型，但它的容器模型与EJB容器有很大的不同。前者仅仅是一种容纳的机制，而后者则是一种声明型构造驱动的模式。因为JavaBean不需要在设计时之外与用户交互，所以也可以使用JavaBean来构造更复杂的EJB。（JavaBean和EJB与NET框架中的构件类及被服务的构件类大致对应。）</p>
<p>第四个Java构件模型是servlet。它跟Applet相似，但属于服务器端构件模型，而且是通常由Web服务器进程进行实例化的轻量级构件，Web页面就是一个典型的例子。Java Server Page（SP）是一种与之匹配的技术，能够声明式地定义要生成的页面，然后JSP会被编译成servlet。</p>
<p>J2EE引入的第五种Java构件模型为应用客户端构件。它本质上是在客户端的不受限制的Java程序。一个客户端构件通过用命名语境的JNDI企业来访问J2EE服务器中的环境属性、EJB和各种资源。这些资源可以包括对E-mail（通过JavaMail）或数据库（通过JDBC）的访问。</p>
<p>对Java构件模型不同种类的支持是不同的需求的反映。但无论如何，要在这些不同的领域实际地建立构件市场，还需要在基于领域的概念等方面建立更深入的标准化。现在，只有很少的EJB构件在需要开发它们的系统之外的其他系统中使用。</p>
<p>10.2.5　高级Java服务</p>
<p>本节将介绍Java如何在企业级范围支持分布式计算。实际上Java中有4种模式支持分布式计算——RMI，RMI over IIOP,CORBA和EJB容器（本身是建立在RMI或RMI over IIOP上的）。EJB在前面已经论述了。本章将论述其他的几种，以及一些最重要的支持分布式应用的服务。</p>
<p>1．分布式对象模型和RMI</p>
<p>分布式计算主要由对象序列化服务和远程方法调用（Remote Method Invocation，RMI）服务支持。这两种服务都是在JDK 1.1引入的。下面的章节介绍RMI和RMI over IIOP，它们有细微的差别。</p>
<p>一个分布式对象的句柄为一个接口类型的引用——它不能指向一个remote对象类及其超类。能够远程访问的接口必须直接或间接从java.rmi.Remote继承下来。一个远程操作可以由于网络或远程硬件故障而失败。remote接口的所有方法都要声明检查java.rmi.Remote Exception异常。将参数传给远程操作很有意思，如果一个参数是remote接口类型，那么就是按引用来传，其他类型则按值来传——这就意味着，参数将在调用端序列化，在调用remote接口方法的时候反序列化。Java对象不需要序列化。如果企图传一个无法序列化的对象将会抛出运行时刻异常。如果语言规定使用Java RMI，那么编译器可以静态地规定只有可序列化对象可以通过值来传送，而且所有的方法都声明Remote Exception异常。</p>
<p>Java分布式模型扩展了垃圾回收。它将所有有远程引用指向它们的对象都记录下来，这样就可以支持分布式的垃圾回收了。回收器是基于Network Object（Birrel，1993）的工作的。分布式垃圾回收是RMI比当今其他模型出色的一点。唯一的另外一种基于Network Object的和有租用引用思想的就是CLI remoting，但这种方法的提出比JavaRMI晚了四年。</p>
<p>2．Java和CORBA</p>
<p>一个OMG IDL到Java的绑定和OMG最先给出的Java到OMG IDL的绑定，是1998年在CORBA 2.2中定义的。将CORBA包含在Java项目的一个重要原因是能用ⅡOP和非Java系统通信。为了能访问CORBA服务，通常使用Java规范定义的接口会更方便，这些接口能够映射到兼容CORBA或其他服务。</p>
<p>3．企业级服务接口</p>
<p>J2EE的重要部分就是一些适合于企业级服务的接口。这些服务接口也可以通过CORBA来建立。然而，Java-CORBA的集成必然会引起一些冲突。与此相反，在本节讨论的以Java为中心的接口，从客户和实现者的角度来减小这些不足。</p>
<p>1）Java命名和目录接口（JNDI）</p>
<p>在计算系统中的一个全局性问题就是通过名字或属性来定位服务的问题。命名服务针对前一个问题，目录服务针对后一个。命名服务的例子包括Internet域名服务（DNS）、RMI注册表和CORBA命名服务。目录服务的例子包括兼容LDAP的目录系统，比如Novell的eDirectory、微软的Active Directory和开放源码的OpenLDAP（<a target="_blank" rel="noopener" href="http://www.openldap.org)./">www.openldap.org）。</a></p>
<p>JNDI为命名服务（javax.naming）和目录服务（javax.naming.directory）提供了统一的API。Context这个最普遍使用的接口使命名语境对lookup方法有效，使用这个方法就可以根据名字来定位对象了。一个命名语境也可以用来对绑定在某个语境中的名字进行列表，或者是解除一个绑定，或是创建或删除一个子语境。</p>
<p>EJB的Bean的一个重要的命名语境就是EJB容器提供的环境命名语境（Environment Narning Context, ENC）。通过它可以访问环境属性、其他Bean和资源。接口DirContext扩展Context来提供目录功能，包括检查和更新与目录上列出的对象相关联的属性，以及通过值来搜索一个目录语境。因为DirContext是从Context继承而来的，所以一个目录语境也是命名语境。绝大部分的语境是通过对其他语境的递归查找而找到的。而查找的起始点就是通过初始化InitialContext这个类得到的。</p>
<p>JNDI也定义了一个事件API（javax.naming.event）、一个支持LDAP v3的超过DirContext的功能，以及一个能够使命名和目录服务的提供者与JNDI连接起来的服务提供者接口（javax.naming.spi）。事件机制用来为改变通知进行注册。J2SE 1.4内置了4种服务提供者——CORBA命名、DNS、LDAP和RMI。</p>
<p>2）Java消息服务（JMS）</p>
<p>异步消息是将实例的操作和覆盖的组装模型通过消息进行通信。基于事务的消息队列建立的可靠性级别，正常情况下需要基于同步调用的模型。灵活的消息路由、广播和过滤增强了灵活性。JMS是Java对消息系统的访问机制，但它本身并不实现消息。</p>
<p> $\color{red}{\text{JMS}}$ 支持点对点分发的消息队列，也支持多个目标订阅的消息主题。当消息发布给一个主题的适合，消息就会发送给所有那个主题的订阅者。JMS支持各种消息类型（二进制、流、名—值表、序列化的对象和文本）。通过声明与SQL的WHERE相近的句段，可以建立消息的过滤器。</p>
<p>3）Java数据库连接（JDBC）</p>
<p>JDBC是根据流行的微软ODBC（Open DataBase Connectivity，开放数据库连接）标准建立的一个通用的与数据库交互的方法。JDBC API分成核心API（在java.sql包和J2SE的一部分中）和JDBC可选包（在javax.sql包中，J2SE可选但J2EE必须遵循）。JDBC像ODBC一样，需要驱动程序将JDBC API映射到特定数据库的本地接口。</p>
<p>JDBC驱动程序有4种。Type 1和Type 2驱动通过JNI来使用本地代码（非Java代码）。Type 1驱动使用具有通用接口的本地代码，而Type 2允许使用数据库特定的接口。最普遍的Type 1驱动就是JDK包含的JDBC-ODBC桥，它将JDBC调用映射为ODBC调用。因为ODBC是用字句的驱动模型来访问特定的数据库，因此这种方式相对会慢一些。Type 3和Type 4驱动都是纯Java的。Type 3通过网络协议和数据库网关来间接地访问数据库，Type 4则是直接访问数据库。驱动程序的选择不会影响客户的代码，因为JDBC API本身是不受驱动影响的。对于性能来说，Type 4通常是最好的，接下来是Type 2，再接下来是Type 1，最后是Type 3。</p>
<p>4）Java事务API和服务（JTA, JTS）</p>
<p>事务管理常常是由EJB容器来委派的，但有些情况还需要显式的事务管理。CORBA对象事务服务（OTS）或者它的Java实现（Java Transaction Service, JTS）可以用于这个目的。然而，EJB中有一个更为简单的接口，称为Java事务API。它是服务器/容器的实现使用的低级XA接口（X/Open事务API接口标准）和EJB Bean的实现可以访问的高级客户端接口。</p>
<p>在JTS（或OTS）中，需要显式地和仔细地使用事务中的资源，这样，这个显式的对事务的划分会形成一个边界。高级JTA（Java Transaction API）接口，这个容易出错的功能是由EJB容器来完成的。然而，由于资源由长事务所掌握，显式的事务管理仍然是很容易出错的，并且将引起不一致或效率低下。</p>
<h5 id="J2EE连接器架构（JCA）"><a href="#J2EE连接器架构（JCA）" class="headerlink" title="J2EE连接器架构（JCA）"></a>J2EE连接器架构（JCA）</h5><p> $\color{red}{\text{JCA标准化连接}}$ 是由J2EE 1.3首先提出的，它位于J2EE应用服务器和企业信息系统（Enterprise Information System, EIS）之间，比如数据库管理、企业资源规划（ERP）、企业资产管理（Enterprise Asset Management, EAM）和客户关系管理（CRM）系统。不是用Java开发的企业应用或者在J2EE框架内的应用都可以通过JCA连接。JCA是在javax.resource包和它的子包（cci, spi和spi.security）中定义的（JCA的形式也用于Javacryptography API的缩写）。</p>
<h5 id="Java和XML"><a href="#Java和XML" class="headerlink" title="Java和XML"></a>Java和XML</h5><p>Sun是XML的一个早期提倡者。然而，最初Java对XML的支持只是限定在定义能够处理XML文档的接口，能够表示XML文档（Document Object Module, DOM）和XML流（Sinple API for XML, SAX）的模型。而更多对XML支持，包括对XML Schema和Web服务标准的支持已经作为预发布版本，在2002年初加了进来。</p>
<h4 id="Java和Web服务——SunONE"><a href="#Java和Web服务——SunONE" class="headerlink" title="Java和Web服务——SunONE"></a>Java和Web服务——SunONE</h4><p>SunONE（Sun开放网络环境）是J2EE的扩展，它可以通过特殊的servlet来处理Web服务协议。SunONE也包含了以前由iPlanet策划的J2EE服务器产品。（注意：Netscape公司和Sun公司组建的iPlanet联盟在2002年年初已经结束了，并把iPlanet开发的产品留给了Sun公司。在2002年年初，iPlanet在J2EE的市场份额中占7％，排名在它之前的是IBM公司的WebSphere和BEA公司的WebLogic（各占34％），紧随其后的是Oracle公司（占6％）。随着在2002年年初Java Web服务开发包（JavaWSDP）可用版的发布，Sun公司对SOAP、WSDL、UDDI都提供了支持。JavaWDSP包括了Java为XML消息处理（Java API for XML Messaging, JAXM）、XML处理（Java API for XML Processing, JAXP）、XML注册（JAXR）和基于XML的RPC（JAX-RPC）提供支持的API。另外它还包括JSP标准标签库（Java Server Pages Standard Tag Library, JSTL）、Ant创建工具、Java WSDP登记服务器、网络应用工具，以及Apache Tomcat网络服务器容器。</p>
<h3 id="Microsoft的方式"><a href="#Microsoft的方式" class="headerlink" title="Microsoft的方式"></a>Microsoft的方式</h3><p>从某种意义上讲，微软选择的是最简单的路线。它没有提出一整套标准，并期望依此改变自己的系统。相反，它不断地对已有的应用和平台基础进行再工程。构件技术是渐进引入的，这就可以获益于以前的成功技术，例如，Visual Basic控件（VBX，一种不是面向对象的构件！），对象链接和嵌入（OLE），OLE数据库连接（ODBC），ActiveX，微软事务服务器技术（MTS），以及主动式服务器端页面技术（ASP）。</p>
<p>在技术标准的领域里，微软的主要兴趣放在Internet标准（Internet Engineering Task Force, IETF）和Web标准（W3C）上。最近，它的.NET规范的一部分被ECMA（European Computer Manufacturers Association）组织采纳。ECMA是欧洲的一家标准化组织，它被视为通向ISO的捷径（参见ECMA, 2001a, 2001b）。微软并未试图让自己的方法与OMG或Java标准保持一致。尽管Java曾在微软的战略中扮演过一段重要角色，它目前的地位却已不高，而仅仅是为了继续支持一项较老的Visual J++产品。这其中有一部分是解决Sun公司和微软公司争讼所带来的后果。而且，微软还重点瞄准使用Visual J++6.0的用户，靠着Visual J#.NET的名称，推出一个向.NET迁移的工具。</p>
<p>作为.NET计划的一部分，微软正在推动语言无关性，把它作为CLR的一条主要原则，并构造了一种新的语言C#。C#吸纳了Java的很多成功特性，另一方面，它又新增若干独有的特征（例如值类型），且不支持某些关键的Java特征（例如内部类）。C#虽然定位于CLR的模型语言，但它与若干其他语言占有同等地位，包括被全面革新过的Visual Basic .NET, Managed C++（对C++的扩展，它与ANSI兼容），以及许多被其他供应商或组织支持的语言。</p>
<p>在依赖语境的组装方面，微软、OMG和Sun这些公司技术之间的螺旋演进很有意思。依赖环境的组装最先在COM套间模型被粗略描述，又在微软事务服务器（Microsoft Transaction Server, MTS）中被丰富，在被Enterprise JavaBean采纳和改进的同时它又在COM+技术中独立地发展，后来被CORBA构件模型（CCM）采纳和改善，最后，它变为CLR中的一项可扩展的和开放的机制，与此同时，EJB 2.0的发展超越了意欲成为各项技术超集的CCM，这意味着CCM规范进入了“维护阶段”。</p>
<p>COM可能在未来多年内仍很重要，而且，CLR与它的互操作能力格外强。鉴于此，下面对微软方法的讨论就以COM介绍开始。COM+在COM基础上新增了服务，CLR的首次发布是使用COM互操作来提供COM+服务的，因此，许多服务并非冗余。</p>
<h4 id="第一个基础关联模型——COM"><a href="#第一个基础关联模型——COM" class="headerlink" title="第一个基础关联模型——COM"></a>第一个基础关联模型——COM</h4><p>COM是微软平台上所有构件的基石，微软还将之在Macintosh系统实现。在其他的许多平台，COM也被诸如Software AG、惠普这样的第三方厂商实现。即便如此，可以说，COM从未在微软的Windows平台之外赢得更多支持。但是，COM的基本理念却有着相当的影响力。</p>
<p>COM所定义的一个基础实体是接口。在二进制层面上，一个接口被表示为指向一个接口结点的指针。而一个接口结点唯一被指定的部分是置于其内部第一个域的另一个指针，这个指针指向一个过程变量表（或者说，函数指针表）。这些表源自C++等语言用来实现虚函数（方法）的表，因此，也被称做vtable。图10-6所示为二进制层面的一个COM接口。</p>
<details><summary>图10-6　COM接口的二进制表示</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082436.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082436.png';" /></details>


<p>表示COM对象的通常方法是将其画成带有插口的盒子。由于每个COM对象都有IUnknown接口（它标志着COM对象），通常把IUnknown接口置于COM对象图的顶端。图10-7所示为COM对象图，这里是一个ActiveX文档对象。</p>
<details><summary>图10-7　COM对象描述</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082452.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082452.png';" /></details>

<p>回到IUnknown接口。它的“真实”名字当然是它的IID，即00000000-0000-0000-C000-000000000046。但为了方便，所有接口也有一个可读名。根据习惯，可读接口名以字母I开头。与IID不同，可读名并不保证是唯一的。因此，编程中的接口引用均使用IID。</p>
<p>IUnknown接口的首要用途是在最抽象的情况下标志COM对象，此时COM对象没有任何特殊功能。因此，IUnknown接口的引用可被用来和ANY类型的引用或面向对象语言的Object引用比较。从某种意义上，IUnknown用词不当。它并不是一个未知的接口，相反，它是唯一能被保证永远存在的接口。对于一个没有别的已知接口的COM对象，它被获知的唯一途径就是通过IUnknown接口的引用。</p>
<p>IUnknown接口只提供对任何COM接口都必须的三个强制性方法。第一个强制性方法是QueryInterface，前面已提及。另两个强制性方法名为AddRef和Release。结合关于何时调用的规则，这两个强制性方法被用来控制对象的生命周期。后面会有更多解释。使用类似COM IDL的表示法，IUnknown可被定义为：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082516.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082516.png';" /></details>

<p>类型HRESULT被大多数COM接口的方法用来表示调用的成功或失败。QueryInterface则用它表明查询的接口是否被支持。如果接口属于一个远程对象，HRESULT也可能表示网络错误。</p>
<p>每个COM对象都会进行引用计数，或者是对整个对象体，或者是对每个单独的接口结点。引用计数变量被共享使用的情况下，COM对象不能释放接口结点，即使这个结点已经没有引用。一般来说，这样做没有问题。而共享一个引用计数变量也是通常的做法。可是，某些情况下，接口结点会占据很多资源，例如当它们保留着一个大缓冲结构时。对于这类接口结点，可以使用独立的引用计数变量，以便结点可以尽早释放。这种根据需要创建和删除接口结点的技术有时被称做“快速装卸接口（Tear-Off Interface）”。</p>
<p>当对象或结点被创建，其第一个引用被传出之前，引用计数变量会初始化为1。之后，每逢一个引用复制被创建，计数值必须增加（AddRef）；每逢一个引用被丢弃，计数值必须减少（Release）。在引用值变成0的瞬间COM对象无法被访问，因此它就该自行销毁。销毁工作的一部分是通过调用Release方法释放对其他对象的引用。其后果是，被正待销毁对象引用的所有对象都会被递归销毁。最终，被销毁的对象释放它所占有的内存空间。</p>
<h4 id="COM对象重用"><a href="#COM对象重用" class="headerlink" title="COM对象重用"></a>COM对象重用</h4><p>COM不支持任何形式的实现继承。注意，COM没有定义或考虑单独的构件从内部如何去实现。构件可以由使用了实现继承的类组成。无论何种情况，缺少实现继承并不意味着缺少对重用的支持。为实现对象重用，COM支持两种形式的对象组装：包含（Containment）和聚集（Aggregation）。</p>
<p>包含就是一种简单的对象组装技术，其含义是一个对象拥有指向另一个对象的唯一引用。从概念上来说，前者（称做外部对象）“包含”后者（称做内部对象）。外部对象只是把请求转发给内部对象。所谓转发，就是调用内部对象的方法，以实现对某个外部对象方法的调用。</p>
<p>包含能重用内含于其他构件的实现。特别是，对于使用外部对象的客户程序，包含是完全透明的。调用接口函数的客户无法辨别调用是由提供接口的对象处理，还是被转发给另一个对象处理。如果包含层次较深，或者被转发的方法本身相对简单，包含会存在性能上的问题，因此COM定义第二类重用形式，即聚集。聚集的基本思想很简单，直接把内部对象的接口引用传给外部对象的客户，而不再转发请求。对此接口的调用将直接到达内部对象，从而省去转发的代价。当然，只有在外部对象不希望截取调用以执行诸如过滤等额外处理时聚集。还有，保持透明性是很重要的，因为外部对象的客户无法辨别哪个特定接口是从内部对象聚集而来的。</p>
<h4 id="接口和多态"><a href="#接口和多态" class="headerlink" title="接口和多态"></a>接口和多态</h4><p>COM接口可通过（单）接口继承从其他COM接口中派生。实际上，所有COM接口都直接或间接地继承了Iunknown，它是接口体系中的公共基类型。除了Iunknown外，只有Idispatch和Ipersist这两种重要的基接口被公共继承。COM中接口继承为什么如此鲜为使用呢？</p>
<p>令人吃惊的是，COM的接口继承与其支持的多态无关。例如，假定客户持有一个接口，比方说IDispatch的引用。实际上，客户引用的接口可以是IDispatch的任何子类型。换句话说，函数表可以包含IDispatch所需之外的方法。但重要的是，客户无法发现这一点。如果客户想要更特殊的接口，必须使用QueryInterface。这样就能保证获得更多的方法，至于返回的接口结点实际上是否就是QueryInterface被调用发出的那个结点，对客户来说没有关系。</p>
<p>接口和版本化。一旦公布，COM接口和它的规范不允许以任何形式改变。这种避免的方法既解决了语法问题，也解决了语义上的脆弱基类的问题。换言之，COM中的IID可用于标志接口中的版本。因为接口总是通过IID被请求的，系统中的所有参与者都对接口的版本达成一致。CORBA讨论中所提及的传递性版本冲突问题在COM中不会发生。</p>
<p>构件可以选择实现接口的多个版本，只不过处理方式就像处理任何别的不同接口一样。使用这种策略，基于COM的系统能并发支持旧接口和新接口，同时允许渐进的迁移。在某些系统中，由单个对象实现的多个接口被合并成单个类的命名空间，类似上述的策略实现起来就变得困难，或至少不自然。对于建立在传统对象模型（像Java或CORBA）之上的方法，这会给二进制兼容性带来问题。CLR避免此问题的方法是，在相同的类实现的不同接口上，允许分别实现具有相同名字和签名的方法。除此之外的其他方面，CLR还是基于传统对象模型。</p>
<h4 id="COM对象的创建和COM库"><a href="#COM对象的创建和COM库" class="headerlink" title="COM对象的创建和COM库"></a>COM对象的创建和COM库</h4><p>创建对象的最简单方法是调用CoCreateInstance（所有COM库的过程名以Co起头，它代表COM）。此函数需要一个CLSID和一个IID，然后创建指定类（CLSID）的新实例，并返回所请求类型（IID）的接口。如果COM无法定位或启动能实现所请求CLSID的服务器，或者指定的类不支持所请求的接口，就会返回错误提示。</p>
<p>创建COM类的实例对象时，COM需要把给定的CLSID映射为包含所请求类的实际构件。为此目的，COM支持系统注册器，它类似CORBA存储器。注册器指明哪些服务器是可用的，它们支持哪些类。服务器可以是进程内（inprocess）服务器、本地服务器和远程服务器这三种类型中的一种。进程内服务器支持存在于客户进程中的对象；本地服务器支持的对象位于客户所在的机器上，但在不同的进程内；远程服务器支持的对象位于不同的机器上。</p>
<p>CoCreateInstance接受一个额外的参量，用于指定何种服务器是可接受的。CoCreateInstance查询注册器以定位服务器。若服务器尚未被激活，就载入并启动它。对于进程内服务器，需要载入和链接动态链接库（DLL）。而对于本地服务器，独立的可执行文件会被载入。最后，对于远程机器，会联系远程机器上的服务控制管理器，以载入并启动该机器上的服务器（以中间件观点看，SCM起着类似CORBA ORB的作用）。</p>
<p>COM服务器具有定义好的结构，包含一个或多个类，对每个类它又实现一个工厂对象（在COM里，工厂对象被称做类工厂。这个名称可能让人误解，因为工厂创建的不是类，而是类的实例）。工厂是支持IClassFactory或IClassFactory2接口的对象，使用后一个接口意味着需要许可机制。COM使用工厂的原因是，COM对象不一定是简单的单体对象（single-object），因此其创建需要由其构件而非系统提供的服务来指定。</p>
<p>图10-8含两个coclasses的COM服务器，每个都有一个工厂。启动时，自注册服务器为每个类创建一个工厂对象，并将之注册到COM。CoCreateInstance使用工厂对象创建实例。为了提升性能，客户也可以使用CoGetClassObject获得对工厂的直接访问。在需要创建许多新对象时，这种做法较有用。很多时候，客户所要的不是具体的类，而是更一般的东西。例如，客户并不使用对应Microsoft Word的CLSID，而是使用对应rich text的CLSID。为了支持这种一般性CLSID和相应的配置，COM允许一个类仿真另一个类。仿真配置保存在系统注册器里。例如，某个仿真项也许会指定类Microsoft Word仿真类rich text。</p>
<h4 id="从COM到分布式COM（DCOM）"><a href="#从COM到分布式COM（DCOM）" class="headerlink" title="从COM到分布式COM（DCOM）"></a>从COM到分布式COM（DCOM）</h4><p>COM透明地扩展COM的概念和服务。DCOM中已存在客户端代理（Proxy）对象和服务器端桩（Stub）对象，它们只被用于支持进程间通信。DCOM建立在这两者的基础上，在前面谈到远程服务器时已暗示过DCOM服务。</p>
<p>为支持跨进程或跨机器的透明通信，COM在客户端创建代理对象，在服务器端创建桩对象。为了单个机器内进程间的通信，代理和桩需要实现的，仅仅是从简单数据类型到字节流和从字节流到简单数据类型的映射。因为发送和接收进程在同样的机器上执行，所以不需要担心数据类型是如何表达的。而当接口引用被传递时，尽管仍在相同机器的不同进程间，情况也会变得稍微复杂些。</p>
<details><summary>图10-8　一个COM服务器支持两个各带工厂的COM类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082642.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082642.png';" /></details>

<p>跨进程传递的接口引用需要被映射为对象引用，它的意义在穿过进程时仍能维持不变。当接到对象引用时，COM需要确定对应的代理对象存在于接收端。然后，COM选择该代理的对应接口，并传送这个接口引用而非先前的那个接口引用。先前的引用会指向“错误”进程的接口。</p>
<p>图10-9显示了客户向对象A发出一个调用。被调用的方法只有一个参量，它引用对象B的一个接口。由于对象A位于另一进程，本地代理对象中转此调用。代理决定对象B的对象标志符（OID）和被传递接口的接口指针标志符（IPID）。OID和IPID一起随着客户进程ID被传递给服务器进程的桩。桩使用OID定位对象B的本地代理，使用IPID定位具体的接口。接着，桩代表客户发出先前的调用，它将本地B代理的接口引用传给调用接受者——对象A。</p>
<details><summary>图10-9　单机上进程间接口引用的编排与起源</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082659.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082659.png';" /></details>

<p>DCOM所用的方法相当近似。有两点不同，在不同机器上数据类型的表达可能是不一样的，并且对象引用需要包含比OID和IPID更多的信息。为了解决数据表达的差异，DCOM将数据整理成平台无关的网络数据表达（NDR）形式。为了形成与机器无关的对象引用，DCOM将OID、IPID和那些足以定位对象输出器（Object Exporter）的信息结合在一起。对象输出器是DCOM提供的对象，它知道如何绑定服务器公布的对象。每个对象输出器有唯一的标志符（OXID），它被包括在对象引用中。</p>
<h4 id="复合文档和OLE对象"><a href="#复合文档和OLE对象" class="headerlink" title="复合文档和OLE对象"></a>复合文档和OLE对象</h4><p>链接和嵌入是微软的复合文档标准。创造OLE的原本意图是为了将各以应用为中心的遗留程序融合成单一的以文档为中心的范型。也有可能创建只存在于OLE环境中的对象，ActiveX就是最好的例子。然而，OLE也继续用变化的OLE集成程序来支持独立的应用。这种实用化的一面使很多OLE技术非常复杂。然而，可以按平滑的路径进行技术迁移，以保护在开发和用户培训方面的投资，这样就可以保住客户。</p>
<p>如同COM之上的每项技术，OLE可被概括为一组预定义的COM接口。OLE所需的几项关键技术由COM服务提供。这包括结构化存储、绰号、包含拖放的统一数据传输、可连接对象和自动化支持。</p>
<p>OLE复合文档的方法对文档容器和文档服务器进行区分。文档服务器提供某种内容模型和显示、操作内容的能力。文档容器没有自己的内容，但可以接受任意文档服务器提供的内容成分。许多文档容器也是文档服务器，这即是说，它们支持外来的成分，同时也有自己的内容。大多数流行的“重家伙”，像微软的Office应用（如Word、Excel和PowerPoint等），是结合为一体的服务器和容器。例如，Excel有自己的内容模型，它是按照电子数据表排列的数据和公式单元。Excel也是容器，作为容器，它能接受所插入的Word文本对象。</p>
<h4 id="NET框架"><a href="#NET框架" class="headerlink" title=".NET框架"></a>.NET框架</h4><p>.NET框架是更大的.NET空间的一部分。它包含的内容有通用语言运行环境，许多部分接口化和基于类的框架（被打包成配件），以及许多工具。CLR是通用语言基础设施规范的实现，它增加了COM+互操作和Windows平台访问服务。特别地，CLR提供了动态载入和卸载、垃圾回收、语境截取、元数据自省、远程化、持久性，以及其他完全和语言无关的运行时刻服务。目前，微软在CLR上支持4种语言：C#、JScript、ManagedC++和Visual Basic .NET。</p>
<p>配件（Assemblies）是.NET中部署、版本控制和管理的单元，也就是说，它们是.NET的软件构件。“并排”使用同一配件的多个版本是完全可以的。配件包含元数据、模块和资源，所有这些以平台无关的方式被表达。模块中的代码以CIL（通用中介语言）表达，CIL大致像Java、Smalltalk的字节码，或者Pascal P码。与早期字节码格式不同，配件中使用的语言不重视解释。MSIL（微软中介语言）是与CLI兼容的超集，它带有支持CLR互操作特性的指令，这些特性就在CLI规范之外。CLR在安装或者载入时被编译，执行的始终是本地码。CLR自省和其他基于类型的概念覆盖了很大的类型系统空间，此空间被称做CTS（通用类型系统）。</p>
<p>下面涵盖了各种与.NET框架相关的技术细节。</p>
<h5 id="NET大图景"><a href="#NET大图景" class="headerlink" title=".NET大图景"></a>.NET大图景</h5><p>微软公司的.NET计划的目标是，将范围广泛的微软产品和服务组织起来，置于各种互联设备共同的视野范围内，这些设备包括服务器、固定和移动PC及特殊设备。在技术层次，.NET瞄准如下三个层面。</p>
<p>（1）Web服务。</p>
<p>（2）部署平台（服务器和客户机）。</p>
<p>（3）开发平台。</p>
<p>Web服务想达到因特网的传递式可编程性（这就不仅仅是传统意义上瞄准人类客户的Web了，它应包括支持Web服务的构造、定位和使用的因特网和Web的标准和建议）。为启动Web服务空间，微软公司计划推出许多基础的核心服务。第一个这样的服务已推出一段时间，它就是用于验证用户的.NET护照。另一个是.NET警报，它在2002年早期被应用。它是通用警报服务，在引入时是通过Windows信使发送警报的。作为.NET MyServices和其他计划的一部分，微软公司公布了更多的服务，例如用于存储的服务。从各式服务器产品和Windows.NET服务器开始，微软平台正在经过一系列步骤被转变，以便以本地和有效的方式支持、使用Web服务和处理XML。</p>
<p>最后，也是本章的焦点，会有新的开发平台，它包含CLR、框架和工具。CLR提供了新的构件基础设施，可以（但不是必须）为构件屏蔽底层硬件平台的细节。类似JVM，CLR定义了一套脱离具体处理器的指令集。与JVM不同的是，CLR还支持需要和特定底层平台紧密集成的构件。</p>
<h5 id="通用语言基础设施"><a href="#通用语言基础设施" class="headerlink" title="通用语言基础设施"></a>通用语言基础设施</h5><p>通用语言基础设施规范由微软公司、英特尔公司和惠普公司联合提交给ECMA，它建立了类似CORBA的语言中性平台。可是与CORBA不同，CLI也定义了中介语言（Intermediate Language, IL）和部署文件格式（配件），例如Java字节码、类和JAR文件。与CORBA和Java不同，CLI支持可扩展元数据。通用语言运行环境是微软.NET框架的一部分，它是微软公司对CLI规范的实现。CLR超出了CLI兼容的范围，它包括对COM和平台互操作的支持（细节参见下个小节）。CLI包括了执行引擎服务的规范（例如载入器、JIT编译器、起垃圾回收作用的内存管理器）、通用类型系统（Common Type System, CTS）和通用语言规范（Common Language Specification, CLS）。CTS和CLS起着互补的作用，CTS范畴是许多语言在类型空间的核心概念的超集。与CLI兼容的代码能够在整个CTS空间运行。可是，没有哪两种语言能精确覆盖相同的CTS子集。以不同语言实现的代码要互操作，CLS空间就显得有用。CLS是CTS的严格子集，它被构建的方式使许多语言都完全覆盖它。特别地，若某个定义是与CLS兼容的，那么任何被归为CLS消费者的语言均能使用该定义，这是CLI目标语言中最简单而有用的一类。能在CLS空间引入新定义的语言称做CLS生产者，能扩展CLS空间已有定义的语言称做CLS扩展者。CLS扩展者也总是CLS生产者，CLS生产者也总是CLS消费者。CTS为所有类型定义了单根类型——System.Object。Object之下，CTS区分了值类型和引用类型。所有值类型是System.ValueType的单态子类型，它本身又是System.Object子类型。引用类型被分成接口、类、数组和代理（技术上，接口被建模为CTS中特殊的类），其中的类被分成按值排置（Marshal-by-value）和按引用排置（Marshal-by-reference）两种。按引用排置又被分成随环境变化和与环境绑定两种。从图10-10可看到CTS类型体系的概况。</p>
<details><summary>图10-10　顶层CTS类型层次</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082824.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082824.png';" /></details>

<p>原始类型是没有的，因此，诸如整型或浮点等类型只是预定义的值类型。多个接口和单个类继承关系是被支持的，甚至值类型也能继承（实现）多个接口。访问权限从两个方面被控制，即定义点和使用点是否位置相同，以及定义点和使用点是否通过类继承而相关。为了前者，区分了三种位置范畴：类、配件和全局。因此，访问权限关系有6种可能的约束组合，但大多数语言支持的只是其子集。例如，C#不支持把protected访问权限定义在小于全局的范畴上。某些语言，像Managed C++，则支持所有组合。</p>
<p>方法可以是静态的、与实例绑定的或者虚拟的（虚拟也暗示着是与实例绑定）。对重载的支持要依靠方法名、签名，但没有返回类型。重载的解析策略依语言而定（因此，CLI自省机制引入了自己的重载解析策略）。</p>
<p>类能实现多个接口，并可以用引入的接口名修饰方法名。因此，能够在相同的类上实现两个接口，即使它们包含具有相同名字和特征的方法，但这两个方法应以不同的方式实现。例如，C#完全支持显式地实现接口方法的概念。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082843.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082843.png';" /></details>

<p>尽管上面的cowboy/shape例子被广为使用，但实际上它没有包含一个重要情况：偶然的名字冲突会发生这个问题。然而，重要得多的是这样一个例子：发布新的接口版本时还希望能并排支持多个构件。图10-11显示了类C应该如何实现版本1的接口I和版本2的接口I，以便和类A和B正确交互，此二者都需要接口I，只是版本不同。CTS把所有的名字定义锚定在包含它们的配件的名字里。因为配件的名字包含了版本信息，接口I的两个版本实际上可以被区分开，不过它们的方法名还有可能冲突。CTS支持在同样的类上实现接口的两个版本，这是支持并排使用配件多个版本的重要步骤。</p>
<details><summary>图10-11　一个接口不同版本的并行实现</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904082856.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904082856.png';" /></details>

<p>各种方法命名规范，例如属性和索引器的取值—设值方法，也是CTS的一部分。定义这些规范的目的是支持跨语言互操作，而没有考虑对各种语言中传统命名的特性的显式支持。例如，对于C#属性Foo，对应的访问方法被称做get_Foo和set_Foo。C#不允许直接使用这些方法名，但其他不直接支持属性的语言就可以调用这些方法来访问属性。</p>
<p>可抛出异常不是CTS方法特征的一部分。与Java和C++不同，CTS没有规定调用方法时要静态检查可抛出的异常。语言仍可以在它们自己领域内自由执行这类检查。没有哪两种语言对声明和检查的语义能达成完全一致，这使得跨语言检查没什么用处，即便CTS曾支持注释。</p>
<h4 id="COM和平台的互操作"><a href="#COM和平台的互操作" class="headerlink" title="COM和平台的互操作"></a>COM和平台的互操作</h4><p>CLR能真正支持与COM的互操作，并能直接访问底层平台（即Win32和其他基于DLL的API）。通过整合对COM互操作和平台调用的支持，CLR执行引擎能提供几乎最优的性能。例如，平台调用通过JIT被编译为本地代码序列，它实际上和传统编译的代码是等同的。COM互操作是通过提供两类自动合成的包装达到的。一种是COM可调用包装，它通过COM接口来呈现CLR对象；另一种是运行环境可调用包装，它通过CLR接口呈现COM对象。</p>
<p>为了和COM互操作，CLR工具可被用来创建互操作配件，这些配件定义的类型和COM类型库定义的类型相匹配。被多个.NET应用共享的CLR配件必须有唯一的强名字，这对COM互操作有微妙的影响。正是这点使多方可能为相同的COM接口（相同的IID）产生互操作配件。然而，得到的互操作配件会公布相互不兼容的类型，尽管所有这些类型对应着有相同IID的相同COM接口。为避免此种情况，定义了主互操作配件（Primary Interop Assemblies, PIA）。PIA应由COM接口（IID“所有者”）的发布者产生。如果得不到PIA，可以产生替代的互操作配件，只是它的类型只能在配件内部使用。把这些类型公布在新的配件特征中，最终会导致与其他配件的不兼容，它们或者依赖PIA，或者将自己的依赖公布于另一个替代的互操作配件。</p>
<p>尽管COM表面简单，但是COM互操作却是微妙而复杂的。原因是，COM调用规范的细节（包括分派接口），排置规范（包括由谁分配或释放的规则），以及对底层不安全类型的支持（包括指向大小未知的数组的指针）。远程化接口（DCOM代理能自动生成的接口）更容易处理，因为代理需要的是和CLR包装所需大致相同的信息。不幸的是，DCOM给自己带来了麻烦——类似[call_as()]属性的IDL注释只有过程意义，不能被自动解释，以产生合适的CLR包装。</p>
<p>奇怪的是，若接口被限制为“同构类型”（此类型在穿过CLR/COM边界时无需变换），调用代码中的COM方法时，其开销大约只有50个指令周期。</p>
<h3 id="战略比较"><a href="#战略比较" class="headerlink" title="战略比较"></a>战略比较</h3><p>迄今为止，讨论过的每个方法都已给出了丰富的技术细节，那么它们有什么显著的区别和基本的共同点呢？战略上的后果又是什么呢？</p>
<h4 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h4><p>很明显，所讨论过方法的共性不能帮助决定应该遵循哪一种方法。然而不管具体的方法是什么，这些方法的共性有助于我们做出使用构件化软件技术的决定。对这些共性的理解还可以避免一些没有意义的争论，这些争论的产生是因为把一些次要问题简单地误解为主要的不同点了。</p>
<p>所有的方法都依赖于延后绑定机制、封装和动态多态性（也被称为包含多态性或者子类型化）。除了COM之外，其他方法都支持接口继承（COM中的多态性来源于接口及类的分离及每个类的多接口支持）。换一个说法就是，所有的方法都依赖于某种类型的对象模型。</p>
<p>另外，随着时间的推移，这些方法互相取长补短。大多数的方法目前支持：</p>
<p>（1）一种构件传输格式——JavaJAR文件、COMcab文件、CCM:-、CLI配件。</p>
<p>（2）统一方式的数据传输。</p>
<p>（3）事件和事件连接或者信道、单播和多播。</p>
<p>（4）元信息——自省、反射。</p>
<p>（5）某种形式的持久化、序列化或者外部化。</p>
<p>（6）基于属性的编程或部署描述符。</p>
<p>（7）适合于应用服务器的特定构件模型——EJB、COM+、CCM和CLR:COM+。</p>
<p>（8）适合于Web服务器的特定构件模型——JSP/servlets、COM:-、CCM:-和ASP.NET。</p>
<p>一个通常被忽视的事实是，非COM方法慢慢地汇聚到同样支持COM方法已经拥有的功能上来，这个功能就是构件对象通过多个截然不同的对象将自身展现给客户的构件对象。这样做使得动态配置成为可能，这已经得到了认可。CORBA构件模型的等价接口的概念几乎等同于COM的QueryInterface方法。JavaBean引入了间接的库java.beans.Beans，来代替Java语言的类型测试（instanceof）和类型检查（检查转换）。通过这种方法，将来的bean可以将它们自己作为一组Java对象表示给客户，而不是一个单独的对象。有趣的是，CLI/CLR在第一个版本中没有追随COM，不提供对处理拥有多个实现体的实例的支持和转换，尽管提供了通用的设计模式，使用C#的属性从主对象中获得子对象。</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>一旦做出使用软件构件的决定，下一步就要选择使用哪一种方法。鉴于很多方法具有较多的共性，可以同时遵循几种不同的方法。特别地，支持者们和第三方或许会提供主要方法之间的互连的解决方案。这里有若干例子。IONA公司的Orbix 2000 COMet是一个CORBA/COM集成工具。Sun公司的ActiveX bridge允许JavaBean实例被嵌入到ActiveX容器中。IONA公司的技术总监Annrai说：“我们的座右铭是，不兼容就意味着商业机会，对于我们而言是巨大的机遇。”</p>
<p>以下是一个这些方法间明显区别的（不全面的）列表。</p>
<h5 id="每个平台的二进制接口标准"><a href="#每个平台的二进制接口标准" class="headerlink" title="每个平台的二进制接口标准"></a>每个平台的二进制接口标准</h5><p>构件交互的二进制标准是COM的核心（值得注意的是，虽然从技术上是可行的，也曾经做过尝试，但是COM从来没有脱离过Windows领域。从而，有一个平台就有一个二进制标准）。Java通过标准化字节码来避免实际的二进制标准。Java为二进制接口定义了Java本地接口（JNI），JNI的设计是基于COM的，不过是特定于Java。特别的是，其设计为支持现代的垃圾搜集器提供了空间。CORBA仍然没有定义二进制标准。二进制标准是Direct-to-*编译器需要的，这些编译器将一种特定编程语言的语言构造直接映射到二进制接口。CLR（CLI的超集）和Java类似，采用标准化MSIL（CIL的超集）来代替二进制标准。CLR支持了领先时代的编译，提供了对平台API调用进行转换的有效支持和与COM的互操作。</p>
<h5 id="兼容性和可移植性的源代码级的标准"><a href="#兼容性和可移植性的源代码级的标准" class="headerlink" title="兼容性和可移植性的源代码级的标准"></a>兼容性和可移植性的源代码级的标准</h5><p>CORBA在标准化语言绑定方面做得相当好，语言绑定保证了跨ORB实现的源代码的兼容性。大量的标准化的服务接口增强了它在这方面的地位。目前在对象服务器上对ORB特定的功能进行存取的实践，降低了基于CORBA服务器的可移植性。对于Java，对Java语言规范达成一致，即只要没有其他语言在Java平台上被使用，就解决了这个问题。于是语言绑定的标准化成为一个问题，不然由多种源语言产生的字节码之间的互操作将受到危害。Java包含了越来越多的（事实上是Sun的）标准，特别是其中的J2EE标准受到很多厂商的追随并提供了实现。COM没有任何源代码级标准或标准语言绑定的概念。COM接口市场的标准也没有超出微软事实上的标准。.NET CLR提供了通用语言规范（Common Language Specification, CLS）来指导语言绑定，它在没有规定单个语言绑定的情况下达到了很高程度的互操作性。位于CLR之下的公共语言基础设施（Common Language Infrastructure, CLI）规范，以及一组基框架和C#语言，都已经由ECMA进行了标准化</p>
<h5 id="逐渐形成的和仓促造就的标准"><a href="#逐渐形成的和仓促造就的标准" class="headerlink" title="逐渐形成的和仓促造就的标准"></a>逐渐形成的和仓促造就的标准</h5><p>在被制定成“标准”之前，COM、CORBA、Java和CLI标准（按照这个次序）经历了越来越短的演化期。COM（具有OLE1的）与CORBA（1.2）已经经过了不少实质性的修订，已经没有了向后的兼容性。COM/OLE/ActiveX有许多冗余的机制——例如外出接口和可连接对象（又被称为变化通知接口，也被称为advice接口）与分派接口（又叫做verb接口，在ActiveX出现以后，还被称为command target接口）。不同演化期长度的一个结果就是这些方法在市场上产品数量的不同。市场上有成千上万的ActiveX对象，而只有很少的Bean。然而，EJB构件已经在工业界获得了实质性的支持，虽然目前大多数的EJB构件只是在内部被开发和使用。对于CLI/CLR标准的构件，报告其市场的接受程度还为时过早。</p>
<h5 id="内存管理、生命周期和垃圾回收"><a href="#内存管理、生命周期和垃圾回收" class="headerlink" title="内存管理、生命周期和垃圾回收"></a>内存管理、生命周期和垃圾回收</h5><p>目前CORBA尚未提供解决分布式对象系统中的全局内存管理问题的一般方法。COM和DCOM完全依赖于引用计数——这在所有构件都遵循特定规则的情况下是可行的，但是在大的开放的分布式系统中存在伸缩问题。Java完全依赖于垃圾回收机制，JDK1.1以后通过使用Java RMI也定义了分布式对象模型并支持分布式垃圾回收，这个概念基于“租期”——预先指定远程引用的生命周期。CLR也采用垃圾回收机制并融入基于“租期”的对远程引用的生命周期控制。另外，CLR支持其他的通信和列集协议，诸如HTTP之上的SOAP。</p>
<h5 id="容器管理的持久性和关系"><a href="#容器管理的持久性和关系" class="headerlink" title="容器管理的持久性和关系"></a>容器管理的持久性和关系</h5><p>EJB创新性地引入了容器管理的持久性技术，并且从EJB2.0开始，还引入了容器管理的关系。CCM也有类似的技术，因为它可以算是EJB的超集。迄今为止，COM+和CLR都尚未提供这样的支持。这些机制仍然需要进行改进，例如一个J2EE服务器中过度热心地装载一个关系中的所有实体，导致了很多应用程序的性能低下。OLEDB（及COM+和CLR）支持可插拔的持久性映射，允许将数据保存到除数据库外的其他多种外部存储的持久性。2.0版本的EJB不包括对可插拔映射的支持，使得纯数据库应用程序外的容器管理的持久性和关系功能很弱。同样地，当映射需要复杂的连结或存储过程时，EJB 2.0的局限性也很大。</p>
<h5 id="演化和版本的概念"><a href="#演化和版本的概念" class="headerlink" title="演化和版本的概念"></a>演化和版本的概念</h5><p>COM坚持一旦接口和它们的接口ID被公布之后，就必须冻结接口和接口的规约。这样可以解决版本和移植问题，但在某些特定的部署场所使用受控的版本兼容策略时会暴露出一些问题。CORBA没有直接处理这个问题，而是选择支持主、次版本号这样一个较弱的概念。CORBA的解决方案是有问题的，因为它允许某个版本的对象的引用被传递给另一个希望接收不同版本对象引用的对象——版本检查只在对象创建的时候进行。Java只在二进制兼容性级别上考虑版本，为此给出了令人头痛的规则列表。有些规则的实际意义可能不大。例如，一个版本中某个常量的值在另一个版本中被改变，这对于以前编译过的客户程序不会有影响，它们只需简单地保持以前的值就可以了。虽然客户程序使用了不同版本，但是原有的客户程序仍然是可用的（尽管可能会出现一些功能失常），而不用声称该客户程序被破坏。构件Pascal的实现使用指纹标注每个接口的算法来保持小粒度上的兼容性（Crelier, 1994）。CLI拥有最完整的版本控制方法。CLI构件，被称为配件，都标记它们自己的版本信息，以及它们依赖的构件集合的所有版本信息。策略可以用来建立匹配版本的可容忍的范围。通过支持并行运行来允许一个构件的多个版本同时存在，这使得滑动窗口方式的移植成为可能——不是每个构件都需要立刻更新到一个新的版本。然而，最初的.NET框架和面向CLR的语言都没有利用CLI版本支持的全部优势。</p>
<h5 id="分类的概念"><a href="#分类的概念" class="headerlink" title="分类的概念"></a>分类的概念</h5><p>COM中的分类通常被忽视，因为这个概念比较新，并且看起来没有什么坏处，不过实际上，它引入了合约绑定到包含任意多个接口的规约这样的概念。一个构件可以属于任意数目的分类，一个框架或者其他构件可以使用分类成员资格作为高层的断言。Java和CORBA没有任何类似的概念，虽然Java中的空标记接口按照类似的目的被使用。CLI提供定制属性来扩展构件的元数据，因此分类和其他元信息可以使用定制属性来获取。</p>
<h5 id="产业界的实现支持及应用状况"><a href="#产业界的实现支持及应用状况" class="headerlink" title="产业界的实现支持及应用状况"></a>产业界的实现支持及应用状况</h5><p>这里，所有的方法有它们自己的领地。COM在客户机/桌面系统方面最强。J2EE和COM+则在基于非PC和基于PC的服务器的解决方案中占主导地位。Web服务器主要使用JSP或者ASP（现在还有ASP.NET）。CORBA在商业计算层次上对传统的遗留系统的集成是最强的。COM和CLR很大程度被限制在微软所提供的实现上。很多厂商提供了CORBA和J2EE的实现。从一个J2EE服务器移植到另一个J2EE服务器并不是一件容易的事情，但是当然要比J2EE和.NET间的移植简单很多。</p>
<h5 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h5><p>支持COM的开发环境相当多。Java的开发环境也比较多。支持CORBA的开发环境非常少，几乎没有。对于CLR——微软对CLI的实现，其开发环境是与之一起发布的Visual Studio.NET，该环境包括对Visual Basic、JScript、C#和Managed C++的支持。</p>
<h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>CORBA目前拥有全套的标准化服务，不过其中的大部分缺少商业实现。COM+用一组丰富的关键服务对COM进行了补充，其中包括事务和消息。包括EJB的J2EE也拥有相对丰富的服务。CLR用COM+提供高度的互操作性支持，包括所有的COM+服务（现在被称为企业服务）。然而，这些服务没有被CLI规范所涵盖。在未来，一些COM+服务可能发展成为真正的基于CLR的服务。在CORBA和COM+中提供了对分布式事务协作的支持（对于CLR也是同样的），不过并不包括在EJB 2.0标准的范围中。J2EE服务器的支持则会相应的不同。</p>
<h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><p>J2EE、COM+、CCM和CLR全都遵循基于属性编程的MTS概念。EJB将属性分离出来并将它们放置在单独的基于XML的部署描述符中，使得在特定的部署步骤中可以拥有清晰的操作对象。J2EE将部署描述符的概念扩大到若干个构件模型。CLR将基于XML的配置和基于CLI的定制属性组合到一起。定制属性简化了代码的排列，作为属性的元数据被直接存放在相应的源代码中。这样划分了开发者（放置定制属性）和部署者（处理配置文件）两者的任务。</p>
<h5 id="网络服务构件"><a href="#网络服务构件" class="headerlink" title="网络服务构件"></a>网络服务构件</h5><p>CORBA和COM在这方面没有特定的构件模型。J2EE有JSP和servlet构件。.NET框架有ASP.NET的页面构件类。JSP在某些方面遵循以前的ASP模型，但是在JSP页面与servlet方面有所改进。ASP.NET在某些方面遵循JSP模型，不过使用目标独立的方式，从而作为取代提供生成HTML的构件的方式，ASP.NET鼓励使用已有的生成界面显示的构件。因此，很多ASP.NET构件连一行HTML也不直接生成，使得它们独立于特定目标设备的要求，例如为移动设备生成WML显示。</p>
<h5 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h5><p>CORBA支持IIOP，用来作为ORB之间互操作的标准的传输协议。另外，OMG采用XML和XML Schema规范作为应用程序层的传输格式描述。Java支持IIOP绑定，不过也自然支持它自己的RMI协议。Java对XML的支持正在改进中。COM使用DCOM作为自身的传输协议，COM+增加了对多种消息格式的支持。CLR延续了COM和COM+所支持的所有格式，并添加了对XML schema定义和SOAP调用协议的支持。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch9-%E9%9D%A2%E5%90%91%E6%9E%84%E5%BB%BA%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch9-%E9%9D%A2%E5%90%91%E6%9E%84%E5%BB%BA%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch9-面向构建的软件设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:54:43" itemprop="dateCreated datePublished" datetime="2021-07-19T12:54:43+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-19 15:26:34" itemprop="dateModified" datetime="2021-09-19T15:26:34+08:00">2021-09-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="面向构件的软件设计"><a href="#面向构件的软件设计" class="headerlink" title="面向构件的软件设计"></a>面向构件的软件设计</h2><p>面向构件的软件设计是现在软件设计的重要方法，是软件生产线技术、软件工厂技术重要的理论基础。而在20世纪90年代之前，软件领域中的构件一直没有成功发展，这与软件领域中软件复杂度管理和软件复用粒度需求有关。术语“软件构件”的定义以及“构件化软件”等的仍然存在许多不同的观点，但构件概念已经在工程中被建立并且发展较为成熟，本章讨论软件构件的概念及构件化软件开发设计的方法与存在问题。</p>
<blockquote>
<p>他这里的构件,给我的感觉更像是docker的容器？<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/121698366">构件开发技术与微服务架构的区别</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuwc/p/13989081.html">SOA和微服务</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25089273">领域建模</a></p>
</blockquote>
<h3 id="构件的概念"><a href="#构件的概念" class="headerlink" title="构件的概念"></a>构件的概念</h3><p>人们经常不做区分地使用术语“构件”和“对象”，以及像“构件对象”这样的短语组合。对象常被称为是类的实例，对象和构件都通过类或接口向外界提供服务。对于对象和构件之间的交互，设计人员常用模式描述，用框架规范。而构件和框架又都常被称为是白盒的或黑盒的。程序语言设计者还不断提出诸如名字空间、模块、包等各种名词。这种术语和概念泛滥的现象亟待改变，应该消除它们的冗余歧义，或者对它们进行阐明、解释与辨析。这些都让术语“构件”更加扑朔迷离。</p>
<h4 id="术语与概念"><a href="#术语与概念" class="headerlink" title="术语与概念"></a>术语与概念</h4><p>构件技术蕴涵了太多概念。一个典型的例子就是含义众多的术语“对象”。随着时间的推移，模块、类和构件的概念都最终为“对象”所包括。最近，术语“软件构件”甚至到了把以前的普通对象也称作是构件的程度。将几个术语合并为一个，看起来似乎方便了使用，但除此之外再无其他好处。所以，必须在保证术语的准确度和直观性的前提下取得某种平衡。下面定义了几个关键的术语，并描述了它们之间的关系。</p>
<h5 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h5><p>构件的特性如下。</p>
<p>●　独立部署单元。</p>
<p>●　作为第三方的组装单元。</p>
<p>●　没有（外部的）可见状态。</p>
<p>这些特性有几重含义。一个构件是独立可部署的，意味着它必须能跟它所在的环境及其他构件完全分离。因此，构件必须封装自己的全部内部特征。并且，构件作为一个部署单元，具有原子性，是不可拆分的。也就是说，第三方没有权利访问其所使用的任何构件的内部细节信息。</p>
<p>在这样的约束下，如果第三方厂商能将一个构件和其他构件组装在一起，那么这个构件不但必须具备足够好的内聚性，还必须将自己的依赖条件和所提供的服务说明清楚。换句话说，构件必须封装它的实现，并且只通过良好定义的接口与外部环境进行交互。</p>
<p>最后，一个构件不能有任何（外部的）可见状态——这要求构件不能与自己的拷贝有所区别。但对于不影响构件功能的某些属性，例如，用于计费的序列号，则没有这种限制。通过对属性的可见性进行限制，允许用户在不影响构件的可见行为的前提下，使用合法的技术手段对那些影响性能的状态进行特殊处理。特别是，构件可以将某些状态专门用于缓存（缓存具有这样的特性：当它被清空时除了可能会降低性能以外，没有其他后果）。</p>
<p>构件在特定的系统中可以被装载和激活。但是，由于构件本质上没有状态，因此，在同一操作系统进程中装载多个构件的拷贝是毫无意义的，而且它们之间是不可区分的。也就是说，给定一个进程（或者其他的语境），至多会存在一个特定构件的拷贝。因此，谈论某个构件的可用拷贝的数量是没有什么意义的。</p>
<p>在目前许多系统中，构件被实现为大粒度的单元，系统中的构件只能有一个实例。例如，一个数据库服务器可以作为一个构件。如果这个服务器刚好只维护了一个数据库，那么会很容易把该数据库误认为是实例，如公司里的员工工资管理服务器。该数据库服务器连同其中的数据库，可以被视为一个有可见状态的模块。根据上面的定义，该数据库并不是一个构件，但那个静态的数据库服务器程序却是一个构件——它只支持一个数据库“对象”实例。也就是说，在这个例子中，工资管理服务器程序是一个构件，而其中的工资数据只是实例（对象）。这种将不易变的“模型”和易变的“实例”分离的做法避免了大量的维护问题。如果允许构件拥有可见状态的话，那么任何两个来自同一个构件的实例都不会拥有相同的属性。</p>
<p>在这一点上一定要分辨清楚。这里所说的构件的概念与对象层次上的可见或不可见状态无关，也与对象状态的生命周期（每次呼叫，每次会话，或是永久的）无关。这些全都是对象层次上所关心的东西，与构件的概念并没有直接的关系，但是通过构件，我们可以获得拥有任何这些属性的对象。</p>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>说起对象，不得不提实例化、标志和封装。与构件的特性不同，对象的特性是：</p>
<p>（1）一个实例单元，具有唯一的标志。</p>
<p>（2）可能具有状态，此状态外部可见。</p>
<p>（3）封装了自己的状态和行为。</p>
<p>同样，对象的一系列属性随之而来。由于对象是一个实例化的单元，所以不能被局部初始化。由于对象有各自的状态，它必须有唯一的标志，以使它在整个生命周期内，无论状态如何变化，都能够被唯一地识别。</p>
<p>当对象被实例化的时候，需要一个构造方案来描述其状态空间、初始状态和新生对象的行为。该方案在对象存在之前就已经存在。显式存在的实例化方案称为类。也有隐式的实例化方案，即通过克隆一个已存在的对象来实现，即原型对象。</p>
<p>无论使用类的形式，还是用原型对象的形式来初始化一个对象，这个新生的对象都必须被设置一个初始状态。创建与初始化控制对象的代码可以是一个静态的过程——如果它是对象所从属类的一部分，就被称为构造函数。如果这个对象是专门用来创建与初始化对象的，则简称为工厂。对象中专门用来返回其他新创建的对象的方法常被称为工厂方法。</p>
<h5 id="构件与对象"><a href="#构件与对象" class="headerlink" title="构件与对象"></a>构件与对象</h5><p>构件的行为显然可以通过对象来实现，因此构件通常包含了若干类或不可更改的原型对象。除此之外，构件还包括一系列对象，这些对象被用来获取默认的初始状态和其他的构件资源。</p>
<p>但构件并非一定要包含类元素，它甚至可以不包含类。实际上，构件可以拥有传统的过程体，甚至全局变量，它也可以通过函数语言，或者汇编语言，或者其他可用方法实现自身的全部特性。构件创建的对象——更确切地说是对这些对象的引用——可以与该构件分离开来，并对构件的客户可见。构件的客户通常是指其他的构件。除非构件的对象对客户可见，否则我们无从判断一个构件内部是否是“完全面向对象”的。</p>
<p>一个构件可以包含多个类元素，但是一个类元素只能属于一个构件。将一个类拆分进行部署通常没什么意义。另外，正如类之间可以通过继承关系等产生依赖一样，构件之间也可以存在互相依赖的关系——这种依赖很重要。一个类的父类并不一定与它的子类存在于同一个构件中。如果一个类的父类存在于外部的其他构件中，那么这两个类之间的继承关系便是跨构件的，这种关系将会导致相关联的构件间的导入关系。规约的继承是保证正确性的一项很关键的技术，因为共同的规约是构件间达成共识的基础。至于构件间对实现的继承是好是坏，仍然是众多学术流派争论的焦点。</p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>构件与模块的概念其实非常类似。模块的概念出现于20世纪70年代后期的模块化语言（Wirth, 1977; Mitchell等人，1979）。最广泛使用的模块化语言是Modula-2 (Wirth, 1982）和Ada。在Ada里面，模块被称做包，但其实两者是相同的。模块化方法成熟的标志是其对分离编译技术的支持，包括跨模块的正确的类型检查能力。</p>
<p>随着Eiffel语言的面世，类被认为是更好的模块（Meyer, 1988）。这似乎是正确的，因为我们最初的想法是每个模块实现一种抽象数据类型。毕竟，我们可以把一个类看成是一个抽象数据类型的实现，只不过它多了继承和多态的特性而已。然而，模块常常被用于把多个诸如抽象数据类型、类等实体打包到一个单元中。并且，模块没有实例化的概念，而类却有。</p>
<p>在其后出现的程序设计语言中——比如Modula-3，Component Pascal，和C#模块的概念（C#中的集合）与类的概念是区分对待的。在任何情况下，模块都可以包含多个类。在有些没有模块概念的语言（诸如Java语言）中，模块可以通过嵌套类来模拟实现。类之间的继承关系并不受模块界限的限制。另外值得一提的是，在Smalltalk系统中，经常会通过修改当前已存在的类来构造一个应用程序，人们已经开始尝试定义“模块系统”，这将使Smalltalk越过类而直接达到构件级水平，例如Fresco（Wills, 1991）。</p>
<p>模块本身就可以作为一个最简单的构件。即使不包含任何类元素的模块也可以实现构件的功能。传统的数值计算函数库就是一个很好的例子，这些库是功能性的，而不是面向对象的，但却可以打包成模块。然而，一个成熟的复杂的构件却并不是简单地仅用模块就可以实现的。模块没有持久不变的资源，有的只是那些被硬编码到程序中的常量。资源可以参数化一个构件。通过替换这些资源，就可以重新配置该构件而无需更改构件代码。例如，本地化设置可以通过资源配置实现。看起来资源配置好像为构件赋予了可变的状态值。但是我们知道，构件不能修改它们自身的资源，这些资源与编译后的代码一样只是构件的组成部分。追踪一个构件与它所派生的本地化了的构件之间的关联，在某种程度上，和追踪同一构件的不同的发布版本之间的关系相似。</p>
<p>某些情况下，模块并不适合作为构件，掌握这些情况是非常有用的。根据本书的定义，构件没有外部可见的状态，但是模块却可以显式地用全局变量来使其状态可见。并且，通过直接导入其他模块的接口，模块之间可以存在静态的代码依赖。而对于构件来说，虽然也允许存在对构件外部代码的静态依赖关系，但却并不提倡。这种静态依赖关系应被限定用于那些合约元素，包括类型和常量。使用间接而非直接的接口表示模块的依赖关系，把对实现代码的依赖关系限定于对象层次，就可以利用同一接口的不同实现来灵活地组装模块。</p>
<p>总的说来，模块化是构件技术产生的前提，但对于构件来说，传统的模块化的概念和标准是远远不够的。很多模块化的概念源自Parnas（1972），其中包括最大化内聚性与最小化耦合性这条基本原理。因此，模块化的思想并不新鲜。但遗憾的是，现今的大部分的软件仍然不是模块化的。比如，有不少的大型企业应用都是对一个单一的数据库进行操作，允许应用系统的任何一部分依赖于数据模型的任何部分。但构件技术则要求系统中各部分必须互相独立，或者存在可控的显式依赖关系。因此构件技术必将导致模块化的解决方案。这种软件工程效益充分说明对构件技术的投资是有价值的。</p>
<h5 id="白盒抽象、黑盒抽象与重用"><a href="#白盒抽象、黑盒抽象与重用" class="headerlink" title="白盒抽象、黑盒抽象与重用"></a>白盒抽象、黑盒抽象与重用</h5><p>黑盒抽象与白盒抽象的区别主要在于接口“后面”的实现细节是否可见。在理想的黑盒抽象的情况下，客户对接口和规约之外的实现细节一无所知。而在白盒抽象中，在接口限制了用户行为并确保了封装性的情况下，客户仍然可以通过继承对构件的实现细节进行修改。由于在白盒方式中实现细节对外界是完全可见的，因此可以对实现细节进行研究，以加深对该接口抽象含义的理解。</p>
<p>揭示实现细节的可控部分。这是一个有争议的概念，因为部分可见的实现细节可以是规约的一部分。一个完整的实现只需要保证，能被客户看见的那部分实现细节与抽象的接口规约一致即可。这是将规约实现的标准方式。</p>
<p>黑盒重用指仅仅依赖接口和规约来实现。比如，在绝大多数系统中，应用程序接口（Application Programming Interface, API）完全与内部的具体实现无关。用这样的应用程序接口构造系统相当于黑盒重用这些接口的实现。</p>
<p>相反，白盒重用指依赖于对具体实现细节的理解，通过接口来使用软件部件。大部分类库和框架都会提供源代码，应用程序开发人员通过学习类的具体实现，就可以知道如何构造该类的子类。</p>
<p>在白盒重用中，被重用的软件不可以轻易地被另外的软件替换。如果贸然替换将有可能破坏正在重用的客户端，因为这些客户端依赖于那些在未来可能发生改变的实现细节。</p>
<p>根据上述特性可以得出以下的定义：“软件构件是一种组装单元，它具有规范的接口规约和显式的语境依赖。软件构件可以被独立地部署并由第三方任意地组装。”</p>
<p>这个定义最先是在1996年的面向对象程序设计欧洲会议上（European Conference on Object-Oriented Programming, ECOOP），由面向构件程序设计工作组（Szyperski和Pfister, 1997）提出。该定义涵盖了我们之前讨论的那些构件特性。它既包括了技术因素，例如独立性、合约接口、组装，也包括了市场因素，例如第三方和部署。就技术和市场两方面的因素融为一体而言，即使是超出软件范围来评价，构件也是独一无二的。</p>
<p>而从当前的角度看，上述定义仍然需要进一步澄清。一个可部署构件的合约内容远不只接口和依赖，它还要规定构件应该如何部署、一旦被部署（和启动）了应该如何被实例化、实例如何通过规定的接口工作等。事实上，各个接口的规约都应该被独立地看待，任何提供与使用该接口实现的构件之间都是相对独立的。比如，一个实现队列操作的构件通过一个接口获得物理存储空间，通过另外两个接口提供入队列和出队列的操作。在构件的合约中说明，通过入队列接口插入队列的元素，可以通过出队列接口中的操作取出来，这种关联关系，任何接口规约都不能单独提供。该合约同时也规定构件一旦被实例化，就必须在关联一个实现了物理存储空间接口的构件之后才能被使用。这种关联将受到底层构件模型的组装规则的影响。具体的部署和安装的细节由特定的构件平台提供。</p>
<h5 id="color-green-text-接口"><a href="#color-green-text-接口" class="headerlink" title="$\color{green}{\text{接口}}$"></a>$\color{green}{\text{接口}}$</h5><p>接口是一个已命名的一组操作的集合。构件的客户（通常是其他构件）通过这些访问点来使用构件提供的服务。通常来说，构件在不同的访问点有多个不同的接口。每一个访问点会提供不同的服务，以迎合不同的客户需求。强调构件接口规范的合约性非常重要，因为构件和它的客户是在互不知情的情况下分别独立开发的，是合约提供了保证两者成功交互的公共中间层。</p>
<p>成功的合约接口需要遵循哪些非技术因素？首先，必须时刻关注经济效益。一个构件可以有多个接口，每一个接口提供一种服务。有一些服务会格外受客户欢迎，但是如果所有服务都不受欢迎，那么服务的组合也不会受欢迎，这个构件就没有市场价值了。这样的话，就没有必要在非构件的实现方案的构件化上进行投资了。</p>
<p>其次，应当避免不当的市场分化，因为这威胁到构件的生存。所以，尽量不要重复引入功能相近的接口。在市场经济中，这通常是主要生产商在市场早期努力推行标准化的结果，或者是经过残酷的市场竞争优胜劣汰的结果。但是，前者可能会由于笨拙官僚的“委员会设计”问题而不能达到最优；而对于后者，市场竞争的非技术本质也可能导致结果不是最优的。</p>
<p>最后，为了使一个接口的规范和实现该接口的构件得到广泛应用，需要有一个公共传媒来向大众进行宣传和推广。要做到这一点，至少需要几种能被广泛认可的保证命名唯一性的命名方案。 $\color{red}{\text{接口标准化}}$ 的一个非常有意思的变种，是对 $\color{green}{\text{消息的格式}}$ 、 $\color{green}{\text{模式}}$ 和 $\color{green}{\text{协议}}$ 的标准化。它不是要将接口格式化为参数化操作的集合，而是关注输入输出的消息的标准化，它强调当机器在网络中互连时，标准的消息模式、格式、协议的重要性。这也是因特网（IP、UDP、TCP、SNMP等）和Web（HTTP、HTML等）标准的主要做法。为了获得更广泛的语义，有必要在一个单一通用的消息格式语境中标准化消息模式。这就是XML的思想。XML提供了一种统一的数据格式。</p>
<h5 id="显式语境依赖"><a href="#显式语境依赖" class="headerlink" title="显式语境依赖"></a>显式语境依赖</h5><p>在上文的构件定义中，构件除了要说明所提供的接口外，还要说明其需求。也就是说为了使构件正常地工作，必须说明其对部署环境的具体要求。这些要求被称为语境依赖，指的是构件组装和部署的语境，包括了定义组装规则的构件模型和定义构件部署、安装和激活规则的构件平台。如果只存在一种软件构件体系的话，那么只需要列举该构件所需的所有其他构件提供的接口，这样就足够可以说明全部的语境依赖。例如，一个合并邮件的构件会声明它需要一个文件系统的接口。但是，今天的大多数构件即使连这样的需要的接口也通常不进行声明。而构件提供的接口更受关注。</p>
<p>事实上，目前有几种构件体系同时存在，它们相互竞争，彼此冲突。例如，现在就有OMG的CORBA，Sun的Java，以及微软的COM和CLR（Common Language Runtime）等体系。并且，因为要支持不同的计算和网络平台，构件体系本身并不是单一的。这种状况还没有很快改善的迹象。而另外一种观点则认为，所有这些构件体系最终都只能归结为两类——CORBA+Java体系和微软体系（包括COM+和.NET/CLR）。但即使构件体系被刻意减少到不能再少的区区两种，在具体实现层次上还是存在着千差万别的。</p>
<h5 id="构件的规模"><a href="#构件的规模" class="headerlink" title="构件的规模"></a>构件的规模</h5><p>显然，构件只有在提供了“恰当”的接口集，以及对语境依赖没有严格限制的情况下，该构件可以在所有的构件体系中运行，并且其依赖的接口不会超出那些构件体系所能提供的范围时最好用。然而，只有极少的构件拥有这么弱的环境依赖性。技术上来说，一个构件可能和它所需要的所有软件捆绑起来被提供，但这显然违背了使用构件的初衷。注意，环境需求往往取决于构件运行的目标机器。如果是虚拟机，例如Java虚拟机，这就显然是该构件体系规范的内容之一。如果是本地代码平台，仍然有类似于Apple的将多个二进制文件打包成一个文件的Fat Binaries这样的机制，可以使构件在“所有地方”运行。</p>
<p>构件设计者通常不会构造自给自足的构件，将所需的所有东西都打包进来，而是采取一种“最大化重用”的策略。为了避免在构件中重复实现那些次要的服务，设计师通常会只实现该构件的核心功能，然后重用其他所有的一切。面向对象的设计有向这种极端发展的趋势，许多面向对象的方法论者都大力提倡这种最大化重用的思想。</p>
<p>虽然最大化重用的思想有很多为人称道的优点，但是它也有一个潜在的缺点——语境依赖的爆炸性增长。如果构件在发布后其设计一直冻结不变，同时所有的部署环境也都一样，那么这个问题就不会出现。然而，构件会不断地演化，不同的部署环境会提供不同的配置，多种版本会同时存在，在这样的情况下大量的语境依赖只会使构件成为众矢之的。语境依赖越多，能满足构件环境需求的客户构件就越少。总之，最大化重用降低了可用性。</p>
<p>构件设计者需要为以上两者找到一个平衡点。当要描述构件的基本接口的时候，设计者们就需要做出抉择。增加语境依赖通常会使构件因重用而简洁，但却会降低可用性。此外，还必须考虑环境的演化会使构件更加脆弱，例如引入新版本带来的变化。增加构件的自给性可以减少语境依赖，增加可用性，并且使构件更健壮，但却会使构件规模过大。</p>
<h4 id="标准化与规范化"><a href="#标准化与规范化" class="headerlink" title="标准化与规范化"></a>标准化与规范化</h4><p>通过提高接口与构件体系的标准化和规范化程度，可以使上文优化问题中的最优点偏向于简洁性一侧。一个东西越稳定，越容易被广泛接受，其成为某个构件的特殊需求的危险就越小。如果语境依赖能够被广泛支持，就不是什么缺点。比如仅仅在50年前，要求客户必须拥有电话才能谈妥生意是极不明智的。而现在，在世界上的许多地方，拥有电话已经成为必要条件。</p>
<h5 id="通用市场与专业市场"><a href="#通用市场与专业市场" class="headerlink" title="通用市场与专业市场"></a>通用市场与专业市场</h5><p>如果要制定一种覆盖所有领域、有广泛市场的标准，就有必要区分面向通用市场与面向专业市场的两种标准。通用市场覆盖了多数甚至全部不同的市场领域；它对所有或绝大多数的客户和生产商都有影响。专业市场往往只限于某个特定的领域，相对来说影响比较小。例如，因特网和万维网的标准都属于通用市场标准。与之相反，放射医学领域的标准就只影响一个比较窄的专业市场，却同样会占有相当大的市场份额。</p>
<p>通用市场的标准化是非常困难的。如果有一项服务几乎和每个人都相关，那么它就得满足所有人的需求。想像一下那些通用程序设计语言标准化委员会，他们为顾全各方面的利益而疲于奔命。与此同时，成功的标准只有在通用市场中才能形成最广泛的影响，网络标准就是其中最好的例子。</p>
<p>令人吃惊的是，专业市场的标准化与通用市场同样艰辛，虽然原因各不相同。由于专业市场中涉及的人相对较少，所以比较容易形成一种折中的方案。然而，如果某个专业领域正在考虑标准化，那么为了培育市场，该领域就不能够太窄。由于所涉及的人较少，市场经济的机制就不容易很好地发挥作用，也就不太可能在短期内找到理想的、成本效益好的解决方案。</p>
<h5 id="标准的构件体系与规范化"><a href="#标准的构件体系与规范化" class="headerlink" title="标准的构件体系与规范化"></a>标准的构件体系与规范化</h5><p>在基本构件体系和那些最重要的接口合约形成标准，并且在这些标准被相关的工业界支持的情况下，构件技术最为成功。然而，要发挥标准化的作用，就必须使与之竞争的其他标准的数目尽量很小。如果某个标准背后有一个强大的国际标准化组织认可，有一个非常有实力的企业推动，有众多有影响力的公司或组织联合支持，那么一切自然不成问题。然而，通常却是几个标准在相互竞争。如果因专业市场各自为政，导致某标准在不同领域重复建设，而该标准又可能适合其他领域，就可能出现戏剧性的结果：很多原先互不知情的标准竞争者在一夜之间一起出现。例如，放射医学和射电天文学就可以共享多种图像处理标准。</p>
<p>如果相互竞争的标准过多，而其相应的市场份额过小，就可能引发危机，这个问题可以通过规范化的手段来解决。公布共同的设计“模式”，并对其进行编目，原来互不知情的各方标准化实体就有可能在各自的目标领域发现共同点。当然，寻找和利用共同点的努力是否值得，即成本效益是否理想是个规模效益的问题。</p>
<h3 id="构件的布线标准"><a href="#构件的布线标准" class="headerlink" title="构件的布线标准"></a>构件的布线标准</h3><p>“布线”用于连接电子构件。无论天然气、水或排污系统，对于所有要连接的部件来说，管道工程本质上是相同的。对于可连接的构件来说，这一级的标准是重要的。但是，需要注意的是不要高估了“布线”标准的重要性。比如说，庞大的世界范围内的电话系统之间的互联互通就是一个例子。</p>
<h4 id="布线标准从何而来"><a href="#布线标准从何而来" class="headerlink" title="布线标准从何而来"></a>布线标准从何而来</h4><p>由于过程的交互为进程边界所限，所以操作系统支持多种多样的进程间通信（Internet Process Connection, IPC）机制，典型的例子有文件、套接字（socket）及共享内存。除了BSD-UNIX套接字外，这些机制都不能跨平台移植。</p>
<p>IPC机制的一个共同的优势是：它们可以很容易地被扩展到网络甚至是因特网上。这是传统进程模型的直接结果。在这个传统进程模型中，每个进程产生了一个幻象，就好像一个共享的物理主机上的每个进程都拥有单独的虚拟机。</p>
<p>RPC的设想是在本地被调用者和远程调用者两端都使用指代（stub）。调用者使用严格的本地调用约定，就像调用了一个本地被调用者，实际上，却调用了一个本地指代来编排（串行化）参数，并把它们发送到远端。在远端，另一个指代接收参数，并还原（反串行化）参数，然后调用真正的被调用者。和调用者一样，被调用者的过程本身也要遵循本地调用约定，并且不知道自己被远程调用了。编排和还原过程负责转化数据值，将它们从本地表示转化为网络格式，然后再转化为远端表示。通过这种方法，格式的差异等被跨越了。</p>
<p>分布式计算环境（DCE）是OSF （Open Software Foundation, Open Group的一部分）的一个标准，它是在跨越异构的平台上实现RPC机制的最重要的服务。在另一个极端，轻量RPC变化能被用来处理单机上的IPC问题。例如，Windows支持跨进程的轻量RPC；DCOM出现后，可以支持不同机器间的完全RPC。DCE也通过对每个服务附加主版本号来支持版本控制。客户可以指定他们想要版本的服务。</p>
<p>潜在的透明性既是RPC的优点，同时也是其负担。因为它隐藏了本地调用、进程间调用及机器间调用的很重要的代价上的差异。在大多数当前的体系结构上，进程间调用比本地调用慢10～1000倍，而机器间调用比进程间调用慢10～10000倍。</p>
<blockquote>
<p>RPC<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41609070/answer/2079027802">既然有 HTTP 请求，为什么还要用 RPC 调用？</a>:RPC的接口规范基于代码。http的接口规范基于文档。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357118189">RPC实现原理之高并发场景下的技术运用</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349263565">RPC是在什么场景使用？</a></p>
</blockquote>
<p>接口定义语言（Interface Definition Language, IDL），保证了不同环境下过程调用语义的一致性。对每一个可以被远程调用的过程，IDL指定了参数的数目、传递模式和类型，以及可能的返回值的类型。为了确保跨机器边界的通信正常工作，所有的IDL都必须固定基本类型的范围，例如指定整数是32位的二进制的补码值（二进制的补码表示是一种以二进制形式表示负数的数学方案）。</p>
<p>过程调用及它们的二进制调用约定提供了一个良好证明的“布线”标准。但是它们还不能直接支持对象所需要的远程方法调用。如果和动态链接库（Dynamic Link Library, DLL）结合起来，远程过程调用就会在为构件“布线”形成一个有用的基础的过程中更进一步。服务可以通过名字（DLL的名字）来定位，并被动态地绑定（不仅在编译时刻），而且服务可以是远程的。今天，Web服务似乎已成为事实上的构件布线标准。</p>
<h4 id="从过程到对象"><a href="#从过程到对象" class="headerlink" title="从过程到对象"></a>从过程到对象</h4><p>使对象调用与过程调用区别开来的首要因素在于它们很靠后的、数据驱动的调用代码选择。一个方法调用，除非是优化过的，否则总会去检查接收消息的对象的类，并从该类提供的方法中选择方法实现。而且，一个方法总是将目标对象的引用作为另一个参数向外提供，该引用是消息发往的地址。面向对象编程的大多数优点来自方法调用的属性。</p>
<p>有趣的是，当前的对象调用并不遵循标准平台调用约定。原因很简单，就是由于当前的操作系统和它们的库有过程化的接口，因而对操作系统提供商来说从来就没有必要定义方法调用约定。结果，使用不同的编译器编译出来的代码就无法互操作，甚至使用同一种语言实现的代码也不行。为了通用，一个面向对象的库必须以源代码的形式发布。这也是为什么可执行类库（而不是源代码）在这种面向对象的情况下远不及在过程化的情况下流行的原因。</p>
<p>在实现了过程调用的机器上实现方法调用是可能的。比如IBM的系统对象模型（System Object Model, SOM）就是这么做的。在SOM中，所有的语言绑定只是简单地调用SOM库过程，然后在SOM运行时刻动态地选择要调用的方法。CORBA的ORB（Object Request　Broker）是另一个例子——最新版本的SOM实际上就是基于CORBA的。Microsoft的COM也非常接近于仅使用过程调用约定，虽然它依赖包含函数指针的过程变量表（也称分配表）。但这不是问题，因为过程变量很久以来已经是调用约定的一部分。</p>
<p>另一个可能的方法是为方法调用定义一个带有内建支持的新的虚拟机层。这就是Java虚拟机和.NET的运行时刻公共语言采用的方法。但是，和库的支持及系统范围的调用约定不同，虚拟机可能阻止或干扰超越它的边界的互操作。因此，JVM和CLR都为跨越虚拟机边界的互操作提供特殊的支持。</p>
<h4 id="深层次问题"><a href="#深层次问题" class="headerlink" title="深层次问题"></a>深层次问题</h4><p>如果在执行层上过程调用约定几乎是能胜任的，那为什么还要有这么多不同的竞争的提议呢？原因在于，为了实现互操作，还有其他的重要方面需要被考虑和标准化。需要回答的问题包括“接口如何指定”、“当离开它们的本地进程后对象引用如何处理”、“服务如何被定位和提供”及“构件演化如何处理”。</p>
<h5 id="接口和对象引用规范"><a href="#接口和对象引用规范" class="headerlink" title="接口和对象引用规范"></a>接口和对象引用规范</h5><p>什么是接口？所有当前的方法一律将接口定义为一个已命名的操作的集合，每个操作带有一个已定义的特征标记（signatrue）和可能的返回值的类型。操作的特征标记定义了该操作的参数的数目、类型及传递模式。接口和什么相连接？对于这个问题，每种方法的处理是不同的。那些基于传统的对象模式的方法在接口和对象之间定义一个一对一的关系（CORBA 2.0, SOM）。对象在接口后面提供状态和实现。其他的方法将多个接口和一个单独的对象联系起来（Java, CLR），或者把多个接口和一个构件对象的多个部分对象联系起来（CORBA 3.0的COM, CCM）。明显地，一旦出现一个接口后面有多个对象的情况，就有身份标志的问题产生并且需要处理（为了这个原因，COM和CCM提供了一个特殊的接口）。</p>
<p>如何指定接口？所有传统的处理方式都遵循DCE（Data Communications Equipment），并且使用IDL。遗憾的是，真正使用的不是单个的IDL，而是存在着的几个竞争的提议，特别是OMGIDL和COMIDL这两个最强大的竞争者。Java和CLR没有IDL，这里，相关信息作为元数据被保留并可以映射到任何被支持的语言。程序员可以使用他们熟悉的语言来看待接口和其他类型定义，而不需要去学习他们熟悉的语言之外的一种IDL。所谓的Java IDL，实际上是一种结合了一个IDL到Java编译器的Java可调用的CORBA ORB。通过一个从Java类型到OMG IDL（反之亦可）的映射来支持Java。在OMG IDL和COM IDL之间也已经定义了一个相似的双向映射。目前OMG IDL和CLR类型之间或者和更多的特定于C#的类型之间还没有相似的映射。</p>
<p>什么是对象引用？当它们作为一个远程方法调用的参数被传递时是如何被处理的？每种方法的做法是不同的。但所有的方法都有一些机制，用于把本地的有意义的引用映射到包含跨进程、机器及网络边界的引用。</p>
<h5 id="接口关系和多态性"><a href="#接口关系和多态性" class="headerlink" title="接口关系和多态性"></a>接口关系和多态性</h5><p>所有的方法都规定了多态性。在所有的情况下，某个具有一个已知接口的实体可以是多个不同的、可能实现中的一个。同时，在所有的情况下，一个实现所能提供的方法比接口指定的要多。</p>
<p>在细节上，所有的做法都是不同的。CORBA 2.0遵循一个传统的对象模型。一个对象有一个单独的接口，但这个接口可能是由其他的接口使用接口多继承组合而成的。实际提供的接口可能是所期望接口的子类型，其额外附加的能力可以被动态地发现。CORBA 3.0中的CCM支持多接口继承及在它们间动态的导航。COM也明确地支持除了被共同支持的已经提供的接口之外的必需的接口。COM拥有不变的接口，也就是说一旦发布则不可扩展或修改。单接口继承被支持用来从已发布的接口派生出新的接口。但是，一个COM对象可以拥有多个接口。对一个特定的对象来说，它提供的接口的集合可能会随着时间的流逝而变化，并且可以被动态地发现。通过约定，COM支持必需的接口。一个Java对象也可以实现多个接口，但是这更接近于多接口继承而不是COM那样的完全分离的接口，一个对象所实现的接口的集合由这个对象的类静态地确定。同样的情况也适用于CLR对象。Java接口的多继承的传统在试图支持有冲突的方法名的接口时会导致问题的出现——Java对象不能支持多个这样的接口。COM和CLR都维护不同接口上的方法在实现层次上的分离，而不关心方法的名字。CLR模型在支持多接口继承方面也超出了COM，像Java或CORBA。和COM一样，Java和CLR仅通过约定的方式采取了支持必需的接口的做法。</p>
<h5 id="命名和定位服务"><a href="#命名和定位服务" class="headerlink" title="命名和定位服务"></a>命名和定位服务</h5><p>接口是如何命名的？它们是如何相互关联的？没有两种做法对这两个问题的处理是完全一致的。COM采用了DCE的UUID（Universally Unique Identifier）的做法，在COM中被称为全局唯一标志符（Globals Unique Identifiers, GUID）。GUID用来唯一地命名多样性的实体，包括接口（Image Impoet Descriptor, IID）、接口的组（称为分类（Category ID, CATID））以及类（Class ID, CLSID）。OMG CORBA最初是把唯一命名留下用来单独实现的，依赖语言的绑定来维护程序的可移植性。在CORBA 2.0中，引入了全局唯一标志符。这些既可以是DCE UUID，也可以是类似于常见的用于万维网的统一资源定位符（URL）的字符串。Java完全依赖由内嵌的命名包来建立的唯一的名字路径。CLR提供类似的有资格的名字来建立一个可读的命名方案，但最后把所有的名字都放入那些所谓的强组装名字（strong names of assemblies）。其实有很大的可能性，私有/公有密钥对中公有的那一半是独一无二的。这就是说，尽管标志符使用唯一的标志符来支持个别的名字，但CLR可以使用一个独一无二的标志符来支持整个名字家族，只要这样的名字家族是在一个单独的组装中（一个CLR软件构件）被一起发布的。通过给定一个名字，所有的服务都提供一些注册表或者库的分类来帮助定位相应的服务。在这个类似目录的功能之上，所有的方法都还提供某种程度上的关于可用服务的一些元信息。所有方法都支持的最小的功能是，对被提供的接口类型的运行时刻的测试、接口的运行时刻反射及新实例的动态生成。</p>
<h5 id="复合文档"><a href="#复合文档" class="headerlink" title="复合文档"></a>复合文档</h5><p>软件构件的第一个实用方法是复合文档模型。复合文档是一个模型，对那些构成，即用户来说，在模型中构件及其合成具有直观的意义。Xerox Star系统是第一个基于Xerox Palo Alto研究中心的研究结果的，但是没有能够获得足够的市场和观念份额。第一个突破是苹果公司的Hypercard，因为它有简单直观的合成及使用模型，但是创建新的构件却是一件困难的事情。Microsoft的Visual Basic也遵循了它，对Visual Basic控件有一个合理的编程模型。有了Microsoft的OLE和苹果公司的OpenDoc技术后，一般的文档都可以遵循它了。后来，嵌入对象比如Java applets和ActiveX控件的网页的出现，增加了一个新的维度。</p>
<p>在OLE中，复合文档的概念更前进了一步。首先，任意的容器可以被允许。除Visual Basic表单外，Word文本、Excel电子表格、PowerPoint幻灯片等，都变成了OLE（Object Linking and Embedding）容器。而且，“控件”的概念被推广到任意的文档服务器中去。然而最大的变化是构件可以同时是文档容器和服务器。结果，Word文本能被用来注释一张PowerPoint幻灯片，而这张幻灯片也能被嵌入到另一Word文本里去。</p>
<p>复合文档还可以是一个把对象嵌入到了HTML页面里的网页。浏览器为所有的Web页面提供一个统一的文档模型。嵌入对象，比如Java applets，能根据需要加入细节。但是，现在有了强大的服务器端Web编程模型，例如Sun的JSP（Java Server Page）和Microsoft的ASP（Active Server Pages）及目前的ASP.NET。当合成一个基于后端数据和用户输入相结合的复合文档的时候，现代Web页面远远超过OLE技术的地方，正是这种服务器端模型。</p>
<h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>尽管1998年才出现，但XML（扩展标记语言；W3C, 2000b）在此前大量尝试都失败的地方获得了成功。一部分原因是由于XML的一些有趣的属性；一部分是由于合适的时机。XML的到来与一个数量大量增长着的领域相关，特别是电子商务的领域需要用XML标准化。</p>
<p>XML对于表示任何（半）结构化的数据十分有用，新的XML的应用就应运而生了。除了消息、Web页和传统文档之外，现在普遍用XML来配置数据，即使这些数据从未被其他任何应用（而不是为之定义方案的应用）处理过或者阅读过，使用XML仍然是有用的。浏览器比如Internet Explorer，直接支持显示和查找XML文档。还有很多的工具为基于XML的数据提供其他普遍支持的形式，这些工具包括编辑器、方案检查器和方案驱动的翻译器。没有异常情况的话，XML在独立起源和操作的应用间作为一门公共语言来使用会获得最大的好处。在某种意义上，XML成了从协议和“布线”格式层到持久数据表示层的“布线”标准的概念。</p>
<h3 id="构件框架"><a href="#构件框架" class="headerlink" title="构件框架"></a>构件框架</h3><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>系统的体系结构是任何大规模软件技术的关键基础，在基于构件的系统中起着至关重要的作用。只有当整体的体系结构良好地定义和维护，构件及系统的升级和维护才会有坚实的基础。构件体系结构的核心包括：构件和外部环境的交互；构件的角色；标准化工具的界面；对最终用户和部署人员的用户界面等。</p>
<h5 id="体系结构的角色"><a href="#体系结构的角色" class="headerlink" title="体系结构的角色"></a>体系结构的角色</h5><p>体系结构是关于一个系统的整体视图，一个体系结构从总体上定义了总体的不变性，即那些根据这个特定的体系结构建立起来的所有系统的共同属性。体系结构把核心资源分类，以支持在资源竞争下的独立性。操作系统就是一个很好的例子，通过定义独立的进程之间如何竞争资源，操作系统部分地定义了运行于其上的系统所采用的体系结构。</p>
<p>体系结构为所有涉及的机制规定了恰当的框架，限制自由度，以控制变化性并支持协作。体系结构包括了所有支持独立使用机制进行互操作的策略决策。策略决策包括构件的角色。</p>
<p>体系结构需要基于对整体功能、性能、可靠性和安全性的主要考虑过细的决策可以放在一边，但关于所期望层次功能和性能的指导是必须的。例如，体系结构可能确切地规定一些细节来保证性能、可靠性或者安全性。在安全关键的应用中，有强调这些所谓非功能需求的传统。在任何体系结构中把这4个方面都作为一个整体的高优先级问题仍然是一个重要的目标。</p>
<h5 id="概念化"><a href="#概念化" class="headerlink" title="概念化"></a>概念化</h5><p>在概念层次上，划分层次、标志构件、分离关注点的作用是显而易见的。但在一个具体的体系结构中，它们是否还存在？更具有争论性的是，超越对象的粒度是否真有必要？有趣的是，有时认为对象最主要的优势是对象和对象间的关系在需求、分析、设计和实现等阶段是一致的（Goldberg和Rubin, 1995）。这种说法的成立需要两个前提，一是如果在所有的上述过程中都只有对象起主要作用；二是系统中所有超越对象的事物都可以被隔离。这两个前提也是所谓的“纯”面向对象方法的主要动机。</p>
<p>显然，并不是所有的事物都是对象。然而，任何需要一组对象进行交互的系统都可以通过指定一个代表对象来抽象这个交互对象组。此时，区分“has a”（或者“contain a”）联系和“use a”关系就变得很必要了。这个代表对象“包含”（“has a”）对象组，而组中的对象之间也可以通过代表对象的协调而相互使用（use）。以图的形式建模对象之间的关系时，对象是节点，联系是这些节点间的有向边。“has a”和“use a”分别是图际边和图内边。让我们考虑在时间和空间语境中支持对象转换的外部服务，例如，存储复合文档。在典型的外部行为中，图内边需要追溯下去；图际边不需要追溯，但需要抽象地保持为“连接”，连接象征性地代表了有向边的目标节点。</p>
<h5 id="构件系统架构特性"><a href="#构件系统架构特性" class="headerlink" title="构件系统架构特性"></a>构件系统架构特性</h5><p>●　构件系统体系结构由一组平台决策、一组构件框架和构件框架之间的互操作设计组成。</p>
<p>平台是允许在其上安装构件和构件框架的一个基础设施，支持构件和构件框架的实例化和激活。平台可以是实际平台，也可以是虚拟平台。实际平台提供了直接的物理支持——也就是在硬件上实现了它们的服务。虚拟平台（也可以称做平台抽象或者平台外壳）在其他平台之上仿真了一个平台，以支持灵活的成本权衡能力。</p>
<p>●　构件框架是一种专用的体系结构（通常围绕一些关键的机制），同时，也是一组固定地作用于构件层次机制的策略。</p>
<p>构件框架常常实现一些协议以连接构件，并强制实施一些由框架决定的策略。管理如何使用框架自身所用机制的策略并不确定。实际上，它们可以留给更高一层的体系结构来确定。</p>
<p>●　概念框架的互操作设计包括系统体系结构连接的所有框架间的互操作的规则。</p>
<p>这样的设计是第二等的构件框架，构件框架可以看成是它的内插构件。到现在我们可以确信第二层次是必要的——包含所有内容的单个构件框架是不切实际的。现在还不清楚第三层或者更高的层次是否必要，但此处暗示的元体系结构模型是可扩展的，允许增长。</p>
<p>●　 $\color{red}{\text{构件}}$ 是一组通常需要同时部署的 $\color{green}{\text{原子构件}}$ 。构件和原子构件之间的区别在于，大多数 $\color{red}{\text{原子构件}}$ 永远都不会被单独部署，尽管它们 $\color{green}{\text{可以被单独部署}}$ 。</p>
<p>相反，大多数原子构件都属于一个构件家族，一次部署往往涉及整个家族。</p>
<p>●　一个原子构件是一个模块和一组资源。</p>
<p>原子构件是部署、版本控制和替换的基本单位。原子构件通常成组地部署，但是它也能够被单独部署。一个模块是不带单独资源的原子构件（在这个严格定义下，Java包不是模块——在Java中部署的原子单元是类文件。一个单独的包被编译成多个单独的类文件——每个公共类都有一个）。</p>
<p>●　模块是一组类和可能的非面向对象的结构体，比如过程或者函数。</p>
<p>显然，一个模块可能静态地需要另一个模块的存在才能起作用。因此，一个模块只有在其依赖的所有模块都已经可用后才能部署。这个依赖图必须是无循环的，否则一组循环依赖关系的模块总是需要同时部署，这就破坏了模块定义的性质。</p>
<p>●　资源是一个类型化的项的固定集合。</p>
<p>资源这个概念可以包含代码资源，进而包含模块。问题在于除了编译器编译一个模块或包生成的资源外，还可能存在其他的资源。在“纯对象”的方法中，资源是外部化的不可改变的对象——不可改变是因为构件没有持久化的标志，而且复制不能被区分。</p>
<h5 id="分层的构件体系结构"><a href="#分层的构件体系结构" class="headerlink" title="分层的构件体系结构"></a>分层的构件体系结构</h5><p>层的概念和层次分解在构件系统中十分有用。构件系统的每一个部分，包括构件本身，都可以被分层，因为在一个更大的体系结构中，构件可以被定位到特定层次。为了控制更大型的构件系统的复杂性，体系结构自身也需要分层。</p>
<p>如前所述的构件系统体系结构具有一组开放的构件框架。这组构件框架形成了第二水平层次，而每个构件框架都定义了第一水平层次的体系结构。在这里，区分水平分层和传统的垂直分层之间的本质区别非常重要。传统的垂直分层，自底向上地，抽象程度渐增，与应用相关的性质逐渐提高。在一个良好的垂直分层系统中，各个层次都应该考虑相应的性能和资源。相反，水平分层是性能和资源相关性递减而结构相关性渐增的。不同的水平层次关注不同的集成性，但都与同一个应用相关。图9-1描述了在一个三水平分层多垂直分层的体系结构中垂直分层和水平分层的相互影响。如同描绘的那样，高水平分层提供了共享的低垂直分层以集成低水平分层。水平分层被描绘成相邻的，而垂直分层则是一个叠于另一个的上面。</p>
<details><summary>图9-1　三水平分层多垂直分层的体系结构——构件、构件框架和构件系统</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904003123.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904003123.png';" /></details>

<p>图9-2展示了构件实例之间如何相互通信。它们可以直接通信（例如，通过使用COM可连接对象、COM消息服务的消息、CORBA的事件或者JavaBean的事件），也可以通过构件框架做中介来间接通信，这时构件框架可以规范构件间的交互。当构件框架实例交互的时候同样的选择又会发生——这次的中介者是第三水平层次的运行实例。在图9-2中，CI代表构件实例，CFI（Component framework instance）代表构件框架实例，CFFI（Component Framework of Framework Instance）代表构件系统（或者构件框架的框架）实例。</p>
<p>在单体软件处于主导地位的世界里，甚至第一水平分层的体系结构都是不常见的。值得一提的是，对象和类框架并没有形成最底层的水平分层。水平分层的结构是从可部署的实体——构件开始的。传统的类框架只能形成单独的构件，独立于水平分层体系结构的布局。对象和类框架可以存在于构件内部。这些对象和类框架可以形成自己的层次，这取决于构件的复杂性，比如在OLE中的MFC。但是，当编译构件的时候所有类框架的结构都会被展平。跟构件框架不一样的是，类框架和它的实例间的界限是很模糊的，这是因为这个框架在运行时刻并不是实体，而在编译时刻，实例并不存在。这种二重性也可解释我们对术语“类”和“对象”常见的混淆。</p>
<details><summary>图9-2　多水平分层体系结构中的自由与间接的交互</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904003143.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904003143.png';" /></details>

<p>轻量级体系结构把注意力集中到一个问题，而不覆盖所有的问题，以有效支持轻量级构件的创建。这种构件的创建在一些限制性假设的前提下很容易想象出来。如果轻量级构件的指导性体系结构在限定其他决策的同时支持较好的易扩展性，那么它的商业价值就非常大。</p>
<p>中间件是一个软件集合的名字，这些软件位于操作系统和高层次分布式编程平台之间。中间件有时被分为面向消息的中间件（Microsoft Operations Manager, MOM）和面向对象的中间件（Object Oriented Method, OOM）。然而，现有的大多数中间件都是这两种类型的混合体。当然，现在也有一种趋势是由传统的操作系统直接支持。操作系统总是包含了对通信协议的支持。Web服务的推进和程序世界从以程序为中心到以协议为中心的转变，导致两种中间件的价值观：支持合适的协议或者提供简化本地服务构造的结构。</p>
<p>独立的中间件产品，如消息队列系统、事务处理监控器或者集线器，已经慢慢地消失了。取而代之的是结合了中间件功能和某个特定构件框架的特殊的服务器。应用服务器结合了应用管理、数据事务、负载平衡和其他的功能。集成服务器结合了协议转换、数据变换、路由和其他功能。工作流和复杂交互服务器结合了事件路由、决策和其他功能。</p>
<p>应用服务器市场有很多种不同的产品，包括IBM的MQ系列工作流系统和Microsoft的BizTalk服务器。集成服务器市场可能是最分散的，有各种提供商提供的各种类型的产品，包括CrossWorlds，IBM（WebSphere B2B Integrator），Microsoft（BizTalk server），Oracle（XML lntegration server），Tibco（ActiveEnterprise），WebMethods（Enterprise）和WRQ（Verastream）等。</p>
<h5 id="构件与生成式编程"><a href="#构件与生成式编程" class="headerlink" title="构件与生成式编程"></a>构件与生成式编程</h5><p>生成式编程致力于通过转换的方法来构造软件。这种转换对软件工程师来说并不陌生。编译器把源代码转换成目标代码，JIT编译器将中间代码变换成机器代码。然而，生成式编程试图超越传统的转换方法中转换器固定不变的弊端。其思路是允许程序员定义新的转换器。Czarnecki和Eisenecker（2000）详尽探讨了一个方法，它使用C++模版来定义变换。他们同样也讨论了很多其他的方法，包括诸如GenVoca家族（Batory和O\Malley，1992）中的特殊的生成技术。而Biggerstaff则更广泛地讨论了生成式方法的动机（1998）。在可部署构件的世界中，生成式方法在两个领域里面起着重要作用。它们可以用来生产单独的构件，也可以用来增强由构件组装的系统。如果用于生产单独的构件，生成式方法就限定在单个构件中。当目标是生产规模较大的构件或者是生产潜在的数目较大的相关构件时，这个方法显得特别有用。仔细挑选可以被边界条件参数化的技术是很重要的，这些边界条件是对生成构件的需求。特别地，必须要精确控制实际的构件边界，包括提供接口和需求接口。此外，必须能精确控制同其他构件间的静态依赖。</p>
<h4 id="语境相关组合构件框架"><a href="#语境相关组合构件框架" class="headerlink" title="语境相关组合构件框架"></a>语境相关组合构件框架</h4><p>构件框架使构件化软件发展成为最重要的一步。当前大多数研究的重点都放在单个构件的创建和基本构件间的绑定支持。在这种条件下，独立开发的构件几乎不可能进行有效的协作。因而，构件的独立部署和集成将无法实现。</p>
<p>构件框架是一个软件实体，该实体支持符合某种标准的构件，允许这些构件的实例“插入”构件框架。构件框架为构件实例创建了环境条件、规定了对象实例间的交互。构件框架能单独存在并为某些构件创建其生存空间，构件框架也能与其他构件和构件框架协作。因而我们可以很自然地把构件框架自身建模为构件。这样，我们可以在构件框架的基础上建立更高层次的构件框架，该构件框架规定了其底层构件框架间的交互。</p>
<p>构件框架关键性的贡献在于体系结构准则的部分强制要求。在构件框架的控制下，通过强制构件实例执行某种任务，构件框架能够强制某些策略执行。我们来看一个具体的例子，一个构件框架可以强制规定事件多播时的某种顺序，这样就排除了一类由于误操作或竞争而导致的难以捉摸的错误。</p>
<p>第一个对语境相关组合提供商业支持的也许是COM的“套间”模型。事实上，其下一代，MTS（Microsoft Translation Server）语境，能看做是当前所有语境相关组合方法（EJB容器、COM+语境、CCM容器和CLR语境）的源头。顺便提一句，必须注意EJB（Enterprise JavaBean）和CCM（Component Category Model）容器紧密地对应于MTS，COM+和CLR语境，而不是对应于OLE和ActiveX容器。一个OLE和ActiveX容器并不截取所有内含的控件的输入或输出调用。</p>
<h5 id="COM-语境"><a href="#COM-语境" class="headerlink" title="COM+语境"></a>COM+语境</h5><p>COM+源于COM“套间”和MTS语境。COM“套间”使用线程模型来分离对象；MTS语境通过事务域分离对象。COM+统一了这两个概念，同时也加入了大量的新的语境属性。无论哪种情况，用于驱动语境运行时语境的构造和将对象放置在合适的语境中的都是公开声明的属性。在COM“套间”的情况下，属性声明采用每一个COM类都有一个注册表项的形式。注册的条目要求类的实例必须仅仅被放置在单线程“套间”中，或者仅仅被放置在多线程的“套间”中。（COM+增加了可租赁线程“套间”的概念，在这种类型的“套间”中一次只允许一个线程入住，但是多个线程能顺序地入住该“套间”。）</p>
<p>微软事务服务器（MTS）引入了事务语境的概念。在MTS中运行的COM类的事务声明属性规定，该类必须或者位于非事务语境，或者位于新的事务语境，或者位于新的或是已有的事务语境，或者不做任何要求。通过这些声明，MTS和分布式事务协调器（Distributed Transaction Coordinator, DTC）共同创建了一个合适的事务域。相同事务域中的对象共享一个单独的逻辑线程和一个单独的共享事务资源集合（比如数据库连接和锁）。一旦线程从事务域中返回，事务要么提交要么终止，该事务域被销毁，该域所持有的资源被释放。</p>
<p>对于MTS的事务域，COM+增加了临时从一个事务域中返回、保持当前正在进行的事务的状态和在下一次调用时继续执行事务的功能。该模型允许客户端通过多个调用/返回接口进入一个事务服务的对话。（COM+也极大地扩展了语境属性、域和声明配置等概念。通过与以前的微软消息队列（Microsoft Message Queue, MSMQ））。服务集成以及加入几个其他的服务，COM+具有了大量的声明属性。COM+还引入了队列构件，这种类型的构件通过接收消息而实例化。</p>
<p>在COM+中，如果两个构件共享一组兼容的语境属性集，则它们可以被看做是处在同一域中。比如，如果两个对象共享相同的事务ID，则它们处于相同的事务域中。MTS中的域能够扩展进程和机器的边界。而MTS中的语境自身对进程进行了划分，而不是扩展了进程边界。相同语境中的对象具有相同的语境属性。域是同一属性的分组，而语境则基于属性集。图9-3显示了三个语境，两个属于相同的事务域（c2和c3），两个属于相同的负载平衡域（cl和c2）。这两个域都含有相同的语境c2。图中还显示了三个语境中的4个对象。对象u，v和w共享相同的负载平衡资源（资源ID为7），对象w和x共享相同的事务（事务ID为42）。</p>
<details><summary>图9-3　域和语境</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210904003406.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210904003406.png';" /></details>

<p>跨越语境边界的调用被拦截，然后根据语境属性或者被预处理，或者被置后处理，或者被拒绝。</p>
<h5 id="EJB容器"><a href="#EJB容器" class="headerlink" title="EJB容器"></a>EJB容器</h5><p>EJB为EJB实例提供了容器。虽然这些容器在MTS语境的基础上被模式化，但它们仍然有自己——也就是说，该类的实例需要直接调用事务API来开始、提交和结束一个事务。如此明确的控制使得这些类组装更加困难，但是当添加合法的事务代码时这种控制开辟了一条更加容易的道路。明确的控制在COM+中是可能做到的，但是不如EJB直接（本质上，外部控制需要独立存在于COM+的事务域之外，并且和微软的分布式事务控制器DTC直接发生交互）。</p>
<p>此外，EJB容器通过支持会话Bean和实体Bean支持持久对象。会话Bean的行为类似于MTS语境中的COM实例——旦事务结束（异常中断或是正常提交）其状态将丢失。实体Bean在事务正常提交时就保存至事务永久存储器。也就是说，Bean能够作为永久对象保存，除了可显式编写语句——这是MTS或COM+的唯一选择。</p>
<p>从版本2.0开始，EJB提供了改进的由容器管理的持久性和关系，提高了EJB实体Bean从一个应用服务器的容器到另外一个应用服务器容器的可移植性。EJB 2.0也增加了消息驱动的Bean类型，这是一个完全由数据驱动的EJB构件类型。与无状态会话Bean一样，消息驱动的Bean也是在消息到达时实例化，消息处理完毕后被销毁。这类似于COM+中的队列构件。消息驱动激活的概念可以追溯到IBM信息管理系统（Information Management System, IMS）的事务管理功能，该系统激活和停止IMS程序以处理队列消息。</p>
<h5 id="CCM容器"><a href="#CCM容器" class="headerlink" title="CCM容器"></a>CCM容器</h5><p>CORBA构件模型（CCM），CORBA 3.0规范的语境中被引入。正如EJB建立在MTS的概念上一样，CCM建立在EJB的概念上。CCM容器可以定义为EJB容器的超集（EJB规范和CCM规范分别发展的事实意味着，如果EJB不吸收CCM的进步、将二者融合的话，CCM将赶上EJB）。CCM在EJB的会话构件和实体构件之外增加了对过程构件的支持。更确切地说是，CCM的会话构件相对于EJB中的有状态会话Bean，然而无状态的会话bean在CCM中被称为服务构件。过程构件的实例的状态在一次调用后不再保持。过程构件实例具有持久的状态但是不能通过主键来定位。因此，过程构件对于捕获正在进行的过程状态是有用的，但不能用于捕获可确认的实体状态。</p>
<h5 id="CLR语境和通道"><a href="#CLR语境和通道" class="headerlink" title="CLR语境和通道"></a>CLR语境和通道</h5><p>CLR语境的内部设施也许是第一个尝试为语境相关组装提供真正的可扩展设施的主流结构。它不像MTS，COM+，EJB和CCM容器，其所谓的语境属性的列表不是封闭的。如果语境中的对象确实需要，那么第三方就能够在语境边界上添加新的属性。这样，当调用跨越语境边界时，语境的属性能够截取、产生作用或操作任何输入和输出消息。</p>
<p>当构造一个新的语境时，CLR提供一个一次性的机会在语境边界上设置属性。一个特殊的语境属性可以通过编程的方式添加，比如通过其他的属性或是请求创建该属性的对象。另外，一个新的语境属性能够被创建它的对象公开地请求。公布的机制依赖于CLR的定制属性——能够直接被CLR类替换的可扩展元数据。类似于COM+属性或是EJB的部署描述，这样的定制属性需要明确的声明。比如，一个类需要同步支持。当实例化时，系统检查这个新的对象是否处于一个具有同步属性的语境中。.NET框架为COM+企业服务定义了标准的属性。这样，通过CLR-COM之间的互操作内部结构，在CLR中调用COM+的服务，创建被管理的对象就变得很容易了。</p>
<p>CLR对象有4种类型——值类型、传值类型、传引用类型和语境约束类型。在通过应用域（AppDomain）的边界通信时，值类型和传值类型都是使用值编排。传引用和语境约束类型则都是将应用编排。其中唯一有趣的方面在于它们创建了一个方便的编排边界。编排在通道上执行，并能加入新的通道类型。标准类型包括在SOAP/HTTP协议之上编排和在DCOM（Distributed Component Object Mode）之上编排。在通道的末端，如果系统为传引用类型的对象设置了代理则系统会重新构造传值对象。新的代理实现也可以被加入。</p>
<p>语境约束类型总是位于一个带有合适属性的语境中。位于语境之外的其他对象是语境“（agile）”。COM中类似的概念叫“套间（agile）”对象，但这个概念不安全。不过，在CLR中，对语境约束对象的应用不能撤销。当调用通过语境边界时，语境边界拦截所有调用者或者被调用者是语境约束对象的所有调用。例如，当在一个“（agile）”对象的域中存储一个语境约束对象的引用时，先传递该引用到另外一个语境，当通过该引用调用对象的一个方法时，该调用将会被拦截。如果该引用——通过各种方式——回到了原来的语境中，则当另外一个调用到达时，该调用将不会被拦截。</p>
<p>默认的情况下，新的对象放置在和请求创建新对象的对象一样的语境中。或者，新创建的对象可以选择其他的语境（不过需要该语境中另一个对象的“帮助”）或者创建一个新的语境。如果被选中的语境的属性与该对象声明的要求不匹配，则一个新的语境将自动被创建。</p>
<h5 id="元组和对象空间"><a href="#元组和对象空间" class="headerlink" title="元组和对象空间"></a>元组和对象空间</h5><p>在所有以上方法之前的一个关于语境相关组装的方法是基于无所不在的数据空间的概念，数据空间能够在不需要明确寻址的情况下被用于通信。该工作的发起人是耶鲁大学的David Gelernter和他的小组（<a target="_blank" rel="noopener" href="http://www.cs.yale.edu/Linda/linda.html%EF%BC%89%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%AF%A5%E8%AE%BE%E8%AE%A1%E9%A2%86%E5%9F%9F%E3%80%82%E7%89%B9%E5%88%AB%E8%A6%81%E6%8C%87%E5%87%BA%E7%9A%84%E6%98%AF%EF%BC%8C%E7%94%B1Nicholas">www.cs.yale.edu/Linda/linda.html），他们建立了该设计领域。特别要指出的是，由Nicholas</a> Carriero和David Gelernter创建的Linda协作语言引入了元组空间的概念。那些保存有原子数据的空间就称为元组。在元组空间上，Linda仅仅定义了三种基本的操作——添加一个元组到一个空间中、在一个空间中匹配和读取一个元组、在一个空间中匹配和删除一个元组。当前这种思想的“追随者”是JavaSpaces（java.sun.com/products/javaspaces）。</p>
<p>协调数据和对象空间有一些附加的好处，比如我们没有必要确认构件实例之间的位置和它们的依赖性，决策安排也与数据流上的功能需求完全分开。同时，这些性质也面临着挑战。比如，为了避免在分布式实现中的集中瓶颈问题，元组空间不应该位于一个单独的物理位置。然而，为了实现高效的安排，有效的信息和被请求的数据元组或对象需要被传播至系统的每一个部分。保持元组空间操作原子性的需求使得对机构的要求进一步复杂化。</p>
<p>元组和对象空间对语境相关组装的求精有潜在的好处——即数据驱动的组装。在写这本书的时候，该方法已经不局限于研究项目，并影响着主流的技术。然而，有的人会说目录结构的广泛使用是元组空间融合的有趣的例子。这方面的例子包括因特网域名服务（DNS），轻量级目录访问协议（LDAP）目录，微软的活动目录和Web服务的UDDI目录。</p>
<p>目录假定了一个弱一致性模型，即条目很少被复制，临时的更新不一致性也是可以忍受的，条目改变的频率远远低于读条目的频率。这些性质保证了目录实现能进行大规模甚至是全局的可扩展性。比如，DNS就被实现为DNS服务器的全局层次，这些服务器联合起来以惊人的速度来处理数百万台机器的基于DNS的名字解析请求。</p>
<p>可以证明，所有主流的构件方法都是依靠目录来进行某种形式的语境组装，而没有哪种主流方法是像Linda协作方法所建议的那样通过构件框架来做。相反，目录服务通过一些API得以应用，而协作的工作则留给客户端构件的开发人员。</p>
<p>更通用的数据驱动的构件框架也是存在的。在COM+的队列构件或者J2EE的消息驱动Bean中，数据的分布就是通过面向消息的中间件（消息排队系统）来进行的。消息的到达引起相应的处理构件的自动激活，后者则通过在局部产生影响或者进一步发送消息来做出响应。</p>
<h4 id="构件开发"><a href="#构件开发" class="headerlink" title="构件开发"></a>构件开发</h4><p>面向构件的编程目前仍然是一门年轻的学科，其涉及的许多方面仍需要进一步地研究。本章的论述主要涉及了面向构件编程的方法学、环境和语言等三个方面。编程方法学主要考虑如何用一种系统化的方式来进行构件系统的划分、构件的交互和建造。而编程的环境和语言则主要考虑如何表现和支持特定的编程方法学。</p>
<h5 id="color-red-text-面向构件的编程方法学"><a href="#color-red-text-面向构件的编程方法学" class="headerlink" title="$\color{red}{\text{面向构件的编程方法学}}$"></a>$\color{red}{\text{面向构件的编程方法学}}$</h5><p>如同面向对象的编程（OOP）关注于如何支持建立面向对象的软件解决方案一样，面向构件的编程（Component-Oriented Programming, COP）关注于如何支持建立面向构件的解决方案。一个基于一般OOP风格的COP定义如下（Szyperski, 1995）：“面向构件的编程需要下列基本的支持：</p>
<p>—— $\color{green}{\text{多态性}}$ （可替代性）；</p>
<p>—— $\color{green}{\text{模块封装性}}$ （高层次信息的隐藏）；</p>
<p>—— $\color{green}{\text{后期的绑定和装载}}$ （部署独立性）；</p>
<p>—— $\color{green}{\text{安全性}}$ （类型和模块安全性）。”</p>
<p>面向构件的编程仍然缺乏完善的方法学支持。现有的方法学往往只关注于单个构件本身，并没有充分考虑由于构件的复杂交互而带来的诸多困难。其中的一些问题可以在编程语言和编程方法的层次上进行解决。这其中，面向连接的编程尤其吸引了语言设计领域众多研究者的关注，例如，ArchJava（Aldrich等人，2002和Jiazzi McDermid等人，2001）。然而，面向连接的编程并不是通向面向构件的唯一途径。</p>
<p>分层体系结构或其他体系结构的设计方法有助于控制系统的复杂性，并能够指导系统的演化。但是，单独依靠体系结构并不能有效地指导构件及构件框架的开发活动。许多问题仍然没有得到根本的解决。主要问题如下。</p>
<p>1）异步问题</p>
<p>当前的构件互连标准大都使用某种形式的事件传播机制作为实现构件实例装配的手段。其思想是相对简单的：构件实例在被期望监听的状态发生变化时发布出特定的事件对象；事件分发机制负责接收这些事件对象，并把它们发送给对其感兴趣的其他构件实例；构件实例则需要对它们感兴趣的事件进行注册，因为它们可能需根据事件对象所标志的变化改变其自身的状态。</p>
<p>2）多线程</p>
<p>“多线程会使你寝食难安。”Swaine在后来的著作中解释，他的一些与此相似的论断具有明显的煽动性，但是他并不认为这些论断是错误的。多线程是指在同一个状态空间内支持并发地进行多个顺序活动的概念。相对于顺序编程，多线程的引入为编程带来了相当大的复杂性。特别是，需要避免对多个线程共享的变量进行并发的读写操作可能造成的冲突。这种冲突也被称做数据竞争，因为两个或多个线程去竞争对共享变量的操作。线程的同步使用某种形式的加锁机制来解决此类问题，但这又带来了一个新的问题：过于保守的加锁或者错误的加锁顺序都可能导致死锁。</p>
<p>多线程主要关注于对程序执行进行更好的分配，发送并发请求的客户端能够很好地观察到这种分配。然而，获取性能最大化的手段却根本不依赖于多线程，而是尽量在第一时间内以最快的速度处理用户的请求。即使能够避免死锁，同步也可能导致一定程度的性能损失。必须避免对经常使用的共享资源进行不必要的加锁。跨线程的异常传播也会导致处理非同步的异常变得更加困难。而且，使用多线程和复杂的互锁机制将使得代码调试变得异常困难。</p>
<p>显然，在真正并发的环境下，这些问题无一不需要考虑。例如，如果构件实例运行在独立的处理器上，就需要考虑并发请求的问题。可以在处理一个请求时对某个构件实例进行完全的加锁，但这样做可能会导致死锁或者糟糕的响应时间。</p>
<p>3）“生活”在没有实现继承的状态下</p>
<p>构件间的实现继承所引起的严重问题使得人们倾向于使用简单对象组合或消息转发来替代实现继承。但是，当我们仅需要对已有的实现进行轻微的修改时，这种替代方式却又显得太笨拙。创建一个具有很多方法的类的子类，且只重写父类中一小部分方法是很容易实现的。相对而言，仅为转发一小部分方法调用而生成一个新的包装类却是一件十分繁琐的事情。除了实现上的开销以外，简单的转发还增加了运行时的开销（执行时间和代码占用空间的增加）。</p>
<p>当一个对象中的方法被分组成若干个接口，每个接口中含有数目恰当的方法时，COM风格的聚合有助于避免由于转发所带来的性能损失。通过使用多种自动化技术，对于程序员而言，其实现成本没有丝毫的增加。</p>
<p>一种解决方案是根据转发目标对象的接口生成转发类的代码。这种方案的弱点也是所有代码生成途径所共有的：目标对象接口的改变要求重新生成转发类的代码，或者手工调整旧的生成代码。</p>
<p>另外一种解决方案是利用模板机制（如C++中的模板）在编译时刻生成所需的代码。模板可以通过参数化的方式配置，而不必手工编辑生成的代码。编译器根据模板的实例化参数来生成最终的代码。</p>
<p>4）坚壳类</p>
<p>第三种解决方案是使用实现继承。虽然一般来讲实现继承具有严重的问题，但对于白盒类（以完整的源代码形式发布并且不再被改变的类）使用实现继承是没有问题的。对经常成为转发目标的构件接口来说，可以为其关联一个专门负责处理转发者琐碎细节的坚壳类（Szyperski, 1992b）。坚壳类与转发目标具有相同的接口，而且所有方法的实现都是简单地向目标转发消息。坚壳类本身是抽象的，尽管所有的方法都有实现，但是这种实现完全没有引入新的功能。（有趣的是，某些语言包括C++，无法表现这样一个事实，即一个没有抽象方法的类仍然是抽象类。）然而，可以通过继承坚壳类去截取某些方法调用，从而产生一个有意义的转发者。由此导致的程序员工作量与一般的实现继承类似，但产生的效果是转发而不是代理。</p>
<p>Java中的代理类（proxy class）就是这样的一种机制。一个代理看起来是某种给定的类型，但其内部却实现为代理类的一个子类。这种实现提供了一种对调用进行截取的机会。CLR通过实时代理类也提供了类似的机制。</p>
<p>5）语言支持</p>
<p>第四种解决方案是语言支持，这种解决方案或许更易于被接受。如果编程语言直接支持转发类的构造，则所有以上方案的缺点都可以被避免。编程的开销也将是最小的，且在运行时刻时间和空间上的开销与实现继承方式相比也都是一样的。但目前还没有主流的编程语言来支持这种构造。比如，C++的虚拟基类机制不允许在几个独立的对象之间共享基类对象。它也不允许动态改变基类对象，或虚拟基类的独立子类化。Objective-C（Apple Computer, 2000; Pinson和Wiener, 1991）是一种支持对象动态继承的非主流编程语言。</p>
<p>6）调用者封装</p>
<p>语言支持带来的另外一个好处是接口定义。当构件对外提供一个接口时，可能会涉及两种不同的意图。一方面，构件外部的代码可能会调用这个接口中的操作。另一方面，构件内部的代码可能需要调用实现这个接口的一些操作。在COM技术中，这体现为入接口和出接口的差异。除了Component Pascal以外，没有别的语言能够恰当地支持构件的纯出接口。</p>
<p>正如许多传统的封装机制一样，如果出接口和入接口之间的对称可以被接受，那么仅对调用者而不是对被调用者进行封装也就不应该令人感到惊奇。然而，适合于构造构件的调用者封装机制被大多数的语言丢弃了。在类似Simula的语言，包括Beta语言（Lehrmann Madsen等人，1993），均支持内部方法。在类的层次上，这种机制和调用者封装很相似。引介基类（Introducing Base Class）之外的代码无法访问由子类所实现的内部方法。每个人都可以试图调用该方法，但是基类代码的执行受到了保护，至少能够动态地防止非法的外部调用者。</p>
<p>调用者封装策略被应用于黑盒构件框架的若干方面。例如，只有框架可以调用视图的关键方法。如果框架在早些时候捕获了对同一个视图的同一个方法调用产生的异常，它将会阻止对此方法的进一步调用。这样，产生错误的视图的某些方法将被屏蔽，从而不会再继续扰乱系统的运行。黑盒是很少几个能够保证嵌在复合文档中的视图不会破坏文档的整体性的系统之一。</p>
<h5 id="环境与选择目标框架"><a href="#环境与选择目标框架" class="headerlink" title="环境与选择目标框架"></a>环境与选择目标框架</h5><p>脱离了良好定义的环境，一个构件实例是不能正常工作的。构件框架定义了这样的环境。然而，一个构件实例可能被设计成可以在多个构件框架中工作。根据构件系统体系结构的不同，框架可以根据不同的角色被分割成不同的子框架。例如，每个框架都可能会采用某种特定的机制实现构件之间的协同运作。在这种情况下，分布式框架可能会负责在机器之间分发构件实例。而另外一个单独的框架将会负责对复合文档的集成。构件的设计可能需要考虑所有的这些子框架，以使得最终的构件实现能够在这些框架下正常运行。</p>
<h5 id="工具与选择编程语言"><a href="#工具与选择编程语言" class="headerlink" title="工具与选择编程语言"></a>工具与选择编程语言</h5><p>原则上，构件编程几乎可以使用任何一种语言，并采用任何范型。并不存在所谓的最低需求。构件编程主要关注的是对相关构件的多态处理。由于构件之间的交互需要动态进行，因此就必须支持后期绑定。参数构造安全性还需要封装及安全——类型安全和模块安全——的支持，在大多数情况下垃圾回收的支持也是必需的。此外，构件编程需要一种能够显式化声明状态依赖的机制，理想情况下应该保持这些依赖是可以参数化的。对实现中的依赖进行完全的参数化导致了面向连接的编程。在语言范型的层次上，面向对象范型最接近于面向构件的编程范型，但是其他的范型，比如功能范型，可能也是合适的。</p>
<p>到目前为止，只有少数编程语言在应用层次上支持面向构件的编程。许多流语言，如COBOL、Object COBOL、FORTRAN、C、C++ Pascal和Smalltalk在不同程度上均缺少对封装、多态、类型安全性、模块安全性的支持。</p>
<p>Java、C#和Component Pascal都分别支持在包一级或者模块一级的访问保护。通过这种方式，可以建立对模块安全性的支持。但Java的开放包机制对模块安全性的支持太过脆弱。即使不使用替换目标文件的方式，也可以通过向包中添加新的类，从而完全穿越包机制提供的保护！这种漏洞需要通过另外的途径来弥补。因此，需要把包放在文件系统中的保护目录下，或者其他带有访问控制的地方。在一个从远端服务器动态获取类文件的环境中，这种情况将变得更为复杂。需要一种机制来保证同一个包中的类文产生于同一个编译源。为了支持更加开放的设置，Java或许需要采用封闭的模块构造机制，其中每一个这样的模块被映射到一个被发布的编译文件上。Java的嵌套类机制有助于建立真正的所谓模块，但是Java缺少一个能够支持对一个类及其嵌套类的访问保护层。另外，由于JVM实际上并不真正支持嵌套类，Java编译器不得不把嵌套类抽取出来，放入单独的类文件中。</p>
<p>C#令人感兴趣的地方在于其模块级访问保护适用于集合。C#的任何构造机制（事实上任何基于CLR的语言都适用）可以被打包成为一个集合。一旦被打包，该集合也就被加密了，从而避免对其的任意窜改，这也使得对集合内部的访问控制机制变得强大和有效。因此这种基于CLR的集合内部访问机制是目前为止最灵活的包概念。</p>
<h4 id="构件组装"><a href="#构件组装" class="headerlink" title="构件组装"></a>构件组装</h4><p>构件是可被第三方独立部署的基本单元。每个构件的部署过程之间不是相互孤立的，构件实例之间通常会在一个或多个构件框架的介入下发生交互。将构件组装成系统的一种显而易见的方法是通过传统的编程方式进行。然而，由于这种方式支持用较简单的方式生成大多数常用的构件系统（或由于其能够完全避免单独的组装过程），因此构件的适用范围和生存能力都大大地增加了。</p>
<h5 id="构件初始化及互连"><a href="#构件初始化及互连" class="headerlink" title="构件初始化及互连"></a>构件初始化及互连</h5><p>体系结构描述语言（ADL）即遵从了这样的思想：这些语言通常都把构件和连接子作为其核心的建模概念。组装因此表现为选择一组构件并通过适当的连接子将这组构件进行连接的过程。基于这种方式的组装过程实际描述的是被选择的构件的“实例”应该如何通过适当的连接子“实例”互连的过程。这个细节揭示的一个重要之处在于：构成一个组合体的基本元素是构件或连接子的实例而不是构件或连接子本身。例如，虽然概念上一个构件可以出现在两个组合体中，但实际上是这个构件的不同实例将出现在这两个组合体的若干实例中。</p>
<p>BML（bean markup language）是种由IBMalphaWorks实验室在1998年发布的针对JavaBean的构件组装语言。BML基于XML并针对JavaBean构件模型进行了定制。通过使用XSLT，可以从更抽象的系统描述中生成BML。实际上，BML自身与JavaBean构件模型已相当接近，能够支持Bean构件实例的创建、访问及配置等操作。为了支持配置，BML允许对Bean属性进行访问和设置。当提供了具有这种配置方式的Bean构件实例后，BML能够用来绑定Bean构件，使其作为监听者监听其他Bean产生的事件。BML既可以通过直接产生配置后的可运行子系统而被解释，也可以被编译而生成Java代码。BML解释器的基础是bean定制化框架。该框架也能够支持实现不同于BML的其他形式的bean配置和互连语言。</p>
<p>1）构件的可视化组装</p>
<p>构件实例的可视化组装方式能够有效地简单化组装过程。例如，JavaBean构件能够区分其实例的使用和构造阶段。一个bean因此可以表现出特定的外观（例如，一个类似建筑单元的图标）、行为（例如，一个可以和其他实例连接的句柄）和帮助信息（例如，针对特定人员的构件组装帮助文档）。在组装过程中，构件被实例化，实例通过统一的方式把其具有的出接口和入接口连接到相关的实体上。JavaBean和COM技术均支持这种一般方式的连接范型。</p>
<p>2）用复合文档取代可视化组装</p>
<p>在构件实例可见的情况下（通过提供一个可视化的用户界面），专业的构造器或组装环境可以和一般用途的软件开发环境相统一。而通过复合文档，构造和使用这两个不同的环境也可以自然直接地集成在一起（文档代表应用系统），对文档的编辑相当于构件（实例）的组装过程。在这样的系统中，构件的组装者和使用者之间不存在任何的隔阂。这两者之间的平滑过渡就如同在已有构件组合体的基础上，通过后期组装生成新组合体，与通过编程生成新组合体可以随意地相互结合使用，以满足特定应用系统的需要一样。因此，为了全面地满足使用者的需求，组装机制应该具有在使用时刻的可用性。黑盒构件构造器及构件框架即遵循了这样的途径。虽然我们可以通过不部署所需的构造器构件的方式来区分构件的组装和使用，但复合文档并不对这两者做严格的区分。</p>
<p>构造环境和使用环境的无缝集成（特别是在复合文档的方式下）也形成了对于快速应用开发（Rapid Application Development, RAD）的强有力支持。在这样的环境中，工业级构件、原型构件及一次性解决方案可以自由地结合。需求捕获和对需求改变请求的确认也可以高效且有效地执行。如果企业或组织需要，经过相应的培训后，最终用户可以进一步地调整他们的系统。</p>
<p>3）非图形用户界面环境的构件</p>
<p>大多数早期的构件化软件方法往往关注于客户端的前台交互式应用系统。现代图形用户界面的需求本质，加上用户界面的相对规则性，使得与用户界面相关的可重用构件成为具有独特价值的软件资产。然而，计算的其他领域，特别是基于服务端的解决方案，存在同样甚至更多的复杂性，而且已经引起了现阶段许多构件化软件方法的关注。</p>
<p>对基于服务的构件，构造和使用阶段的清晰划分显得更为自然。Oliver Sims于1994年提出的业务对象，是最早提出的针对“无处不在的构件”（Components Everywhere）思想的建议之一。接下来的一个重要进展则是Java servlet的出现。Java servlet是运行于服务器上的构件，但它们仍可以通过可视化的方式来进行组装。为了与现存的构件模型良好协调（包括CORBA提出的构件模型），使用前的组装通常需要较早地做出某些决策，如分布式系统中构件实例的分布决策。值得注意的是，虽然对象迁移能够带来的益处仍然值得讨论，但大多数系统，包括当前的CORBA实现，都支持持有其他对象引用的对象的迁移能力。然而最近的一些围绕Web服务的途径（基于SOAP），却不支持对远程对象引用的传递。相反，SOAP主张对定位器（Locator）的传递，如URL或COM中的moniker。这些定位器在不同的机器上每次可能会被解析到不同的对象上。因此，远程对象标志这个概念在SOAP和Web服务中并不存在，迁移问题也由此变得非常简单。</p>
<p>关于服务端构件模型的典型解决方案包括适用于应用服务器的EJB模型（Sun公司J2EE的一部分）和COM+模型（微软公司），以及适用于Web服务器的servlet模型（基于Sun公司JSP技术）和Visual Basic及其他技术（基于微软公司ASP技术）。微软的.NET框架还引入了一种新的同时适用于客户端和服务端的基于CLI（Command Line Interface）的构件模型。</p>
<p>4）可管理且“自引导的”构件组装</p>
<p>构件的组装实际上是指对构件实例的组装（一个采用对象技术实现的构件实例通常是一个由若干对象形成的消息网络）。当然，通过组合已有构件来实现新构件也是可行的，这种方式类似于传统的基于底层函数库构建高层函数库的过程。换而言之，构件组装（不是构件实例）只不过是编程的一个代名词，而构件实例的组装并非如此。构件实例组装提倡把实现构件的代码和资源与“连接”构件实例的代码这两个方面保持分离。构件实例的连接可以通过轻量级编程的方式（如编写脚本）来实现，而新构件的编写则应采用其他的方式（脚本语言或接口语言并不适合编写构件，因为编写构件与连接构件实例有本质的不同）。</p>
<p>5）最终用户组装</p>
<p>当需要时，允许最终用户进行系统组装以获得高度定制的解决方案是非常有价值的。最终用户的参与导致产生了一个有趣的、介于完全自引导和完全静态预定义之间的构件组装模式。显然，即使有最终用户的参与，组装过程仍然需要一定程度的自引导性。我们不应当期望用户能够完全承担技术细节层次上的构件组装工作。</p>
<p>系统组装分为三个不同的层次：定制（customization）、集成（integration）和扩展（extension）。这三个层次对应于构件组装过程中的不同任务。但这种最终用户剪裁仅仅是从用户的角度观察其关心的领域问题，而不是从构件组装的技术角度来进行的。Robert Slagter和Henriter Hofte（2002）展示了这种思想在计算机支持的协作应用软件系统中的一个有趣应用。该系统支持最终用户根据需要去组合群件的行为。Groove Transceiver（<a target="_blank" rel="noopener" href="http://www.groove.net)具有的类似特征则允许最终用户通过选择和配置工具快速地组装工作空间./">www.groove.net）具有的类似特征则允许最终用户通过选择和配置工具快速地组装工作空间。</a></p>
<p>6）构件演化</p>
<p>构件技术体现了一种后期组装的思想。构件的逐渐成熟会进一步推后组装（或绑定）时间，但随之而来的是整个系统将变得越来越脆弱。构件通常也会经历一般软件产品具有的演化过程。</p>
<p>安装新版本的构件将会与期望使用旧版本构件的现有系统发生冲突，甚至直接与现存的旧版本构件实例发生冲突。相对于已经实例化的构件，一个构件从构件库中被获取并实例化的时间越晚，潜在的版本冲突问题就会越严重。</p>
<p>在分布式系统中，为安装新版本的构件实例而终止所有现有构件的运行是不现实的。不同版本的客户端和不同版本的构件实例之间的二进制互操作性需要在版本间二进制兼容性中就加以考虑。如何实现构件实例的在线版本升级仍然是一个非常活跃的研究领域。</p>
<p>在实际配置中，必须考虑构件的不同版本实例共存于一个系统的情况。系统的升级就是一个重要的例子。除采用多版本共存技术之外，解决“遗留系统移植”问题还需要通过使用包裹器构件来适配旧版软件或解决系统不兼容性。</p>
<p>支持版本共存和包裹器构件技术的方法之一是COM所使用的方法。按照约定，一旦COM接口被发布，其就不能再被更改。因此，COM中不存在针对单个接口的版本问题。一个提供新版本服务的构件将不得不使用一个新的接口。采用这种方式的一个重要优点是它使得同时支持具有不同语义的新旧接口成为可能。显然，一旦一个接口不再被支持时，该接口就可以从系统中安全删除。</p>
<p>CORBA采用的版本管理机制的能力则较弱，它仍然试图将所有版本的所有操作合并成一个接口。因此，这种方式不支持仅改变操作的语义而不改变该操作名称或原型的能力。由此导致的一个后果是，虽然可以引入操作的新名称，但若想删除一个旧的操作而不改变二进制兼容性却非常困难。甚至SOM的版本序列机制（SOMs Release Orders）也无法解决这个问题。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2662a2c4034a">什么是corba</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch8-XML%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch8-XML%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch8-XML技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:54:26" itemprop="dateCreated datePublished" datetime="2021-07-19T12:54:26+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-03 23:44:57" itemprop="dateModified" datetime="2021-09-03T23:44:57+08:00">2021-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="XML技术"><a href="#XML技术" class="headerlink" title="XML技术"></a>XML技术</h2><h3 id="XML概述"><a href="#XML概述" class="headerlink" title="XML概述"></a>XML概述</h3><p>可扩展标记语言（XML）是标准通用标记语言（Standard Generalized Markup Language, SGML）的一个子集：XML包含了很多SGML特性，但是比SGML要简单得多。像SGML一样，可以用XML来开发一种标记语言，它的元素和属性多是为专门行业和产业而定义的。创建这种语言之后，就可以使用XML——就像使用HTML（Hypertext Markup Language）一样——来标记并结构化文档了。</p>
<p>XML和HTML都支持统一字符编码协会（Unicode Consortium）制定的通用字符集（Universal Character Set, UCS），它不仅包括特殊字符、标点和数学符号，还包括了非英语语言的字符和字母表，这使得XML成为了国际标准，这些字符和符号被认为是实体。XML和HTML都支持样式表（style sheet）的使用，样式表有助于你定义整篇复杂的文档的结构和外观。然而，HTML在许多方面都传统地定义了它的输出样式（当然最新版的HTML和由它继承而来的XHTML极力鼓励你使用层叠样式表来编制文档的样式）。而且，XML在支持文档样式符号、规范语言（The Document Style Semantics and Specification Language, DSSSL）和层叠样式表（Cascading Style Sheets, CSS）等性能方面大大超过了HTML。</p>
<p>专为XML“服务”的样式表标准是可扩展样式表语言（Extensible Stylesheet Language, XSL），它是基于在线文档样式符号和规范语言（DSSSL-O）的，DSSSL-O是DSSSL的一个子集，像CSS一样是专门为电子文档而创建的。有关CSS的更多信息，请参考同样由Sandra E.Eddy著IDG Book Worldwide公司出版的《XHTML参考教程》，XSL在本书第2部分的“XSL样式表语法”和第7章的“使用XSL设计文档”中分别都有介绍。XSL现在还只是一个建议，要跟上它的发展，请浏览其最新的建议：<a target="_blank" rel="noopener" href="http://www.w3.org/TR/xsl/%E3%80%82XSL%E8%BD%AC%E6%8D%A2%EF%BC%88XSL">http://www.w3.org/TR/xsl/。XSL转换（XSL</a> Transformations, XSLT）是一种新的语言，它可以和XML协同工作。请参阅“XSLT组件”中的有关XSLT的内容。</p>
<p>XML包括如下特点和功能：</p>
<p>（1）XML允许各种各样的文档显示类型，不仅可以显示在许多计算机平台上，而且可以显示蜂窝电话、掌上电脑等其他设备上。程序员可以使用任何编程语言或脚本语言来定义文档。</p>
<p>（2）XML支持但并不需要DTD （Document Type Definition，文档类型定义）。如果你使用DTD，就要通知XML编辑器严格地按照DTD中设定的规则来处理文档。</p>
<p>（3）XML的支持标准（XLink和XPointer）支持比HTML更为复杂的链接。在HTML和XML中你只能链接到一个URL。然而在XML支持标准中可以同时使用几个或者一组链接。</p>
<p>（4）XML标准支持打印文档和电子文档以及其他的为不同用户定义了不同内容和外观的文档。</p>
<p>（5）XML支持客户端或者服务端计算机上的进程，这就允许开发人员分配资源和随时地节省资源。当前，XML 1.0规范已经定义了，而XLink和XPointer语言仍处在开发和候选建议状态，这意味着它们已经被各技术团体评论过了。在成为最后建议之前，两种语言都可能发生改变。</p>
<h4 id="XML基本语法"><a href="#XML基本语法" class="headerlink" title="XML基本语法"></a>XML基本语法</h4><p>本节将比较简略地介绍XML的基本语法，通过一个基本文档的例子来了解它的实质内容。希望这部分内容对于初次接触XML技术或者Web服务技术的读者，能有一个简要的知识铺垫。</p>
<p>以下是XML 1.0规范（第2版）的规范文本和该版本的中译本的URL。</p>
<p>●　<a target="_blank" rel="noopener" href="http://www.w3.org/TR/2000/REC-xml-20001006">http://www.w3.org/TR/2000/REC-xml-20001006</a></p>
<p>●　<a target="_blank" rel="noopener" href="http://lightning.prohosting.com/-ggiu/REC-xml-20001006-cn.html">http://lightning.prohosting.com/-ggiu/REC-xml-20001006-cn.html</a></p>
<h4 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h4><p>XML标签负责提供、描述一个XML文件或数据包（也就是大家所熟知的XML实体）的内容结构。它们由界定内容的不同部分的标签（tag）所组成，负责提供到特殊符号和文本宏的引用，或者将特殊指令传递给应用软件，以及把注释传递给文档编辑器。</p>
<p>XML元素的结构与HTML基本相同，XML也同样使用尖括号来界定标签：以小于号（〈）结尾，但二者的相同点也就仅此而已。</p>
<p>与HTML不同，几乎所有的XML标签都是大小写敏感的，其中包括元素的标签名和属性值，主要是满足XML国际化的设计目标和简化处理过程的需要。大多数非英语的语言并不把字母表分成若干种写法，许多字母可能也没有对应的大写或小写。合并写法会存在许多缺陷，尤其对于非ASCII码更是如此，而XML的设计者们大多选择避免这些问题。</p>
<h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><p>由于XML要在全球范围内使用，所以不能局限于7位的ASCII码字符集。XML指定的字符均在16位的Unicode2.1字符集（参见<a target="_blank" rel="noopener" href="http://www.unicode.org,它目前与iso/IEC">http://www.unicode.org，它目前与ISO/IEC</a> 10646一致，后者可参见<a target="_blank" rel="noopener" href="http://www.iso.ch)中定义.这些都是相对较新的标准,而且当今世界还有许多文字没有编入统一码中.但是,由于它被设计为大多数现存字符编码的超集,所以遗留的内容向统一码的转换也是简单直观的,例如,把ascii码转换成统一码只需要把16位字符的前8位填充为0(而保留后8位)即可./">http://www.iso.ch）中定义。这些都是相对较新的标准，而且当今世界还有许多文字没有编入统一码中。但是，由于它被设计为大多数现存字符编码的超集，所以遗留的内容向统一码的转换也是简单直观的，例如，把ASCII码转换成统一码只需要把16位字符的前8位填充为0（而保留后8位）即可。</a></p>
<h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p>在XML中使用的结构几乎总是被命名的。所有XML命名都必须以字母、下划线（_）或冒号（:）开头，后面跟着的是有效命名字符。有效命名字符除了前面的这些字符外，还包括数字、连字符（-）、句号（.）。在实际应用中不应该使用冒号，除非是用作命名空间修饰的分隔符（可参见本章后面的关于命名空间的相关描述）。字母并非局限于ASCII码，这一点是非常重要的，因为不说英语的人们可以把自己的语言用在标签中。</p>
<p>下面就是一些合法的命名：</p>
<p>Web、WEB、WebService: Interface、中国软件</p>
<p>注意前两个命名并不等同，因为XML的命名是大小写敏感的，第三个是使用建议的命名空间分隔符（冒号）的典型例子，最后一个例子提醒大家注意汉语同英语一样，都可以用于XML的命名。</p>
<p>下面是一些非法的命名：</p>
<p>-Web、4Web、Web$Service</p>
<h4 id="文档部分"><a href="#文档部分" class="headerlink" title="文档部分"></a>文档部分</h4><p>一个格式正规的XML文档由以下三个部分组成。</p>
<p>（1）一个可选的序言（prolog）。</p>
<p>（2）文档的主体（body），由一个或多个元素组成，其形式为层次树状结构，其中可能也包含了一些字符数据（character data）。</p>
<p>（3）可选的“繁杂”的尾声（epilog），其内容包括注释、处理指令（Processing Instruction, PI）和/或紧跟在元素树后面的空白。</p>
<h4 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h4><p>元素是XML标签的基本组成部分，它们可以包含其他的元素、字符数据、字符引用、实体引用、PI、注释和（或）CDATA（即Charactor Data缩写）部分——这些合在一起被称为元素内容（element content）（要注意这些元素都是容器）。所有的XML数据（除了注释、PI和空白）都必须包容在其他元素中。</p>
<p>元素使用标签（tag）进行分隔：由一对尖括号（〈 〉）围住元素类型名（一个字符串）。每一个元素都必须由一个起始标签和一个结束标签分隔开，这与要求比较松的HTML不同，后者的结束标签可以省略。这项规则唯一的例外是没有任何内容的元素，即空元素（Empty Element），它既可以使用起始标签/结束标签对，也可以使用短小精悍的混合形式——空元素标签。在后面，我们会看到许多标签的例子。</p>
<h5 id="起始标签"><a href="#起始标签" class="headerlink" title="起始标签"></a>起始标签</h5><p>一个元素开始的分隔符被称为起始标签。起始标签是一个包含在尖括号里的元素类型名。我们也可以把起始标签看作是“打开”了一个元素，就像我们打开一个文件或通信链路一样。</p>
<p>下面就是一些合法的命名：</p>
<p>〈Web〉、〈WEB〉、〈WebService: Interface〉、〈中国软件〉</p>
<h5 id="结束标签"><a href="#结束标签" class="headerlink" title="结束标签"></a>结束标签</h5><p>一个元素最后的分隔符被称为结束标签。结束标签由一个反斜杠和元素类型名组成，被围在一对尖括号中。每一个结束标签都必须与一个起始标签相匹配，我们可以把结束标签理解为“关闭”了一个由起始标签打开的元素。</p>
<p>下面是一些合法的结束标签，它们与前面列举的起始标签相对应。</p>
<p>〈/Web〉、〈/WEB〉、〈/WebService: Interface〉、〈/中国软件〉</p>
<p>所以，带有完整的起始、结束标签的元素应该是如下形式：</p>
<p>〈某个标签〉包含的内容〈/某个标签〉</p>
<h5 id="空元素标签"><a href="#空元素标签" class="headerlink" title="空元素标签"></a>空元素标签</h5><p>空元素可能不包含任何内容。比如说想准确地指明文档中的某些特定位置，我们可以只加入起始标签和结束标签，而不在其中包含任何内容。</p>
<p>〈WebService〉〈/WebService〉</p>
<p>当然，如果你只是想指定一个点，而不是提供一个包容器，节省些空间可能会更好。所以，XML指定空元素可以用缩略形式表示，它是起始和结束标签的混合体。它短小精悍，而且还能明确指出该元素既不会有内容，也不允许有内容。</p>
<p>空元素标签由一个元素类型名称紧跟一个反斜杠组成，并围在一对尖括号中。</p>
<p>〈WebService/〉</p>
<p>一个XML数据对象可能只包含单个文档根元素和一些空元素（可能有属性），这样的文件可以用来描述应用程序的配置信息或者面向对象编程语言中的对象模板。</p>
<h5 id="文档元素"><a href="#文档元素" class="headerlink" title="文档元素"></a>文档元素</h5><p>格式正规的XML文档的定义形式是一个简单的层次树，每个文档都有一个，而且只有一个根节点，它被称为文档实体（document entity）或文档根（document root）。这个节点可能包含PI和（或）注释，而且总是包含子元素树，它们的根被称为文档元素（document element）。这个元素是这个树中其他所有元素的父元素，而且它可能不包含在其他任何元素当中。每个XML文档的文档根也是使用DTD （Document Type Definition，文档类型定义）或模式定义的文档描述的附属品（由于本章并不想就DTD展开详细讨论，文章对于XML建模的重点是XML Schema，因此只对XMLSchema进行讨论）。</p>
<p>任何格式正规的XML文档都必须由形成一个简单的层次树的元素所组成，其中有一个被称为“文档根”的单个根节点。它包含第二层的元素树，这个树也存在一个被称为“文档元素”的根节点。</p>
<h5 id="元素嵌套"><a href="#元素嵌套" class="headerlink" title="元素嵌套"></a>元素嵌套</h5><p>XML对元素有一种非常重要的要求：它们必须正确地嵌套。对现实世界对象的分析会有助于解释“正确嵌套”的含义。实际上，我们甚至可以说XML元素是任何必须遵守它们的现实来源规则的单词。</p>
<p>让我们来看一看本书传递到读者手中的整个过程。在完成印刷后，本书会和其他23本书打包到一个盒子中。两个盒子会被封装到一个纸箱中，许多纸箱会被装入一辆卡车然后运送到书店中。</p>
<p>整个过程可以用以下XML元素表示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230807.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230807.png';" /></details>

<p>在上面的例子中，缩排只是为了突出这些嵌套元素的层次结构，为了简单起见也省略了许多对书和纸箱的描述。现实世界中的盒子能够包容整本书，但不可能出现书的某些部分在盒子中，而其他部分在外面的情况；同样，一本书也只能放在一个盒子中，不可能一部分在一个盒子，其他部分在另一个盒子。此外，盒子必须放在纸箱中，而纸箱必须顺序摆放在卡车里。当然，XML元素也必须遵守这些现实世界包容关系的基本法则。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>字符串（string literal）主要用在属性值、内部实体和外部标识符中。XML都使用单引号（’）或双引号（””）作为一对分隔符将其中的字符串包围起来。对于这些字符串的一个限制是用于分隔符的字符不能够出现在字符串中，如果字符串中包含单引号，分隔符就必须使用双引号，反之亦然。如果两个字符都必须出现在字符串中，用在字符串中（同时也用作分隔符）的字符必须用适当的实体引用顶替（&amp;apos；或者”）。</p>
<p>下面是一些合法的字符串表述：</p>
<p>‘string’, “string”. ‘this&apos;s a “Web Service”‘</p>
<p>而下面则是一些不合法的字符串表述：</p>
<p>“string’. ‘this’s a “Web Service”‘</p>
<p>从技术的角度讲，根据XML规范，字符串分隔符之间的文本是文档字符数据的一部分。在讨论属性之前，我们先看一看它所包含的意义。</p>
<h4 id="字符数据"><a href="#字符数据" class="headerlink" title="字符数据"></a>字符数据</h4><p>字符数据就是任何不是标记的文本，它是元素或属性值的文本内容。小于号、大于号和&amp;符号是标记分隔符，因此它们绝不能以字符串的形式出现在字符数据中（CDATA部分除外，这一点我们将在后面提到）。如果这些字符是字符数据所必需的，它们必须使用实体引用“&It;”、“&gt;”以及“&amp;”来代替。这几个替代物是XML规范定义的5个类似字符串中的一部分，而且在所有兼容XML的解析器中都得到实现。</p>
<p>这里，需要再次提醒大家，由于XML的目的是在全球范围使用，所以文本是指统一代码，而不仅仅是ASCII码。现在，我们就来讨论属性的问题。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>如果说元素是XML中的名词，那么属性就是这种语言的形容词。在很多情况下，我们会希望将某些信息附着在元素上，它们与元素本身包含的信息内容有所不同。我们利用属性（attribute）来做到这一点，它们都包括一个名称/值对组合，使用的格式有如下两种形式：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230937.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230937.png';" /></details>

<p>属性值必须是分隔开的字符串（字符串规则的要求），其中可能包含实体引用、字符引用以及（/或）文本字符。但是，正如我们刚才解释的那样，任何一个受保护的标记字符（“〉”、“〈”和“&amp;”）都不能简单地在属性值中当作字符使用，它们必须用“&It; ”、“&gt;”或“&amp;”实体引用来替代。</p>
<p>HTML允许数字化的属性，例如〈IMGWIDTH=300〉；或者不分隔的属性，比如〈PALIGN=LEFT〉；但这两种情况在XML中都不允许存在。</p>
<p>在起始标记或空标记中属性只允许有一个实例存在。例如，下面的例子在XML中就是非法的，因为src在一个标记中出现了两次：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230954.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230954.png';" /></details>

<p>这种限制极大地简化了XML的处理。正如我们在前面暗示的，起始标记和空标记可能在标记中包含属性。例如，回到我们前面提到的关于书本、盒子、纸箱和卡车的例子，如果我们希望给每个运送书本的纸箱编上一个号码的话，可以使用如下属性：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231010.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231010.png';" /></details>

<p>在这个例子中，属性名称是number，相应元素起始标签中的值为”0-232-93-1’”及’0-232-93-2’。注意两个合法的字符串分隔符”和’在本例中都被使用了。</p>
<h5 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h5><p>管是对于人类语言还是计算机语言来说，空白确实是一个非常重要的语言概念。在XML数据中，只有4个字符可以作为空白使用，如表8-1所示。</p>
<details><summary>表8-1　4个字符的描述</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231030.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231030.png';" /></details>

<p>无论如何，制表位占用的位置都不会只超过一个字符，所以它们中的每一个都可以简单地看作是一个字符。同样，任何由LF和（/或）CR隐含的格式也是交给应用程序和（/或）样式表处理；同时，Unicode定义了许多不同种类的空格，但其中没有一个能够成为XML中的空白。XML处理空白的规则非常简单：解析器会保留内容中所有的空白字符并不加修改地传递给应用程序，但元素标记和属性值中的空白会被删除。</p>
<p>现在，让我们看一看XML是如何处理文档中的行尾的。</p>
<h5 id="行尾的处理"><a href="#行尾的处理" class="headerlink" title="行尾的处理"></a>行尾的处理</h5><p>XML数据对象经常存储在离散的计算机文件中，它们被分割为若干个文本“行”。在4个XML空白字符中有两个是标准的ASCII码行尾控制字符。正如我们前面提到的，在用来表示行尾时，会有这两个字符的三种常见组合：CR/LF、只有LF以及只有CR。</p>
<p>为了简化XML应用程序的编码，XML解析器需要将所有的行尾字符串转换为单个LF（换行）字符。很自然，这会让Unix编程者感到非常高兴，而让许多MS-Windows的开发人员怨声载道（Mac OS用户已经适应了处理多种行尾字符串）。Tim Bray曾经提出过一些折衷办法（主要是考虑到MS-Windows的市场份额），但结果是XML仍然要求使用Unix风格的行尾字符。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>这种机制对于在文档当中插入提示，或者叫注释（comment）来说是相当有帮助的。这些注释可能提供修订记录、历史信息或者其他类型的可能，这对创建者或者文档编辑者来说有着特殊意义，但又不是真正的文档内容的元数据。注释可能出现在文档中除其他标记部分以外的任何地方。</p>
<p>XML注释的基本语法如下。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231135.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231135.png';" /></details>


<h4 id="CDATA部分"><a href="#CDATA部分" class="headerlink" title="CDATA部分"></a>CDATA部分</h4><p>CDATA部分是一种用来包含文本的方法，其对象是那些其中的字符如果不如此处理就会被识别为标记的文本。这项特性对于希望在自己的文档中包含XML标记的使用举例的作者来说是最有用的，就像本书中的举例。但这可能是在文档中包含CDATA部分的唯一说得过去的理由，因为在使用这些部分时XML几乎所有的优势都丧失殆尽。</p>
<p>只要有字符数据出现的地方就可能出现CDATA部分，但它们不能够嵌套。CDATA部分的基本语法如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231157.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231157.png';" /></details>

<p>在这里，”…。.”部分可以是任何字符串，只要不包含字符串”]]〉”。</p>
<p>由于在Web服务系列技术中，CDATA同样不是常用技术，因此在这里也不加以详细讨论。</p>
<h4 id="格式正规的文档"><a href="#格式正规的文档" class="headerlink" title="格式正规的文档"></a>格式正规的文档</h4><p>所有遵守XML语法规范的数据对象（文档）都是格式正规的XML文档。这类文档在使用时可以不使用DTD或模式来描述它们的结构，它们也被称作独立的（standalone）XML文档。这些文档不能够依靠外部的声明，属性值只能是没有经过特殊处理的值或默认值。</p>
<p>一个格式正规（well-formed）的XML文档包含一个或多个元素（用起始和结束标记分隔开），它们相互之间正确地嵌套。其中有一个元素，即文档元素，包含了文档中其他所有的元素。所有的元素构成一个简单的层次树，所以元素和元素之间唯一的直接关系就是父子关系。兄弟关系经常能够通过XML应用程序内部的数据结构推断出来，但这些既不直接，也不可靠（因为元素可能被插入到某个元素和它的一个或多个子元素之间）。文档内容可能包括标签和（/或）字符数据。</p>
<p>数据对象如果满足下列条件就是格式正规的文档。</p>
<p>（1）语法合乎XML规范。</p>
<p>（2）元素构成一个层次树，只有一个根节点。</p>
<p>（3）没有对外部实体的引用，除非提供了DTD。</p>
<p>任何XML解析器如果发现在XML数据中存在并不是格式正规的结构，就必须向应用程序报告一个“致命”错误。致命错误不一定导致解析器终止操作，它可以继续处理，试图找出其他错误，但它不再会以正常的方式向应用程序传递字符数据和（或）XML结构。之所以采用这类错误处理方式，一是因为XML简洁的设计风格，二是因为XML更多的不是用于显示，因为这不太容易使得XML数据对象做到格式正规。</p>
<p>对于HTML/SGML来说，它们的工具都要比XML宽容许多。HTML浏览器通常会显示出大多数支离破碎的Web页面，这为HTML的快速流行做出了巨大贡献。此外，真正的显示会因浏览器而异。同样，SGML（Standard Generalized Markup Language）工具即使遇到错误，通常也会尽力继续处理文档。</p>
<p>格式正规的文档的存在使得可以使用XML数据而不必承担构建和引用外部描述的重任。术语“格式正规”与正式的数学逻辑有着相似之处，一个命题如果满足语法规则就是格式正规，而不在于它的正确与否。</p>
<h3 id="XML命名空间"><a href="#XML命名空间" class="headerlink" title="XML命名空间"></a>XML命名空间</h3><p>我们知道，XML是一种元语言，我们可以使用XML来定义各种各样的应用。在上一节中，我们就已经看到了如此多的基于XML的规范，它们都是使用XML定义的XML Application（XML应用语言）。一般来说，我们可以使用DTD或者XML Schema来规范化定义每种特别的XML。本书将不再介绍DTD，如果有兴趣的话，可以阅读XML规范或者相关材料去了解其细节；对于XML Schema，本书将在下一节结合实例进行描述。</p>
<p>无论是使用DTD还是XML Schema，都是去定义一个专用XML词汇集以及使用这些词汇的规则，这样我们就不可避免地面对这样一些问题：</p>
<p>（1）如何知道我们在一个XML实例文档使用的XML词汇是在哪个XML Application中定义的？</p>
<p>（2）当我们混合使用两个XML Application的词汇集时，如果两个词汇集中有相同名字的元素名（当然它们表示的是不同的含义），如何区分它们？</p>
<p>同样，这些问题也会发生在我们自己来定义XML标签的场合中。比如说，如果你考虑使用monitor这样的元素，那么它在不同的环境将有几种不同的意思。如果你在计算机外围设备描述中使用，monitor可能指的是计算机屏幕，同时在音乐制作间里扬声器通常也叫做monitor。如果这里有一个专用于描述学校信息的数据模式，monitor可能指的是一个被赋予几种职责的学生，然而在原子核电站，monitor可能放在报警的地方。即便意思相同，在两种不同的定义中，其内容也会发生改变。</p>
<p>面对元素的这些潜在的不同用途，我们需要一种方法去区分元素的特定用途，特别是我们在同一个XML文档里混用不同的词汇。为了解决这个问题，W3C提出了称为XML命名空间的规范，它允许我们在一个命名空间定义元素的前后联系，同时可以使用不同的命名空间来区分不同的XML词汇集中的元素名。</p>
<p>1999年1月14日，XML命名空间成为了W3C的推荐标准的程度。这一节将主要介绍XML命名空间。命名空间帮助XML词汇表设计者去将复杂的问题分解成细小的问题，以及根据需要混合多义词来描述单一XML文档里的问题。模式允许词汇表设计者去建立更多而准确的词汇定义。</p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>XML命名空间是解决多义性和名字冲突问题的方案。根据W3C组织的推荐标准XML Namespace （1999年1月14日）中的描述，XML命名空间是一种名称的集合，通过一种URI （Uniform Resource Identifier）引用来标识，作为元素类型和属性名称，它应用于XML文档。</p>
<p>命名空间是一组具有结构的名称的集合，这听起来像一个DTD，的确，一个DTD可以是一种命名空间（因为一个DTD定义了一个XML词汇集）。在这种情况下，URI可以是在你的服务器上的地址，如<a target="_blank" rel="noopener" href="http://www.uddi-china.org/schema/PubCatalog.dtd%E3%80%82">http://www.uddi-china.org/schema/PubCatalog.dtd。</a></p>
<p>DTD规定了一个文档的整体结构（并且是那么的准确），我们正好以一个命名空间为资源，规划所需要的定义。说到这里，一个命名空间不需要是一个像DTD那样的有固定结构的定义，而这个有限的定义领域使命名空间广泛应用于XML。如果命名空间是DTD或者XML Schema，我们使用的定义就必须在所描述的结构和语法上保持连续性。但是我们可以自由地使用需要的名称，并且使用命名空间来区分元素的使用。</p>
<p>于是，为了在文档里有效地使用命名空间，而文档中连接着来自不同地方的元素，我们需要两部分：</p>
<p>（1）URI引用，定义了元素的使用方法。</p>
<p>（2）一个别名，我们可以用此来标识元素来自哪个命名空间，这将采用元素前缀的形式（例如在〈中，catalog是模糊的contact元素的命名空间别名）。</p>
<h4 id="定义和声明命名空间"><a href="#定义和声明命名空间" class="headerlink" title="定义和声明命名空间"></a>定义和声明命名空间</h4><p>看到了命名空间在XML里所带来的优点，我们需要仔细看一下如何真正地使用它们。首先看一下在文档里怎样声明一个命名空间，然后看一下在文档里怎样使用命名空间，最后给出了几个例子。</p>
<p>通常，简单描述的特性作为属性来建模，并且这就说明了命名空间是怎样在XML中声明的。但这里有几个变形与转化，于是我们需要一步一步地去学习当在一个XML文档里声明一个命名空间时所能描述的东西。</p>
<h5 id="声明一个命名空间"><a href="#声明一个命名空间" class="headerlink" title="声明一个命名空间"></a>声明一个命名空间</h5><p>如果每个人在他们打算去识别一个命名空间声明的时候，我们需要在XML表示中提供一个保留的词汇给他们，命名空间推荐标准为我们提供了xmlns属性。属性值就是URI，其唯一地定义了当前使用的命名空间。URI经常是一个指向模式定义描述的URL（可能是DTD，也可能是XML Schema文档，甚至是其他）。用这种方式管理一个URI,以唯一区分命名空间已经足够了。</p>
<p>这里有几个简单的命名空间声明：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231359.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231359.png';" /></details>

<p>关于Web资源的术语可能令人混淆。统一资源标识符（URI）是一些资源的唯一名称，它根据协议和网络位置定位资源。第一个例子是URL，因为它允许一个浏览器利用HTTP（Hypertext Transfer Protocolv）从一个特定的位置得到资源。第二个例子给资源命名但没提供位置，字面上的urn来自于URI。</p>
<p>最初使用命名空间的动机之一是能够从不同的来源混合名称。基于这个考虑，为命名空间提供别名就成为非常有用的机制。而你能在一个涉及到相关声明的文档里通篇使用这个别名，可以靠加个冒号和你的别名到xmlns属性而实现该功能。因此上面的例子就变成了：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231418.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231418.png';" /></details>

<p>通过这样的命名空间声明之后，文档中的元素如果使用了uddi前缀（形如uddi:businessEntity），那么表示这个元素使用了<a target="_blank" rel="noopener" href="http://www.uddi-china.org/schema/uddiv2.xsd">http://www.uddi-china.org/schema/uddiv2.xsd</a> 中描述的定义。而如果使用了catalog这个前缀（元素形如），那么则表明使用了urn:catalog-specification所标识的定义。使用这些声明和它们的别名为我们提供了更多的元素信息。当然如果没有前缀那就等同于使用了xmlns=”…”的命名空间约束。’</p>
<h5 id="修饰名"><a href="#修饰名" class="headerlink" title="修饰名"></a>修饰名</h5><p>如果不能和一个我们想要使用的特定的名称绑定在一起，声明一个命名空间是没有什么用处的。这些已经通过利用修饰名（或成为命名空间修饰名，也就是使用命名空间前缀进行修饰的元素名或属性名）做到了。这就可能是你所希望的，一个从命名空间勾画出来并经其限定了的名称。通过别名创建一个确认过的名称，确切地说称作命名空间前缀，并把它放在名称的开始。下面是一个命名空间的例子：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231506.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231506.png';" /></details>

<p>此后我们就能够使用前缀catalog来进一步修饰每个元素名，使元素更加明确地表示出是来自哪个命名空间。于是，将要告诉我们contact名来自catalog命名空间声明；同样可能来自其他的命名空间，比如某个Order命名空间也有contact名称，但经过修饰的名称避免了多义性和冲突的可能性。</p>
<p>命名空间前缀经常被提及为前缀，而名称本身是基本名。修饰名可被应用于元素和属性名称。这里有一个混合一些命名空间的例子：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231517.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231517.png';" /></details>

<p>这个元素从我们在上面看到的第一个命名空间那里产生，而属性id则从identifier命名空间产生。</p>
<h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><p>命名空间声明就像变量在程序语言里那样有它的作用范围。这非常重要，这是因为命名空间并不总是定义在XML文档开始，它们能够被包含在文档的较后部分。一个命名空间声明因此也应用于有声明出现的元素，尽管与此同时子元素并没有清清楚楚地描述出来。只要被用在命名空间声明的范围之内，就能够访问到命名空间。</p>
<p>但是我们也需要去混合命名空间，元素可能会回去另外地继承命名空间的作用域，于是这里有两种可以声明作用域的办法，即默认和修饰。</p>
<h6 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h6><p>如你所想象的，在一个文档里，在每一个名称前加一个前缀非常令人厌烦。实际上，通过在工具集里引入名称作用域的概念，能够分配很多前缀。如果定义了默认的命名空间（没有声明别名的，形式为xmlns=”…”），在声明作用域里所有没有经命名空间前缀修饰的名称被假定属于默认的命名空间。于是如果在根元素声明了一个默认的命名空间，它将被看作整个文档将默认的命名空间，并只能被在文档内部声明的其他的默认命名空间所覆盖。</p>
<p>通常省略前缀可以将一个命名空间声明为某范围内默认的。当一个前缀被定义并被一个名称引用时，明确地声明了命名空间。而对于那个带有命名空间声明但又不包含命名空间前缀修饰（使用默认命名空间）的元素，它们同样是属于其自身所带的命名空间声明所指定的命名空间的。</p>
<h6 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h6><p>如果你能够清楚地区分命名空间，那当然非常好。但有些时候可能想要在一篇文档里从某个元素之外的命名空间来修饰名称，你就需要一个更精细的划分尺度。除了在整个空间声明命名空间，还可以利用带命名空间修饰的名称。在文档开头声明将需要的命名空间，然后在使用地点使用命名空间来修饰那些需要的元素和属性。</p>
<p>命名空间的存在主要是用来将名称组织成特有的集合以及回避名称冲突。W3C命名空间推荐标准没有描述任何有关验证的使用方法。确实，XML 1.0规范中没有说任何有关命名空间的东西。XML Schema则将充分利用命名空间的功能。我们将在后面的章节中结合实例来阐述XML Schema的使用方法。</p>
<h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>一个XML文档是有效的，则它必须满足：文档和一个文档类型定义或者模式相关联，这样XML处理器才能够理解并解析。那么怎样定义并利用这样一个文档类型定义呢？本节会具体讲述文档类型定义（DTD）。</p>
<h4 id="什么是DTD"><a href="#什么是DTD" class="headerlink" title="什么是DTD"></a>什么是DTD</h4><p>DTD即文档类型定义，是SGML、标准经XML的简化继承而来的，顾名思义，它主要是用来查看XML文档的格式，正如第7章所提到的，有关DTD的声明如果存在，则应出现在XML文档的序言中，以便XML校验器一开始就可以得到DTD所定义的该份XML文档的格式定义。另外，已经介绍过良构的XML文档和有效的XML文档的区别，所以可以知道DTD声明不是必须出现的。</p>
<p>在DTD中主要定义以下几个方面的内容：</p>
<p>（1）元素声明，包括元素的内容和元素的排列组合方式。</p>
<p>（2）实体声明。</p>
<p>（3）属性的种类</p>
<h4 id="为什么引入DTD"><a href="#为什么引入DTD" class="headerlink" title="为什么引入DTD"></a>为什么引入DTD</h4><p>首先考虑一下DTD的作用问题。事实上，DTD也好，XML Schema也好，它们都是提供一种验证的手段。验证对于XML来说是一大贡献，正是有了验证才可以确保XML文件确实地遵守了指定的格式，而这个格式可能是一个标准，或是数据交换双方所共同制定的协议，也正是如此，XML在电子商务领域掀起了轩然大波。</p>
<p>DTD的使用实现了文件格式的统一化，促进了行业或系统内部的文件的标准化，同时也提高了文件的重用性。DTD定义了文件的格式，这种统一的格式可能为某一领域的大量文件所共用，减少了文件制作的时间。也正是由于DTD（和XML Schema）的存在才突出了XML文档的数据的结构性。</p>
<p>但是也应该看到，并不是所有的文件都强调结构性。对于本身的结构性很强，或是在实际应用中不强调它的结构性的文档，使用DTD进行验证，增加了操作时间，得不偿失，可以考虑不使用DTD，只建立良构的XMI文档就行了</p>
<h4 id="DTD的声明"><a href="#DTD的声明" class="headerlink" title="DTD的声明"></a>DTD的声明</h4><h5 id="内部DTD声明"><a href="#内部DTD声明" class="headerlink" title="内部DTD声明"></a>内部DTD声明</h5><p>DTD的声明分为内部DTD声明和外部DTD声明。在本节通过如下例子介绍内部DTD声明。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231707.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231707.png';" /></details>

<p>从上面的例子中可以看到内部DTD声明的语法是：</p>
<!DOCTYPE根元素名称[...DTD规则

...]>

<p>可以看出内部DTD声明是内嵌于相应的XML文档当中的，这种方式虽然简单，但是从引入DTD的原因考虑，很容易想到，这种做法并不利于文档结构的重用。为此XML还提供了另一种DTD声明——外部DTD声明。</p>
<h5 id="外部DTD声明"><a href="#外部DTD声明" class="headerlink" title="外部DTD声明"></a>外部DTD声明</h5><p>外部DTD声明的语法规则可以描述为如下形式。</p>
<!DOCTYPE根元素名称SYSTEM DTD的URI><p>或者</p>
<!DOCTYPE根元素名称PUBLIC DTD的名称DTD的URI>

<p>可以看出，外部DTD声明是依照两种方式进行的，分别把它们叫做SYSTEM方式和PUBLIC方式。下面分别说明两种方式的使用方法。</p>
<h6 id="SYSTEM方式的外部DTD声明"><a href="#SYSTEM方式的外部DTD声明" class="headerlink" title="SYSTEM方式的外部DTD声明"></a>SYSTEM方式的外部DTD声明</h6><p>与PUBLIC相对，使用SYSTEM模式的DTD一般在未公开、私人或小团体内使用，可以根据有关URL的规定设置该DTD与用它的XML文档之间的路径关系。</p>
<p>●　“..”代表到该文档所在目录的上层目录。</p>
<p>●　“/”代表子目录。</p>
<p>●　默认情况代表当前目录。</p>
<p>下面是一个XML文档，它使用的是SYSTEM方式的外部DTD声明。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231753.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231753.png';" /></details>

<p>这个XML文档引用的DTD文件dtd1.dtd内容如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231809.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231809.png';" /></details>

<p>关于这个例子，需要说明的是，在处理指令)<code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;standalone=&quot;no&quot;?)&gt;</code>时，属性standalone应该设置为no，因为此时不是单个的XML文件，还需要读取它的DTD文件。</p>
<h6 id="PUBLIC方式的外部DTD声明"><a href="#PUBLIC方式的外部DTD声明" class="headerlink" title="PUBLIC方式的外部DTD声明"></a>PUBLIC方式的外部DTD声明</h6><p>在很多情况下，可能与其他合作伙伴共同制定为一个行业或某个工作领域共同遵守的XML文档格式，这时所使用的DTD就不是小团体或个人所属的，而具有公共性质，就如本书下半部分将要介绍的电子商务领域的XML标准。这时作为一种公用的DTD，它可能存放在某个Web网站上，用PUBLIC方式的外部DTD声明指明这种公用的DTD。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903231858.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903231858.png';" /></details>

<p>关于这个例子，需要说明的是，DTD的URL必须是绝对路径，另外可能注意到了增加了一个参数”TransactionDTD”，这个参数是DTD的名称，如果公用DTD的原作者没有指明它的名称，可以自行定义一个名称。</p>
<p>事实上，XML的验证器在验证XML文档是否符合它所声明的PUBLIC方式的外部DTD声明时，首先将外部DTD从指定的URI.处下载，然后做与SYSTEM方式下同样的验证。</p>
<h5 id="内部DTD和外部DTD同时使用"><a href="#内部DTD和外部DTD同时使用" class="headerlink" title="内部DTD和外部DTD同时使用"></a>内部DTD和外部DTD同时使用</h5><p>DTD的使用方式相当的灵活，它不仅提供了内部DTD和外部DTD两种方式，而且还支持内部DTD和外部DTD的同时使用以及和多个外部DTD的同时使用，那么很自然想到一个问题，当两种DTD有一部分声明是重复的，该怎么办呢？事实上，在两种声明存在重复的情况下，处理重复部分的方式和面向对象概念中的重载很类似，把内部声明看作对外部声明中重复部分的再一次说明，重复的部分以内部声明为主。这样就大大提高了外部声明的重用率，使得取用外部DTD的机会增加。</p>
<h4 id="元素的声明"><a href="#元素的声明" class="headerlink" title="元素的声明"></a>元素的声明</h4><p>元素是XML文档中相当重要的组成部分，通过介绍在DTD中元素的声明方式进一步了解元素。</p>
<p>元素声明的基本语法可以写作：</p>
<!ELEMENT元素名称　元素定义>

<p>其中ELEMENT是XML中预留的关键字。可以看出在元素声明中比较复杂的是元素定义部分。下面分不同的情况介绍元素的定义。</p>
<h5 id="空元素的声明"><a href="#空元素的声明" class="headerlink" title="空元素的声明"></a>空元素的声明</h5><p>空元素应该说是最简单的元素，它通过预留关键字EMPTY来实现。下面是一个空元素的声明：</p>
<!ELEMENT附加条件EMPTY>

<h5 id="文本元素的声明"><a href="#文本元素的声明" class="headerlink" title="文本元素的声明"></a>文本元素的声明</h5><p>这里主要指元素的内容完全是文本形式的元素类型，XML中用（#PCDATA）来描述，意思是可解析数据。下面是一个文本元素的声明：</p>
<!ELEMENT地址 (#PCDATA)>

<h5 id="无限制元素的声明"><a href="#无限制元素的声明" class="headerlink" title="无限制元素的声明"></a>无限制元素的声明</h5><p>这里所指的无限制元素是XML为某些结构性比较差的元素提供的说明方法，它对该元素不作限制。这里的不作限制可以理解为：</p>
<p>（1）可以包含任何在该DTD中声明过的子元素。</p>
<p>（2）这些子元素的出现次数与次序不作限制。</p>
<p>（3）可以包含文本数据，即（#PCDATA）型数据。</p>
<p>（4）数据内容与子元素可以交错出现。</p>
<p>XML通过关键字ANY实现对无限制元素的声明。这类无限制元素的声明语法如下：</p>
<!ELEMENT附加条件ANY>

<h5 id="包含子元素的元素声明"><a href="#包含子元素的元素声明" class="headerlink" title="包含子元素的元素声明"></a>包含子元素的元素声明</h5><p>第7章就介绍过了关于根元素、父元素和子元素的概念。事实上，XML文档本身通过元素之间的嵌套关系描述了数据（元素）之间树状结构关系，正因如此DOM等应用程序接口才能十分方便地将XML文档转化为许多应用程序习惯处理的树状结构或其变种。</p>
<p>所以，考虑包含子元素的元素声明时，应该注意不只要定义包含的子元素是什么，而且要定义这些子元素出现的次数和次序，在XML中通过一些结构符号描述这些信息，这些符号的描述如表8-2所示。</p>
<details><summary>表8-2　结构符号的具体描述</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232017.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232017.png';" /></details>

<h4 id="实体的声明"><a href="#实体的声明" class="headerlink" title="实体的声明"></a>实体的声明</h4><h5 id="什么是实体"><a href="#什么是实体" class="headerlink" title="什么是实体"></a>什么是实体</h5><p>简单地说，实体（entity）是一些预先定义好的数据，在需要使用这些数据的时候通过引用的方法将它放入特定的位置。使用实体的好处在于对于一些重用率很高的数据，通过将它们定义成实体，减少对这类数据进行修改是必须做的重复工作。另外，通过实体可以把一些特殊的数据，如声音文件、图片文件等引入XML文档。</p>
<p>根据不同的角度可以对实体进行多种不同的分类：按照实体存储的部位的不同，实体可以分为内部实体和外部实体；按照实体的组成内容的不同，实体可以分为可分解实体和不可分解实体两种；按照实体引用方式的不同，可以分为一般型实体和参数型实体。不同类型的实体的声明和使用方法略有不同，下面进行详细的介绍。</p>
<h5 id="内部实体和外部实体"><a href="#内部实体和外部实体" class="headerlink" title="内部实体和外部实体"></a>内部实体和外部实体</h5><p>内部实体在声明的时候就被完整地定义，因此应该想到，内部实体只能是文本型的数据。内部实体的声明方法如下：</p>
<!ENTITY实体名称　实体内容>

<p>实体的引用方法是：</p>
<p>&amp;实体名称；</p>
<p>如下例子说明如何声明并引用实体。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232118.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232118.png';" /></details>

<p>外部实体的声明虽然在DTD文档中，但是实体代表的数据本身存储于DTD文档之外。外部实体的声明方法如下：</p>
<!ENTITY实体名称SYSTEM I PUBLIC"URI">

<p>有关属性SYSTEM和PUBLIC的意义和DTD声明中介绍的一样，这里不再重复。外部实体的引用方法和内部实体是一样的。</p>
<p>最后要说明的是特殊字符的使用问题。在XML中，一些字符被赋予了特殊的意义，当不想使用这些字符的特殊意义而引用它们时，就使用实体引用的方式。表8-3是常见特殊字符的实体引用方式。</p>
<details><summary>表8-3　常见特殊字符的实体引用方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232134.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232134.png';" /></details>

<h5 id="可分解实体和不可分解实体"><a href="#可分解实体和不可分解实体" class="headerlink" title="可分解实体和不可分解实体"></a>可分解实体和不可分解实体</h5><p>可分解实体又称为文本实体。所谓可分解是指可以被XML验证器所解读，并且在解读后将实体的内容放入引用该实体的位置上去，例如相对于可分解实体，不可分解实体就是不能直接被XML验证器所解读的实体，例如图片、声音文件等。由于XML校验器本身不能解读这种实体，所以在声明这类实体时应该声明它的格式以及处理该实体的应用程序的位置。下面是不可分解实体的声明方法：</p>
<!NOTATION格式SYSTEM|PUBLIC处理程序的URI>

<!ENTITY实体名称SYSTEM|PUBLIC实体的URI NDATA格式>

<p>实体的引用方式没有变化。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232209.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232209.png';" /></details>

<h5 id="一般型实体和参数型实体"><a href="#一般型实体和参数型实体" class="headerlink" title="一般型实体和参数型实体"></a>一般型实体和参数型实体</h5><p>到现在为止，所介绍的实体都是一般型实体。这种类型的实体不仅可以在XML文件本体中引用，而且可以在它所在的DTD中使用。在所在DTD中使用应该注意的是，一般只用于对另外的实体的声明，不用于对元素的声明中，同时应该避免实体中引用实体时产生循环引用的现象。</p>
<p>一般型实体在引用时都采用如下方式：&amp;实体名称；而将要介绍的参数型实体则有很大不同，这类实体只在外部DTD声明中使用，而且不同于一般型实体，它可以用于元素的声明中。它的声明语法如下：</p>
<!ENTITY％实体名称　实体内容>

<p>引用语法如下：</p>
<p>％实体名称</p>
<p>可见，参数型实体和一般型实体有着很大的不同。事实上，可以把参数型实体看作在声明外部DTD时为避免重复工作提供的一种方法。如果有机会读到一些用作行业标准的DTD文档，会发现其中存在着大量的参数型实体的引用。</p>
<p>对一般型实体和参数型实体的区别总结如表8-4所示。</p>
<details><summary>表8-4　一般型实体和参数型实体的区别</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232228.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232228.png';" /></details>

<details><summary>续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232240.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232240.png';" /></details>

<h4 id="属性的声明"><a href="#属性的声明" class="headerlink" title="属性的声明"></a>属性的声明</h4><p>属性是XML提供的描述元素某些性质的信息，XML本身提供了一些默认属性，如最早在处理语句<code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;standalone=&quot;no&quot;?&gt;</code>就接触到默认属性version、encoding和standalone。当然除了默认属性以外，还可以根据需要自行设计属性，在一个良构XML文档中，属性只要满足命名规则就可以了，但是在一个有效的XML文档中，属性要经过DTD的属性声明，这是DTD声明中比较复杂的一部分。</p>
<p>在DTD声明中，属性的声明语法可以归纳为如下形式。</p>
<!ATTLIST元素名称　属性名称　属性类型　属性默认值类型>

<p>这里需要说明的是，元素名称指的是属性所属的元素名称，关于属性类型和属性默认值类型是属性中比较复杂的内容，下面详细地进行介绍。</p>
<h5 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h5><p>属性类型是对属性取值的约束，属性值类型共有7种选择，下面一一介绍。</p>
<p>（1）CDATA类型：CDATA类型是最简单的属性类型，也是约束最少的属性类型，代表该属性值为一般的文字，除此没有其他限制。声明语法如下：</p>
<!ATTLIST元素名称　属性名称　CDATA　属性默认值类型>

<p>（2）枚举型：枚举型列举了该属性所能取得的全部值。声明语法如下：</p>
<!ATTLIST元素名称属性名称（可选属性值1|可选属性值2|...|可选属性值n）属性默认值类型>

<p>（3）NMTOKEN和NMTOKENS类型：使用NMTOKEN属性类型时，表明该属性的属性值只能由字母、数字、“_”等字符所构成的字符串，即属性值满足命名规则，且不能出现空格。NMTOKENS属性则表明属性值可能由若干个满足NMTOKEN属性要求结合在一起形成的，即多个NMTOKEN之间可能存在空格，声明语法如下：</p>
<!ATTLIST元素名称　属性名称　NMTOKENINMTOKENS属性默认值类型>

<p>（4）ENTITY和ENTITIES类型：当属性值是一个外部实体的引用时，用ENTITY来说明属性类型；一般来说，当属性值是一个内部实体引用时，将属性类型声明为CDATA即可。</p>
<p>（5）NOTATION类型：在介绍不可分解实体类型时已经提到过NOTATION的声明，当属性只是一个声明过NOTATION格式时，将属性声明为NOTATION类型。由此也可以看出，在把一个属性声明为NOTATION类型时，首先应该确定存在相应的NOTATION声明。下面把NOTATION声明和NOTATION类型属性声明的语法写在一起。</p>
<p><code>&lt;NOTATION格式SYSTEM I PUBLIC处理程序的URI&gt;</code></p>
<p><code>&lt;ATTLIST元素名称属性名称NOTATION属性默认值类型&gt;</code></p>
<p>（6）ID类型：CDATA类型对于属性的限制是比较少的，ID类型是在CDATA类型的属性类型上加入一点更强的约束条件，那就是作为此类型值的名字只能在XML文件中出现一次。此即，ID类型的值必须能唯一标识元素。</p>
<p>（7）IDREF和IDREFS类型与ID类型相对，IDREF就是ID REFERENCE的意思，表明该属性的取值是对声明过的一个ID型属性值的引用，也就是说，IDREF类型的值必须匹配某些ID属性的值。同样道理，IDREFS类型表明该属性的取值是对声明过的多个ID型属性值的引用。</p>
<h5 id="属性默认值类型"><a href="#属性默认值类型" class="headerlink" title="属性默认值类型"></a>属性默认值类型</h5><p>属性默认值类型有4种可选情况，下面一一介绍它们的使用时机和使用方法。</p>
<p>（1）#IMPLIED表明该属性可出现可不出现，声明语法：</p>
<!ATTLIST元素名称　属性名称#IMPLIED>

<p>（2）#REQUIRED表明该属性一定要出现，声明语法：</p>
<!ATTLIST元素名称　属性名称#IMPLIED>

<p>（3）#FIXED表明该属性一定要出现，且固定为特定值，不许用其他值，声明语法：</p>
<!ATTLIST元素名称　属性名称#FIXED属性特定值>

<p>（4）特定属性值表明该属性的默认值，当XML文档中没有显式给出该属性的取值时，取此值。当该属性的取值已经显式地给出时，则为给出值：</p>
<p>&lt;–!ATTLIST元素名称　属性名称　属性默认值&gt;</p>
<h3 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h3><p>DTD在制定标记语言方面历史悠久，早在XML正式标准出现以前就已经存在，当时它配合SGML来制定标记语言，是专门为SGML服务的DTD。当XML出现之后，DTD尽管进行了很大的简化，但还是一门风格和XML完全不同的语言，不经过细致学习，根本不可能应用这种语言制定标记语言。而schema文档是一种特殊的XML文档，它遵循XML的语法要求，避免用户再去另外学习一套语法，同时schema语法结构简单，容易学习和使用。因而在发展势头上schema远高于DTD。</p>
<p>DTD的另一个缺点是数据类型相当有限。在DTD中根本不提供数值数据类型，例如整数、浮点数、布尔数等，所有的文档内容都是字符数据。而schema则提供了丰富的数值类型，不但有整数、浮点数等常用的类型，还提供了自定义数据类型的机制。</p>
<p>一个XML文档只能使用一个DTD文档，尽管DTD可以通过多数实体机制来部分改变这种缺点，但还是严重地导致了DTD的继承和使用的有限性。schema则采用了名域空间的机制，使得一个XML文档可以调用多种schema文档。在代码的重用性和可扩展性方面要远远优于DTD。</p>
<h4 id="逻辑XML-Schema的文档结构"><a href="#逻辑XML-Schema的文档结构" class="headerlink" title="逻辑XML Schema的文档结构"></a>逻辑XML Schema的文档结构</h4><p>XML Schema则是一类特殊的XML文档，除了具有XML文档的语法要求外，还要有一些特殊的要求。下面给出了这种文档的一个模板程序1，任何的XML Schema文档只要在该文档的基础上进行继续编写即可。</p>
<p>程序1</p>
<p>文件l.xml</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232440.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232440.png';" /></details>

<p>所有的内容都添加在<code>&lt;Schema&gt;&lt;/Schema&gt;</code>当中，该程序可以作为所有schema文档的模板。关于schema的模板在语法方面总结几点：</p>
<p>（1）根标记必须为<code>&lt;Schema&gt;&lt;/Schema&gt;</code>。</p>
<p>（2）xmlns是一个名域声明，表示Schema文档中使用的标记都是内标识为urn:schemas-microsoft-com:xml-data规范所定义的，前面字符串可以当作是该规范的名字。</p>
<p>（3）xmtns:dt指定了文档中有关数据类型定义的标识都来自下面规范：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232502.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232502.png';" /></details>

<p>上面的模板是一切schema文档都要遵守的一般性语法要求，下面我们将分别的从各个方面来介绍XML Schema的一些细节知识。</p>
<h4 id="元素的定义"><a href="#元素的定义" class="headerlink" title="元素的定义"></a>元素的定义</h4><p>schema中元素的定义使用标记<code>&lt;ElementType&gt;</code>来完成，具体的语法如下面的例子所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232521.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232521.png';" /></details>

<p>上面一条语句声明了一个<code>&lt;name&gt;</code>标记，该标记内容的类型是一般的文字，如果想指定为其他的数值类型，可以按以下的语法来制定。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232551.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232551.png';" /></details>

<p>上面语句声明了一个<code>&lt;date&gt;</code>标记，它内容的数据类型是日期型的，其他数据类请参考表8-5。</p>
<details><summary>表8-5　XML Schema所提供的常用数据类型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232614.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232614.png';" /></details>

<p>此外还有entity、entities、enumerationn、id、idref、idrefs、nmtoken、nmtokens、notation等数据类型。</p>
<p>如果一个标记中含有子标记，则子标记的定义采用下面的语法：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232630.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232630.png';" /></details>

<p>上面程序段定义了一个标记<code>&lt;books&gt;</code>，它有一个子标记。下面我们通过一个完整的程序2来说明标记的定义方法。</p>
<p>程序2</p>
<p>文件2.XML</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232651.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232651.png';" /></details>

<p>下面是使用该schema的XML文档程序3。</p>
<p>程序3</p>
<p>文件3.xml</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232706.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232706.png';" /></details>

<p>程序3中有一点需要注意：<code>&lt;books xmlns=&quot;x-schema:2.xml&quot;&gt;</code>该语句的作用是指定标记<code>&lt;books&gt;&lt;/books&gt;</code>之间的所有标记都是在文件2中定义的。这也是XML调用一个schema文件的方法。</p>
<p>上面程序的错误在于，标记<code>&lt;book&gt;</code>的内容定义的是整数型，而实际的XML文档中使用的却是一个字符串，因而是一个不合法的文档。只要将<code>&lt;book&gt;&lt;/book&gt;</code>标记的内容改成整数型的就成为合法的文档，例如下面的程序：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232739.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232739.png';" /></details>

<h5 id="元素内容类型的指定"><a href="#元素内容类型的指定" class="headerlink" title="元素内容类型的指定"></a>元素内容类型的指定</h5><p>有的标记只能自己独立使用，有的标记必须包含其他标记作为自己的子标记，决定一个标记语言的该方面的技术是元素的内容类型。这里可以通过关键字content指定这种属性。</p>
<p>Content属性可以有下面的几种取值。</p>
<p>（1）textOnly:表示该标记只包含文本型的内容。</p>
<p>（2）eltOnly：表示该标记只包含元素类型的内容。</p>
<p>（3）empty：表示是一个空元素。</p>
<p>（4）mixed：表示上面的各种情况。</p>
<h5 id="标记的子标记的出现次数"><a href="#标记的子标记的出现次数" class="headerlink" title="标记的子标记的出现次数"></a>标记的子标记的出现次数</h5><p>一个标记子标记的出现次数有minOccurs、maxOccurs两个属性来设置，它有如下的几种设置情况。</p>
<p>（1）子标记可以出现不止一次，即可以出现一次或多次，如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232811.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232811.png';" /></details>

<p>如果一个标记的子标记可以出现一次或多次时，只要指定该标记的maxOccurs的属性值为“*”即可。</p>
<p>（2）只能出现一个，如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232842.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232842.png';" /></details>

<p>在默认情况之下maxOccurs的属性值为1，除非content的属性设置为mixed，如果content的属性被设置成了mixed，那么maxOccuu默认位为“*”。</p>
<p>（3）子标记可有可无，如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232857.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232857.png';" /></details>

<p>如果一个标记的子标记指定了上面的属性，表示该子标记是可选的。</p>
<p>（4）子标记最少出现的次数，该次数通常是0或1。如果minOccurs的值设置为1就表示该标记必须出现。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903232915.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903232915.png';" /></details>

<h5 id="标记的子标记出现的次序"><a href="#标记的子标记出现的次序" class="headerlink" title="标记的子标记出现的次序"></a>标记的子标记出现的次序</h5><p>一个标记的子标记出现次序由一个属性order来控制，通常情况下该属性有三种取值。</p>
<p>（1）order=”one”</p>
<p>如果一个标记设置了该属性，则表示此标记的子标记是它子标记列表中的任一个。</p>
<p>（2）order=”many”</p>
<p>如果一个标记设置了该属性，则表示该标记的所有子标记可以按任意的顺序出现任意的次数。</p>
<p>（3）order=”seq”</p>
<p>如果一个标记设置了该属性，则表示该标记的所有子标记必须按照定义好的次序出现。</p>
<p>4．元素的开放性和封闭性</p>
<p>元素的开放性和封闭性指的是元素能否包含定义以外子元素的问题，该方面的功能由属性model来描述，当该属件的值是open时，该元素是开放的，除了可以包含自己定义的子标记外，还可以包含其他的标记。当该属性的值为close时，元素除了包含自己定义时定义的子标记外，不能再包含别的标记。下面通过一个例子程序来演示该属性的应用。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233004.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233004.png';" /></details>

<h3 id="可扩展样式表语言"><a href="#可扩展样式表语言" class="headerlink" title="可扩展样式表语言"></a>可扩展样式表语言</h3><h4 id="可扩展样式表语言概述"><a href="#可扩展样式表语言概述" class="headerlink" title="可扩展样式表语言概述"></a>可扩展样式表语言概述</h4><p>eXtensible Stylesheet Language, XSL）是描述XML文档样式信息的一种语言，是由W3C制定的。</p>
<p>前面已经讲过，XML的一个优点就是形式与内容相分离，这使得XML文档具有简洁、易读的特点。它的样式信息都包含在称为样式单的样式文件中。而XSL就是它的两种样式单的其中之一。另一种是上一节介绍过的已经运用在HTML中的层叠样式单（CSS），是一种静态的样式描述格式，其本身不遵从XML的语法规范。而XSL不同，它本身就是一个XML文档，系统可以使用同一个XML分析器对XML文档及其相关的XSL文档进行分析处理。</p>
<p>XSL是通过XML进行定义的，遵从XML语法规范，是XML的一种具体应用。它由两大部分组成：第一部分描述了如何将一个XML文档进行转换、转换为可浏览或可输出的格式；第二部分则定义了格式对象（Fomatted Object, FO）。在输出时，首先根据XML文档构造源树，然后根据给定的XSL将这个源树转换为可以显示的结果树，这个过程称为树转换，最后再按照FO分析结果树，产生一个可以在屏幕上、纸上、语音设备或其他媒体中输出的结果，这个过程称为格式化。</p>
<p>到目前为止，W3C还未能出台一个得到多方认可的FO，但是描述树转换的这一部分协议却日趋成熟，已从XSL中分离出来，另取名为XSLT（XSL Transformations），其正式推荐标准于1999年11月16日推出，现在一般所说的XSL大多指的是XSLT。与XSLT—同推出的还有其配套标准Xpath（XML Path Language, XML路径语言），这个标准用来描述如何识别、选择、匹配XML文档中的各个构成元件，包括元素、属性和文字内容等。</p>
<p>使用XSL显示XML的基本思想是通过定义模板将XML源文档转换为带样式信息的可浏览文档。最终的可浏览文档可以是HTML格式、带CSS的XML格式及FO格式。</p>
<p>XSL最初是由Microsoft公司提出来的，因此它对XSL的支持也比较好，Microsoft IE 5已经部分支持XSL。</p>
<p>在XML中使用如下语句声明XSL样式单：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233032.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233032.png';" /></details>

<p>如前所述，XSLT主要的功能就是转换，它将一个没有形式表现的XML内容文档作为一个源树，将其转换为一个有样式信息的结果树。在XSLT文档中定义了与XML文档中各个逻辑成分相匹配的模板，以及模板匹配和转换方式。值得一提的是，尽管制定XSLT规范的初衷只是利用它来进行XML文档与可格式化对象之间的转换，但它的巨大潜力却表现在它可以很好地描述从XML文档向任何一个其他格式的文档作转换的方法，例如转换为另一个逻辑结构的XML文档、HTML文档、XHTML（The Extensible HyperText Markup Language）文档、VRML（Virtual Reality Modeling Language）文档甚至SVG（Scalable Vector Graphics）文档。</p>
<p>XSL在网络中的应用大体分为两种模式。</p>
<h5 id="服务器端转换模式"><a href="#服务器端转换模式" class="headerlink" title="服务器端转换模式"></a>服务器端转换模式</h5><p>在这种模式下，XML文件下载到浏览器前先转换成HTML，然后再将HTML文件送往客户端进行浏览。有两种方式：</p>
<p>（1）动态方式。即当服务器接到转换请求时再进行实时转换．这种方式无疑对服务器要求较高。</p>
<p>（2）批量方式。事先用XSL将一批XML文档转换为HTML文件，接到转换请求后直接调用转换好的HTML文件即可。</p>
<h5 id="客户端转换模式"><a href="#客户端转换模式" class="headerlink" title="客户端转换模式"></a>客户端转换模式</h5><p>这种方式将XML和XSL文件都传送到客户端，需要浏览时由浏览器实时进行转换，前提是浏览器必须支持XML+XSL的工作方式。</p>
<p>本节将着重介绍XSLT对XML文档的显示转换功能，并将XPath作为XSLT的基础予以介绍。对于FO，在此只用少量的篇幅介绍一下，使读者对其有一个概括性的了解。</p>
<h4 id="XSLT的常用句法和函数"><a href="#XSLT的常用句法和函数" class="headerlink" title="XSLT的常用句法和函数"></a>XSLT的常用句法和函数</h4><h5 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h5><p>前面说过，XSLT文档本身是XML文档，因此文档的第一句自然是：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233142.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233142.png';" /></details>

<p>接下来是样式单部分：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233159.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233159.png';" /></details>

<p>也可以写作：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233212.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233212.png';" /></details>

<p>xsl:transform与xsl:stylesheet具有相同的含义，都表示元素所包含的内容为样式单。xsl:stylesheet元素必须包含有version属性，用以指示该XSL文档遵从哪一个版本的XSL标准。另外，xmlns:xsl指示了XSL的命名空间，在XSLT标准中，定义了XSLT的命名空间为<a target="_blank" rel="noopener" href="http://www.w3.org/1999/XSL/Transform%E3%80%82">http://www.w3.org/1999/XSL/Transform。</a></p>
<p>xsl:stylesheet又可包含以下几种元素：</p>
<p>xsl:import    xsl:output    xsl:attribute-set    xsl:include    xsl:key<br>xsl:variable　    xsl:strip-space　    xsl:decimal-format　    xsl:param　    xsl:preserve-space　<br>xsl:namcspace-alias        xsl:template</p>
<p>由此，一个样式单可以写成如下形式：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233246.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233246.png';" /></details>

<p>通常把xsl:stylesheet的子元总称为顶级元素（top-level），顶级元素在xsl:stylesheet元素中出现的次序可以是任意的，没有固定的先后次序。每个样式单都包含有零个或多个顶级元素，有关各顶级元素的具体含义我们将在以后的小节中逐步介绍。</p>
<p>XSLT在进行转换时，首先遍历XML源文档树，找到要处理的节点，然后将定义好的模板信息施加到该节点中。</p>
<h5 id="模板与应用"><a href="#模板与应用" class="headerlink" title="模板与应用"></a>模板与应用</h5><p>xsl:template是模板元素，通常每个xsl:template有一个节点匹配属性，由“match=”指定。在对模板进行匹配时使用xsl:apply templates，选择要匹配的模板，相当于一个调用的过程。对节点的匹配规则遵照XPath的标准定义。</p>
<p>XSLT对文档树的匹配总是从根节点“/”开始。<code>&lt;xsl:template match=&quot;/&quot;&gt;</code>就是匹配根节点，然后把定义好的包含HTML文档的开始部分的模板施加给根节点。</p>
<p>在该例子中，定义了一个roster模板：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233312.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233312.png';" /></details>

<p>并在根节点的模板中调用了该模板：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233325.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233325.png';" /></details>

<p>不向的模板的设计，可以导致同一个文档有不同的输出效果的输出样式主要有以下两种方法。</p>
<p>1）定义不同的样式</p>
<p>例如，CAPTION (font-size:l5pt;font-weight:bold:co1or:red)</p>
<p>2）利用mode属性</p>
<p>xsl:template元素还有一个mode属性，利用这个属性可以根据需要去匹配不同模式的模板。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233338.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233338.png';" /></details>

<p>那么，如果要将表格标题输出为蓝色字，要用下面语句匹配：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233349.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233349.png';" /></details>

<p>如果要将表格标题输出为红色字，则应写为：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233403.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233403.png';" /></details>


<p>以上介绍了利用模板达到不同输出效果的两种方法，第一种方法采取的是直接修改模板中内容，从而达到得到另外一种输出效果的目的。而第二种方法则是利用了xsl:template元素本身的mode属性，相对于第一种方法而言，具有更强的灵活性。</p>
<p>模板总是与节点相对应的，一个节点可能对应于不同的模板，那么在进行模板匹配时如何确定各模板匹配的先后次序呢？</p>
<p>在XSLT中，允许为xsl:template设置优先级，写法是：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233431.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233431.png';" /></details>

<p>n为优先级数。</p>
<h5 id="计算节点值"><a href="#计算节点值" class="headerlink" title="计算节点值"></a>计算节点值</h5><p>在使用XSLT进行转换时，常常需要获取节点值，使用xsl:value-of元素可达到这个目的，如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233454.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233454.png';" /></details>

<p>得到的是学生原籍的值，select属性指定要获取的是哪一个节点的节点值。</p>
<h5 id="元素与属性创建"><a href="#元素与属性创建" class="headerlink" title="元素与属性创建"></a>元素与属性创建</h5><p>XSLT是一个动态的样式单，在处理过程中可产生新的元素或元素属性。</p>
<h6 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h6><p>xsl:element元素可在XSLT对文档转换时动态地生成新元素，如下例子中的CAPTION标记就可以用动态生成的方法来生成。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233520.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233520.png';" /></details>

<p>XSLT处理此句时，将生成下面的元素：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233534.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233534.png';" /></details>

<h6 id="创建属性"><a href="#创建属性" class="headerlink" title="创建属性"></a>创建属性</h6><p>xsl:attribute元素可在XSLT对文档转换时动态地生成元素属性，如下面的例中CAPTION标记可以用动态生成的方法加入属性。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233548.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233548.png';" /></details>

<p>经XSLT转换后，将生成下面的元素：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233559.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233559.png';" /></details>

<h6 id="创建文本"><a href="#创建文本" class="headerlink" title="创建文本"></a>创建文本</h6><p>xsl:text元素可实现在样式单转换时动态创建文本，例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233632.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233632.png';" /></details>

<p>在XSLT进行转换时，匹配到roster节点后，将输出文字：</p>
<p>这是学生花名册</p>
<p>从上面的例子中似乎看不出使用xsl:text的必要性，事实上xsl:text的优势在于它可以保护文本中的空白字符。对于处理特殊类型的文本是很有用处的。</p>
<h6 id="创建处理指令"><a href="#创建处理指令" class="headerlink" title="创建处理指令"></a>创建处理指令</h6><p>xsl:processing-instruction元素可以实现在XSLT进行转换时自动生成处理指令，例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233709.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233709.png';" /></details>

<p>将创建如下处理指令：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233800.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233800.png';" /></details>

<h6 id="创建注释"><a href="#创建注释" class="headerlink" title="创建注释"></a>创建注释</h6><p>xsl:comment元素可在XSLT结果树中创建一个注释节点，例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233811.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233811.png';" /></details>

<p>经XSLT转换后生成注释：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233901.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233901.png';" /></details>

<h5 id="节点拷贝"><a href="#节点拷贝" class="headerlink" title="节点拷贝"></a>节点拷贝</h5><p>在对XML文档进行处理时，XSLT还可以通过拷贝的方式复制节点，方法是利用xsl:copy和xsl:copy-of。</p>
<p>xsl:copy只拷贝当前节点，不包括子节点和属性。而xsl:copy-of的拷贝内容则包括当前节点、子节点和属性。</p>
<h5 id="循环处理"><a href="#循环处理" class="headerlink" title="循环处理"></a>循环处理</h5><p>使用xsl:for-each可对所选节点依次进行处理，如在生成表格处理中利用循环将各个学生的信息取出放入表格中的，写法如下。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233933.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233933.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903233946.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903233946.png';" /></details>

<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>用xsl:for-each或xsl:apply-templates匹配的节点可使用xsl:sort将所选节点内容进行排序，如下所示。</p>
<p>1）按大小写排序</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234012.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234012.png';" /></details>

<p>将以id为关键字按大写优先排序，而</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234024.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234024.png';" /></details>

<p>将以id为关键字按小写优先排序。</p>
<h6 id="按字母顺序排序"><a href="#按字母顺序排序" class="headerlink" title="按字母顺序排序"></a>按字母顺序排序</h6><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234046.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234046.png';" /></details>

<p>将以id为关键字按字母升序排序，而</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234103.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234103.png';" /></details>

<p>将以id为关键字按字母降序排序。</p>
<h6 id="按数据类型排序"><a href="#按数据类型排序" class="headerlink" title="按数据类型排序"></a>按数据类型排序</h6><p>在有文本和数字混合的内容排序时，可指定按哪种数据类型排序。</p>
<p>对于一组id数据101, 2, 44, 305来说，如果写为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234126.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234126.png';" /></details>

<p>排序结果是101, 2, 305, 44。而写成</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234139.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234139.png';" /></details>

<p>排序结果是2, 44, 101, 305。</p>
<p>另外，还有一种排序方式，就是在前面学生花名册例中所使用的order-by:</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234223.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234223.png';" /></details>


<p>也可使得输出学生时按名字排序。</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>XSLT是一个转换语言，它的目的是将XML源文档转换为另一种格式文档，它的输出结果可以是HTML文档，也可以是带css的XML文档。具体的输出格式由xsl:output指定。如果要输出为HTML文档，则写为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234251.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234251.png';" /></details>

<p>同样，要输出XML文档写为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234305.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234305.png';" /></details>

<p>另外method”text”用来输出文本节点的内容，例如：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234315.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234315.png';" /></details>

<p>如果文档中不出现xsl:output，将默认输出为XML文档，但如果在匹配模板时使用了<HTML>标记，则输出为HTML文档。输出为HTML文档时系统都会自动加上下面语句：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234328.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234328.png';" /></details>

<h3 id="其他相关规范"><a href="#其他相关规范" class="headerlink" title="其他相关规范"></a>其他相关规范</h3><h4 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h4><p>当W3C首次开始开发一种XML查询语言时，他们意识到XPointer和XSLT组正在尝试完成访问一个XML文档的特定段的功能。因此，Xpointer，XSLT和XPath组进行了合作，指定为XML使用一种查询语言。XPath给XSLT和XPointer提供一个共同、整合的定位语法，用来定位XML文档中各个部位。在XSLT和XPointer之间，使用一种通用的语法——XPath来实现功能的共享。</p>
<p>XPath采用简洁的、非XML的语法，它基于XML文档的逻辑结构，在该结构中进行导航。XPath表达式通常出现在URL和XML属性值里。除了用于定位，XPath自身还有一个子集能用于进行匹配，它能验证一个节点是否匹配某个模式。XPath将XML文档描绘为树或节点的模型，节点的类型有根节点、元素节点、属性节点、文本节点、注释节点、名称空间节点和处理指令节点7种。</p>
<p>XPath规范定义了两个主要部分：一部分是表达式语法，另一部分是一组名为XPath核心库的基本函数。</p>
<p>指向某个XML文档中一个特定节点的路径由三部分信息构成：一个轴类型、一个节点测试和谓词。轴类型有多种，用来指定所选节点和环境之间的关系。节点测试用来指定根据上下文节点要查找什么类型的节点，除元素和属性节点外，可能使用的其他节点测试包括通配符“*”、text()、node()、comment()、processing-instruction()等。谓词以“<code>[</code>”开始，以“<code>]</code>”结束。谓词可以通过使用内置的函数来过滤不需要的节点，从而到达所需节点。将轴、节点测试和谓词信息类型放到一起，会生成下面的位置步语法结构。</p>
<p><code>&lt;轴&gt;::&lt;节点测试&gt;[&lt;谓词表达式&gt;]</code></p>
<p>例如，<code>child::sibling[position()=3]</code>，这个XPath语句使用一个谓词来选择上下文节点的第3个sibling子节点。</p>
<p>位置步首先利用轴和节点测试计算，得到初始结果集，然后依次利用谓词进行过滤；初始结果集中满足所有谓词的就是返回结果。</p>
<p>位置步总结了XPath语言实际上是如何工作的。要到达一个特定节点的位置，必须使用一个XPath表达式或模式来列出到达那步骤，这个过程的每一步都被一个“/”字符分开，这些位置步和“/”字符组成位置路径。位置路径是XPath中最普通的表达式类型。</p>
<p>XPath是用作XSLT和XPointer的对XML文档各部分进行定位的语言。但是，XPath不是作为一种独立语言设计的，它只在与另一种语言（例如XPointer或XSLT）一起使用时才有用。</p>
<h4 id="XLink和XPointer"><a href="#XLink和XPointer" class="headerlink" title="XLink和XPointer"></a>XLink和XPointer</h4><p>XLink指定一个文档如何链接到另一个文档，XPointer指定文档内部的位置，它们都是基于XPath推荐标准。现在对它们进行一下简要的介绍。</p>
<p>XLink规范是W3C在2000年2月21日发布的工作草案。在<a target="_blank" rel="noopener" href="http://www.w3.org/TR/xlink%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E8%A7%84%E8%8C%83%E7%9A%84%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E3%80%82XLink%E7%94%A8%E4%BA%8E%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3%E9%93%BE%E6%8E%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E6%96%87%E6%A1%A3%E3%80%82%E4%B8%8B%E9%9D%A2%E6%98%AFW3C%E5%9C%A8%E5%B7%A5%E4%BD%9C%E8%8D%89%E6%A1%88%E4%B8%AD%E6%8F%8F%E8%BF%B0%E7%9A%84%EF%BC%9A">www.w3.org/TR/xlink可以找到这个规范的最新版本。XLink用于从一个文档链接到另一文档。下面是W3C在工作草案中描述的：</a></p>
<p>此规范定义了3CML链接语言（XML Linking Language, XLink），它允许为创建和描述资源间的链接而在XML文档中插入元素。它使用XML语法创建结构对象，能够描述现在的HTML简单的单向超链接，也能描述更复杂的链接。</p>
<p>这里有一个例子用来了解一下XLink大概是什么样子。不像HTML超链接，在XML中任何元素都可以是一个链接。用xlink:type属性来指定一个元素成为链接，在这里创建了一个简单的Xlink。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234428.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234428.png';" /></details>

<p>在本例中，通过设置xlink:type属性为simple创建了一个简单的XLink，很像HTML中的超链接。将xlink:show属性设置为new，这意味着兼容XLink的软件应当在新的窗口或其他显示上下文中打开链接到的文档。另外，将xlink:href属性设置为新文档的URIURI更为通用，并且链接不一定使用在这里使用的URL形式。</p>
<p>出于熟悉的缘故，以一个简单的XLink开始，因为它与HTML链接非常相似。除了基本的单向链接，也就是在这里创建的简单链接，也可以创建双向链接和多文档间的链接，甚至是文档集间的链接。另外，还可以做更多的事情，包括在被称为链接库的链接数据库中对的链接排序。</p>
<p>XLink使能链接到一个指定的文档，但是经常需要更为精确的定位。XPointer允许在文档内部定位，而不必改变文档嵌入特殊的标记。</p>
<p>在文档内部指定位置，XPointer规范是基于XPath规范的。</p>
<p>它允许识别文档中指定结点，举例如下。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234442.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234442.png';" /></details>

<p>下面是W3C关于XPointer的描述：</p>
<p>此规范定义了XML指针语言（XML Pointer Language, XPointer），为任何URI引用用作段标识符，URI引用是用于定位Internet媒体类型text/xml或application/xml资源的。基于XML路径语言的XPointer支持在XML文档内部结构中寻址。它允许遍历文档树和选择其中的一部分，并且是基于各种特性的，例如元素类型、属性值、字符内容、相对位置等。</p>
<p>尽管XPointer基于xPath规范，但是XPointer规范在许多方面扩展了XPath。</p>
<p>如何将XPointer加入文档的URI来识别文档中的指定位置？只需加上符号“#”，（遵从HTML对URL的用法，URL指明链接的目标），然后是xpointer()，并将想使用的表达式放入圆括号中。举例如下：</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903234453.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903234453.png';" /></details>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch7-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch7-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch7-设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:54:10" itemprop="dateCreated datePublished" datetime="2021-07-19T12:54:10+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-16 22:31:03" itemprop="dateModified" datetime="2023-04-16T22:31:03+08:00">2023-04-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>近年来，在面向对象领域中的一个重要突破就是提出了设计模式的概念。软件的设计模式是人们在长期的开发实践中良好经验的结晶，它提供了一个简单、统一的描述方法，使人们可以复用这些软件设计方法、过程管理经验。由于设计模式在表达上既经济又清楚，从而越来越受到重视。本章将介绍软件设计模式的概念、组成要素和分类，并介绍了façade、Adapter、Abstract Factory等常用设计模式。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38024782/category_10439360.html">spring中的设计模式</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43367550/article/details/104953732">七大原则和23种设计模式</a></li>
<li><a target="_blank" rel="noopener" href="https://levelup.gitconnected.com/basic-javascript-design-patterns-decorators-facades-and-proxies-2309eb485229">Basic JavaScript Design Patterns — Decorators, Facades, and Proxies</a></li>
<li><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/catalog">非常优秀的设计模式的讲解！</a></li>
<li><a target="_blank" rel="noopener" href="https://zhaoyang.me/posts/architecture-from-source-code-ood-dip/">读源码学架构系列：依赖倒置原则</a></li>
</ul>
<h3 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h3><p>在任何设计活动中都存在着某些重复遇到的典型问题，不同开发人员对这些问题设计出不同的解决方案，随着设计经验在实践者之间日益广泛地被利用，描述这些共同问题和解决这些问题的方案就形成了所谓的模式。</p>
<h4 id="设计模式的历史"><a href="#设计模式的历史" class="headerlink" title="设计模式的历史"></a>设计模式的历史</h4><p>模式概念是建筑师Christopher Alexander提出的，他提出可以把现实中一些已经实现的较好的建筑和房屋的设计经验作为模式，在以后的设计中直接加以运用。他还定义了一种“模式语言”来描述建筑和城市中的成功的架构。</p>
<p>Christopher Alexander将模式分为几个部分：首先是特定的情景（Context），指模式在何种状况下发生作用；其二是动机（System of Force），指问题或预期的目标；其三是解决方案（Solution），指平衡各动机或解决所阐述问题的一个构造或配置。他提出模式是表示特定的情景、动机、解决方案三个方面关系的一个规则，每个模式描述了一个在某种特定情景下不断重复发生的问题，以及该问题解决方案的核心所在。模式既是一个事物又是一个过程，不仅描述该事物本身，而且提出了通过怎样的过程来产生该事物。设计模式的核心是问题描述和解决方案，问题描述说明模式的最佳使用场合及它将如何解决问题，解决方案是用一组类和对象及其结构和动态协作来描述的。</p>
<p>20世纪80年代中期由Ward Cunningham和Kent Beck将其思想引入到软件领域。1995年，E. Gamma，R. Helm，R. Johnson和J. Vlissides4人合著了Design Patterns; Elements of Object-Oriented Software，这是软件设计模式领域中的一本经典书籍，从此设计模式成为软件工程领域内的一个重要研究领域，这四人也因此被称为Gang of Four（GoF），成为设计模式中的大师级人物。</p>
<h4 id="为什么要使用设计模式"><a href="#为什么要使用设计模式" class="headerlink" title="为什么要使用设计模式"></a>为什么要使用设计模式</h4><p>面向对象设计时需要考虑许多因素，例如封装性、粒度大小、依赖关系、灵活性和可重用性等。如何确定系统中类及类之间的关系？如何保证在系统内部的一个类始终只有一个实例被创建？如何动态地将追加的功能增加到一个对象？哪些是设计时要努力达到的目标？这些都是软件设计中不容易掌握的问题。要真正掌握软件设计，必须研究其他软件设计大师的设计，这些设计中包含了许多设计模式。软件模式的应用对软件开发产生了重大的作用，主要表现在以下几个方面。</p>
<h5 id="简化并加快设计"><a href="#简化并加快设计" class="headerlink" title="简化并加快设计"></a>简化并加快设计</h5><p>开发人员面对的问题来自不同的层次。在最底层，涉及的是单个类的接口或实现的细节问题；在最高层，涉及的是系统的整体架构的创建问题。设计模式关注的是中间层，在这一层必须保证局部化的特定的设计性质。设计模式使得软件开发人员无须从底层做起，开发人员可以重用成功的设计，可节省开发时间，同时有助于提高软件质量。</p>
<h5 id="方便开发人员之间的通信"><a href="#方便开发人员之间的通信" class="headerlink" title="方便开发人员之间的通信"></a>方便开发人员之间的通信</h5><p>利用设计模式可以更准确地描述问题及问题的解决方案，使解决方案具有一致性；也有利于开发人员可以在更高层次上思考问题和讨论方案。例如，如果所有人都理解Factory设计模式的意思，则开发人员可以用“建议采用Factory设计模式来解决这个问题”这样的话来表达。</p>
<h5 id="降低风险"><a href="#降低风险" class="headerlink" title="降低风险"></a>降低风险</h5><p>由于设计模式经过很多人的使用，已被证明是有效的解决方法，所以采用设计模式可以降低失败的可能性，也有利于在复杂的系统中产生简洁、精巧的设计。</p>
<h5 id="有助于转到面向对象技术"><a href="#有助于转到面向对象技术" class="headerlink" title="有助于转到面向对象技术"></a>有助于转到面向对象技术</h5><p>新技术要在一个开发机构中得到应用，一般要经历两个阶段，即技术获取阶段和技术迁移阶段。技术获取阶段较容易，但在技术迁移阶段，由于开发人员对新技术往往会有抵触或排斥心理，对新技术可能带来的效果持怀疑态度，同时由于对新技术还是一知半解，所以要在一个开发机构中进行技术迁移并不是一件容易的事。设计模式一般都是基于面向对象技术而提出的，也可应用于接口定义良好的结构化方法中。另外，设计模式是可重用的设计经验的总结，已在实际的系统中多次得到成功应用，因此通过对设计模式的研究，能够深入理解良好设计的最基本的性质，从而有助于说服开发人员采用新技术。</p>
<p>成熟的软件设计模式具有以下特性。</p>
<p>（1）巧妙：设计模式是一些优雅的解决方案，是在大量实践经验的基础上提炼出来的。</p>
<p>（2）通用：设计模式通常不依赖于某个特定的系统类型、程序设计语言或应用领域，它们是通用的。</p>
<p>（3）得到很好的证明：设计模式在实际系统和面向对象系统中得到广泛应用，它们并不仅仅停留在理论上。</p>
<p>（4）简单：设计模式通常都非常简单，只涉及很少的一些类。为了构建更多更复杂的解决方案，可以把不同的设计模式与应用代码结合或混合使用。</p>
<p>（5）可重用：设计模式的建档方式使它们非常易于使用，因而可方便用于任何适宜的系统。</p>
<p>（6）面向对象：设计模式是用最基本的面向对象机制如类、对象、多态等构造的。许多模式特别强调了某些面向对象设计擅长的领域，例如，区分接口和实现、降低各部分之间的依赖性、隔离硬件和软件等。</p>
<h4 id="设计模式的组成元素"><a href="#设计模式的组成元素" class="headerlink" title="设计模式的组成元素"></a>设计模式的组成元素</h4><p>模式是一个高度抽象的概念。设计模式的基本组成元素如下。</p>
<h5 id="模式名"><a href="#模式名" class="headerlink" title="模式名"></a>模式名</h5><p>模式必须具有一个有意义的名称，这样就可以用一个词或短语来指代该模式，以及它所描述的知识和结构。模式名称简洁地描述了模式的本质。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果，找到恰当的模式名也是设计模式编目工作的难点之一。</p>
<h5 id="问题或意图"><a href="#问题或意图" class="headerlink" title="问题或意图"></a>问题或意图</h5><p>陈述问题并描述它的意图，以及它在特定的情景和动机下要达到的目标，它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等，也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。通常情况下这些动机和目标是相互矛盾、相互影响的。</p>
<h5 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h5><p>情景是问题及其解决方案产生时的前提条件。情景告诉我们该模式的适用性，可以将情景视为应用该模式之前的系统初始配置。</p>
<h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><p>它描述相关的动机和约束，它们之间或与期望达到的目标之间的相互作用（或冲突），通常需要对各期望的目标进行优先级排序。动机阐明了问题的复杂性，定义了在相互冲突时所采取的各种权衡手段。一个好的模式应尽可能将所有产生影响的动机考虑在内。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>解决方案是描述一些静态的关系和动态的规则，用以描述如何得到所需的结果。通常是给出一组指令来说明如何构造所需的工作制品。该说明可包括图表、文字，用以标示模式的结构、参与者及其之间的协作，从而表明问题是如何解决的。因为模式就像一个模板，可应用于多种不同的场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>示例指一个或多个该模式的应用例子，示例说明了模式在怎样的初始情景下如何发生作用，如何改变情景而导致结果情景的出现。示例帮助读者理解模式的具体使用方法。</p>
<h5 id="结果情景"><a href="#结果情景" class="headerlink" title="结果情景"></a>结果情景</h5><p>结果情景指在应用该模式后系统的状态或配置，包括模式发生作用后带来的后果，以及在新的情景下产生的问题、可应用的模式等。它阐述了模式的后续状态和副作用。通常通过对结果情景的描述，使该模式与其他模式联系起来（该模式的结果情景成为其他模式的初始情景）。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>基本原理指对该模式中的解决步骤或采用的规则的解释、证明，解释该模式如何、为何能解决当前问题，它采用的方法为何能得到与期望相一致的结果。</p>
<h5 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h5><p>该模式与其他模式的关系，包括静态的和动态的。例如，该模式的前导模式（前导模式应用后产生的结果情景与该模式的初始情景一致）、后续模式（该模式应用后产生的结果情景与后续模式的初始情景一致）、替代模式（使用该模式的替代模式产生同样的效果）等。</p>
<h5 id="已知应用"><a href="#已知应用" class="headerlink" title="已知应用"></a>已知应用</h5><p>阐述该模式在已有应用系统中的实际应用情况，有助于验证该模式的有效性。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。模式效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</p>
<p>通常好的模式前面都有一个摘要，提供简短的总结和概述，为模式描绘出一个清晰的图画，提供有关该模式能够解决问题的快速信息。有时这种描述称为模式的缩略概要，或一个缩略图。模式应该说明它的目标读者，以及对读者有哪些知识要求。</p>
<h4 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h4><p>软件模式主要可分为设计模式、分析模式、组织和过程模式等，每一类又可细分为若干个子类。在此着重介绍设计模式，目前它的使用最为广泛。设计模式主要用于得到简洁灵活的系统设计，GoF的书中共有23个设计模式，这些模式可以按两个准则来分类：一是按设计模式的目的划分，可分为创建型、结构型和行为型三种模式；二是按设计模式的范围划分，即根据设计模式是作用于类还是作用于对象来划分，可以把设计模式分为类设计模式和对象设计模式。</p>
<h5 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h5><p>该类型模式是对对象实例化过程的抽象，它通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息。</p>
<h5 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h5><p>该类模式主要用于如何组合已有的类和对象以获得更大的结构，一般借鉴封装、代理、继承等概念将一个或多个类或对象进行组合、封装，以提供统一的外部视图或新的功能。</p>
<h5 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h5><p>该类模式主要用于对象之间的职责及其提供的服务的分配，它不仅描述对象或类的模式，还描述它们之间的通信模式，特别是描述一组对等的对象怎样相互协作以完成其中任一对象都无法单独完成的任务。</p>
<h3 id="设计模式实例"><a href="#设计模式实例" class="headerlink" title="设计模式实例"></a>设计模式实例</h3><ul>
<li>中介模式和代理模式的区别（<a target="_blank" rel="noopener" href="https://blog.csdn.net/mengmei16/article/details/43981791">中介者模式、代理模式和外观模式的Pk</a>）</li>
</ul>
<h4 id="创建性模式"><a href="#创建性模式" class="headerlink" title="创建性模式"></a>创建性模式</h4><p>在系统中，创建性模式支持对象的创建。该模式允许在系统中创建对象，而不需要在代码中标识特定类的类型，这样用户就不需要编写大量、复杂的代码来初始化对象。它是通过该类的子类来创建对象的。但是，这可能会限制在系统内创建对象的类型或数目。本节将介绍如下的创建性模式：</p>
<ul>
<li>Abstract Factory（抽象工厂）。</li>
<li>Builder（构建器）。</li>
<li>Factory Method（工厂方法）。</li>
<li>Prototype（原型）。</li>
<li>Singleton（单例）。</li>
</ul>
<h5 id="Abstract-Factory模式"><a href="#Abstract-Factory模式" class="headerlink" title="Abstract Factory模式"></a>Abstract Factory模式</h5><p>在不指定具体类的情况下，这种模式为创建一系列相关或相互依赖的对象提供了一个接口。根据给定的相关抽象类，Abstract Factory模式提供了从一个相匹配的具体子类集创建这些抽象类的实例的方法，如图7-1所示。</p>
<p>Abstract Factory模式提供了一个可以确定合适的具体类的抽象类，这个抽象类可以用来创建实现标准接口的具体产品的集合。客户端只与产品接口和Abstract Factory类进行交互。使用这种模式，客户端不用知道具体的构造类。Abstract Factory模式类似于Factory Method模式，但是Abstract Factory模式可以创建一系列的相关对象。</p>
<p>其优点如下。</p>
<ul>
<li>可以与具体类分开。</li>
<li>更容易在产品系列中进行转换。</li>
<li>提高了产品间的一致性。</li>
</ul>
<details><summary>图7-1　Abstract Factory模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210719133628.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210719133628.png';" /></details>

<p>在以下情况中，应该使用Abstract Factory模式：</p>
<ul>
<li>系统独立于产品的创建、组成以及表示。</li>
<li>系统配置成具有多个产品的系列，例如Microsoft Windows或Apple McIntosh类。</li>
<li>相关产品对象系列是共同使用的，而且必须确保这一点。这是该模式的关键，否则可以使用Factory Method模式。</li>
<li>你希望提供产品的类库，只开放其接口，而不是其实现。</li>
</ul>
<h5 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h5><p>Builder模式将复杂对象的构建与其表示相分离，这样相同的构造过程可以创建不同的对象。通过只指定对象的类型和内容，Builder模式允许客户端对象构建一个复杂对象。客户端可以不受该对象构造的细节的影响。这样通过定义一个能够构建其他类实例的类，就可以简化复杂对象的创建过程。Builder模式生产一个主要产品，而该产品中可能有多个类，但是通常只有一个主类。图7-2所示的就是Builder模式，当使用该模式时，可以一次就创建所有的复杂对象。而其他模式一次就只能创建一个对象。</p>
<p>其优点如下。</p>
<ul>
<li>可以对产品的内部表示进行改变。</li>
<li>将构造代码与表示代码相分离。</li>
</ul>
<p>在以下情况中，应该使用Builder模式：</p>
<ul>
<li>创建复杂对象的算法独立于组成对象的部分以及这些部分的集合方式。</li>
<li>构造过程必须允许已构建对象有不同表示。</li>
</ul>
<details><summary>图7-2　Builder模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210719134540.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210719134540.png';" /></details>

<h5 id="Factory-Method模式"><a href="#Factory-Method模式" class="headerlink" title="Factory Method模式"></a>Factory Method模式</h5><p>Factory Method模式定义了创建对象的接口，它允许子类决定实例化哪个类。它允许类将实例化工作交给其子类，这对于在特定目的下构建单个对象是非常有帮助的，而且它不需要请求者知道要被实例化的特定类，这就可以在不修改代码的情况下引入新类，因为新类只实现了接口，这样它就可以被客户端使用。可以创建一个新的Factory类来创建新类，而由这个Factory类来实现Factory接口。图7-3所示的是Factory Method模式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822193335.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822193335.png';" /></details>

<p>其优点如下。</p>
<p>●　没有了将应用程序类绑定到代码中的要求，代码只处理接口，因此可以使用任何实现了接口的类。</p>
<p>●　允许子类提供对象的扩展版本，因为在类中创建对象比直接在客户端创建要更加　灵活。</p>
<p>在以下情况中，应该使用Factory Method模式：</p>
<p>●　类不能预料它必须创建的对象的类。</p>
<p>●　类希望其子类指定它要创建的对象。</p>
<p>●　类将责任转给某个帮助子类，而用户希望定位那个被授权的帮助子类。</p>
<h5 id="Prototype模式"><a href="#Prototype模式" class="headerlink" title="Prototype模式"></a>Prototype模式</h5><p>Prototype模式允许对象在不了解要创建对象的确切类以及如何创建等细节的情况下创建自定义对象。使用Prototype实例，便指定了要创建的对象类型，而通过复制这个Prototype，就可以创建新的对象。Prototype模式是通过先给出一个对象的Prototype对象，然后再初始化对象的创建。创建初始化后的对象再通过Prototype对象对其自身进行复制来创建其他对象。Prototype模式使得动态创建对象更加简单，只要将对象类定义成能够复制自身就可以实现。图7-4所示的是Prototype模式。</p>
<details><summary>图7-4　Prototype模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822193607.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822193607.png';" /></details>

<p>其优点如下。</p>
<p>●　可以在运行时添加或删除产品。</p>
<p>●　通过改变值指定新对象。</p>
<p>●　通过改变结构指定新对象。</p>
<p>●　减少子类的生成和使用。</p>
<p>●　可以用类动态地配置应用程序。</p>
<p>在以下情况中，应该使用Prototype模式：</p>
<p>●　在运行时，指定需要例化的类，例如动态载入。</p>
<p>●　避免构建与产品的类层次结构相似的工厂类层次结构。</p>
<p>●　当类的实例是仅有的一些不同状态组合之一的时候。</p>
<h5 id="Singleton模式"><a href="#Singleton模式" class="headerlink" title="Singleton模式"></a>Singleton模式</h5><p>Singleton模式确保一个类只有一个实例，并且提供了对该类的全局访问入口，它可以确保使用这个类实例的所有的对象使用相同的实例。图7-5所示的是Singleton模式。</p>
<details><summary>图7-5　Singleton模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822193651.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822193651.png';" /></details>

<p>其优点如下。</p>
<p>●　对单个实例的受控制访问。</p>
<p>●　名称空间的减少。</p>
<p>●　允许改进操作和表示。</p>
<p>●　允许可变数目的实例。</p>
<p>●　比类操作更灵活。</p>
<p>在以下情况中，应该使用Singleton模式：如只有一个类实例。</p>
<h4 id="结构性模式"><a href="#结构性模式" class="headerlink" title="结构性模式"></a>结构性模式</h4><p>结构性模式控制了应用程序较大部分之间的关系。它将以不同的方式影响应用程序，例如Adapter模式允许两个不兼容的系统进行通信，而Facade模式允许在不删除系统中所有可用选项的情况下为用户提供一个简化的界面。结构性模式允许在不重写代码或自定义代码的情况下创建系统。这可以使系统具有增强的重复使用性和应用性能。本节将介绍如下的结构性模式：</p>
<p>●　Adapter</p>
<p>●　Bridge</p>
<p>●　Composite</p>
<p>●　Decorator</p>
<p>●　Facade</p>
<p>●　Flyweight</p>
<p>●　Proxy</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f1049d0a0f4">适配器模式</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/282632692">享元模式为什么是结构性，但其用法更像构造型</a></li>
</ul>
<h5 id="Adapter模式"><a href="#Adapter模式" class="headerlink" title="Adapter模式"></a>Adapter模式</h5><p>Adapter模式可以充当两个类之间的媒介，它可以转换一个类的接口，这样就可以被另外一个类使用，这使得具有不兼容接口的类能够协同使用。Adapter模式实现为客户端所知的接口，并且为客户端提供对不为其所知的类实例的访问。Adapter对象可以在不知道实现该接口的类的情况下提供该接口的功能。图7-6所示的就是Adapter模式。</p>
<details><summary>图7-6　Adapter模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822194048.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822194048.png';" /></details>

<p>其优点如下。</p>
<p>●　允许两个或多个不兼容的对象进行交互和通信。</p>
<p>●　提高已有功能的重复使用性。</p>
<p>在以下情况中，应该使用Adapter模在以下情况中，应该使用Adapter模式：</p>
<p>●　要使用已有类，而该类接口与所需的接口并不匹配。</p>
<p>●　要创建可重用的类，该类可以与不相关或未知类进行协作，也就是说，类之间并不需要兼容接口。</p>
<p>●　要在一个不同于已知对象接口的接口环境中使用对象。</p>
<p>●　必须要进行多个源之间的接口转换的时候。</p>
<h5 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h5><p>Bridge模式可以将一个复杂的组件分成两个独立的但又相关的继承层次结构：功能性的抽象和内部实现。改变组件的这两个层次结构很简单，以至于它们可以相互独立地变化。当具有抽象的层次结构和相应的实现层次结构时，Bridge模式是非常有用的。除了可以将抽象和实现组合成许多不同的类，该模式还可以以动态组合的独立类的形式实现这些抽象和实现。图7-7所示的是Bridge模式。</p>
<details><summary>图7-7　Bridge模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822194138.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822194138.png';" /></details>

<p>其优点如下。</p>
<p>●　可以将接口与实现相分离。</p>
<p>●　提高了可扩展性。</p>
<p>●　对客户端隐藏了实现的细节。</p>
<p>在以下情况中，应该使用Bridge模式：</p>
<p>●　想避免在抽象及其实现之间存在永久的绑定。</p>
<p>●　抽象及其实现可以使用子类进行扩展。</p>
<p>●　抽象的实现被改动应该对客户端没有影响；也就是说，你不用重新编译代码。</p>
<h5 id="Composite模式"><a href="#Composite模式" class="headerlink" title="Composite模式"></a>Composite模式</h5><p>Composite模式允许创建树型层次结构来改变复杂性，同时允许结构中的每一个元素操作同一个接口。该模式将对象组合成树型结构来表示整个或部分的层次结构。这就意味着Composite模式允许客户端使用单个对象或多个同一对象的组合。图7-8所示的是Composite模式。</p>
<details><summary>图7-8　Composite模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822194226.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822194226.png';" /></details>

<p>其优点如下。</p>
<p>●　定义了由主要对象和复合对象组成的类层次结构。</p>
<p>●　使得添加新的组件类型更加简单。</p>
<p>●　提供了结构的灵活性和可管理的接口。</p>
<p>在以下情况中，应该使用Composite模式：</p>
<p>●　想要表示对象的整个或者部分的层次结构。</p>
<p>●　想要客户端能够忽略复合对象和单个对象之间的差异。</p>
<p>●　结构可以具有任何级别的复杂性，而且是动态的。</p>
<h5 id="Decorator模式"><a href="#Decorator模式" class="headerlink" title="Decorator模式"></a>Decorator模式</h5><p>Decorator模式可以在不修改对象外观和功能的情况下添加或者删除对象功能。它可以使用一种对客户端来说是透明的方法来修改对象的功能，也就是使用初始类的子类实例对初始对象进行授权。Decorator模式还为对象动态地添加了额外的责任，这样就在不使用静态继承的情况下，为修改对象功能提供了灵活的选择。图7-9所示的是Decorator模式。</p>
<p>其优点如下。</p>
<p>●　比静态继承具有更大的灵活性。</p>
<p>●　避免了特征装载的类处于层次结构的过高级别。</p>
<p>●　简化了编码，因为用户编写的每一个类都针对功能的一个特定部分，而不用将所有的行为编码到对象中。</p>
<p>●　改进了对象的扩展性，因为用户可以通过编写新的类来作出改变。</p>
<p>在以下情况中，应该使用Decorator模式：</p>
<p>●　想要在单个对象中动态并且透明地添加责任，而这样并不会影响其他对象。</p>
<p>●　想要在以后可能要修改的对象中添加责任。</p>
<p>●　当无法通过静态子类化实现扩展时。</p>
<details><summary>图7-9　Decorator模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822194521.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822194521.png';" /></details>

<h5 id="Facade模式"><a href="#Facade模式" class="headerlink" title="Facade模式"></a>Facade模式</h5><ul>
<li><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/facade">比较好的解释</a></li>
</ul>
<p>Facade模式为子系统中的一组接口提供了一个统一的接口。因为只有一个接口，该模式就定义了更容易使用子系统的高级接口。这个统一的接口允许对象使用该接口与子系统进行通信，从而实现对子系统的访问。图7-10所示的是Facade模式。</p>
<details><summary>图7-10　Facade模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822194605.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822194605.png';" /></details>


<p>其优点如下。</p>
<p>●　在不减少系统所提供的选项的情况下，为复杂系统提供了简单接口。</p>
<p>●　对客户端屏蔽了子系统组件。</p>
<p>●　提高了子系统与其客户端之间的弱耦合度。</p>
<p>●　如果每一个子系统使用自身的Facade模式而且系统的其他部分也使用Facade模式与子系统进行通信的话，就可以降低子系统之间的耦合度。</p>
<p>●　将客户端请求转换后发送给能够处理这些请求的子系统。</p>
<p>在以下情况中，应该使用Facade模式：</p>
<p>●　想要为复杂的子系统提供简单的接口。</p>
<p>●　在客户端和抽象的实现类中存在许多依赖关系。</p>
<p>●　想要对子系统进行分层</p>
<h5 id="Flyweight模式"><a href="#Flyweight模式" class="headerlink" title="Flyweight模式"></a>Flyweight模式</h5><p>Flyweight模式可以通过共享对象减少系统中低等级的、详细的对象数目。如果一个类实例包含用来互换使用的相同信息，Flyweight模式允许程序通过共享一个接口来避免使用多个具有相同信息的实例所带来的开销。图7-11所示的是Flyweight模式。</p>
<details><summary>图7-11　Flyweight模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822194709.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822194709.png';" /></details>

<p>其优点如下。</p>
<p>●　减少了要处理的对象数目。</p>
<p>●　如果对象能够持续，可以减少内存和存储设备。</p>
<p>在以下情况中，应该使用Flyweight模式：</p>
<p>●　应用程序使用大量的对象。</p>
<p>●　由于对象数目巨大，导致很高的存储开销。</p>
<p>●　应用程序不依赖于对象的身份。</p>
<h5 id="Proxy模式"><a href="#Proxy模式" class="headerlink" title="Proxy模式"></a>Proxy模式</h5><p>Proxy模式为控制对初始对象的访问提供了一个代理或者占位符对象。它的实现可以有多种类型，其中Remote Proxy（远程代理）和Virtual Proxy（虚拟代理）是最常见的。图7-12所示的是Proxy模式。</p>
<details><summary>图7-12　Proxy模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822195216.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822195216.png';" /></details>

<p>其优点如下。</p>
<p>●　远程代理可以隐藏对象位于不同的地址空间的事实。</p>
<p>●　虚拟代理可以执行优化操作，例如根据需要创建一个对象。</p>
<p>在以下情况中，应该使用Proxy模式，如需要比简单的指针更灵活、更全面的对象引用。</p>
<h4 id="行为性模式"><a href="#行为性模式" class="headerlink" title="行为性模式"></a>行为性模式</h4><p>行为性模式可以影响一个系统的状态和行为流。通过优化状态和行为流转换和修改的方式，可以简化、优化并且提高应用程序的可维护性。本节将介绍如下的行为性模式：</p>
<p>●　Chain of Responsibility</p>
<p>●　Command</p>
<p>●　Interpreter</p>
<p>●　Iterator</p>
<p>●　Mediator</p>
<p>●　Memento</p>
<p>●　Observer</p>
<p>●　State</p>
<p>●　Strategy</p>
<p>●　Template Method</p>
<p>●　<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/visitor">Visitor</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f1049d0a0f4">访问者模式：讲的好鸭</a></li>
</ul>
<h5 id="Chain-of-Responsibility模式"><a href="#Chain-of-Responsibility模式" class="headerlink" title="Chain of Responsibility模式"></a>Chain of Responsibility模式</h5><ul>
<li>责任链模式的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/198a29556f30">参考文献</a>,应用：浏览器中的事件有冒泡机制</li>
</ul>
<p>Chain of Responsibility模式可以在系统中建立一个链，这样消息可以在首先接收到它的级别处被处理，或者可以定位到可以处理它的对象。图7-13所示的是Chain ofResponsibility模式。</p>
<details><summary>图7-13　Chain of Responsibility模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822195318.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822195318.png';" /></details>

<p>其优点如下。</p>
<p>●　降低了耦合度。</p>
<p>●　增加向对象指定责任的灵活性。</p>
<p>●　由于在一个类中产生的事件可以被发送到组成中的其他类处理器上，类的集合可以作为一个整体。</p>
<p>在以下情况中，应该使用Chain of Responsibility模式：</p>
<p>●　多个对象可以处理一个请求，而其处理器却是未知的。</p>
<p>●　想要在不指定确切的请求接收对象的情况下，向几个对象中的一个发送请求。</p>
<p>●　可以动态地指定能够处理请求的对象集。</p>
<h5 id="Command模式"><a href="#Command模式" class="headerlink" title="Command模式"></a>Command模式</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyrblog/p/9252664.html">参考文献</a></p>
<p>Command模式在对象中封装了请求，这样就可以保存命令，将该命令传递给方法以及像任何其他对象一样返回该命令。图7-14所示的是Command模式。</p>
<p>其优点如下。</p>
<p>●　将调用操作的对象与知道如何完成该操作的对象相分离。</p>
<p>●　更容易添加新命令，因为不用修改已有类。</p>
<p>在以下情况中，应该使用Command模式：</p>
<p>●　想要通过要执行的动作来参数化对象。</p>
<p>●　要在不同的时间指定、排序以及执行请求。</p>
<p>●　必须支持Undo、日志记录或事务。</p>
<details><summary>图7-14　Command模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822200925.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822200925.png';" /></details>

<h5 id="Interpreter模式"><a href="#Interpreter模式" class="headerlink" title="Interpreter模式"></a>Interpreter模式</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaochundong/p/design_pattern_interpreter.html#implementation_interpret_polish_notation">解释器模式</a></p>
<p>interpreter模式可以解释定义其语法表示的语言，还提供了用表示来解释语言中的语句的解释器。图7-1所示的是Interpreter模式。</p>
<details><summary>图7-15　Interpreter模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822201000.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822201000.png';" /></details>

<p>其优点如下。</p>
<p>●　容易修改并扩展语法。</p>
<p>●　更容易实现语法。</p>
<p>在以下情况中，应该使用Interpreter模式：</p>
<p>●　语言的语法比较简单。</p>
<p>●　效率并不是最主要的问题。</p>
<h5 id="Iterator模式"><a href="#Iterator模式" class="headerlink" title="Iterator模式"></a>Iterator模式</h5><p>Iterator模式为集合中的有序访问提供了一致的方法，而该集合是独立于基础集合，并与之相分离的。图7-16所示的是Iterator模式。</p>
<details><summary>图7-16　Iterator模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822201444.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822201444.png';" /></details>

<p>其优点如下。</p>
<p>●　支持集合的不同遍历。</p>
<p>●　简化了集合的接口。</p>
<p>在以下情况中，应该使用Iterator模式：</p>
<p>●　在不开放集合对象内部表示的前提下，访问集合对象内容。</p>
<p>●　支持集合对象的多重遍历。</p>
<p>●　为遍历集合中的不同结构提供了统一的接口。</p>
<h5 id="Mediator模式"><a href="#Mediator模式" class="headerlink" title="Mediator模式"></a>Mediator模式</h5><ul>
<li>仲裁者设计模式：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyrblog/p/9246643.html">参考文献</a></li>
</ul>
<p>Mediator模式通过引入一个能够管理对象间消息分布的对象，简化了系统中对象间的通信。该模式可以减少对象之间的相互引用，从而提高了对象间的松耦合度，并且它还可以独立地改变其间的交互。图7-17所示的是Mediator模式。</p>
<p>其优点如下。</p>
<p>●　去除对象间的影响。</p>
<p>●　简化了对象间协议。</p>
<p>●　集中化了控制。</p>
<p>●　由于不再需要直接互传消息，单个组件变得更加简单，而且容易处理。</p>
<p>●　由于不再需要包含逻辑来处理组件间的通信，组件变得更加通用。</p>
<p>在以下情况中，应该使用Mediator模式：</p>
<p>●　对象集合需要以一个定义规范但复杂的方式进行通信。</p>
<p>●　想要在不使用子类的情况下自定义分布在几个对象之间的行为。</p>
<details><summary>图7-17　Mediator模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822201655.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822201655.png';" /></details>

<h5 id="Memento模式"><a href="#Memento模式" class="headerlink" title="Memento模式"></a>Memento模式</h5><ul>
<li>备忘录模式：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyrblog/p/9249660.html">参考文献</a></li>
</ul>
<p>Memento模式可以保持对象状态的“快照”（snapshot），这样对象可以在不向外界公开其内容的情况下返回到它的最初状态。图7-18所示的是Memento模式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822203222.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822203222.png';" /></details>

<p>其优点如下。</p>
<p>●　保持封装的完整。</p>
<p>●　简化了返回到初始状态所需的操作。</p>
<p>在以下情况中，应该使用Memento模式：</p>
<p>●　必须保存对象状态的快照，这样以后就可以恢复状态。</p>
<p>●　使用直接接口来获得状态可能会公开对象的实现细节，从而破坏对象的封装性。</p>
<h5 id="Observer模式"><a href="#Observer模式" class="headerlink" title="Observer模式"></a>Observer模式</h5><p>Observer模式为组件向相关接收方广播消息提供了灵活的方法。该模式定义了对象间一到多的依赖关系，这样当对象改变状态时，将自动通知并更新它所有的依赖对象。图7-19所示的是Observer模式。</p>
<p>其优点如下。</p>
<p>●　抽象了主体与Observer之间的耦合关系。</p>
<p>●　支持广播方式的通信。</p>
<details><summary>图7-19　Observer模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822203637.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822203637.png';" /></details>

<p>在以下情况中，应该使用Observer模式：</p>
<p>●　对一个对象的修改涉及对其他对象的修改，而且不知道有多少对象需要进行相应修改。</p>
<p>●　对象应该能够在不用假设对象标识的前提下通知其他对象。</p>
<h5 id="State模式"><a href="#State模式" class="headerlink" title="State模式"></a>State模式</h5><p>State模式允许对象在内部状态变化时，变更其行为，并且修改其类。图7-20所示的是State模式。</p>
<details><summary>图7-20　State模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822204337.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822204337.png';" /></details>

<p>其优点如下。</p>
<p>●　定位指定状态的行为，并且针对不同状态来划分行为，使状态转换显式进行。在以下情况中，应该使用State模式：</p>
<p>●　对象的行为依赖于其状态，并且该对象必须在运行时根据其状态修改其行为。</p>
<p>●　操作具有大量以及多部分组成的取决于对象状态的条件语句。</p>
<h5 id="Strategy模式"><a href="#Strategy模式" class="headerlink" title="Strategy模式"></a>Strategy模式</h5><p>Strategy模式定义了一组能够用来表示可能行为集合的类。这些行为可以在应用程序中使用，来修改应用程序功能。图7-21所示的是Strategy模式。</p>
<details><summary>图7-21　Strategy模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822204420.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822204420.png';" /></details>


<p>其优点如下。</p>
<p>●　另一种子类化方法。</p>
<p>●　在类自身中定义了每一个行为，这样就减少了条件语句。(减少条件语句的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53089925">参考文献</a>)</p>
<p>●　更容易扩展模型。在不对应用程序进行代码修改的情况下，使该模式具有新的行为。</p>
<p>在以下情况中，应该使用Strategy模式：</p>
<p>●　许多相关类只是在行为方面有所区别。</p>
<p>●　需要算法的不同变体。</p>
<p>●　算法使用客户端未知的数据。</p>
<h5 id="Template-Method模式"><a href="#Template-Method模式" class="headerlink" title="Template Method模式"></a>Template Method模式</h5><p>Template Method模式提供了在不重写方法的前提下允许子类重载部分方法的方法。在操作中定义算法的框架，将一些步骤由子类实现。该模式可以在不修改算法结构的情况下，让子类重新定义算法的特定步骤。图7-22所示的是Template Method模式。</p>
<details><summary>图7-22　Template Method模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822204455.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822204455.png';" /></details>


<p>其优点为：代码重用的基础技术。</p>
<p>在以下情况中，应该使用Template Method模式：</p>
<p>●　想要一次实现算法的不变部分，而使用子类实现算法的可变行为。</p>
<p>●　当子类间的通用行为需要分解、定位到通用类的时候，这样可以避免代码重复的问题。</p>
<h5 id="Visitor模式"><a href="#Visitor模式" class="headerlink" title="Visitor模式"></a>Visitor模式</h5><ul>
<li><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/visitor">visitor模式</a>代码</li>
</ul>
<p>Visitor模式提供了一种方便的、可维护的方法来表示在对象结构元素上要进行的操作。该模式允许在不改变操作元素的类的前提下定义一个新操作。图7-23所示的是Visitor模式。</p>
<details><summary>图7-23　Visitor模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822204534.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822204534.png';" /></details>


<p>其优点如下。</p>
<p>●　更容易添加新操作。</p>
<p>●　集中相关操作并且排除不相关操作。</p>
<p>在以下情况中，应该使用Visitor模式：</p>
<p>●　对象结构包含许多具有不同接口的对象类，并且想要对这些依赖于具体类的对象进行操作。</p>
<p>●　定义对象结构的类很少被修改，但想要在此结构之上定义新的操作。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul>
<li>单一职责原则:设计目的单一的类</li>
<li>开放-封闭原则:对扩展开放，对修改封闭</li>
<li>李氏(Liskov)替换原则:子类可以替换父类，(不要随便重载)</li>
<li>依赖倒置原则︰要依赖于抽象，而不是具体实现;针对接口编程，不要针对实现编程(电视机：针对实现，计算机：针对接口)</li>
<li>接口隔离原则:使用多个专门的接口比使用单一的总接口要好</li>
<li>组合重用原则∶要尽量使用组合，而不是继承关系达到重用目的</li>
<li>迪米特(Demeter)原则(最少知识法则):一个对象应当对其他对象有尽可能少的了解(不设为私有的就会直接去使用内部的内容)</li>
</ul>
<h4 id="面向对象设计-设计模式的概念"><a href="#面向对象设计-设计模式的概念" class="headerlink" title="面向对象设计(设计模式的概念)"></a>面向对象设计(设计模式的概念)</h4><ul>
<li>√架构模式:软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策</li>
<li>√设计模式:主要关注软件系统的设计，与具体的实现语言无关</li>
<li>√惯用法:是最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法</li>
</ul>
<h4 id="面向对象设计-设计模式的分类"><a href="#面向对象设计-设计模式的分类" class="headerlink" title="面向对象设计(设计模式的分类)"></a>面向对象设计(设计模式的分类)</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903135908.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903135908.png';" /></details>

<p>行为:类之间交互,职责的方面<br>结构：类和对象之间的组合</p>
<h4 id="创建型模式-1"><a href="#创建型模式-1" class="headerlink" title="创建型模式"></a>创建型模式</h4><details><summary>创建型模式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903135955.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903135955.png';" /></details>

<h4 id="结构型模式-1"><a href="#结构型模式-1" class="headerlink" title="结构型模式"></a>结构型模式</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903140146.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903140146.png';" /></details>

<h4 id="行为型模式-1"><a href="#行为型模式-1" class="headerlink" title="行为型模式"></a>行为型模式</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903140439.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903140439.png';" /></details>


<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903140624.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903140624.png';" /></details>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch6-UML%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%96%87%E6%A1%A3%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch6-UML%E5%BB%BA%E6%A8%A1%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%96%87%E6%A1%A3%E5%8C%96/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch6-UML建模与架构文档化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:53:46" itemprop="dateCreated datePublished" datetime="2021-07-19T12:53:46+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-25 10:28:54" itemprop="dateModified" datetime="2021-10-25T10:28:54+08:00">2021-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="UML建模与架构文档化"><a href="#UML建模与架构文档化" class="headerlink" title="UML建模与架构文档化"></a>UML建模与架构文档化</h2><p>早在20世纪70年代就陆续出现了面向对象的建模方法，在80年代末到90年代中期，各种建模方法如雨后春笋般从不到10种增加到50多种。但方法种类的膨胀，同时极大地妨碍了用户的使用和交流。UML（统一建模语言）一出现，以融合了多种面向对象建模方法，简洁的图形与符号，直观的表示和强大的表示能力，得到工业界与学术界认可。它通过统一的表示法，使不同知识背景的领域专家、系统分析和开发人员以及用户可以方便地交流。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/3160571?fromtitle=UML&fromid=446747&fr=aladdin">全称</a>，Unified Modeling Language<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23569835">zhihu:UML 还有用吗？</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24840463">zhihu:敏捷开发</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23208040">zhihu：UML 在业界的使用情况如何？</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/57620b762160">简书：uml类图（言简意赅）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lxy344x/article/details/40346525">包含，拓展，泛化关系的区别</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/e5945/article/details/5968654">类图中的四种类关系</a>：关联、聚合和组合、依赖、泛化</p>
</blockquote>
<h3 id="UML现状与发展"><a href="#UML现状与发展" class="headerlink" title="UML现状与发展"></a>UML现状与发展</h3><h4 id="UML起源"><a href="#UML起源" class="headerlink" title="UML起源"></a>UML起源</h4><p>在1995年，Gray Booch和Janes Rumbaugh将他们的面向对象建模方法统一为Unified Method V0.8。一年之后Ivar Jacobson加入其中，共同将该方法统一为二义性较少的UML0.9。同时，这三位杰出的方法学家被称为“三友（Three <a target="_blank" rel="noopener" href="https://fanyi.baidu.com/?aldtype=85#en/zh/Amigos">Amigos</a>）”。</p>
<p>很快用户也认识到可对软件系统进行可视化、描述、构造和文档化的通用建模语言所带来的益处。他们充满激情地将这种语言的早期草案应用于不同的领域。受用户强烈需求的驱动，建模工具厂商也很快在它们的产品中加入了对UML的支持。</p>
<p>UML成了实际上的工业标准。1996年，一个由建模专家组成的国际性队伍“UML伙伴组织”开始同“三友”一起工作，计划将UML提议作为OMG（Object Management Group）的标准建模语言。</p>
<p>1997年1月，伙伴组织向OMG提交了最初的提案UML 1.0。经过了九个月的紧张修订，于1997年9月提出了最终提案UML 1.1，这个提案在1997年11月被OMG正式采纳为对象建模标准。</p>
<p>在一个规范被采纳后不久，将成立一个修订任务组，负责该规范的修订。1997年9月，OMG采纳UML1.1规范之后不久，特许成立了第一个UML修订任务组（Revision Task Forces, RTF），负责收集有关评论，并且提出修改建议。</p>
<p>该RTF提交的第一个主要产品是一个编辑版本UML 1.2，它改编了规范，使之与其他OMG规范更为一致。尽管这一版本纠正了印刷和语法错误，以及某些明显的逻辑上的不一致，但还是没有涉及对重要技术的改进。</p>
<p>该RTF的第二个主要的产品是其技术版本UML 1.3，它修正和改善了UML 1.1的遗留问题，并矫正了在此之后发现的许多小错误。该RTF一致推荐OMG批准其UML 1.3最终草案，并于1999年6月提交了一份最终报告。被推荐的规范随后被提交给组织委员会和平台技术委员会以获得批准。</p>
<h4 id="UML体系结构演变"><a href="#UML体系结构演变" class="headerlink" title="UML体系结构演变"></a>UML体系结构演变</h4><p>UML是用元模型来描述的，元模型是4层元模型体系结构模式中的一层。此模式的其他层次分别是元—元模型层、模型层和用户对象层。其中元模型层由元—元模型层导出，UML的元—元模型层在OMG MOF的元—元模型中定义，而UML元模型中的元类是MOF元—元类的实例。</p>
<p>元模型的体系结构模式已被证明可以用来定义复杂模型所要求的精确语义，这种复杂模型通常需要被可靠地保存、共享、操作以及在工具之间进行交换。它的特点如下：</p>
<p>（1）它在每一层都递归地定义语义结构，从而使语义更精确、更正规。</p>
<p>（2）它可用来定义重量级和轻量级扩展机制，如定义新的元类和构造型。</p>
<p>（3）它在体系结构上将UML元模型与其他基于4层元模型体系结构的标准（比如MOF和用于模型交换的XMI Facility）统一起来。</p>
<p>在元模型层，UML元模型又被分解为三个逻辑子包：基础包、行为元素包和模型管理包。其中基础包由核心、扩展机制和数据类型三个子包构成，它是描述模型静态结构的语言底层结构，支持类图、对象图和构件图和部署图等结构图。行为元素包是描述模型动态行为的语言上层结构，支持不同的行为图，包括Use Case（用况）图、顺序图、协作图、状态图和活动图。模型管理包则定义了对模型元素进行分组和管理的语义，它描述了几种分组结构，包括包、模型和子系统。行为元素包和模型管理包都依赖于基础包。</p>
<p>UML 1.3是建模语言规范第一个成熟的发布。它纠正或调整了从UML 1.1中继承下来的遗留问题，并且修正了最终提交后的一年来所发现的大多数错误。从建模者的角度看，从UML 1.1到UML 1.3并没有很大变化，对语言的大部分改进是在底层对UML元模型语义的调整，只有很少量的变化是针对表示法的细枝末节的修改。底层结构上的变化对大多数用户来说是看不到的，但这使得UML在将来更容易实现和扩展。</p>
<h5 id="解决UML-1-1的遗留问题"><a href="#解决UML-1-1的遗留问题" class="headerlink" title="解决UML 1.1的遗留问题"></a>解决UML 1.1的遗留问题</h5><p>1）完善活动图的语义和表示法增加了状态的动态激发语义，定义了执行条件线程的语义和表示法，而且增加了对象流功能。为了做这些修订，还需要对活动图所依赖的状态机语义做以下修改：为同步并发的活动加入“同步状态”、精化信号的语义、为合并状态转换定义附加的伪状态。</p>
<p>（2）清理关系的标准元素。引入关系元类来组织各种类型的关系，并且把依赖构造型改造为依赖和流。此外，精练了泛化，不再需要以前的许多构造型（如继承、私有、子类、子类型等）。依赖和其他关系名称的一致性也有所改进。</p>
<p>（3）体系结构的一致性。通过加入物理元模型和XMI （XML metadata Interchange）、DTD （Document Type Definition）定义，提高了UML 1.3元模型的体系结构跟MOF和XMI Facility的一致性。从UML语义逻辑元模型导出的物理元模型包含了一些支持产生IDL （Interface Definition Language）和XMI DTD的修改（例如将关联类转化为类）。尽管这样做与严格的元模型方法相左，但它为未来UML的修订达到这一目标提供了桥梁。</p>
<h5 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h5><p>（1）静态结构图。放宽了限制，使类和接口之间可以关联，并且在类中可以声明信号。信号被定义为一个类元，可以操作。另外，还重新定义了模板和强类型的语义。</p>
<p>（2）用例图。用例之间的关系被重新定义为三种主要类型： $\color{green}{\text{泛化}}$ 、 $\color{green}{\text{包含}}$ 和 $\color{green}{\text{延伸}}$ 。</p>
<p>（3）交互图。放宽了限制，使用户可以描述角色或实例。而且协作也可以泛化。</p>
<p>（4）模型管理图。改进了模型和子系统的语义和表示法，将它们从包中分离出来，并使之更容易使用。澄清了对包的访问和引入权限的区别。</p>
<p>尽管UML规范的核心是语法和语义定义，但它还包括模型交换、语言扩展以及约束等方面的定义。UML 1.3对这些相关规范都进行了错误纠正，并使之与核心语言的改进保持一致。</p>
<h5 id="为UML-2-0确立路标"><a href="#为UML-2-0确立路标" class="headerlink" title="为UML 2.0确立路标"></a>为UML 2.0确立路标</h5><p>该RTF在最终报告中明确了因为超出其范围或时间不允许而不能做的各种改进。他们建议下一个RTF应特别注意扩展性和文档管理方面的问题。对目前的扩展机制，用户和工具开发商已经发现了一些重要问题，而涌入新UML外围的提案可能会加剧这些困难。在文档管理方面，物理元模型和XMI DTD规范的加入大幅度地增加了UML规范的长度，并使它变得笨拙难用（它现在已有800多页了）。下一次UML修订将会把物理建模规范拆分为单独的文档。</p>
<p>该RTF还进一步建议负责起草UML 2.0 RFP的工作组考虑以下问题。</p>
<ul>
<li>体系结构：使用严格的元模型方法定义一个与MOF元—元模型严格一致的物理元模型。给出改进的指导方针，以决定哪些部分应该定义在核心语言中，哪些部分应定义在UML的外围或标准模型库中。</li>
<li>扩展性：提供同4层元模型体系结构一致的扩展机制。提高外围规范的严密程度，使其支持用户对语言定制能力不断增加的要求。</li>
<li>构件：增强基于构件的软件开发的语义和表示法。</li>
<li>关系：提供“精化”和“追踪”依赖关系的基本语义。在多个抽象层次上定义关联的语义。</li>
<li>状态图和活动图：定义独立于状态图语义的活动图语义。在活动图和状态图中提供更随意的并发。详细说明状态机的泛化。</li>
<li>模型管理：重新定义模型和子系统的表示法和语义，以增强对企业体系结构视图的支持。</li>
<li>总体机制：定义一种模型版本管理的机制。详细说明图的互换机制。</li>
</ul>
<h4 id="UML的应用与未来"><a href="#UML的应用与未来" class="headerlink" title="UML的应用与未来"></a>UML的应用与未来</h4><p>UML是在多种面向对象建模方法的基础上发展起来的建模语言，主要用于软件密集型系统的建模。它的演化，可以按其性质划分为以下几个阶段：最初的阶段是专家的联合行动，由三位Object-Oriented（面向对象）方法学家将他们各自的方法结合在一起，形成UML 0.9。第二阶段是公司的联合行动，由十几家公司组成的“UML伙伴组织”将各自的意见加入UML，形成UML 1.0和1.1，并作为向OMG申请成为建模语言规范的提案。第三阶段是在OMG控制下的修订与改进，OMG于1997年11月正式采纳UML 1.1作为建模语言规范，然后成立任务组进行不断的修订，并产生了UML 1.2、1.3和1.4版本，其中UML 1.3是较为重要的修订版。目前正处于UML的重大修订阶段，目标是推出UML 2.0，作为向ISO提交的标准提案。</p>
<p>从UML的早期版本开始，便受到了计算机产业界的重视，OMG的采纳和大公司的支持把它推上了实际上的工业标准的地位，使它拥有越来越多的用户。它被广泛地用于应用领域和多种类型的系统建模，如管理信息系统、通信与控制系统、嵌入式实时系统、分布式系统和系统软件等。近几年还被运用于软件再工程、质量管理、过程管理和配置管理等方面。而且它的应用不仅仅限于计算机软件，还可用于非软件系统，例如硬件设计、业务处理流程、企业或事业单位的结构与行为建模。</p>
<p>对UML的讨论和评价，无论是Internet上的意见交流，或是每年一次的UML研讨会，还是学术期刊上发表的文章，都是既肯定其成绩，又指出其缺点和错误，并且以积极的态度提出建设性意见。总的来说：</p>
<ul>
<li>UML已经取得重要成功，它已成为在软件工业中占支配地位的建模语言，并在许多领域的软件开发中得到应用。</li>
<li>UML还存在许多问题，自它产生之日起就从未离开过批评：用户和教师抱怨它内容庞大、难学难教而且太过复杂；学者认为它缺少一个精练的核心和定义良好的外围，有些语义定义得不够精确而且带有二义性；建模实践者认为它缺少支持自己领域建模要求的机制；工具开发商则因为规范本身的不确定性而产生理解上的偏差，它们对UML的自行诠释有可能误导用户。</li>
<li>UML的关键问题是过于庞大和复杂，以及在语言体系结构、语义等方面存在理论缺陷。产生这些问题的一个重要原因是，在形成规范的过程中不得不照顾多种方法流派的观点和多家公司的利益。</li>
</ul>
<h3 id="UML基础"><a href="#UML基础" class="headerlink" title="UML基础"></a>UML基础</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>UML通过图形化的表示机制从多个侧面对系统的分析和设计模型进行刻画。它共定义了10种视图，并将其分为如下4类。</p>
<p>（1）用例图（use case diagram）。从外部用户的角度描述系统的功能，并指出功能的执行者。</p>
<p>（2）静态图。包括类图（class diagram）、对象图（object diagram）和包图（package diagram）。类图描述系统的静态结构，类图的节点表示系统中的类及其属性和操作，类图的边表示类之间的联系，包括 $\color{green}{\text{继承}}$ 、 $\color{green}{\text{关联}}$ 、 $\color{green}{\text{依赖}}$ 和 $\color{green}{\text{聚合}}$ 等。对象图是类图的一个实例，它描述在某种状态下或在某一时间段，系统中活跃的对象及其关系。包图描述系统的分解结构，它表示包（package）以及包之间的关系。包由子包及类组成。包之间的关系包括继承、构成与依赖关系。</p>
<p>（3）行为图。包括交互图（interactive diagram）、状态图（statechart diagram）与活动图（active diagram），它们从不同的侧面刻画系统的动态行为。交互图描述对象之间的消息传递，它又可分为顺序图（sequence diagram）与合作图（collaboration diagram）两种形式。顺序图强调对象之间消息发送的时间序。合作图更强调对象间的动态协作关系。合作图也可通过消息序号来表示消息传递的时间序，只不过这种表示不如顺序图那样直观。状态图描述类的对象的动态行为，它包含对象所有可能的状态、在每个状态下能够响应的事件以及事件发生时的状态迁移与响应动作。活动图描述系统为完成某项功能而执行的操作序列，这些操作序列可以并发和同步。活动图中包含控制流和信息流。</p>
<p>4）实现图（implementation diagram）。包括构件图（component diagram）与部署图（deployment diagram），它们描述软件实现系统的组成和分布状况。构件图描述软件实现系统中各组成部件以及它们之间的依赖关系。部署图描述作为软件系统运行环境的硬件及网络的物理体系结构，其节点表示实际的计算机和设备，边表示节点之间的物理连接关系，也可显示连接的类型及节点之间的依赖性。</p>
<h4 id="用例和用例图"><a href="#用例和用例图" class="headerlink" title="用例和用例图"></a>用例和用例图</h4><p>用例（use case）国内也翻译为用况、用案等，在UML中，用例用一个椭圆表示，用例名往往用动宾结构或主谓结构命名。它有两个比较有代表性的定义如下。</p>
<p>定义1：用例是对一个 $\color{green}{\text{活动者}}$ （actor）使用系统的一项功能时所进行的交互过程的一个文字描述序列。</p>
<p>定义2：用例是系统、子系统或类和外部的参与者（actor） $\color{green}{\text{交互的动作序列}}$ 的说明，包括可选的动作序列和会出现异常的动作序列。</p>
<p>用例是代表系统中各相关人员之间就系统的行为所达成的契约。软件的开发过程可以分为$\color{green}{\text{需求分析}}$、$\color{green}{\text{设计}}$、$\color{green}{\text{实现等阶段}}$，在需求阶段用例是分析人员与客户沟通的工具和项目规模估算的依据；设计阶段用例是系统功能设计的主要输入；在实现阶段用例是检测类行为正确性的文档。因此，面向对象的软件开发过程是用例驱动的。</p>
<p>用例分析可以支持领域建模（domain modeling），以确保定义正确的需求（right requirements），是保证OO软件开发成功的基础。但要在具体的项目中灵活使用用例来捕获用户的需求并不是一件容易的事情，往往需要用户的经验、沟通能力、丰富的领域知识等。</p>
<p>本质上，用例分析是一种功能分解（functional decomposition）的技术，并未使用到面向对象思想。但用例是UML的重要部分，确定一个系统的用例是开发OO系统的第一步，用例分析这步做得好，接着的交互图分析、类图分析等才有可能做得好，整个系统的开发才能顺利进行。</p>
<p>编写用例必须识别以下元素。</p>
<h5 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h5><p>角色（actor）是指系统以外的、需要使用系统或与系统交互的东西，包括人、设备、外部系统等。actor有很多不同的译名，包括参与者、活动者、执行者和行动者等。</p>
<p>一个参与者可以执行多个用例，一个用例也可以由多个参与者使用。但需要注意的是，参与者实际上并不是系统的一部分，尽管在模型中会使用参与者。</p>
<p>参与者实际上是一个版型化的类，其版型是〈〈Actor〉〉。图6-1是参与者的三种表示形式。</p>
<details><summary>图6-1　参与者的表示形式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725163741.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725163741.png';" /></details>

<blockquote>
<p>$\color{red}{\text{版型}}$化是什么意思。</p>
</blockquote>
<h5 id="用例间的关系"><a href="#用例间的关系" class="headerlink" title="用例间的关系"></a>用例间的关系</h5><p>用例除了与参与者有 $\color{green}{\text{关联}}$ （association）关系外，用例之间也存在着一定的关系（relationship），如 $\color{green}{\text{泛化}}$ （generalization）关系、 $\color{green}{\text{包含}}$ （include）关系、 $\color{green}{\text{扩展}}$ （extend）关系等。</p>
<p>包含（include）关系指的是两个用例之间的关系，其中一个用例（称作基本用例，base use case）的行为包含了另一个用例（称作包含用例，inclusion use case）的行为。包含关系是依赖关系的版型，也就是说包含关系是比较特殊的依赖关系，它们比一般的依赖关系多一些语义。如图6-2所示是包含关系的例子，其中用例取款机专用（ATM Session）是基本用例，用例识别客户（Identify Customer）和验证账号（Validate Account）是包含用例。</p>
<details><summary>图6-2　用例的包含关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725164243.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725164243.png';" /></details>


<p>扩展（extend）关系的基本含义与泛化关系类似。但在扩展关系中，对于扩展用例（extension use case）有更多的规则限制，即基本用例必须声明若干“扩展点”（extension point），而扩展用例只能在这些扩展点上增加新的行为和含义。图6-3所示是同时具有扩展关系和包含关系的例子，在这个例子中，可以看到基本用例、包含用例、扩展用例等概念间的联系和区别。</p>
<details><summary>图6-3　包含用例和扩展用例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725164701.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725164701.png';" /></details>

<p>对于“购货”这个用例，它扩展了“浏览网站”这个用例，同时也包含了“订单加入库存系统”这个用例。因此对于“浏览网站”这个用例来说是扩展用例，但对于“订单加入库存系统”这个用例来说是基本用例。</p>
<h5 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h5><p>用例图（use case diagram）是显示一组用例、参与者以及它们之间关系的图。在UML中，一个用例模型由若干个用例图描述。如图6-4显示了电话系统的使用用例图。</p>
<p>UML规范说明中并不使用颜色作为图形语义的区分标记，但建模人员可以在图中给某些图符加上填充颜色，以强调某一部分的模型，或希望引起使用者的特别注意。但在语义上，使用填充颜色和不使用填充颜色的模型是一样的。</p>
<h5 id="用例的描述"><a href="#用例的描述" class="headerlink" title="用例的描述"></a>用例的描述</h5><p>用例的描述才是用例的核心部分，用例采用自然语言描述参与者与系统进行交互时双方的行为，不追求形式化的语言表达。以下是一个典型描述多方式。</p>
<details><summary>图6-4　电话系统的使用用例图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725165901.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725165901.png';" /></details>


<p>用例：〈编号〉〈名称〉</p>
<p>用途及特征：</p>
<p>　　　　用例在系统中的目标（用例目标描述）</p>
<p>　　　　范围（当前考虑的是哪个系统）</p>
<p>　　　　级别（概要任务/首要任务/子功能）</p>
<p>　　　　当前条件（用例执行前系统应具有的状态）</p>
<p>　　　　成功后续条件（用例成功执行后应具有的状态）</p>
<p>　　　　失效后续条件（用例没有完成目标的状态）</p>
<p>　　　　触发（启动该用例执行的系列动作）</p>
<p>角色：首要角色（与该用例关联的首要角色）</p>
<p>主场景：动作序列</p>
<p>　　　　〈步骤编号〉〈动作描述〉〈系统响应〉</p>
<p>扩展场景：动作序列</p>
<p>　　　　〈步骤编号〉〈条件〉：〈动作或另一个用例〉</p>
<p>异常场景：</p>
<p>　　　　〈步骤编号〉〈条件〉：〈异常动作〉</p>
<p>相关信息（可选）：</p>
<p>　　　　优先级（该用例对于系统/组织的关键程度）</p>
<p>　　　　性能目标（该用例的执行时间耗费）</p>
<p>　　　　频度（该用例被执行的频度）</p>
<p>　　　　与首要角色的联系渠道（包括交互式、静态文件、数据库等）</p>
<p>存在问题：</p>
<p>　　　　列出关于该用例的未解决问题</p>
<h5 id="交互图"><a href="#交互图" class="headerlink" title="交互图"></a>交互图</h5><p>交互图（interaction diagram）是用来描述对象之间以及对象与参与者（actor）之间的动态协作关系以及协作过程中行为次序的图形文档。它通常用来描述一个用例的行为，显示该用例中所涉及的对象和这些对象之间的消息传递。交互图包括顺序图</p>
<p>（sequence diagram）和协作图（collaboration diagram）两种形式。顺序图着重描述对象按照时间顺序的消息交换，协作图着重描述系统成分如何协同工作。顺序图和协作图从不同的角度表达了系统中的交互和系统的行为，它们之间可以相互转化。一个用例需要多个顺序图或协作图，除非特别简单的用例。</p>
<p>交互图可以帮助分析人员对照检查每个用例中所描述的用户需求，如这些需求是否已经落实到能够完成这些功能的类中去实现，提醒分析人员去补充遗漏的类或方法。</p>
<h6 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h6><p>顺序图也称时序图。Rumbaugh对顺序图的定义是：顺序图是显示对象之间交互的图，这些对象是按时间顺序排列的。特别地，顺序图中显示的是参与交互的对象及对象之间消息交互的顺序。图6-5所示是一个简单的顺序图例子。</p>
<details><summary>图6-5　顺序图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725170635.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725170635.png';" /></details>

<p>顺序图是一个二维图形。在顺序图中水平方向为$\color{green}{\text{对象维}}$，沿水平方向排列的是参与交互的对象。其中对象间的排列顺序并不重要，但一般把表示参与者的对象放在图的两侧，主要参与者放在最左边，次要参与者放在最右边（或表示人的参与者放在最左边，表示系统的参与者放在最右边）。顺序图中的垂直方向为$\color{green}{\text{时间维}}$，沿垂直向下方向按时间递增顺序列出各对象所发出和接收的消息。</p>
<h6 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h6><p>协作图是用于描述系统的行为是如何由系统的成分协作实现的图，协作图中包括的建模元素有对象（包括参与者实例、多对象、主动对象等）、消息、链等。</p>
<h4 id="类图和对象图"><a href="#类图和对象图" class="headerlink" title="类图和对象图"></a>类图和对象图</h4><p>类是具有相似结构、行为和关系的一组对象的抽象。在UML中，类表示为划分成三个格子的长方形，如图6-6所示。</p>
<details><summary>图6-6　UML中类的表示图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725170953.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725170953.png';" /></details>

<p>在定义类的时候，类的命名应尽量用应用领域中的术语，应明确、无歧义，以利于开发人员与用户之间的相互理解和交流。一般而言，类的名字是名词。</p>
<p>一般说来，类之间的关系有关联、聚集、组合、泛化和依赖等，下面将对这些关系进行详细说明。</p>
<h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><p>关联（association）是模型元素间的一种语义联系，它是对具有共同的结构特性、行为特性、关系和语义的链（link）的描述。在上面的定义中，需要注意链这个概念，$\color{green}{\text{链}}$是一个实例，就像对象是类的实例一样，链是关联的实例，关联表示的是类与类之间的关系，而链表示的是对象与对象之间的关系。</p>
<p>在类图中，关联用一条把类连接在一起的实线表示。关联两端的类可以某种角色参与关联。例如在图6-7中，Company类以employer的角色、Person类以employee的角色参与关联，employer和employee称为角色名。如果在关联上没有标出角色名，则隐含地用类的名称作为角色名。角色还具有多重性（multiplicity），表示可以有多少个对象参与该关联。在图6-7中，employer可以雇佣多个employee，表示为0..n；employee只能被一家employer雇佣，表示为1。</p>
<details><summary>图6-7　关联的角色</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725171105.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725171105.png';" /></details>

<p>通过关联类（association class）可以进一步描述关联的属性、操作以及其他信息。关联类通过一条虚线与关联连接。图6-8中的Contract类是一个关联类，Contract类中有属性salary，这个属性描述的是Company类和Person类之间的关联的属性，而不是描述Company类或Person类的属性。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725183957.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725183957.png';" /></details>

<p>自返关联（reflexive association）又称递归关联（recursive association），是一个类与自身的关联，即同一个类的两个对象间的关系。自返关联虽然只有一个被关联的类，但有两个关联端，每个关联端的角色不同。自返关联的例子如图6-9所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725184016.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725184016.png';" /></details>

<h5 id="聚集和组合"><a href="#聚集和组合" class="headerlink" title="聚集和组合"></a>聚集和组合</h5><p>聚集（aggregation）是一种特殊形式的关联。聚集表示类之间整体与部分的关系。在对系统进行分析和设计时，需求描述中的“包含”、“组成”、“分为……部分”等词常常意味着存在聚集关系（见图6-10）。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725191648.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725191648.png';" /></details>

<p>组合（composition）表示的也是类之间的整体与部分的关系，但组合关系中的整体与部分具有同样的生存期。也就是说，组合是一种特殊形式的聚集。</p>
<h5 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h5><p>泛化（generalization）定义了一般和特殊元素之间关系，如果从面向对象程序设计语言的角度来说，类与类之间的泛化关系就是平常所说的类与类之间的继承关系。</p>
<p>UML中用一头为空心三角形的连线表示泛化关系。</p>
<h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>假设有两个元素X、Y，如果修改元素X的定义可能会导致对另一个元素Y的定义的修改，则称元素Y依赖于元素X。</p>
<h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p>6-11所示为学校内主要对象的类图。学校包含若干学生，是由多个系组成。每个系开设若干课程，学生参加不同课程学习（管联）关系；老师教一门或多门课程。在一个系中，有一个老师是领导，系包含若干老师。</p>
<p>类图以直观、抽象形式展示了不同对象之间关系。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725191917.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725191917.png';" /></details>

<h4 id="状态图和活动图"><a href="#状态图和活动图" class="headerlink" title="状态图和活动图"></a>状态图和活动图</h4><h5 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h5><p>UML中的状态图（state chart diagram）主要用于描述一个对象在其 $\color{green}{\text{生存期间}}$ 的 $\color{green}{\text{动态行为}}$ ，表现一个对象所经历的状态序列，引起状态转移的 $\color{green}{\text{事件}}$ （event），以及因状态转移而伴随的 $\color{green}{\text{动作}}$ （action）。状态图是UML中对系统的动态行为建模的5个图之一，状态图在检查、调试和描述类的动态行为时非常有用。一般可以用状态机对一个对象的生命周期建模，状态图是用于显示状态机的，重点在于描述状态之间的控制流。</p>
<p>图6-12所示是一个简单的状态图的例子。这个状态图中描述的对象除了初态和终态外，还有Idle和Running两个状态，而keyPress、finished、shut Down等是事件。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192052.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192052.png';" /></details>

<h5 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h5><p>活动图是对系统的动态行为建模的5个图之一。活动图可以用于描述系统的工作流程和并发行为。活动图其实可看作状态图的特殊形式，活动图中一个活动结束后将 $\color{green}{\text{立即进入}}$ 下一个活动（在状态图中状态的转移可能需要事件的触发）。</p>
<p>下面讨论活动图中的几个基本概念：活动、泳道、分支、分叉和汇合、对象流。</p>
<p>1）活动</p>
<p>活动（activity）表示的是某流程中的任务的执行，它可以表示某算法过程中语句的执行。在活动图中需要注意区分动作状态（action state）和活动状态（activity state）这两个概念。动作状态是原子的，不能被分解，没有内部转移，没有内部活动，动作状态的工作所占用的时间是可忽略的。动作状态的目的是执行进入动作（entry action），然后转向另一个状态。活动状态是可分解的，不是原子的，其工作的完成需要一定的时间。可以把动作状态看作活动状态的特例。</p>
<p>2）泳道</p>
<p>泳道（swimlane）是活动图中的区域划分，根据每个活动的职责对所有活动进行划分，每个泳道代表一个 $\color{green}{\text{责任区}}$ 。泳道和类并不是一一对应的关系，泳道关心的是其所代表的职责，一个泳道可能由一个类实现，也可能由多个类实现。</p>
<p>3）分支</p>
<p>在活动图中，对于同一个触发事件，可以根据不同的警戒条件转向不同的活动，每个可能的转移是 $\color{green}{\text{一个分支}}$ （branch）。</p>
<p>4）分叉和汇合</p>
<p>分支表示的是从多种可能的活动转移中选择一个，如果要表示系统或对象中的并发行为，则可以使用分叉（fork）和汇合（join）这两种建模元素。分叉表示两个或多个控制流经过分叉后，这些控制流 $\color{green}{\text{并发}}$ 进行；汇合正好与分叉相反。</p>
<p>5）对象流</p>
<p>在活动图中可以出现对象。对象可以作为活动的输入或输出。活动图中的对象流表示活动和对象之间的关系，如一个活动创建对象（作为活动的输出）或使用对象（作为活动的输入）等。如图6-13所示。</p>
<details><summary>活动图案例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192219.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192219.png';" /></details>


<h4 id="构件图"><a href="#构件图" class="headerlink" title="构件图"></a>构件图</h4><p>构件（component）是系统中遵从一组接口且提供其实现的物理的、可替换的部分。构件图（componentdiagram）则显示一组构件以及它们之间的相互关系，包括编译、链接或执行时构件之间的依赖关系。图6-14所示是一个构件图的例子，表示.html文件、.exe文件、.dll文件这些构件之间的相互依赖关系。</p>
<details><summary>图6-14　构件图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192302.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192302.png';" /></details>

<p>$\color{red}{\text{构件}}$ 就是一个 $\color{green}{\text{实际文件}}$ ，可以有以下几种类型：</p>
<p>1）部署构件（deploymentcomponent），如dll文件、exe文件、COM＋对象、CORBA对象、EJB、动态Web页和数据库表等。</p>
<p>（2）工作产品构件（work productcomponent），如源代码文件、数据文件等，这些构件可以用来产生部署构件。</p>
<p>（3）执行构件（execution component），也就是系统执行后得到的构件。</p>
<p>构件图可以对以下几个方面建模：</p>
<p>（1）对源代码文件之间的相互关系建模，如图6-15所示。</p>
<details><summary>图6-15　构件图用于对源代码建模</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192437.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192437.png';" /></details>

<p>2）对可执行文件之间的相互关系建模。图6-16所示是某可运行系统的部分文件之间的相互关系。</p>
<p>在图6-16中，IDriver是接口，构件path.dll和接口IDriver之间是依赖关系，而构件dirver.dll和接口IDriver之间是实现关系。</p>
<details><summary>图6-16　构件图用于对可运行系统建模</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192455.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192455.png';" /></details>


<h4 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h4><p>$\color{green}{\text{部署图}}$ 也称配置图、实施图，它可以用来显示系统中计算结点的拓扑结构和通信路径与结点上运行的软构件等。一个系统模型只有一个部署图，部署图常用于帮助理解 $\color{green}{\text{分布式系统}}$ 。</p>
<p>部署图由体系结构设计师、网络工程师、系统工程师等描述。图6-17所示是一个部署图的例子。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725192524.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725192524.png';" /></details>

<h3 id="基于UML的软件开发过程"><a href="#基于UML的软件开发过程" class="headerlink" title="基于UML的软件开发过程"></a>基于UML的软件开发过程</h3><h4 id="开发过程概述"><a href="#开发过程概述" class="headerlink" title="开发过程概述"></a>开发过程概述</h4><p>UML是独立于软件开发过程的，即UML能够在几乎任何一种软件开发过程中使用。迭代的渐进式软件开发过程包含4个阶段，即初启、细化、构建和部署。</p>
<h5 id="初启"><a href="#初启" class="headerlink" title="初启"></a>初启</h5><p>在初启阶段，软件项目的发起人确定项目的主要目标和范围，并进行初步的可行性分析和经济效益分析。</p>
<h5 id="细化"><a href="#细化" class="headerlink" title="细化"></a>细化</h5><p>细化阶段的开始标志着项目的正式确立。软件项目组在此阶段需要完成以下工作：</p>
<p>（1）初步的需求分析。采用UML的用例描述目标软件系统所有比较重要、比较有风险的用例，利用用例图表示参与者与用例以及用例与用例之间的关系。采用UML的类图表示目标软件系统所基于的应用领域中的概念与概念之间的关系。这些相互关联的概念构成领域模型。领域模型一方面可以帮助软件项目组理解业务背景，与业务专家进行有效沟通；另一方面，随着软件开发阶段的不断推进，领域模型将成为软件结构的主要基础。如果领域中含有明显的流程处理成分，可以考虑利用UML的活动图来刻画领域中的工作流，并标识业务流程中的并发、同步等特征。</p>
<p>（2）初步的高层设计。如果目标软件系统的规模比较庞大，那么经初步需求分析获得的用例和类将会非常多。此时，可以考虑根据用例、类在业务领域中的关系，或者根据业务领域中某种有意义的分类方法将整个软件系统划分为若干个包，利用UML的包图刻画这些包及其间的关系。这样，用例、用例图、类、类图将依据包的划分方法分属于不同的包，从而得到整个目标软件系统的高层结构。</p>
<p>（3）部分的详细设计。对于系统中某些重要的或者风险比较高的用例，可以采用交互图进一步探讨其内部实现过程。同样，对于系统中的关键类，也可以详细研究其属性和操作，并在UML类图中加以表现。因此，这里倡导的软件开发过程是根据软件元素（用例、类等）的重要性和风险程度确立优先细化原则，建议软件项目组优先考虑重要的、比较有风险的用例和类，不能将风险的识别和解决延迟到细化阶段之后。</p>
<p>（4）部分的原型构造。在许多情形下，针对某些复杂的用例构造可实际运行的原型是降低技术风险、让用户帮助软件项目组确认用户需求的最有效的方法。为了构造原型，需要针对用例生成详尽的交互图，对所有相关类给出明确的属性和操作定义。</p>
<p>综上所述，在细化阶段可能需要使用的UML语言机制包括描述用户需求的用例及用例图、表示领域概念模型的类图、表示业务流程处理的活动图、表示系统高层结构的包图和表示用例内部实现过程的交互图。</p>
<h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><p>在构造阶段，开发人员通过一系列的迭代完成对所有用例的软件实现工作，在每次迭代中实现一部分用例。以迭代方式实现所有用例的好处在于，用户可以及早参与对已实现用例的实际评价，并提出改进意见。这样可有效降低大型软件系统的开发风险。在实际开始构造软件系统之前，有必要预先制定迭代计划。计划的制定需遵循如下两项原则：</p>
<p>（1）用户认为业务价值较大的用例应优先安排。</p>
<p>（2）开发人员评估后认为开发风险较高的用例应优先安排。</p>
<p>在迭代计划中，要确定迭代次数、每次迭代所需时间以及每次迭代中应完成（或部分完成）的用例。</p>
<p>每次迭代过程由针对用例的分析、设计、编码、测试和集成5个子阶段构成。在集成之后，用户可以对用例的实现效果进行评价，并提出修改意见。这些修改意见可以在本次迭代过程中立即实现，也可以在下次迭代中再予以考虑。</p>
<p>构建过程中，需要使用UML的交互图来设计用例的实现方法。为了与设计得出的交互图协调一致，需要修改或精化在细化阶段绘制的作为领域模型的类图，增加一些为软件实现所必需的类、类的属性或方法。</p>
<p>在构建阶段的每次迭代过程中，可以对细化阶段绘出的包图进行修改或精化，以便包图切实反映目标软件系统最顶层的结构划分状况。</p>
<p>综上所述，在构建阶段可能需要使用的UML语言机制包括：</p>
<p>（1） $\color{green}{\text{用例及用例图}}$ 。它们是开发人员在构造阶段进行分析和设计的基础。</p>
<p>（2） $\color{green}{\text{类图}}$ 。在领域概念模型的基础上引进为软件实现所必需的类、属性和方法。</p>
<p>（3） $\color{green}{\text{交互图}}$ 。表示针对用例设计的软件实现方法。</p>
<p>（4） $\color{green}{\text{状态图}}$ 。表示类的对象的状态—事件—响应行为。</p>
<p>（5） $\color{green}{\text{活动图}}$ 。表示复杂的算法过程，尤其是过程中的并发和同步。</p>
<p>（6） $\color{green}{\text{包图}}$ 。表示目标软件系统的顶层结构。</p>
<p>（7） $\color{green}{\text{构件图}}$ 。</p>
<p>（8） $\color{green}{\text{部署图}}$ 。</p>
<h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><p>在部署阶段，开发人员将构造阶段获得的软件系统在用户实际工作环境（或接近实际的模拟环境）中试运行，根据用户的修改意见进行少量调整。</p>
<h4 id="基于UML的需求分析"><a href="#基于UML的需求分析" class="headerlink" title="基于UML的需求分析"></a>基于UML的需求分析</h4><p>在初步的业务需求描述已经形成的前提下，基于UML的需求分析过程（见图6-18）大致可分为以下步骤。</p>
<ul>
<li>利用用例及用例图表示需求。从业务需求描述出发获取执行者和场景；对场景进行汇总、分类、抽象，形成用例；确定执行者与用例、用例与用例图之间的关系，生成用例图。</li>
</ul>
<details><summary>图6-18　需求分析过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725193042.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725193042.png';" /></details>

<ul>
<li>利用包图及类图表示目标软件系统的总体框架结构。根据领域知识、业务需求描述和既往经验设计目标软件系统的顶层架构；从业务需求描述中提取“关键概念”，形成领域概念模型；从概念模型和用例出发，研究系统中主要的类之间的关系，生成类图。</li>
</ul>
<p>上述两个步骤并没有时序关系，它们可以并行展开。</p>
<h5 id="生成用例"><a href="#生成用例" class="headerlink" title="生成用例"></a>生成用例</h5><p>从外部用户的视角看，一个用例是执行者（actor）与目标软件系统之间的一次典型的交互作用。从软件系统内部的视角出发，一个用例代表系统执行的一系列动作，动作执行的结果能够被外部的执行者所察觉。执行者是指外部用户或外部实体在系统中扮演的角色。如果多个用户在使用目标软件系统时扮演同一角色，这些用户将由单一执行者表示。反之，如果一个用户扮演多种角色，则需要用多个执行者来表示同一用户。</p>
<p>对用例的完整描述包括用例名称、参与执行者、前置条件、一个主事件流、零到多个辅事件流和后置条件。主事件流表示正常情况下执行者与系统之间的信息交互及动作序列，辅事件流则表示特殊情况或异常情况下的信息交互及动作序列。显式地分隔主、辅事件流是为了使分析人员首先聚焦于正常的业务处理流程，同时也便于用例的读者理解业务需求。</p>
<p>用例主要来源于分析人员对场景的分类和抽象，即将相似的场景进行归并，使一个用例可以通过实例化和参数调节而涵盖多个场景。</p>
<p>例如，在“家庭保安系统”中，执行者有“用户”、“传感器”、“警报器”、“报警电话”和“显示器”，用例有“系统配置”、“命令响应”和“传感器监测”。下面以“传感器监测”为例说明用例的一般描述格式。</p>
<p><u>用例名称</u>：传感器监测。</p>
<p>参与执行者：各类传感器、警报器、报警电话和显示器。</p>
<p><u>前置条件</u>：系统已开机。</p>
<p><u>主事件流</u>：</p>
<p>①传感器向目标软件系统上报其监测数据，系统判别监测数据是否正常。</p>
<p>②如果不正常，系统启动警报器，拨报警电话号码。</p>
<p>③报警电话接通后，软件系统播出语音，报告异常事件发生的时间、地点和事件的性质。</p>
<p>④系统在控制面板的显示器上显示报警时间及当前状态（报警）。</p>
<p><u>辅事件流</u>：</p>
<p>①如果报警电话无人接听，则按照重拨延迟反复拨号，直至电话接通，再转入主事件流的步骤③。</p>
<p>②如果重拨次数达到系统预设的最大次数，电话仍无人接听，则跳过主事件流的步骤③，转入步骤④。</p>
<p><u>后置条件</u>：如果已发现异常的监测数据，系统处于“报警”状态；否则，系统处于正常的“监测”状态。</p>
<h5 id="用活动图表示用例"><a href="#用活动图表示用例" class="headerlink" title="用活动图表示用例"></a>用活动图表示用例</h5><p>针对前面所述的“传感器监测”用例，其活动图表示如图6-19所示。</p>
<details><summary>活动图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725193731.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725193731.png';" /></details>


<h5 id="生成用例图"><a href="#生成用例图" class="headerlink" title="生成用例图"></a>生成用例图</h5><p>执行者与用例之间的关系有两种：触发执行与信息交换。执行者与用例之间可能兼具这两种关系，例如，在“家庭保安系统”中，执行者“用户”在触发用例“命令响应”的同时，还要向用例传送命令信息。</p>
<p>在UML用例图中，从执行者指向用例的边表示触发执行和/或信息交换，从用例指向执行者的边则表示用例将其生成的信息传递给执行者。例如图6-19中的“传感器监测”用例仅包含正常的处理流程，而“报警电话未接通”用例除正常流程外还增加了“重复拨号”以及“重拨次数达到最大次数仍无人接听”这两种异常处理动作。</p>
<h5 id="建立顶层架构"><a href="#建立顶层架构" class="headerlink" title="建立顶层架构"></a>建立顶层架构</h5><p>顶层架构的主要目的是为后续的分析和设计活动建立一种结构和分划，以便开发人员在不同的开发阶段，以及同一开发阶段的不同开发人员，能够聚焦于系统的不同部分。顶层架构是分析和设计的阶段成果的承载体。随着开发过程的推进，框架中的内容不断丰富、翔实，最终演进为完整的面向对象软件结构。</p>
<h6 id="UML包图"><a href="#UML包图" class="headerlink" title="UML包图"></a>UML包图</h6><p>包是UML对类进行分组的一种机制。可以从某种视角将具有比较密切的关联的一些类划分为一个包，分属于不同包的两个类之间的关联则比较松散。由此可见，对于大型软件系统而言，包的划分是实现“分而治之”的重要技术手段。</p>
<p>包之间存在两种依赖关系：依赖和构成。如果对类A的修改将导致类B的改变，则称B依赖于A。如果两个包中存在具有依赖关系的两个类，则认为这两个类分属的包之间存在依赖关系。</p>
<h6 id="顶层架构设计"><a href="#顶层架构设计" class="headerlink" title="顶层架构设计"></a>顶层架构设计</h6><p>软件系统顶层架构的基本方法是，结合实际需求，从既往的架构设计经验模式中选取适当者，再进行微调或局部改造。目前有如下几种主要的架构模式：</p>
<p>（1）流程处理模式。流程处理系统以算法和数据结构为中心，其系统功能由一系列的处理步骤构成，相邻的处理步骤之间以数据流通管道相互连接。</p>
<p>（2）客户/服务器模式。客户端负责用户输入和处理结果的呈现，服务器端则负责后台的业务逻辑处理。</p>
<ul>
<li>模型——视图——控制器（Model、View、Controller, MVC）模式。该模式将整个软件系统划分为模型、视图和控制器三个部分。模型负责维护并保存具有持久性的业务数据，实现业务处理功能，并将业务数据的变化情况及时通知视图；视图负责呈现模型中包含的业务数据，响应模型变化通知，更新呈现形式，并向控制器传递用户的界面动作；控制器负责将用户的界面动作映射为模型中的业务处理功能并实际调用之，然后根据模型返回的业务处理结果选择新的视图。MVC模式特别适合于分布式应用软件，尤其是Web应用系统。</li>
<li>分层模式。分层模式将整个软件系统分为若干层次，最顶层直接面向用户提供软件系统的操作界面，其余各层为紧邻其上的层次提供服务。分层模式可以有效地降低软件系统的耦合度，因此其应用十分普遍。</li>
</ul>
<p>事实上，大型软件的顶层架构往往需要复合使用多种架构样式。例如，整个目标软件系统采用分层结构，在系统的不同层次内再分别使用适宜的其他种类的架构模式。</p>
<p>在确立顶层架构的过程中需综合考虑以下因素：</p>
<ul>
<li>架构中包的数量。原则上，如果母个包中包含的软件元素（例如类）的数量过多，应考虑将其进一步细分；如果过少，则说明架构过早地陷入了细节，架构划分返工的可能性较大，同时也不合理地限制了后续分析和设计活动的自由空间。</li>
<li>架构中包之间的耦合度。包之间的依赖关系和连接关系应尽量简单、稀疏。</li>
<li>软件系统的稳定性。要尽量抽取不稳定的软件元素之中相对稳定的部分，将不稳引起的软件元素分类聚集于少数几个包中，以提高软件系统的可维护性。</li>
<li>软件系统的必然性。可以将可选功能和必须实现的功能分置于架构中不同的包或子包之中。</li>
<li>作为软件系统运行环境的物理网络拓扑。根据软件元素在分布环境中的部署情况。区分顶层架构中的包，可以使包之间的消息传递与物理节点之间的通信相吻合，使后续的分析和设计活动受益于顶层架构中明确定义的通信关系。</li>
<li>软件元素的安全、保密级别。根据安全访问的权限划分顶层架构中的包或者子包。</li>
<li>开发团队的技术专长。根据开发人员在问题领域和软件技术领域不同的专长划分顶层架构中的包，使每个包都能分配给最适合的开发人员进行后续的分析、设计、编码和测试等，从而有利于并行开发。</li>
</ul>
<h5 id="建立概念模型"><a href="#建立概念模型" class="headerlink" title="建立概念模型"></a>建立概念模型</h5><p>例如，“家庭保安系统”的领域概念模型如图6-20所示。</p>
<details><summary>图6-20　“家庭保安系统”的领域概念模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725194200.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725194200.png';" /></details>

<h4 id="面向对象的设计方法"><a href="#面向对象的设计方法" class="headerlink" title="面向对象的设计方法"></a>面向对象的设计方法</h4><p>面向对象的软件设计过程如图6-21所示。</p>
<details><summary>图6-21　面向对象的软件设计过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725194237.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725194237.png';" /></details>

<h5 id="设计用例实现方案"><a href="#设计用例实现方案" class="headerlink" title="设计用例实现方案"></a>设计用例实现方案</h5><p>UML的交互图（顺序图、协作图）适于用例实现方案的表示。该设计方法包含如下三个步骤：</p>
<h6 id="提取边界类、实体类和控制类"><a href="#提取边界类、实体类和控制类" class="headerlink" title="提取边界类、实体类和控制类"></a>提取边界类、实体类和控制类</h6><p>边界类用于描述目标软件系统与外部环境之间的交互，并负责实现如下功能：</p>
<ul>
<li>界面控制。包括输入数据的格式及内容转换、输出结果的呈现以及软件运行过程中界面的变化写切换等。</li>
<li>外部接口。实现目标软件系统与外部系统或外部设备之间的信息交流和互操作。主要关注跨越目标软件系统边界的通信协议。</li>
<li>环境隔离。将目标软件系统与操作系统、数据库管理系统、应用服务器中间件等境软件进行交互的功能与特性封装于边界类之中，使目标软件系统的其余部分尽可能地独立于环境软件。</li>
</ul>
<p>在UML类图中，边界类往往附加UML构造型〈〈boundary〉〉作为特别标识。</p>
<p>实体类表示目标软件系统中具有持久意义的信息项及其操作。实体类的操作具有“内向收敛”特征，它们仅向目标软件系统的其余部分提供读/写信息项内容的必要的操作接口，并不涉及业务逻辑处理。实体类的UML构造型为〈〈entity〉〉。</p>
<p>控制类作为完成用例任务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。对于比较复杂的用例，控制类通常并不处理具体的任务细节，但是它应知道如何分解任务，如何将子任务分派给适当的辅助类，以及如何在辅助类之间进行消息传递和协调。控制类的UML构造型为〈〈control〉〉。</p>
<p>通常情况下，执行者与用例之间的一种通信连接对应一个边界类。但是，如果两个以上的用例与同一执行者交互，并且这些交互具有共同的行为、完成相同或类似的任务，就可以考虑用同一边界类实现用例与执行者之间的交互。这就意味着边界类的作用范围可以超越单个用例。</p>
<h6 id="构造交互图"><a href="#构造交互图" class="headerlink" title="构造交互图"></a>构造交互图</h6><p>UML交互图，以交互图作为用例的精确实现方案。</p>
<p>如前所述，用例描述中已包含事件流说明。事件流中的事件应直接对应于交互图中的消息，而事件间的先后关系体现为交互图中的时序，对消息的响应则构成消息接收者的职责。这种职责在后续的设计活动中将被确立为类的方法。</p>
<p>对于比较复杂的用例而言，仅仅依靠控制类、边界类和实体类并不能很好地解决问题，因为我们不能使单个控制类过于庞大和复杂，让它既承担控制、协调的任务，又承担复杂的计算任务。因此，在设计复杂用例的实施方案时，应考虑为控制类设置一些独立的辅助类，让控制类将一些任务委托给辅助类完成。例如，在图6-20所示的“家庭保安系统”类图中，“系统配置管理器”和“日志管理器”就是这种意义上的辅助类。</p>
<p>在UML顺序图中，用例的主动执行者应位于最左侧，紧邻其右的类是作为用户界面的边界类，再往右是控制类。控制类的右侧应放置辅助类和实体类，它们的右侧是作为外部接口和环境隔离层的边界类，最右侧是位于目标软件系统边界之外的被动执行者。如此布局之后，在顺序图中不应该出现穿越控制类生命线的消息，即主动执行者向边界类发出命令，边界类将命令进行适当转换后传送至控制类，控制类通过消息请求辅助类、实体类的帮助，协调、控制它们共同完成来自主动执行者的命令。在此过程中，控制类或辅助类可以向右侧的边界类发送消息，将信息或外部处理请求由边界类传向外部系统（被动执行者）。按照上述布局规则绘制的典型的顺序图如图6-22所示。</p>
<details><summary>图6-22　典型布局规则下顺序图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725194500.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725194500.png';" /></details>

<p>在用例描述中，许多用例除主事件流外，往往还包含备选事件流，以说明在某些特殊或异常情况下的事件和响应动作序列。为易于理解，在设计模型中应该用分离的UML交互图分别表示事件流和每个备选事件流。</p>
<p>（3）根据交互图精化类图。</p>
<p>在UML交互图中，对每个类的对象都规定了它必须响应的消息以及类的对象之间的消息传递通道。前者对应于类的操作，后者则对应于类之间的连接关系。因此，可以利用交互图精化分析模型中的类图，将交互图中出现的新类添加到原有类图中，并且对相关的类进行精化，定义其属性和操作。</p>
<p>原则上，每个类都应该有一个操作来响应交互图中指向其对象的那条消息。但是，这并不意味着消息与操作一定会一一对应，因为类的一个操作可能具有响应多条消息的能力。同理，两个类之间的一条连接关系也可以为多条消息提供传递通道。为了简化设计模型，也为了提高重用程度，设计人员应该尽量使用已有的操作来响应新消息，并尽量使用已存在的连接路径作为消息传递的通道。如果两个类之间存在明确、自然的聚合或组合关系，则可以在类图中直接用相应的UML图元符号表示类间的聚合或组成关系，这两个关系均可提供消息传递通道。</p>
<p>接下来讨论如何根据交互图确立类的属性。类的操作完成消息响应责任的能力来源于两方面的知识，一是类本身具有的信息，即类的属性；二是类能够找到的其他类，通过其他类协助其完成消息响应。在综合考虑这两个因素之后，类的操作应该明确哪些子任务可通过消息传递路径委托给其他类完成，哪些子任务必须由自身完成。根据后一种子任务的需要，结合领域和业务知识即可推导出类应具有的属性。</p>
<h5 id="设计技术支撑方案"><a href="#设计技术支撑方案" class="headerlink" title="设计技术支撑方案"></a>设计技术支撑方案</h5><p>在许多软件项目中，应用功能往往都需要一组技术支撑机制为其提供服务。例如，对分布式应用软件（包括电子商务应用、企业ERP系统等）而言，需要数据持久存储服务、安全控制服务、分布式事务管理服务、并发与同步控制服务和可靠消息服务等。这些技术支撑设施并非业务需求的直接组成部分，但形态各异的业务处理功能全都依赖于它们提供的公共技术服务。让每个业务功能的设计者直接面对裸机、基本操作系统或基本网络环境来完成软件实现方案是不可思议的。</p>
<p>技术支撑方案应该为多个用例的软件实现提供技术服务，所以，它应该成为整个目标软件系统中全局性的公共技术平台。当用户需求发生变化时，技术支撑方案应具有良好的稳定性。这就要求软件设计者选用开放性和可扩充性较好的技术支撑方案。如果目标软件系统的顶层架构采用分层方式，那么技术支撑方案应该位于层次结构中的较低层次。</p>
<p>技术支撑方案的设计一方面取决于目标软件系统对公共技术服务的需求，另一方面取决于设计人员对软件技术手段的把握和选取。</p>
<h5 id="设计用户界面"><a href="#设计用户界面" class="headerlink" title="设计用户界面"></a>设计用户界面</h5><p>用户界面设计的策略与步骤如下：</p>
<p>（1）熟悉用户并对用户分类。设计人员应深入用户环境，考虑用户需要完成的任务、完成这些任务需要什么工具支持以及这些工具对用户是否适用。事实上，不同类型的用户要求也不同，一般可按技术熟练程度、工作性质和访问权限对用户进行分类，以便尽量照顾到所有用户的合理要求，并优先满足某些特权用户。</p>
<p>2）按用户类别分析用户的工作流程与习惯。在用户分类的基础上，从每类中选取一个用户代表，建立包括下列内容的调查表，并通过对调查结果的分析判断用户对操作界面的需求和喜好。</p>
<ul>
<li>姓名。</li>
<li>期望软件用途。</li>
<li>特征（如年龄、文化程度、限制等）。</li>
<li>主要要求与喜好。</li>
<li>技术熟练程度。</li>
<li>任务客观场景描述。</li>
</ul>
<p>（3）设计命令系统并进行优化。在设计一个新命令系统时，应尽量遵循用户界面的一般原则和规范，必要时可参考一些优秀的商品软件。根据用户分析结果确定初步的命令系统，然后再优化。命令系统既可为若干菜单、菜单栏，也可为一组按钮。优化命令系统时首先应考虑命令的顺序，一般常用命令居先，命令的顺序与用户工作习惯保持一致；其次，根据外部服务之间的聚合关系组织相应的命令，总体功能对应父命令，部分功能对应子命令；然后，充分考虑人类记忆的局限性（即所谓“7 12”原则或“3×3”原则），命令系统最好组织为一棵两层的多叉树；最后，应尽可能减少用户完成一个操作所需的动作（如单击鼠标、拖曳鼠标和敲击键盘等），并为熟练用户提供操作的快捷方式。</p>
<p>（4）设计用户界面的各种细节。此步骤包括设计一致的用户界面风格、耗时操作的状态反馈、undo机制、帮助用户记忆的操作序列和自封闭的集成环境等。</p>
<p>（5）增加用户界面专用的类与对象。用户界面专用类的设计与所选用的图形用户界面（GUI）工具或者支持环境有关。一般而言，需要为窗口、菜单、对话框等界面元素定义相应的类，这些类往往继承自GUI工具或者支持环境提供的类库中的父类。最后，还需要针对每个与用户命令处理相关的界面类，定义控制设计模型中的其他类的方法。</p>
<p>利用快速原型演示，改进界面设计。为人机交互部分构造原型，是界面设计的基本技术之一。为用户演示界面原型，让他们直观感受目标软件系统的使用方法，并评判系统是否功能齐全、方便好用。</p>
<h5 id="精化设计模型"><a href="#精化设计模型" class="headerlink" title="精化设计模型"></a>精化设计模型</h5><p>对模型进行改进的活动可以分为$\color{green}{\text{精化}}$和$\color{green}{\text{合并}}$两种，一般先从精化开始。首先，由于初始架构模型已经包括了总原则和层结构两部分的内容。现在要做的工作是根据需求和架构原则来划分不同的粗粒度组件。粗粒度组件来源于分析活动中的业务实体。把具有很强相关性业务实体组合起来，形成一个集合。集合内部存在错综复杂的关系，同时集合向外部提供服务接口。这样的集合就称为粗粒度组件。粗粒度组件对外的接口和内部的实现是相区分的。粗粒度组件的形式有很多，Java平台上的Jar文件、Windows平台上的dll文件，甚至古老的。或a文件都可以是粗粒度组件的表现形式。设计优秀的粗粒度组件应该只是完成一项功能，这一点是它与子系统的主要区分。一个系统中可能包括会计子系统、库存管理子系统。但是提供会计粗粒度组件或是库存管理粗粒度组件是没有什么意义的。因为这样的粗粒度组件的范围过于广泛，难以发挥重用的价值。粗粒度组件是可以（可能也是必须）跨越层次的。粗粒度组件拥有持久化的行为，拥有业务逻辑，需要表示层的支持。这样看起来，它所属的轴向和层次的轴向是相互垂直的。粗粒度组件来源于需求。需求阶段产生的需求说明书或是用例模型将是粗粒度组件开发的基础。在拥有了需求工件之后，我们需要对需求进行功能性的划分，将需求分为几个功能组，这样我们基本上就可以得到相应的粗粒度组件了。如果系统比较庞大，可以对功能组再做细分。这取决于粗粒度组件的范围。过小的范围，将会造成粗粒度组件不容易使用，用户需要理解不同的粗粒度组件之间的复杂关系，最后的结果也将包含大量的组件和复杂的逻辑。过大的范围，则会造成粗粒度组件难以重用，导致粗粒度组件称为一个子系统。</p>
<p>假设需要开发一个人力资源管理系统。经过整理，它的需求大致分为如下几个部分。</p>
<ul>
<li>组织结构的设计和管理：包括员工职务管理和员工所属部门的管理。</li>
<li>员工资料的管理：包括员工的基本资料和简单的考评资料。</li>
<li>日常事务的管理：包括了对员工的考勤管理和工资发放管理。</li>
</ul>
<p>对于前两项的功能组，建立粗粒度组件是比较合适的。但是对于第三项功能组，由于范围过大，将之分为考勤管理和工资管理。现在我们得到了4个粗粒度组件。分别是组织结构组件、员工资料组件、员工考勤组件和员工工资组件。</p>
<p>在得到了粗粒度组件之后，下面的工作分为两个部分：第一个部分是定义不同的粗粒度组件之间的关系。第二个部分是在粗粒度组件的基础上定义业务实体或是定义细粒度组件。</p>
<p>不同的粗粒度组件之间的关系其实就是前文提到的粗粒度组件的外部接口。如果可能，在粗粒度组件之间定义单向的关联（如上图所示）可以有效的减少组件之间的耦合。如果必须要定义双向的关联，请确保关联双方组件之间的一致性。在图6-23中，我们可以清晰的看出，组织结构处于最底层，员工资料依赖于组织结构，包括从组织结构中获得员工的所属部门，以及员工职务等信息。而对于考勤、工资组件来说，需要从员工资料中获取必要的信息，也包括了部门和职务两方面的信息。这里有两种关联定义的方法，一种是让考勤组件从组织结构组件中获得部门和职务信息，从员工资料中获得另外的信息，另一种是如图6-23一样，考勤组件只从员工资料组件中获得信息，而员工资料组件再使用委托，从组织结构中获得部门和职务的信息。第二种做法的好处是向考勤、工资组件屏蔽了组织结构组件的存在，并保持了信息获取的一致性。这里演示的只是组件之间的简单关系，现实中的关系不可能如此的简单，但是处理的基本思路是一样的，就是尽可能简化组件之间的关系，从而减少它们之间的耦合度。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725195410.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725195410.png';" /></details>

<p>在得到了粗粒度组件模型之后，我们需要对其进行进一步的分析，以得到细粒度的组件。细粒度的组件具有更好的重用性，并使得架构设计的精化工作更进一步。按Jacobson推荐的面向对象软件工程（Object Oriented Software Enginerring, OOSE）的做法，我们需要从软件的目标领域中识别出关键性的实体，或者说是领域中的名词。例如上例中的员工、部门、工资等。然后决定它们应该归属于哪些粗粒度组件。先识别细粒度组件还是先识别粗粒度组件并没有固定的顺序。</p>
<p>最初得到的组件模型可能并不完善，需要对其进行修改。可能某个组件中的类太多了，过于复杂，就需要对其进一步精化、分为更细的组件，也许某个组件中的类太少了，需要和其他的组件进行合并。也许你会发现某两个组件之间存在重复的要素，可以从中抽取出共性的部分，形成新的组件。组件分析的过程并没有一种标准的做法，你只能够根据具体的案例来进行分析。</p>
<p>最后的模型将会明确的包含几个经过精化之后的粗粒度组件。粗粒度组件之间的关系也会进行一次重新定义。</p>
<h3 id="系统架构文档化"><a href="#系统架构文档化" class="headerlink" title="系统架构文档化"></a>系统架构文档化</h3><h4 id="模型概述"><a href="#模型概述" class="headerlink" title="模型概述"></a>模型概述</h4><p>软件架构用来处理软件高层次结构的设计和实施。它以精心选择的形式将若干结构元素进行装配，从而满足系统主要功能和性能需求，并满足其他非功能性需求，如可靠性、可伸缩性、可移植性和可用性。Perry和Wolfe使用一个精确的公式来表达，该公式由Boehm做了进一步修改。</p>
<p>$\color{green}{\text{软件架构}}$＝｛元素，形式，关系/约束｝</p>
<p>软件架构涉及到抽象、分解和组合、风格和美学。我们用由多个视图或视角组成的模型来描述它。为了最终处理大型的、富有挑战性的架构，该模型包含5个主要的视图如图6-24所示。</p>
<ul>
<li>逻辑视图（logical view），设计的对象模型（使用面向对象的设计方法时）。</li>
<li>过程视图（process view），捕捉设计的并发和同步特征。</li>
<li>物理视图（physical view），描述了软件到硬件的映射，反映了分布式特性。</li>
<li>开发视图（development view），描述了在开发环境中软件的静态组织结构。</li>
</ul>
<p>架构的描述，即所做的各种决定，可以围绕着这4个视图来组织，然后由一些用例（use cases）或场景（scenarios）来说明，从而形成了第5个视图。正如将看到的，实际上软件架构部分从这些场景演进而来。</p>
<details><summary>图6-24　Rational“4＋1”视图模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210725202552.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210725202552.png';" /></details>

<p>我们在每个视图上均独立地应用Perry &amp; Wolf的公式，即定义一个所使用的元素集合（组件、容器、连接符），捕获工作形式和模式，并且捕获关系及约束，将架构与某些需求连接起来。每种视图使用自身所特有的表示法——蓝图（blueprint）来描述，并且架构师可以对每种视图选用特定的架构风格（architectural style），从而允许系统中多种风格并存。</p>
<p>“4＋1”视图模型具有相当的“普遍性”，因此可以使用其他的标注方法和工具，也可以采用其他的设计方法，特别是对于逻辑和过程的分解。</p>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>逻辑架构主要支持功能性需求，即在为用户提供服务方面系统所应该提供的功能。系统分解为一系列的关键抽象，（大多数）来自于问题域，表现为对象或对象类的形式。它们采用抽象、封装和继承的原理。分解并不仅仅是为了功能分析，而且用来识别遍布系统各个部分的通用机制和设计元素。我们使用Rational/Booch方法来表示逻辑架构，借助于类图和类模板的手段。类图用来显示一个类的集合和它们的逻辑关系：关联、使用、组合、继承等。相似的类可以划分成类集合，基本的逻辑蓝图表示法如图6-25所示。类模板关注于单个类，它们强调主要的类操作，并且识别关键的对象特征。如果需要定义对象的内部行为，则使用状态转换图或状态图来完成。公共机制或服务可以在类功能（class utilities）中定义。对于数据驱动程度高的应用程序，可以使用其他形式的逻辑视图，例如E-R图，来代替面向对象的方法。</p>
<p>逻辑视图的表示法来自Booch标记法。当仅考虑具有架构意义的条目时，这种表示法相当简单。特别是在这种设计级别上，大量的修饰作用不大。我们使用Rational Rose来支持逻辑架构的设计。</p>
<details><summary>图6-25　逻辑蓝图的表示法</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822174733.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822174733.png';" /></details>

<h5 id="逻辑视图的风格"><a href="#逻辑视图的风格" class="headerlink" title="逻辑视图的风格"></a>逻辑视图的风格</h5><p>逻辑视图的风格采用面向对象的风格，其主要的设计准则是试图在整个系统中保持单一的、一致的对象模型，避免就每个场合或过程产生草率的类和机制的技术说明。</p>
<h5 id="逻辑结构蓝图的样例"><a href="#逻辑结构蓝图的样例" class="headerlink" title="逻辑结构蓝图的样例"></a>逻辑结构蓝图的样例</h5><p>图6-26显示了Télic PABX架构中主要的类。</p>
<details><summary>Télic PABX架构中主要的类</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822191423.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822191423.png';" /></details>

<p>对于一个包含了大量的具有架构重要意义的类的、更大的系统来说，图6-26（b）描述了空中交通管理系统的顶层类图，包含8个类的种类（例如，类的分组）。</p>
<h4 id="进程架构"><a href="#进程架构" class="headerlink" title="进程架构"></a>进程架构</h4><p>进程架构考虑一些非功能性的需求，如性能和可用性。它解决并发性、分布性、系统完整性、容错性的问题，以及逻辑视图的主要抽象如何与进程结构相配合在一起——即在哪个控制线程上，对象的操作被实际执行。</p>
<p>进程架构可以在几种层次的抽象上进行描述，每个层次针对不同的问题。在最高的层次上，进程架构可以视为一组独立执行的通信程序（叫作“processes”）的逻辑网络，它们分布在整个一组硬件资源上，这些资源通过LAN或者WAN连接起来。多个逻辑网络可能同时并存，共享相同的物理资源。例如，独立的逻辑网络可能用于支持离线系统与在线系统的分离，或者支持软件的模拟版本和测试版本的共存。</p>
<p>进程是构成可执行单元任务的分组。进程代表了可以进行策略控制过程架构的层次（即开始、恢复、重新配置及关闭）。另外，进程可以就处理负载的分布式增强或可用性的提高而不断地被重复。</p>
<p>接着，我们可以区别主要任务、次要任务。主要任务是可以唯一处理的架构元素；次要任务是由于实施原因而引入的局部附加任务（如周期性活动、缓冲、暂停等）。它们可以作为Ada Task或轻量线程来实施。主要任务的通讯途径是良好定义的交互任务通信机制：基于消息的同步或异步通信服务、远程过程调用、事件广播等。次要任务则以会见或共享内存来通信。在同一过程或处理节点上，主要任务不应对它们的分配做出任何假定。</p>
<p>消息流、过程负载可以基于过程蓝图来进行评估，同样可以使用哑负载来实现“中空”的进程架构，并测量在目标系统上的性能。正如Filarey etal在他的Eurocontrol实验中描述的那样。</p>
<details><summary>图6-27　进程蓝图表示法</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822191710.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822191710.png';" /></details>

<p>所有的终端由单个的Termal process处理，其中Termal process由输入队列中的消息进行驱动。Controller对象在组成控制过程三个任务之中的一项任务上执行：Low cycle rate task扫描所有的非活动终端（200 ms），将High cycle rate task（10 ms）扫描清单中的终端激活，其中High cycle rate task检测任何重要的状态变化，将它们传递给Main controller task，由它来对状态的变更进行解释，并通过向对应的终端发送消息来通信。这里Controller过程中的通信通过共享内存来实现。</p>
<h4 id="开发架构"><a href="#开发架构" class="headerlink" title="开发架构"></a>开发架构</h4><p>开发架构关注软件开发环境下实际模块的组织。软件打包成小的程序块（程序库或子系统），它们可以由一位或几位开发人员来开发。子系统可以组织成分层结构，每个层为上一层提供良好定义的接口。</p>
<p>系统的开发架构用模块和子系统图来表达，显示了“输出”和“输入”关系。完整的开发架构只有当所有软件元素被识别后才能加以描述。但是，可以列出控制开发架构的规则：分块、分组和可见性。</p>
<p>大部分情况下，开发架构考虑的内部需求与以下几项因素有关：开发难度、软件管理、重用性和通用性及由工具集、编程语言所带来的限制。开发架构视图是各种活动的基础，如：需求分配、团队工作的分配（或团队机构）、成本评估和计划、项目进度的监控、软件重用性、移植性和安全性。它是建立产品线的基础。</p>
<p>来自Rational的Apex开发环境支持开发架构的定义和实现和前文描述的分层策略，以及设计规则的实施。Rational Rose可以在模块和子系统层次上绘制开发蓝图，并支持开发源代码（Ada、C++）进程的正向和反向工程。</p>
<p>关于开发视图的风格，推荐使用分层（layered）的风格，定义4～6个子系统层。每层均具有良好定义的职责。设计规则是某层子系统依赖同一层或低一层的子系统，从而最大程度地减少了具有复杂模块依赖关系的网络的开发量，得到层次式的简单策略。</p>
<details><summary>图6-29　Hughes空中交通系统（HATS）的5个层</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822192501.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822192501.png';" /></details>

<p>图6-29代表了加拿大的Hughes Aircraft开发的空中交通控制系统（air traffic control system）产品线的5个分层开发组织结构。</p>
<p>第一层和第二层组成了独立于域的覆盖整个产品线的分布式基础设施，并保护其免受不同硬件平台、操作系统或市售产品（如数据库管理系统）的影响。第三层为该基础设施增加了ATC （Adaptive Transform Coding，自适应变换编码方法）框架，形成一个特定领域的软件架构（domain-specific software architecture）。使用该框架，可以在第四层上构建一个功能选择板。层次5则非常依赖于客户和产品，包含了大多数用户接口和外部系统接口。72个子系统分布于5个层次上，每层包含了10～50个模块，并可以在其他蓝图上表示。</p>
<h4 id="物理架构"><a href="#物理架构" class="headerlink" title="物理架构"></a>物理架构</h4><p>物理架构主要关注系统非功能性的需求，如可用性、可靠性（容错性），性能（吞吐量）和可伸缩性。软件在计算机网络或处理节点上运行，被识别的各种元素（网络、过程、任务和对象），需要被映射至不同的节点；我们希望使用不同的物理配置：一些用于开发和测试，另外一些则用于不同地点和不同客户的部署。因此软件至节点的映射需要高度的灵活性及对源代码产生最小的影响。</p>
<p>物理蓝图的表示法，如图6-30所示。</p>
<p>大型系统中的物理蓝图会变得非常混乱，所以它们可以采用多种形式，有或者没有来自进程视图的映射均可。</p>
<details><summary>图6-30　物理蓝图的表示法</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822192601.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822192601.png';" /></details>

<p>TRW（Thompson Ramo Wooldridge Lnc）公司的UNAS（Universal Network Architecture Services）提供了数据驱动方法将过程架构映射至物理架构，该方法允许大量的映射的变更而无需修改源代码。</p>
<details><summary>图6-31　PABX的物理蓝图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822192629.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822192629.png';" /></details>

<p>图6-31　作为物理蓝图的示例，显示了大型PABX（Private Automatic Branch Exchange）可能的硬件配置，而图6-32和图6-33显示了两种不同物理架构上的进程映射，分别对应一个小型和一个大型PABX。C、F和K是三种不同容量的计算机，支持三种不同的运行要求。</p>
<details><summary>图6-32带有过程分配的小型PABX物理架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822192703.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822192703.png';" /></details>

<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>4种视图的元素通过数量比较少的一组重要场景（更常见的是用例）进行无缝协同工作，我们为场景描述相应的脚本（对象之间和过程之间的交互序列）。在某种意义上场景是最重要的需求抽象，它们的设计使用对象场景图和对象交互图来表示。</p>
<details><summary>图6-33　带有过程分配的大型PABX物理架构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822192810.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822192810.png';" /></details>

<p>该视图是其他视图的冗余（因此“＋1”），但它起到了两个作用：</p>
<ul>
<li>作为一项驱动因素来发现架构设计过程中的架构元素。</li>
<li>作为架构设计结束后的一项验证和说明功能，既以视图的角度来说明又作为架构原型测试的出发点。</li>
</ul>
<p>场景表示法与组件逻辑视图非常相似（请对照图6-22），但它使用过程视图的连接符来表示对象之间的交互（请对照图6-25），注意对象实例使用实线来表达。至于逻辑蓝图，我们使用Rational Rose来捕获并管理对象场景。</p>
<p>图6-34是关于场景的例子，显示了小型PABX的场景片段。相应的脚本如下。</p>
<details><summary>图6-34　本地呼叫的初期场景——阶段选择</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210822192906.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210822192906.png';" /></details>

<p>（1）Joe的电话控制器检测和校验摘机状态的变换，并发送消息唤醒相应的终端对象。</p>
<p>（2）终端分配一些资源，并要求控制器发出拨号音。</p>
<p>（3）控制器接受拨号并传递给终端。</p>
<p>（4）终端使用拨号方案来分析数字流。</p>
<p>（5）有效的数字序列被键入，终端开始会话。</p>
<h4 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h4><p>在进行文档化时，提倡一种更具有迭代性质的方法——架构先被原形化、测试、估量、分析，然后在一系列的迭代过程中被细化。该方法除了减少与架构相关的风险之外，对于项目而言还有其他优点：团队合作、培训，加深对架构的理解，深入程序和工具等（此处提及的是演进的原形，逐渐发展成为系统，而不是一次性的试验性的原形）。这种迭代方法还能够使需求被细化、成熟化并能够被更好地理解。</p>
<p>场景驱动（scenario-driven）的方法</p>
<p>系统大多数关键的功能以场景（或use cases）的形式被捕获。关键意味着：最重要的功能，系统存在的理由，或使用频率最高的功能，或体现了必须减轻的一些重要的技术风险。</p>
<h5 id="开始阶段"><a href="#开始阶段" class="headerlink" title="开始阶段"></a>开始阶段</h5><p>（1）基于风险和重要性为某次迭代选择一些场景。场景可能被归纳为对若干用户需求的抽象。</p>
<p>（2）形成“稻草人式的架构”。然后对场景进行“描述”，以识别主要的抽象（类、机制、过程、子系统），如Rubin与Goldberg6所指出的——分解成为序列对（对象、操作）。</p>
<p>（3）所发现的架构元素被分布到4个蓝图中，即逻辑蓝图、进程蓝图、开发蓝图和物理蓝图。</p>
<p>（4）然后实施、测试、度量该架构，这项分析可能检测到一些缺点或潜在的增强要求。</p>
<p>（5）捕获经验教训。</p>
<h5 id="循环阶段"><a href="#循环阶段" class="headerlink" title="循环阶段"></a>循环阶段</h5><p>（1）下一个迭代过程开始进行。</p>
<p>（2）重新评估风险。</p>
<p>（3）扩展考虑的场景选择板。</p>
<p>（4）选择能减轻风险或提高结构覆盖的额外的少量场景。</p>
<p>（5）然后试着在原先的架构中描述这些场景。</p>
<p>（6）发现额外的架构元素，或有时还需要找出适应这些场景所需的重要架构变更。</p>
<p>（7）更新4个主要视图：逻辑视图、进程视图、开发视图和物理视图。</p>
<p>（8）根据变更修订现有的场景。</p>
<p>（9）升级实现工具（架构原型）来支持新的、扩展了的场景集合。</p>
<p>（10）测试。如果可能的话，在实际的目标环境和负载下进行测试。</p>
<p>（11）然后评审这5个视图来检测简洁性、可重用性和通用性的潜在问题。</p>
<p>（12）更新设计准则和基本原理。</p>
<p>（13）捕获经验教训。</p>
<p>（14）终止循环。</p>
<p>为了实际的系统，初始的架构原型需要进行演进。较好的情况是在经过两次或三次迭代之后，结构变得稳定：主要的抽象都已被找到。子系统和过程都已经完成，以及所有的接口都已经实现。接下来则是软件设计的范畴，这个阶段可能也会用到相似的方法和过程。</p>
<p>这些迭代过程的持续时间参差不齐，原因在于：所实施项目的规模，参与项目人员的数量、他们对本领域和方法的熟悉程度，以及该系统和开发组织的熟悉程度等。因而较小的项目迭代过程可能持续2～3周，而大型的项目可能为6～9个月。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903131722.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903131722.png';" /></details>

<p>用例图是静态还是动态</p>
<p>部署图: 部署到哪个硬件上</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch5-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E5%AE%98%E6%96%B9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch5-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">官方系统架构设计师教程-ch5-软件架构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 12:53:25" itemprop="dateCreated datePublished" datetime="2021-07-19T12:53:25+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-25 18:58:40" itemprop="dateModified" datetime="2021-10-25T18:58:40+08:00">2021-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="软件架构设计"><a href="#软件架构设计" class="headerlink" title="软件架构设计"></a>软件架构设计</h2><p>Shaw和Garlan在他们划时代的著作中以如下方式讨论了软件的体系结构：从第一个程序被划分成模块开始，软件系统就有了体系结构。现在，有效的软件体系结构及其明确的描述和设计，已经成为软件工程领域中重要的主题。</p>
<p>由于历史原因，研究者和工程人员对Software Architecture简称SA的翻译不一样，本书中软件“体系结构”和“架构”具有相同的含义。</p>
<h3 id="软件架构概念"><a href="#软件架构概念" class="headerlink" title="软件架构概念"></a>软件架构概念</h3><h4 id="软件架构的定义"><a href="#软件架构的定义" class="headerlink" title="软件架构的定义"></a>软件架构的定义</h4><p>Bass、Clements和Kazman对于这个难懂的概念给出了如下的定义：</p>
<p>一个程序和计算系统软件体系结构是指系统的一个或者多个结构。结构中包括软件的构件，构件的外部可见 $\color{green}{\text{属性}}$ 以及它们之间的 $\color{green}{\text{相互关系}}$ 。</p>
<p>体系结构并非可运行软件。确切地说，它是一种 $\color{red}{\text{表达}}$ ，使软件工程师能够：</p>
<p>（1）分析设计在满足规定需求方面的 $\color{green}{\text{有效性}}$ 。</p>
<p>（2）在设计变更相对容易的阶段，考虑体系结构可能的 $\color{green}{\text{选择方案}}$ 。</p>
<p>（3）降低与软件构造相关联的 $\color{green}{\text{风险}}$ 。</p>
<p>上面的定义强调在任意体系结构表述中“软件构件”的角色。在体系结构设计的环境中，软件构件可以简单到程序模块或者面向对象的类，也可以扩充到包含数据库和能够完成客户与服务器网络配置的“中间件”。</p>
<p>软件体系结构的设计通常考虑了设计金字塔中的两个层次——数据设计和体系结构设计。数据设计使我们表示出传统系统中体系结构的数据构件和面向对象系统中类的定义（封装了属性和操作），体系结构设计则主要关注软件构件的 $\color{green}{\text{结构}}$ 、 $\color{green}{\text{属性}}$ 和 $\color{green}{\text{交互作用}}$ 。</p>
<p>建立体系结构层的“内聚的、良好设计的表示”所需的方法，其目标是提供一种导出体系结构设计的系统化方法，而体系结构设计是构建软件的初始蓝图。</p>
<h4 id="软件架构设计与生命周期"><a href="#软件架构设计与生命周期" class="headerlink" title="软件架构设计与生命周期"></a>软件架构设计与生命周期</h4><h5 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h5><p>需求阶段的SA研究还处于起步阶段。在本质上，需求和SA设计面临的是不同的对象：一个是问题空间；另一个是解空间。保持二者的可追踪性和转换，一直是软件工程领域追求的目标。从软件需求模型向SA模型的转换主要关注两个问题：</p>
<p>（1）如何根据需求模型构建SA模型。</p>
<p>（2）如何保证模型转换的可追踪性。</p>
<p>针对这两个问题的解决方案，随着所采用的需求模型的不同而各异。在采用Use Case图描述需求的方法中，从Use Case图向SA模型（包括类图等）的转换一般经过词性分析和一些经验规则来完成，而可追踪性则可通过表格或者Use Case Map等来维护。</p>
<p>从软件复用的角度看，SA影响需求工程也有其自然性和必然性，已有系统的SA模型对新系统的需求工程能够起到很好的借鉴作用。在需求阶段研究SA，有助于将SA的概念贯穿整个软件生命周期，从而保证了软件开发过程的概念完整性，有利于各阶段参与者的交流，也易于维护各阶段的可追踪性。</p>
<h5 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h5><p>设计阶段是SA研究关注的最早和最多的阶段，这一阶段的SA研究主要包括：SA模型的描述、SA模型的设计与分析方法，以及对SA设计经验的总结与复用等。有关SA模型描述的研究分为三个层次：</p>
<p>（1）SA的基本概念，即SA模型由哪些元素组成，这些组成元素之间按照何种原则组织。传统的设计概念只包括构件（软件系统中相对独立的有机组成部分，最初称为模块）以及一些基本的模块互联机制。随着研究的深入，构件间的互联机制逐渐独立出来，成为与构件同等级别的实体，称为连接子。现阶段的SA描述方法是构件和连接子的建模。近年来，也有学者认为应当把Aspect等引入SA模型。</p>
<p>（2） $\color{red}{\text{体系结构描述语言}}$ （Architecture Description Language, ADL），支持 $\color{green}{\text{构件}}$ 、 $\color{green}{\text{连接子}}$ 及其 $\color{green}{\text{配置}}$ 的描述语言就是如今所说的体系结构描述语言。ADL对连接子的重视成为区分ADL和其他建模语言的重要特征之一。典型的ADL包括UniCon、Rapide、Darwin、Wright、C2 SADL、Acme、xADL、XYZ/ADL和ABC/ADL等。</p>
<p>（3）SA模型的多视图表示，从不同的视角描述特定系统的体系结构，从而得到多个视图，并将这些视图组织起来以描述整体的SA模型。多视图作为一种描述SA的重要途径，也是近年来SA研究领域的重要方向之一。系统的每一个不同侧面的视图反映了一组系统相关人员所关注的系统的特定方面，多视图体现了关注点分离的思想。</p>
<p>把体系结构描述语言和多视图结合起来描述系统的体系结构，能使系统更易于理解，方便系统相关人员之间进行交流，并且有利于系统的一致性检测以及系统质量属性的评估。学术界已经提出若干多视图的方案，典型的包括4＋1模型（逻辑视图、进程视图、开发视图、物理视图，加上统一的场景）、Hofmesiter的4视图模型（概念视图、模块视图、执行视图、代码视图）、CMU-SEI的Views and Beyond模型（模块视图、构件和连接子视图、分配视图）等。此外，工业界也提出了若干多视图描述SA模型的标准，如IEEE标准1471-2000（软件密集型系统体系结构描述推荐实践）、开放分布式处理参考模型（RM-ODP）、统一建模语言（UML）以及IBM公司推出的Zachman框架等。需要说明的是，现阶段的ADL大多没有显式地支持多视图，并且上述多视图并不一定只描述设计阶段的模型</p>
<h5 id="实现阶段"><a href="#实现阶段" class="headerlink" title="实现阶段"></a>实现阶段</h5><p>最初的SA研究往往只关注较高层次的系统设计、描述和验证。为了有效实现从SA设计向实现的转换，实现阶段的体系结构研究在以下几个方面。</p>
<p>（1）研究基于SA的开发过程支持，如项目组织结构、配置管理等。</p>
<p>（2）寻求从SA向实现过渡的途径，如将程序设计语言元素引入SA阶段、模型映射、构件组装、复用中间件平台等。</p>
<p>（3）研究基于SA的测试技术。</p>
<p>SA提供了待生成系统的蓝图，根据该蓝图实现系统需要较好的开发组织结构和过程管理技术。以体系结构为中心的软件项目管理方法，开发团队的组织结构应该和体系结构模型有一定的对应关系，从而提高软件开发的效率和质量。</p>
<p>对于大型软件系统而言，由于参与实现的人员较多，所以需要提供适当的配置管理手段。SA引入能够有效扩充现有配置管理的能力，通过在SA描述中引入版本、可选择项（options）等信息，可以分析和记录不同版本构件和连接子之间的演化，从而可用来组织配置管理的相关活动。典型的例子包括支持给构件指定多种实现的UniCon、支持给构件和连接子定义版本信息和可选信息的xADL等。</p>
<p>为了填补高层SA模型和底层实现之间的鸿沟，通过封装底层的实现细节，模型转换、精化等手段缩小概念之间的差距。典型的方法如下。</p>
<p>（1）在SA模型中引入实现阶段的概念，如引入程序设计语言元素等。</p>
<p>（2）通过模型转换技术，将高层的SA模型逐步精化成能够支持实现的模型。</p>
<p>（3）封装底层的实现细节，使之成为较大粒度构件，在SA指导下通过构件组装的方式实现系统，这往往需要底层中间件平台的支持。</p>
<h5 id="构件组装阶段"><a href="#构件组装阶段" class="headerlink" title="构件组装阶段"></a>构件组装阶段</h5><p>在SA设计模型的指导下，可复用构件组装可以在较高层次上实现系统，并能够提高系统实现的效率。在构件组装的过程中，SA设计模型起到了系统蓝图的作用。研究内容包括：</p>
<p>（1）如何支持可复用构件的互联，即对SA设计模型中规约的连接子的实现提供支持。</p>
<p>（2）在组装过程中，如何检测并消除体系结构失配问题。</p>
<p>对设计阶段连接子的支持：不少ADL支持在实现阶段将连接子转换到具体的程序代码或系统实现，如UniCon定义了Pipe、FileIO、ProcedureCall等多种内建的连接子类型，它们在设计阶段被实例化，并可以在实现阶段在工具的支持下转化成为具体的实现机制，如过程调用、操作系统数据访问、Unix管道和文件、远程过程调用等。支持从SA模型生成代码的体系结构描述语言，如C2 SADL、Rapide等，也都提供了一定的机制生成连接子的代码。</p>
<p>中间件遵循特定的构件标准，为构件互联提供支持，并提供相应的公共服务，如安全服务、命名服务等。中间件支持的连接子实现有如下优势：</p>
<p>（1）中间件提供了构件之间跨平台交互的能力，且遵循特定的工业标准，如CORBA、J2EE、COM等，可以有效地保证构件之间的通信完整性。</p>
<p>（2）产品化的中间件可以提供强大的公共服务能力，这样能够更好地保证最终系统的质量属性。设计阶段连接子的规约可以用于中间件的选择，如消息通信连接子最好选择提供消息通信机制的中间件平台。从某种意义上说，随着中间件技术的发展，也导致一类新的SA风格，即中间件导向的体系结构风格（middleware-induced architectural style）的出现。</p>
<p>检测并消除体系结构失配：体系结构失配问题是由David Garlan等人在1995年提出。失配是指在软件复用的过程中，由于待复用构件对最终系统的体系结构和环境的假设（assumption）与实际状况不同而导致的冲突。在构件组装阶段失配问题主要包括：</p>
<p>（1）由 $\color{green}{\text{构件}}$ 引起的失配，包括由于系统对构件基础设施、构件控制模型和构件数据模型的假设存在冲突引起的失配。</p>
<p>（2）由 $\color{green}{\text{连接子}}$ 引起的失配，包括由于系统对构件交互协议、连接子数据模型的假设存在冲突引起的失配。</p>
<p>（3）由于系统成分对全局体系结构的假设存在冲突引起的失配等。要解决失配问题，首先需要检测出失配问题，并在此基础上通过适当的手段消除检测出的失配问题。</p>
<h5 id="部署阶段"><a href="#部署阶段" class="headerlink" title="部署阶段"></a>部署阶段</h5><p>随着网络与分布式软件的发展，软件部署逐渐从软件开发过程中独立出来，成为软件生命周期中一个独立的阶段。为了使分布式软件满足一定的质量属性要求，如性能、可靠性等，部署需要考虑多方面的信息，如待部署软件构件的互联性、硬件的拓扑结构、硬件资源占用（如CPU、内存）等。SA对软件部署作用如下。</p>
<p>（1）提供高层的体系结构视图描述部署阶段的软硬件模型。</p>
<p>（2）基于SA模型可以分析部署方案的质量属性，从而选择合理的部署方案。</p>
<p>现阶段，基于SA的软件部署研究更多地集中在组织和展示部署阶段的SA、评估分析部署方案等方面，部署方案的分析往往停留在定性的层面，并需要部署人员的参与。</p>
<h5 id="后开发阶段"><a href="#后开发阶段" class="headerlink" title="后开发阶段"></a>后开发阶段</h5><p>后开发阶段是指软件部署安装之后的阶段。这一阶段的SA研究主要围绕维护、演化、复用等方面来进行。典型的研究方向包括动态软件体系结构、体系结构恢复与重建等。</p>
<h6 id="动态软件体系结构"><a href="#动态软件体系结构" class="headerlink" title="动态软件体系结构"></a>动态软件体系结构</h6><p>传统的SA研究设想体系结构总是静态的，即软件的体系结构一旦建立，就不会在运行时刻发生变动。但人们在实践中发现，现实中的软件往往具有动态性，即它们的体系结构会在运行时发生改变。SA在运行时发生的变化包括两类。一类是软件内部执行所导致的体系结构改变。比如，很多服务器端软件会在客户请求到达时创建新的构件来响应用户的需求。某个自适应的软件系统可能根据不同的配置状况采用不同的连接子来传送数据。另一类变化是软件系统外部的请求对软件进行的重配置。比如，有很多高安全性的软件系统，这些系统在升级或进行其他修改时不能停机。因为修改是在运行时刻进行的，体系结构也就动态地发生了变化。在高安全性系统之外也有很多软件需要进行动态修改，比如很多操作系统期望能够在升级时无须重新启动系统，在运行过程中就完成对体系结构的修改。</p>
<p>由于软件系统会在运行时刻发生动态变化，这就给体系结构的研究提出了很多新的问题。如何在设计阶段捕获体系结构的这种动态性，并进一步指导软件系统在运行时刻实施这些变化，从而达到系统的在线演化或自适应甚至自主计算，是动态体系结构所要研究的内容。现阶段，动态软件体系结构研究可分为以下两个部分。</p>
<p>（1）体系结构设计阶段的支持。主要包括变化的描述、根据变化如何生成修改策略、描述修改过程、在高抽象层次保证修改的可行性以及分析、推理修改所带来的影响等。</p>
<p>（2）运行时刻基础设施的支持。主要包括系统体系结构的维护、保证体系结构修改在约束范围内、提供系统的运行时刻信息、分析修改后的体系结构符合指定的属性、正确映射体系结构构造元素的变化到实现模块、保证系统的重要子系统的连续执行并保持状态、分析和测试运行系统等。</p>
<h6 id="体系结构恢复与重建"><a href="#体系结构恢复与重建" class="headerlink" title="体系结构恢复与重建"></a>体系结构恢复与重建</h6><p>当前系统的开发很少是从头开始的，大量的软件开发任务是基于已有的遗产系统进行升级、增强或移植。这些系统在开发的时候没有考虑SA，在将这些系统进行构件化包装、复用的时候，会得不到体系结构的支持。因此，从这些系统中恢复或重构体系结构是有意义的，也是必要的。</p>
<p>SA重建是指从已实现的系统中获取体系结构的过程。一般地，SA重建的输出是一组体系结构视图。现有的体系结构重建方法可以分为4类：</p>
<p>（1）手工体系结构重建。</p>
<p>（2）工具支持的手工重建。通过工具对手工重建提供辅助支持，包括获得基本体系结构单元、提供图形界面允许用户操作SA模型、支持分析SA模型等。如KLOCwork inSight工具（<a target="_blank" rel="noopener" href="http://www.klocwork.com/products/insight.asp%EF%BC%89">www.klocwork.com/products/insight.asp）</a>  使用代码分析算法直接从源代码获得SA构件视图，用户可以通过操作图形化的SA设定体系结构规则，并可在工具的支持下实现对体系结构的理解、自动控制和管理。</p>
<p>（3）通过查询语言来自动建立聚集。这类方法适用于较大规模的系统，基本思路是：在逆向工程工具的支持下分析程序源代码，然后将所得到的体系结构信息存入数据库，并通过适当的查询语言得到有效的体系结构显示。</p>
<p>（4）使用其他技术，比如数据挖掘等。</p>
<h4 id="软件架构的重要性"><a href="#软件架构的重要性" class="headerlink" title="软件架构的重要性"></a>软件架构的重要性</h4><p>软件架构设计是降低成本、改进质量、按时和按需交付产品的关键因素。</p>
<h5 id="架构设计能够满足系统的品质"><a href="#架构设计能够满足系统的品质" class="headerlink" title="架构设计能够满足系统的品质"></a>架构设计能够满足系统的品质</h5><p>系统的功能性是软件构架师通过组成体系架构的多种元素之间的交互作用来支持的。架构设计用于实现系统的品质，如性能、安全性和可维护性等。通过架构设计文档化，可以尽早的评估项目的这些品质。</p>
<h5 id="架构设计使受益人达成一致的目标"><a href="#架构设计使受益人达成一致的目标" class="headerlink" title="架构设计使受益人达成一致的目标"></a>架构设计使受益人达成一致的目标</h5><p>架构设计的过程使得不同的受益人达成一致的目标，体系架构的过程需要确保架构设计被清楚地传达与理解。一个被有效传达的体系架构使得涉众们可以辩论决议和权衡，反复讨论，最终达成共识。文档化体系架构是非常重要的，这是软件构架师的主要职责。</p>
<h5 id="架构设计能够支持计划编制过程"><a href="#架构设计能够支持计划编制过程" class="headerlink" title="架构设计能够支持计划编制过程"></a>架构设计能够支持计划编制过程</h5><p>架构设计将确定组件之间的依赖关系，直接支持项目计划和项目管理的活动，例如，细节化分，日程安排，工作分配，成本分析，风险管理和技能开发等；构架师还能协助估算项目成本，例如，体系架构决定使用第三方组件的成本，以及支持开发的所有工具的成本；构架师支持技术风险的管理，包括制定每一个风险的优先次序，以及确定一个恰当的风险缓解策略。</p>
<h5 id="架构设计对系统开发的指导性"><a href="#架构设计对系统开发的指导性" class="headerlink" title="架构设计对系统开发的指导性"></a>架构设计对系统开发的指导性</h5><p>架构设计主要目标就是确保体系架构能够为设计人员和实现人员所承担的工作提供可靠的框架。很明显，这比简单的传送一个体系架构视图要复杂的多。为了确保最终体系架构的完整性，构架师必须明确的定义体系架构，因为它确定了体系架构的重要元素，例如系统的组件，组件之间的接口以及组件之间的通信。</p>
<p>构架师同时还必须定义恰当的标准和指导方针，它们将会引导设计人员和实现人员的工作。对开发过程活动采取恰当的架构回顾和评估，能够确保体系架构的完整性。这些QA（Quality Assurance，质量保障）活动的任务是确定体系架构的标准和指导方针的有效性。</p>
<h5 id="架构设计能够有效地管理复杂性"><a href="#架构设计能够有效地管理复杂性" class="headerlink" title="架构设计能够有效地管理复杂性"></a>架构设计能够有效地管理复杂性</h5><p>如今的系统越来越复杂，这种复杂性需要我们去管理。体系架构通过构件及构件之间关系，描述了一个抽象的系统，因而提供了高层次的复杂管理的方法。同样，架构设计过程考虑组件的递归分解。这是处理一个大的问题的很好的一个方法，它可以把这个大问题分解成很多的小问题，再逐个的解决。</p>
<h5 id="架构设计为复用奠定了基础"><a href="#架构设计为复用奠定了基础" class="headerlink" title="架构设计为复用奠定了基础"></a>架构设计为复用奠定了基础</h5><p>架构设计过程可以同时支持使用和建立复用资源。复用资源可以降低一个系统的成本，并且可以改进系统的质量，这些好处已经被证明。一个体系架构的建立，能够支持大粒度的资源复用。例如，体系架构的重要组件和它们之间的接口和质量，能够支持现货供应的组件，存在的系统和封装的应用程序等的选择，从而可以用来实现这些组件。</p>
<h5 id="架构设计能够降低维护费用"><a href="#架构设计能够降低维护费用" class="headerlink" title="架构设计能够降低维护费用"></a>架构设计能够降低维护费用</h5><p>架构设计过程可以在很多方面帮助我们降低维护费用。首先最重要的是架构设计过程要确保系统的维护人员是一个主要的涉众，并且他们的需求被作为首要的任务满足。一个被恰当文档化的体系架构不应该仅仅为了减轻系统的可维护性；构架师还应该确保结合了恰当的系统维护机制，并且在建立体系架构的时候还要考虑系统的适应性和可扩充性。</p>
<h5 id="架构设计能够支持冲突分析"><a href="#架构设计能够支持冲突分析" class="headerlink" title="架构设计能够支持冲突分析"></a>架构设计能够支持冲突分析</h5><p>架构设计的一个重要的好处是它可以允许我们在采取改变之前推断它所产生的影响。一个软件构架确定了主要的组件和它们之间的交互作用，两个组件之间的依赖性以及这些组件对于需求的可追溯性。有了这个信息，例如需求的改变等可以通过组件的影响来分析。同样的，改变一个组件的影响可以在依靠它的其他组件上分析出来。</p>
<h3 id="基于架构的软件开发方法"><a href="#基于架构的软件开发方法" class="headerlink" title="基于架构的软件开发方法"></a>基于架构的软件开发方法</h3><h4 id="体系结构的设计方法概述"><a href="#体系结构的设计方法概述" class="headerlink" title="体系结构的设计方法概述"></a>体系结构的设计方法概述</h4><p>$\color{green}{\text{基于体系结构的软件设计}}$ （Architecture-Based Software Design, ABSD）方法。ABSD方法是体系结构驱动，即指构成体系结构的 $\color{green}{\text{商业}}$ 、 $\color{green}{\text{质量}}$ 和 $\color{green}{\text{功能需求}}$ 的组合驱动的。使用ABSD方法，设计活动可以从项目总体功能框架明确就开始，这意味着需求抽取和分析还没有完成（甚至远远没有完成），就开始了软件设计。设计活动的开始并不意味着需求抽取和分析活动就可以终止，而是应该与设计活动并行。特别是在不可能预先决定所有需求时，例如产品线系统或长期运行的系统，快速开始设计是至关重要的。</p>
<p>ABSD方法有 $\color{red}{\text{三个基础}}$ 。第一个基础是 $\color{green}{\text{功能的分解}}$ 。在功能分解中，ABSD方法使用已有的基于模块的内聚和耦合技术。第二个基础是通过选择 $\color{green}{\text{体系结构风格}}$ 来实现 $\color{green}{\text{质量和商业需求}}$ 。第三个基础是 $\color{green}{\text{软件模板}}$ 的使用。软件模板利用了一些软件系统的结构。</p>
<p>ABSD方法是递归的，且迭代的每一个步骤都是清晰地定义的。因此，不管设计是否完成，体系结构总是清晰的，这有助于降低体系结构设计的随意性。</p>
<h4 id="概念与术语"><a href="#概念与术语" class="headerlink" title="概念与术语"></a>概念与术语</h4><h5 id="color-green-text-设计元素"><a href="#color-green-text-设计元素" class="headerlink" title="$\color{green}{\text{设计元素}}$"></a>$\color{green}{\text{设计元素}}$</h5><p>ABSD方法是一个自顶向下，递归细化的方法，软件系统的体系结构通过该方法得到细化，直到能产生软件构件和类。</p>
<p>ABSD方法中使用的设计元素如图5-1所示。在最顶层，系统被分解为若干概念子系统和一个或若干个软件模板。在第二层，概念子系统又被分解成概念构件和一个或若干个附加软件模板。</p>
<details><summary>图5-1　ABSD方法过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829174254.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829174254.png';" /></details>

<h5 id="color-green-text-视角与视图"><a href="#color-green-text-视角与视图" class="headerlink" title="$\color{green}{\text{视角与视图}}$"></a>$\color{green}{\text{视角与视图}}$</h5><p>考虑体系结构时，重要的是从不同的视角（perspective）来检查，这促使软件设计师考虑体系结构的不同属性。例如，展示功能组织的静态视角能判断质量特性，展示并发行为的动态视角能判断系统行为特性。选择的特定视角或视图也就是逻辑视图、进程视图、实现视图和配置视图。使用逻辑视图来记录设计元素的功能和概念接口，设计元素的功能定义了它本身在系统中的角色，这些角色包括功能性能等。</p>
<h5 id="color-green-text-用例和质量场景"><a href="#color-green-text-用例和质量场景" class="headerlink" title="$\color{green}{\text{用例和质量场景}}$"></a>$\color{green}{\text{用例和质量场景}}$</h5><p>用例已经成为推测系统在一个具体设置中的行为的重要技术，用例被用在很多不同的场合， $\color{green}{\text{用例}}$ 是系统的一个给予用户一个结果值的功能点，用例用来捕获 $\color{green}{\text{功能需求}}$ 。</p>
<p>在使用用例捕获功能需求的同时，我们通过定义特定场景来捕获 $\color{green}{\text{质量需求}}$ ，并称这些场景为 $\color{green}{\text{质量场景}}$ 。这样一来，在一般的软件开发过程中，我们使用质量场景捕获变更、性能、可靠性和交互性，分别称之为变更场景、性能场景、可靠性场景和交互性场景。质量场景必须包括预期的和非预期的。例如，一个预期的性能场景是估计每年用户数量增加10％的影响，一个非预期的场景是估计每年用户数量增加100％的影响。非预期场景可能不能真正实现，但它们在决定设计的边界条件时很有用。</p>
<h4 id="基于体系结构的开发模型"><a href="#基于体系结构的开发模型" class="headerlink" title="基于体系结构的开发模型"></a>基于体系结构的开发模型</h4><p>本节讨论基于体系结构的软件开发模型。传统的软件开发过程可以划分为从概念直到实现的若干个阶段，包括问题定义、需求分析、软件设计、软件实现及软件测试等。如果采用传统的软件开发模型，软件体系结构的建立应位于需求分析之后，概要设计之前。</p>
<p>传统软件开发模型存在开发效率不高，不能很好地支持软件重用等缺点。ABSDM模型把整个基于体系结构的软件过程划分为体系结构需求、设计、文档化、复审、实现和演化等6个子过程，如图5-2所示。</p>
<details><summary>图5-2　体系结构开发模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829174339.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829174339.png';" /></details>

<h4 id="color-red-text-体系结构需求"><a href="#color-red-text-体系结构需求" class="headerlink" title="$\color{red}{\text{体系结构需求}}$"></a>$\color{red}{\text{体系结构需求}}$</h4><p>需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。体系结构需求受技术环境和体系结构设计师的经验影响。需求过程主要是获取用户需求，标识系统中所要用到的构件。体系结构需求过程如图5-3所示。如果以前有类似的系统体系结构的需求，我们可以从需求库中取出，加以利用和修改，以节省需求获取的时间，减少重复劳动，提高开发效率。</p>
<h5 id="color-green-text-需求获取"><a href="#color-green-text-需求获取" class="headerlink" title="$\color{green}{\text{需求获取}}$"></a>$\color{green}{\text{需求获取}}$</h5><p>体系结构需求一般来自三个方面，分别是系统的质量目标、系统的商业目标和系统开发人员的商业目标。软件体系结构需求获取过程主要是定义开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足业务上的功能需求。与此同时，还要获得软件质量属性，满足一些非功能需求。</p>
<h5 id="color-green-text-标识构件"><a href="#color-green-text-标识构件" class="headerlink" title="$\color{green}{\text{标识构件}}$"></a>$\color{green}{\text{标识构件}}$</h5><details><summary>图5-3　体系结构需求过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829174430.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829174430.png';" /></details>

<p>在图5-3中虚框部分属于标识构件过程，该过程为系统生成初始逻辑结构，包含大致的构件。这一过程又可分为三步来实现。</p>
<p>第一步：生成类图。生成类图的CASE工具有很多，例如Rational Rose 2000能自动生成类图。</p>
<p>第二步：对类进行分组。在生成的类图基础上，使用一些标准对类进行分组可以大大简化类图结构，使之更清晰。一般地，与其他类隔离的类形成一个组，由概括关联的类组成一个附加组，由聚合或合成关联的类也形成一个附加组。</p>
<p>第三步：把类打包成构件。把在第二步得到的类簇打包成构件，这些构件可以分组合并成更大的构件。</p>
<h5 id="color-green-text-架构需求评审"><a href="#color-green-text-架构需求评审" class="headerlink" title="$\color{green}{\text{架构需求评审}}$"></a>$\color{green}{\text{架构需求评审}}$</h5><p>组织一个由不同代表（如分析人员、客户、设计人员、测试人员）组成的小组，对体系结构需求及相关构件进行仔细的审查。审查的主要内容包括所获取的需求是否真实反映了用户的要求，类的分组是否合理，构件合并是否合理等。必要时，可以在“需求获取—标识构件—需求评审”之间进行迭代。</p>
<h4 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h4><p>体系结构需求用来激发和调整设计决策，不同的视图被用来表达与质量目标有关的信息。体系结构设计是一个迭代过程，如果要开发的系统能够从已有的系统中导出大部分，则可以使用已有系统的设计过程。软件体系设计过程如图5-4所示。</p>
<details><summary>图5-4　体系结构设计过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829174514.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829174514.png';" /></details>

<h5 id="提出软件体系结构模型"><a href="#提出软件体系结构模型" class="headerlink" title="提出软件体系结构模型"></a>提出软件体系结构模型</h5><p>在建立体系结构的初期，选择一个合适的体系结构风格是首要的。在这个风格基础上，开发人员通过体系结构模型，可以获得关于体系结构属性的理解。此时，虽然这个模型是理想化的（其中的某些部分可能错误地表示了应用的特征），但是，该模型为将来的实现和演化过程建立了目标。</p>
<h5 id="把已标识的构件映射到软件体系结构中"><a href="#把已标识的构件映射到软件体系结构中" class="headerlink" title="把已标识的构件映射到软件体系结构中"></a>把已标识的构件映射到软件体系结构中</h5><p>把在体系结构需求阶段已标识的构件映射到体系结构中，将产生一个中间结构，这个中间结构只包含那些能明确适合体系结构模型的构件。</p>
<h5 id="分析构件之间的相互作用"><a href="#分析构件之间的相互作用" class="headerlink" title="分析构件之间的相互作用"></a>分析构件之间的相互作用</h5><p>为了把所有已标识的构件集成到体系结构中，必须认真分析这些构件的相互作用和关系。</p>
<h5 id="产生软件体系结构"><a href="#产生软件体系结构" class="headerlink" title="产生软件体系结构"></a>产生软件体系结构</h5><p>一旦决定了关键的构件之间的关系和相互作用，就可以在第2阶段得到的中间结构的基础上进行精化。</p>
<h5 id="设计评审"><a href="#设计评审" class="headerlink" title="设计评审"></a>设计评审</h5><p>一旦设计了软件体系结构，必须邀请独立于系统开发的外部人员对体系结构进行评审。</p>
<h4 id="color-green-text-体系结构文档化"><a href="#color-green-text-体系结构文档化" class="headerlink" title="$\color{green}{\text{体系结构文档化}}$"></a>$\color{green}{\text{体系结构文档化}}$</h4><p>绝大多数的体系结构都是抽象的，由一些概念上的构件组成。例如，层的概念在任何程序设计语言中都不存在。因此，要让系统分析员和程序员去实现体系结构，还必须得把体系结构进行文档化。文档是在系统演化的每一个阶段，系统设计与开发人员的通信媒介，是为验证体系结构设计和提炼或修改这些设计（必要时）所执行预先分析的基础。</p>
<p>$\color{green}{\text{体系结构文档化}}$ 过程的主要输出结果是 $\color{green}{\text{体系结构规格说明}}$ 和测试体系结构需求的 $\color{green}{\text{质量设计说明书}}$ 这两个文档。生成需求模型构件的精确的形式化的描述，作为用户和开发者之间的一个协约。软件体系结构的文档要求与软件开发项目中的其他文档是类似的。文档的完整性和质量是软件体系结构成功的关键因素。文档要从 $\color{green}{\text{使用者的角度}}$ 进行编写，必须 $\color{green}{\text{分发}}$ 给所有与系统有关的开发人员，且必须保证开发者手上的文档是 $\color{green}{\text{最新}}$ 的。</p>
<ul>
<li>但不要 $\color{red}{\text{随时}}$ 保证最新的，要保持文档的稳定性（2013年真题）</li>
</ul>
<h4 id="color-red-text-体系结构复审-架构复审"><a href="#color-red-text-体系结构复审-架构复审" class="headerlink" title="$\color{red}{\text{体系结构复审(架构复审)}}$"></a>$\color{red}{\text{体系结构复审(架构复审)}}$</h4><p>从图5-2中可以看出，体系结构设计、文档化和复审是一个迭代过程。从这个方面来说，在一个主版本的软件体系结构分析之后，要安排一次由 $\color{green}{\text{外部人员}}$ （ $\color{green}{\text{用户代表和领域专家}}$ ）参加的复审。</p>
<p>鉴于体系结构文档标准化，以及风险识别的现实情况，通常我们根据架构设计，搭建一个可运行的最小化系统用于评估和测试体系架构是否满足需要。是否存在可识别的技术和协作风险。</p>
<p>复审的目的是标识潜在的风险，及早发现体系结构设计中的缺陷和错误，包括体系结构能否满足需求、质量需求是否在设计中得到体现、层次是否清晰、构件的划分是否合理、文档表达是否明确、构件的设计是否满足功能与性能的要求等。</p>
<h4 id="体系结构实现"><a href="#体系结构实现" class="headerlink" title="体系结构实现"></a>体系结构实现</h4><p>所谓“实现”就是要用实体来显示出一个软件体系结构，即要符合体系结构所描述的结构性设计决策，分割成规定的构件，按规定方式互相交互。体系结构的实现过程如图5-5所示。</p>
<details><summary>图5-5　体系结构实现过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829174639.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829174639.png';" /></details>

<p>图5-5中的虚框部分是体系结构的实现过程。整个实现过程是以复审后的文档化的体系结构说明书为基础的，每个构件必须满足软件体系结构中说明的对其他构件的责任。这些决定即实现的约束是在系统级或项目范围内给出的，每个构件上工作的实现者是看不见的。</p>
<p>在体系结构说明书中，已经定义了系统中的构件与构件之间的关系。因为在体系结构层次上，构件接口约束对外唯一地代表了构件，所以可以从构件库中查找符合接口约束的构件，必要时开发新的满足要求的构件。然后，按照设计提供的结构，通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成。</p>
<p>最后一步是测试，包括单个构件的功能性测试和被组装应用的整体功能和性能测试。</p>
<h4 id="体系结构的演化"><a href="#体系结构的演化" class="headerlink" title="体系结构的演化"></a>体系结构的演化</h4><p>在构件开发过程中，用户的需求可能还有变动。在软件开发完毕，正常运行后，由一个单位移植到另一个单位，需求也会发生变化。在这两种情况下，就必须相应地修改软件体系结构，以适应新的变化了的软件需求。体系结构演化过程如图5-6所示。</p>
<details><summary>图5-6　体系结构演化过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829174704.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829174704.png';" /></details>

<p>体系结构演化是使用系统演化步骤去修改应用，以满足新的需求。主要包括以下6个步骤。</p>
<h5 id="需求变化归类"><a href="#需求变化归类" class="headerlink" title="需求变化归类"></a>需求变化归类</h5><p>首先必须对用户需求的变化进行归类，使变化的需求与已有构件对应。对找不到对应构件的变动，也要做好标记，在后续工作中，将创建新的构件，以对应这部分变化的需求。</p>
<h5 id="制订体系结构演化计划"><a href="#制订体系结构演化计划" class="headerlink" title="制订体系结构演化计划"></a>制订体系结构演化计划</h5><p>在改变原有结构之前，开发组织必须制订一个周密的体系结构演化计划，作为后续演化开发工作的指南。</p>
<h5 id="修改、增加或删除构件"><a href="#修改、增加或删除构件" class="headerlink" title="修改、增加或删除构件"></a>修改、增加或删除构件</h5><p>在演化计划的基础上，开发人员可根据在第1步得到的需求变动的归类情况，决定是否修改或删除存在的构件、增加新构件。最后，对修改和增加的构件进行功能性测试。</p>
<h5 id="更新构件的相互作用"><a href="#更新构件的相互作用" class="headerlink" title="更新构件的相互作用"></a>更新构件的相互作用</h5><p>随着构件的增加、删除和修改，构件之间的控制流必须得到更新。</p>
<h5 id="构件组装与测试"><a href="#构件组装与测试" class="headerlink" title="构件组装与测试"></a>构件组装与测试</h5><p>通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成，形成新的体系结构。然后对组装后的系统整体功能和性能进行测试。</p>
<h5 id="技术评审"><a href="#技术评审" class="headerlink" title="技术评审"></a>技术评审</h5><p>对以上步骤进行确认，进行技术评审。评审组装后的体系结构是否反映需求变动，符合用户需求。如果不符合，则需要在第2到第6步之间进行迭代。</p>
<p>在原来系统上所作的所有修改必须集成到原来的体系结构中，完成一次演化过程。</p>
<h3 id="软件架构风格"><a href="#软件架构风格" class="headerlink" title="软件架构风格"></a>软件架构风格</h3><p>软件体系结构设计的一个核心目标是重复的体系结构模式，即达到体系结构级的软件重用。也就是说，在不同的软件系统中，使用同一体系结构。基于这个目的，主要任务是研究和实践软件体系结构的风格和类型问题。</p>
<h4 id="软件架构风格概述"><a href="#软件架构风格概述" class="headerlink" title="软件架构风格概述"></a>软件架构风格概述</h4><p>软件体系结构风格是描述某一特定应用领域中系统组织方式的惯用模式。体系结构风格定义一个系统家族，即一个 $\color{red}{\text{体系结构}}$ 定义一个 $\color{green}{\text{词汇表}}$ 和一组 $\color{green}{\text{约束}}$ 。词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。 $\color{red}{\text{体系结构风格}}$ 反映了领域中众多系统所共有的 $\color{green}{\text{结构}}$ 和 $\color{green}{\text{语义}}$ 特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。对软件体系结构风格的研究和实践促进对 $\color{green}{\text{设计}}$ 的 $\color{green}{\text{重用}}$ ，一些经过实践证实的解决方案也可以可靠地用于解决新的问题。例如，如果某人把系统描述为“客户/服务器”模式，则不必给出设计细节，我们立刻就会明白系统是如何组织和工作的。</p>
<h4 id="经典软件体系结构风格"><a href="#经典软件体系结构风格" class="headerlink" title="经典软件体系结构风格"></a>经典软件体系结构风格</h4><h5 id="管道和过滤器"><a href="#管道和过滤器" class="headerlink" title="管道和过滤器"></a>管道和过滤器</h5><p>在管道/过滤器风格的软件体系结构（见图5-7）中，每个构件都有一组输入和输出，数据输入构件，经过内部处理，然后产生数据输出。因此，这里的构件被称为过滤器，这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一过滤器的输入。</p>
<details><summary>图5-7　管道/过滤器风格的体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829174918.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829174918.png';" /></details>

<h5 id="数据抽象和面向对象组织"><a href="#数据抽象和面向对象组织" class="headerlink" title="数据抽象和面向对象组织"></a>数据抽象和面向对象组织</h5><p>抽象数据类型概念对软件系统有着重要作用，目前软件界已普遍转向使用面向对象系统。这种风格建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例（见图5-8）。</p>
<details><summary>图5-8　数据抽象和面向对象风格的体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829174959.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829174959.png';" /></details>

<h5 id="事件驱动系统"><a href="#事件驱动系统" class="headerlink" title="事件驱动系统"></a>事件驱动系统</h5><p>事件驱动系统风格是构件不直接调用一个过程，而是触发或广播一个或多个事件。系统中的其他构件中的过程在一个或多个事件中注册。当一个事件被触发，系统自动调用在这个事件中注册的所有过程，这样，一个事件的触发就导致了另一模块中的过程的调用。</p>
<h5 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h5><p>层次系统（见图5-9）组成一个层次结构，每一层为上层服务，并作为下层客户。在一些层次系统中，除了一些精心挑选的输出函数外，内部的层接口只对相邻的层可见。这样的系统中构件在层上实现了虚拟机。连接件通过决定层间如何交互的协议来定义，拓扑约束包括对相邻层间交互的约束。由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件重用提供了强大的支持。</p>
<details><summary>图5-9　层次系统风格示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829175037.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829175037.png';" /></details>

<h5 id="仓库系统及知识库"><a href="#仓库系统及知识库" class="headerlink" title="仓库系统及知识库"></a>仓库系统及知识库</h5><p>在仓库（repository）风格中，有两种不同的构件：中央数据结构说明当前状态，独立构件在中央数据存储上执行。</p>
<p>一方面，若构件控制共享数据，则仓库是一传统型数据库；另一方面，若中央数据结构的当前状态触发进程执行的选择，则仓库是一黑板系统（见图5-10）。</p>
<details><summary>图5-10　黑板系统的组成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829175101.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829175101.png';" /></details>

<h5 id="color-green-text-C2风格"><a href="#color-green-text-C2风格" class="headerlink" title=" $\color{green}{\text{C2风格}}$ "></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/G66565906/article/details/100762744"> $\color{green}{\text{C2风格}}$ </a></h5><p> $\color{green}{\text{C2体系结构风格可以概括为通过连接件绑定在一起按照一组规则运作的并行构件网络}}$ 。C2风格中的系统组织规则如下。</p>
<p>（1）系统中的构件和连接件都有一个顶部和一个底部。</p>
<p>（2）构件的顶部应连接到某连接件的底部，构件的底部则应连接到某连接件的顶部。而构件与构件之间的直接连接是不允许的。</p>
<p>（3）一个连接件可以和任意数目的其他构件和连接件连接。</p>
<p>（4）当两个连接件进行直接连接时，必须由其中一个的底部到另一个的顶部。</p>
<p>C2风格如图5-11所示。图中构件与连接件之间的连接体现了C2风格中构建系统的规则。</p>
<details><summary>图5-11　C2风格的体系结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210829175133.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210829175133.png';" /></details>

<h4 id="客户-服务器风格"><a href="#客户-服务器风格" class="headerlink" title="客户/服务器风格"></a>客户/服务器风格</h4><p>客户/服务器（C/S）计算技术在信息产业中占有重要的地位。网络计算经历了从基于宿主机的计算模型到客户/服务器计算模型的演变。在集中式计算技术时代，广泛使用的是大型机/小型机计算模型。它是通过一台物理上与宿主机相连接的非智能终端来实现宿主机上的应用程序。在多用户环境中，宿主机应用程序即负责与用户的交互，又负责对数据的管理。宿主机上的应用程序一般也分为与用户交互的前端和管理数据的后端，即数据库管理系统（DBMS）集中式的系统使用户能共享贵重的硬件设备。如磁盘机、打印机和调制解调器等。</p>
<p>C/S软件体系结构是基于资源不对等且实现共享而提出，是在20世纪90年代成熟的技术，C/S体系结构定义了工作站如何与服务器相连，实现部分数据和应用分布到多个处理机上。C/S体系结构有三个主要组成部分：数据库服务器、客户应用程序和网络，如图5-12所示。</p>
<details><summary>图5-12　C/S体系结构示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903225240.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903225240.png';" /></details>

<p>服务器负责有效地管理系统的资源，例如，数据库管理系统，其任务集中于：</p>
<p>（1）数据库安全性的要求。</p>
<p>（2）数据库访问并发性的控制。</p>
<p>（3）数据库前端的客户应用程序的全局数据完整性规则。</p>
<p>（4）数据库的备份与恢复。</p>
<p>客户应用程序的主要任务如下。</p>
<p>（1）提供用户与数据库交互的界面。</p>
<p>（2）向数据库服务器提交用户请求并接收来自数据库服务器的信息。</p>
<p>（3）利用客户应用程序对存在于客户端的数据执行应用逻辑要求。</p>
<p>C/S体系结构的优点主要在于系统的客户应用程序和服务器构件分别运行在不同的计算机上，系统中每台服务器都可以适合各构件的要求，这对于硬件和软件的变化显示出极大的适应性和灵活性，而且易于对系统进行扩充和缩小。在C/S体系结构中，系统中的功能构件充分隔离，客户应用程序的开发集中于数据的显示和分析，而数据库服务器的开发则集中于数据的管理，不必在每一个新的应用程序中都要对一个DBMS进行编码。将大应用处理任务分布到许多通过网络连接的低成本计算机上，以节约大量费用。</p>
<p>C/S体系结构具有强大的数据操作和事务处理能力，模型思想简单，易于人们理解和接受。但随着企业规模的日益扩大，软件的复杂程度不断提高，C/S体系结构逐渐暴露了以下缺点。</p>
<p>（1）开发成本较高。C/S体系结构对客户端软硬件配置要求较高，尤其是软件的不断升级，对硬件要求不断提高，增加了整个系统的成本，且客户端变得越来越臃肿。</p>
<p>（2）客户端程序设计复杂。采用C/S体系结构进行软件开发，大部分工作量放在客户端的程序设计上，客户端显得十分庞大。</p>
<p>（3）信息内容和形式单一，因为传统应用一般为事务处理，界面基本遵循数据库的字段解释，开发之初就已确定，而且不能随时截取办公信息和档案等外部信息，用户获得的只是单纯的字符和数字，既枯燥又死板。</p>
<p>（4）用户界面风格不一，使用繁杂，不利于推广使用。</p>
<p>（5）软件移植困难。采用不同开发工具或平台开发的软件一般互不兼容，不能或很难移植到其他平台上运行。</p>
<p>（6）软件维护和升级困难。采用C/S体系结构的软件要升级，开发人员必须到现场为客户机升级，每个客户机上的软件都需维护。对软件的一个小小改动（例如只改动一个变量），每一个客户端都必须更新。</p>
<h4 id="三层C-S结构风格"><a href="#三层C-S结构风格" class="headerlink" title="三层C/S结构风格"></a>三层C/S结构风格</h4><p>针对二层C/S体系结构的缺点，三层C/S体系结构应运而生。其结构如图5-13所示。在三层C/S体系结构中，增加了一个应用服务器。可以将整个应用逻辑驻留在应用服务器上，而只有表示层存在于客户机上。这种结构被称为“瘦客户机”。三层C/S体系结构是将应用功能分成表示层、功能层和数据层三个部分。</p>
<details><summary>图5-13　三层C/S结构示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903225337.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903225337.png';" /></details>

<p>1）表示层</p>
<p>表示层是应用的用户接口部分担负与应用逻辑间的对话功能。它用于用户从工作站输入的数据，并显示应用输出的数据。为使用户能直观地进行操作，一般要使用图形用户界面（Graphic User Interface, GUI），在变更用户界面时，只需改写显示控制和数据检查程序，而不影响业务逻辑。</p>
<p>2）功能层</p>
<p>功能层是应用的本体，它负责具体的业务处理逻辑，例如在制作订购合同时要计算合同金额。表示层和功能层之间的数据互交要尽可能简洁。例如，用户检索数据时，要将有关检索要求的信息一次性地传送给功能层，检索结果数据也由功能层一次性地传送给表示层。</p>
<p>3）数据层</p>
<p>数据层通常是数据库管理系统，负责管理对数据库数据的读写。数据库系统必须能迅速执行大量数据的更新和检索。</p>
<p>三层C/S的解决方案对这三层进行明确分割，不同层构件相互独立，层间的接口简洁，适合复杂事务处理。</p>
<h4 id="浏览器-服务器风格"><a href="#浏览器-服务器风格" class="headerlink" title="浏览器/服务器风格"></a>浏览器/服务器风格</h4><p>浏览器/服务器（browser/server, B/S）风格就是上述三层应用结构的一种实现方式。其具体结构为浏览器/Web服务器/数据库服务器。三层C/S的解决方案相比，客户端采用WWW浏览器，应用服务器是Web服务器。B/S体系结构主要是利用不断成熟的WWW浏览器技术，结合浏览器的多种脚本语言，用通用浏览器就实现了原来需要复杂的专用软件才能实现的强大功能，并节约了开发成本。从某种程度上来说B/S结构是种全新的软件体系结构。</p>
<p>在B/S结构中，除了数据库服务器外，应用程序以网页形式存放于Web服务器上，用户运行某个应用程序时只需在客户端上的浏览器中键入相应的网址（URL），调用Web服务器上的应用程序并对数据库进行操作完成相应的数据处理工作，最后将结果通过浏览器显示给用户。</p>
<p>基于B/S体系结构的软件，系统安装、修改和维护全在服务器端解决。用户在使用系统时，仅仅需要一个浏览器就可运行全部的模块。真正达到了“零客户端”的功能，很容易在运行时自动升级。B/S体系结构还提供了异种机、异种网、异种应用服务的联机、联网等。</p>
<p>与C/S体系结构相比，B/S体系结构也有许多不足之处，例如：</p>
<p>（1）B/S体系结构缺乏对动态页面的支持能力，没有集成有效的数据库处理功能。</p>
<p>（2）B/S体系结构的系统扩展能力差，安全性较难以控制。</p>
<p>（3）采用B/S体系结构的应用系统，在数据查询等响应速度上，要远远地低于C/S体系结构。</p>
<p>（4）BS体系结构的数据提交一般以页面为单位，数据的动态交互性不强，不利于在线事务处理（online transaction processing, OLTP）应用。</p>
<p>因此，虽然B/S结构的计算机应用系统有如此多的优越性，但由于C/S结构的成熟性且C/S结构的计算机应用系统网络负载较小，因此，应用系统常以C/S和B/S混合应用形式出现，如图5-14所示。</p>
<details><summary>图5-14　C/S与B/S混合体系结构风格</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903225423.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903225423.png';" /></details>

<p>上图描述了供电调度系统的结构，内部采用C/S风格，对外采用B/S风格，它针对不同应用和客户需要，充分利用了两种体系结构的优点。</p>
<h3 id="特定领域软件体系结构"><a href="#特定领域软件体系结构" class="headerlink" title="特定领域软件体系结构"></a>特定领域软件体系结构</h3><p>早在20世纪70年代就有人提出程序族、应用族的概念，特定领域软件体系结构的主要目的是在一组相关的应用中共享软件体系结构。</p>
<h4 id="DSSA的定义"><a href="#DSSA的定义" class="headerlink" title="DSSA的定义"></a>DSSA的定义</h4><p>简单地说，（Domain Specific Software Architecture, DSSA）就是在一个特定应用领域中为一组应用提供组织结构参考的标准软件体系结构。对DSSA研究的角度、关心的问题不同导致了对DSSA的不同定义。</p>
<p>Hayes Roth对DSSA的定义如下：“DSSA就是专用于一类特定类型的任务（领域）的、在整个领域中能有效地使用的、为成功构造应用系统限定了标准的组合结构的软件构件的集合。”</p>
<p>Tracz的定义为：“DSSA就是一个特定的问题领域中支持一组应用的 $\color{green}{\text{领域模型}}$ 、 $\color{green}{\text{参考需求}}$ 、 $\color{green}{\text{参考体系结构}}$ 等组成的开发基础，其目标就是支持在一个特定领域中多个应用的生成。”</p>
<p>通过对众多的DSSA的定义和描述的分析，可知DSSA的必备特征如下：</p>
<p>（1）一个严格定义的问题域和问题解域。</p>
<p>（2）具有普遍性。使其可以用于领域中某个特定应用的开发。</p>
<p>（3）对整个领域的构件组织模型的恰当抽象。</p>
<p>（4）具备该领域固定的、典型的在开发过程中可重用元素。</p>
<p>一般的DSSA的定义并没有对领域的确定和划分给出明确说明。从功能覆盖的范围角度有两种理解DSSA中领域的含义的方式。</p>
<p>（1）垂直域：定义了一个特定的系统族，包含整个系统族内的多个系统，结果是在该领域中可作为系统的可行解决方案的一个通用软件体系结构。</p>
<p>（2）水平域：定义了在多个系统和多个系统族中功能区城的共有部分。在子系统级上涵盖多个系统族的特定部分功能。</p>
<p>在垂直域上定义的DSSA只能应用于一个成熟的、稳定的领域，但这个条件比较难以满足：若将领域分割成较小的范围，则更相对容易，也容易得到一个一致的解决方案。</p>
<h4 id="DSSA的基本活动"><a href="#DSSA的基本活动" class="headerlink" title="DSSA的基本活动"></a>DSSA的基本活动</h4><p>实施DSSA的过程中包含了一些基本的活动。虽然具体的DSSA方法可能定义不同的概念、步骤和产品等，但这些基本活动大体上是一致的。以下将分三个阶段介绍这些活动。</p>
<h5 id="color-green-text-领域分析"><a href="#color-green-text-领域分析" class="headerlink" title="$\color{green}{\text{领域分析}}$"></a>$\color{green}{\text{领域分析}}$</h5><p>这个阶段的主要目标是获得 $\color{green}{\text{领域模型}}$ 。领域模型描述领域中系统之间的共同的需求，即领域模型所描述的需求为领域需求。在这个阶段中首先要进行一些准备性的活动，包括定义领域的边界。从而明确分析的对象；识别信息源，整个领域工程过程中信息的来源，可能的信息源包括现存系统、技术文献、问题域和系统开发的专家、用户调查和市场分析、领域演化的历史记录等，在此基础上就可以分析领域中系统的需求，确定哪些需求是领域中的系统广泛共享的，从而建立领域模型。当领域中存在大量系统时，需要选择它们的一个子集作为样本系统。对样本系统需求的考察将显示领域需求的一个变化范围。一些需求对所有被考察的系统是共同的，一些需求是单个系统所独有的。很多需求位于这两个极端之间，即被部分系统共享。</p>
<h5 id="color-green-text-领域设计"><a href="#color-green-text-领域设计" class="headerlink" title="$\color{green}{\text{领域设计}}$"></a>$\color{green}{\text{领域设计}}$</h5><p>这个阶段的目标是获得 $\color{green}{\text{DSSA(特定领域软件体系结构)}}$ 。DSSA描述在领域模型中表示的需求的解决方案，它不是单个系统的表示，而是能够适应领域中多个系统的需求的一个高层次的设计。建立了领域模型之后，就可以派生出满足这些被建模的领域需求的DSSA，由于领域模型中的领域需求具有一定的变化性，DSSA也要相应地具有变化性。它可以通过表示多选一的（alternative）、可选的（optional）解决方案等来做到这一点。模型和DSSA来组织的，因此在这个阶段通过获得DSSA，也就同时形成了重用基础设施的规约。</p>
<h5 id="color-green-text-领域实现"><a href="#color-green-text-领域实现" class="headerlink" title="$\color{green}{\text{领域实现}}$"></a>$\color{green}{\text{领域实现}}$</h5><p>这个阶段的主要目标是依据领域模型和DSSA $\color{green}{\text{开发和组织可重用信息}}$ 。这些可重用信息可能是从现有系统中提取得到，也可能需要通过新的开发得到。它们依据领域模型和DSSA进行组织，也就是领域模型和DSSA定义了这些可重用信息的重用时机，从而支持了系统化的软件重用。这个阶段也可以看作重用基础设施的实现阶段。</p>
<p>值得注意的是，以上过程是一个反复的、逐渐求精的过程。在实施领域工程的每个阶段中，都可能返回到以前的步骤，对以前的步骤得到的结果进行修改和完善，再回到当前步骤，在新的基础上进行本阶段的活动。</p>
<h4 id="参与DSSA的人员"><a href="#参与DSSA的人员" class="headerlink" title="参与DSSA的人员"></a>参与DSSA的人员</h4><p>参与DSSA的人员可以划分为 $\color{red}{\text{4种角色}}$ ： $\color{green}{\text{领域专家}}$ 、 $\color{green}{\text{领域分析师}}$ 、 $\color{green}{\text{领域设计人员}}$ 和 $\color{green}{\text{领域实现人员}}$ 。</p>
<ul>
<li>专家+DSSA分析的三个过程，各一类人员</li>
</ul>
<h5 id="领域专家"><a href="#领域专家" class="headerlink" title="领域专家"></a>领域专家</h5><p>领域专家可能包括该领域中系统的有经验的用户、从事该领域中系统的需求分析、设计、实现以及项目管理的有经验的软件工程师等。领域专家的主要任务包括提供关于领域中系统的需求规约和实现的知识，帮助组织规范的、一致的领域字典，帮助选择样本系统作为领域工程的依据，复审领域模型、DSSA等领域工程产品等。</p>
<p>领域专家应该熟悉该领域中系统的软件设计和实现、硬件限制、未来的用户需求及技术走向等。</p>
<h5 id="领域分析人员"><a href="#领域分析人员" class="headerlink" title="领域分析人员"></a>领域分析人员</h5><p>领域分析人员应由具有知识工程背景的有经验的系统分析员来担任。领域分析人员的主要任务包括控制整个领域分析过程，进行知识获取，将获取的知识组织到领域模型中，根据现有系统、标准规范等验证领域模型的准确性和一致性，维护领域模型。</p>
<p>领域分析人员应熟悉软件重用和领域分析方法；熟悉进行知识获取和知识表示所需的技术、语言和工具；应具有一定的该领域的经验，以便于分析领域中的问题及与领域专家进行交互；应具有较高的进行抽象、关联和类比的能力；应具有较高的与他人交互和合作的能力。</p>
<h5 id="领域设计人员"><a href="#领域设计人员" class="headerlink" title="领域设计人员"></a>领域设计人员</h5><p>领域设计人员应由有经验的软件设计人员来担任。领域设计人员的主要任务包括控制核个软件设计过程，根据领域模型和现有的系统开发出DSSA，对DSSA的准确性和一致性进行验证，建立领域模型和DSSA之间的联系。</p>
<p>领域设计人员应熟悉软件重用和领域设计方法；熟悉软件设计方法；应有一定的该领域的经验，以便于分析领域中的问题及与领域专家进行交互。</p>
<h5 id="领域实现人员"><a href="#领域实现人员" class="headerlink" title="领域实现人员"></a>领域实现人员</h5><p>领域实现人员应由有经验的程序设计人员来担任。领域实现人员的主要任务包括根据领域模型和DSSA，或者从头开发可重用构件，或者利用再工程的技术从现有系统中提取可重用构件，对可重用构件进行验证，建立DSSA与可重用构件间的联系。</p>
<p>领域实现人员应熟悉软件重用、领域实现及软件再工程技术；熟悉程序设计；具有一定的该领域的经验。</p>
<h4 id="DSSA的建立过程"><a href="#DSSA的建立过程" class="headerlink" title="DSSA的建立过程"></a>DSSA的建立过程</h4><p>因所在的领域不同，DSSA的创建和使用过程也各有差异，Tract曾提出了一个通用的DSSA应用过程，这些过程也需要根据所应用到的领域来进行调整。一般情况下，需要用所应用领域的应用开发者习惯使用的工具和方法来建立DSSA模型。同时Tracz强调了DSSA参考体系结构文档工作的重要性。因为新应用的开发和对现有应用的维护都要以此为基础。</p>
<p>DSSA的建立过程分为5个阶段，每个阶段可以进一步划分为一些步骤或子阶段。每个阶段包括一组需要回答的问题，一组需要的输入，一组将产生的输出和验证标准。本过程是并发的（concurrent）、递归的（recursive）、反复的（iterative）。或者可以说，它是螺旋模型（spiral）。完成本过程可能需要对每个阶段经历几遍，每次增加更多的细节。</p>
<p>（1）定义领域范围。本阶段的重点是确定什么在感兴趣的领域中以及本过程到何时结束。这个阶段的一个主要输出是领域中的应用需要满足一系列用户的需求。</p>
<p>（2）定义领域特定的元素：本阶段的目标是编译领域字典和领域术语的同义词词典。在领域工程过程的前一个阶段产生的高层块圈将被增加更多的细节，特别是识别领域中应用间的共同性和差异性。</p>
<p>（3）定义领域特定的设计和实现需求约束：本阶段的目标是描述解空间中有差别的特性。不仅要识别出约束，并且要记录约束对设计和实现决定造成的后果，还要记录对处理这些问题时产生的所有问题的讨论。</p>
<p>（4）定义领域模型和体系结构：本阶段的目标是产生一般的体系结构，并说明构成它们的模块或构件的语法和语义。</p>
<p>（5）产生，搜集可重用的产品单元：本阶段的目标是为DSSA增加构件，使它可以被用来产生问题域中的新应用。</p>
<p>DSSA的建立过程是并发的、递归的和反复进行的。该过程的目的是将用户的需要映射为基于实现限制集合的软件需求，这些需求定义了DSSA。在此之前的领域工程和领域分析过程并没有对系统的功能性需求和实现限制进行区分，而是统称为“需求”。图5-1是DSSA的一个 $\color{red}{\text{三层次系统模型}}$ 。</p>
<details><summary>图5-15　DSSA的三层次的 $\color{green}{\text{系统模型}}$ </summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903225816.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903225816.png';" /></details>


<h3 id="系统架构的评估"><a href="#系统架构的评估" class="headerlink" title="系统架构的评估"></a>系统架构的评估</h3><h4 id="系统架构评估概述"><a href="#系统架构评估概述" class="headerlink" title="系统架构评估概述"></a>系统架构评估概述</h4><p>体系结构评估可以只针对一个体系结构，也可以针一对一组体系结构。在体系结构评估过程中，评估人员所关注的是系统的质量属性，所有评估方法所普遍关注的质量属性有以下几个。</p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>性能（performance）是指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段事件内系统所能处理的事件的个数。经常用单位事件内所处理事务的数量或系统完成某个事务处理所需的时间来对性能进行定量的表示。性能测试经常要使用基准测试程序。</p>
<h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><p>可靠性（reliability）是软件系统在应用或系统错误面前，在意外或错误使用的情况下维持软件系统的功能特性的基本能力。可靠性是最重要的软件特性，通常用它衡量在规定的条件和时间内，软件完成规定功能的能力。可靠性通常用平均失效等待时间（meantime to failure, MTTF）和平均失效间隔时间（mean time between failure, MTBF）来衡量。在失效率为常数和修复时间很短的情况下，MTTF和MTBF几乎相等。可靠性可以分为两个方面。</p>
<p>（1） $\color{green}{\text{容错}}$ 。其目的是在错误发生时确保系统正确的行为，并进行内部“修复”。例如在一个分布式软件系统中失去了一个与远程构件的连接，接下来恢复了连接。在修复这样的错误之后，软件系统可以重新或重复执行进程间的操作直到错误再次发生。</p>
<p>（2） $\color{green}{\text{健壮性}}$ 。这里说的是保护应用程序不受错误使用和错误输入的影响，在遇到意外错误事件时确保应用系统处于已经定义好的状态。值得注意的是，和容错相比，健壮性并不是说在错误发生时软件可以继续运行，它只能保证软件按照某种已经定义好的方式终止执行。软件体系结构对软件系统的可靠性有巨大的影响。例如，软件体系结构通过在应用程序内部包含冗余，或集成监控构件和异常处理，来支持可靠性。</p>
<h5 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h5><p>可用性（availability）是系统能够正常运行的时间比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>安全性（security）是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。安全性是根据系统可能受到的安全威胁的类型来分类的。安全性又可划分为机密性、完整性、不可否认性及可控性等特性。其中，机密性保证信息不泄露给未授权的用户、实体或过程；完整性保证信息的完整和准确，防止信息被非法修改；可控性保证对信息的传播及内容具有控制的能力，防止为非法者所用。</p>
<h5 id="可修改性"><a href="#可修改性" class="headerlink" title="可修改性"></a>可修改性</h5><p>可修改性 $\color{red}{\text{（modifiability）是指能够快速地以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为}}$ 基准，通过考察这些变更的代价衡量可修改性。可修改性包含以下4个方面。</p>
<p>（1） $\color{green}{\text{可维护性}}$ （maintainability）。这主要体现在问题的修复上：在错误发生后“修复”软件系统。为可维护性做好准备的软件体系结构往往能做局部性的修改并能使对其他构件的负面影响最小化。</p>
<p>（2） $\color{green}{\text{可扩展性}}$ （extendibility）。这一点关注的是使用新特性来扩展软件系统，以及使用改进版本来替换构件并删除不需要或不必要的特性和构件。为了实现可扩展性，软件系统需要松散耦合的构件。其目标是实现一种体系结构，它能使开发人员在不影响构件客户的情况下替换构件。支持把新构件集成到现有的体系结构中也是必要的。</p>
<p>（3） $\color{green}{\text{结构重组}}$ （reassemble）。这一点处理的是重新组织软件系统的构件及构件间的关系，例如通过将构件移动到一个不同的子系统而改变它的位置。为了支持结构重组，软件系统需要精心设计构件之间的关系。理想情况下，它们允许开发人员在不影响实现的主体部分的情况下灵活地配置构件。</p>
<p>（4） $\color{green}{\text{可移植性}}$ （portability）。可移植性使软件系统适用于多种硬件平台、用户界面、操作系统、编程语言或编译器。为了实现可移植，需要按照硬件无关的方式组织软件系统，其他软件系统和环境被提取出。可移植性是系统能够在不同计算环境下运行的能力。这些环境可能是硬件、软件，也可能是两者的结合。在关于某个特定计算环境的所有假设都集中在一个构件中时，系统是可移植的。如果移植到新的系统需要做些更改，则可移植性就是一种特殊的可修改性。</p>
<h5 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h5><p>功能性（functionality）是系统所能完成所期望的工作的能力。一项任务的完成需要系统中许多或大多数构件的相互协作。</p>
<h5 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h5><p>可变性（changeability）是指体系结构经扩充或变更而成为新体系结构的能力。这种新体系结构应该符合预先定义的规则，在某些具体方面不同于原有的体系结构。当要将某个体系结构作为一系列相关产品（例如，软件产品线）的基础时，可变性是很重要的。</p>
<h5 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h5><p>作为系统组成部分的软件不是独立存在的，经常与其他系统或自身环境相互作用。为了支持互操作性（inter-operation），软件体系结构必须为外部可视的功能特性和数据结构提供精心设计的软件 $\color{green}{\text{入口}}$ 。程序和用其他编程语言编写的软件系统的交互作用就是互操作性的问题，这种互操作性也影响应用的软件体系结构。</p>
<h4 id="评估中重要概念"><a href="#评估中重要概念" class="headerlink" title="评估中重要概念"></a>评估中重要概念</h4><p>敏感点（sensitivity point）和权衡点（tradeoff point）。 $\color{green}{\text{敏感点}}$ 和 $\color{green}{\text{权衡点}}$ 是关键的体系结构决策。敏感点是一个或多个构件（和/或构件之间的关系）的特性。研究敏感点可使设计人员或分析员明确在搞清楚如何实现质量目标时应注意什么。权衡点是影响多个质量属性的特性，是多个质量属性的敏感点。例如，改变加密级别可能会对安全性和性能产生非常重要的影响。提高加密级别可以提高安全性，但可能要耗费更多的处理时间，影响系统性能。如果某个机密消息的处理有严格的时间延迟要求，则加密级别可能就会成为一个权衡点。</p>
<p>风险承担者（stakeholders）或者称为利益相关人。系统的体系结构涉及很多人的利益，这些人都对体系结构施加各种影响，以保证自己的目标能够实现。表5-1列出在体系结构评估中可能涉及的一些风险承担者及其所关心的问题。</p>
<details><summary>表5-1　系统架构评估中的风险</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230028.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230028.png';" /></details>

<details><summary>表5-1　系统架构评估中的风险-续表</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230102.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230102.png';" /></details>

<p>场景（scenarios）在进行体系结构评估时，一般首先要精确地得出具体的质量目标，并以之作为判定该体系结构优劣的标准。为得出这些目标而采用的机制叫做场景。场景是从风险承担者的角度对与系统的交互的简短描述。在体系结构评估中，一般采用刺激（stimulus）、环境（environment）和响应（response）三方面来对场景进行描述。</p>
<h4 id="主要评估方法"><a href="#主要评估方法" class="headerlink" title="主要评估方法"></a>主要评估方法</h4><h5 id="SAAM"><a href="#SAAM" class="headerlink" title="SAAM"></a>SAAM</h5><p>SAAM（Scenarios-based Architecture Analysis Method）是卡耐基梅隆大学软件工程研究所（SEI at CMU）的Kazman等人于1983年提出的一种非功能质量属性的体系结构分析方法，是最早形成文档并得到广泛使用的软件体系结构分析方法。最初它用于比较不同的软件体系的体系结构，以分析SA的可修改性，后来实践证明也可用于其他的质量属性如可移植性、可扩充性等，发展成了评估一个系统的体系结构。</p>
<p>（1）特定目标：SAAM的目标是对描述应用程序属性的文档，验证基本的体系结构假设和原则。此外，该分析方法有利于评估体系结构固有的风险。SAAM指导对体系结构的检查，使其主要关注潜在的问题点，如需求冲突，或仅从某一参与者的观点出发的不全面的系统设计。SAAM不仅能够评估体系结构对于特定系统需求的使用能力，也能被用来比较不同的体系结构。</p>
<p>（2）评估技术：SAAM所使用的评估技术是场景技术。场景代表了描述体系结构属性的基础，描述了各种系统必须支持的活动和将要发生的变化。</p>
<p>（3）质量属性：这一方法的基本特点是把任何形式的质量属性都具体化为场景，但可修改性是SAAM分析的主要质量属性。</p>
<p>（4）风险承担者：SAAM协调不同参与者所感兴趣的方面，作为后续决策的基础，提供了对体系结构的公共理解。</p>
<p>（5）体系结构描述：SAAM用于体系结构的最后版本，但早于详细设计。体系结构的描述形式应当被所有参与者理解。功能、结构和分配被定义为描述体系结构的三个主要方面。</p>
<p>（6）方法活动：SAAM的主要输入问题是 $\color{green}{\text{问题描述}}$ 、 $\color{green}{\text{需求声明}}$ 和 $\color{green}{\text{体系结构描述}}$ 。图5-16描绘了SAAM分析活动的相关输入及评估过程。</p>
<details><summary>图5-16　SAAM输入与评估过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230151.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230151.png';" /></details>

<p>SAAM分析评估体系结构的过程包括 $\color{red}{\text{5个步骤}}$ ，即 $\color{green}{\text{场景开发}}$ 、 $\color{green}{\text{体系结构描述}}$ 、 $\color{green}{\text{单个场景评估}}$ 、 $\color{green}{\text{场景交互}}$ 和 $\color{green}{\text{总体评估}}$ 。</p>
<p>通过各类风险承担者协商讨论，开发一些任务场景，体现系统所支持的各种活动。</p>
<p>用一种易于理解的、合乎语法规则的体系结构描述SA，体现系统的计算构件、数据构件以及构件之间的关系（数据和控制）。对场景（直接场景和间接场景）生成一个关于特定体系结构的场景描述列表。通过对场景交互的分析，能得出系统中所有场景对系统中的构件所产生影响的列表。最后，对场景和场景间的交互作一个总体的权衡和评价。</p>
<p>（7）目前知识库的可重用性：SAAM不考虑这个问题。</p>
<p>（8）方法验证：SAAM是一种成熟的方法，已被应用到众多系统中，这些系统包括空中交通管制、嵌入式音频系统、WRCS（修正控制系统）、KWIC[8]（根据上下文查找关键词系统）等。</p>
<h5 id="color-red-text-ATAM"><a href="#color-red-text-ATAM" class="headerlink" title="$\color{red}{\text{ATAM}}$"></a>$\color{red}{\text{ATAM}}$</h5><p>体系结构权衡分析方法（Architecture Tradeoff Analysis Method, ATAM）是在SAAM的基础上发展起来的，主要针对 $\color{green}{\text{性能}}$ 、 $\color{green}{\text{实用性}}$ 、 $\color{green}{\text{安全性}}$ 和 $\color{green}{\text{可修改性}}$ ，在系统开发之前，对这些质量属性进行 $\color{green}{\text{评价}}$ 和 $\color{green}{\text{折中}}$ 。</p>
<p>（1）特定目标：ATAM的目标是在考虑多个相互影响的质量属性的情况下，从原则上提供一种理解软件体系结构的能力的方法。对于特定的软件体系结构，在系统开发之前，可以使用ATAM方法确定在多个质量属性之间折中的必要性。</p>
<p>（2）质量属性：ATAM方法分析多个相互竞争的质量属性。开始时考虑的是系统的可修改性、安全性、性能和可用性。</p>
<p>（3）风险承担者：在场景、需求收集有关的活动中，ATAM方法需要所有系统相关人员的参与。</p>
<p>（4）体系结构描述：体系结构空间受到历史遗留系统、互操作性和以前失败的项目约束。在5个基本结构的基础上进行体系结构描述，这5个结构是从Kruchten的4＋1视图派生而来的。其中逻辑视图被分为功能结构和代码结构。这些结构加上它们之间适当的映射可以完整地描述一个体系结构。</p>
<p>用一组消息顺序图显示运行时的交互和场景，对体系结构描述加以注解。ATAM方法被用于体系结构设计中，或被另一组分析人员用于检查最终版本的体系结构。</p>
<p>（5）评估技术：可以把ATAM方法视为一个框架，该框架依赖于质量属性，可以使用不同的分析技术。它集成了多个优秀的单一理论模型，其中每一个都能够高效、实用地处理属性。该方法使用了场景技术。从不同的体系结构角度，有三种不同类型的场景，分别是用例（包括对系统典型的使用，还用于引出信息）、增长场景（用于涵盖与它的系统修改）、探测场景（用于涵盖那些可能会对系统造成压迫的极端修改）。</p>
<p>ATAM还使用定性的启发式分析方法（Qualitative Analysis Heuristics），在对一个质量属性构造了一个精确分析模型时要进行分析，定性的启发式分析方法就是这种分析的粗粒度版本。</p>
<p>（6）方法的活动：ATAM被分为 $\color{red}{\text{4个主要的活动领域}}$ （或阶段），分别是 $\color{green}{\text{场景和需求收集}}$ 、 $\color{green}{\text{体系结构视图和场景实现}}$ 、 $\color{green}{\text{属性模型构造和分析}}$ 、 $\color{green}{\text{折中}}$ 。图5-17描述了与每个阶段相关的步骤，还描述了体系结构设计和分析改进中可能存在的迭代。</p>
<details><summary>图5-17　ATAM分析评估过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210903230237.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210903230237.png';" /></details>


<p>属性专家独立地创建和分析他们的模型，然后交换信息（澄清和创建新的需求）。属性分析是相互依赖的，因为每个属性都会涉及其他属性。获得属性交互的方法有两种，即使用敏感度分析来发现折中点和通过检查假设。</p>
<p>在体系结构设计中，ATAM提供了迭代的改进。除了通常从场景派生而来的需求，还有很多对行为模式和执行环境的假设。由于属性之间存在着折中，每一个假设都要被检查、验证和提问，以此作为ATAM方法的结果。在完成所有这些操作之后，把分析的结果和需求进行比较；如果系统预期的行为大多接近于需求，设计者就可以继续前进，进行下一步更为详细的设计或实现。</p>
<p>（7）领域知识库的可重用性：领域知识库通过基于属性的体系结构风格（Attribute-Based Architectare Style）维护。ABAS有助于从体系结构风格的概念转向基于特定质量属性模型的推理能力。获取一组基于属性的体系结构风格的目标在于要把体系结构设计变得更为惯例化、更可预测，并得到一个基于属性的体系结构分析的标准问题集合，使设计与分析之间的联系更为紧密。</p>
<p>（8）方法验证：该方法已经应用到多个软件系统，但仍处在研究之中。虽然软件体系结构分析与评价已经取得了很大的进步，但是在某些方面也存在一些问题。例如，体系结构的描述、质量特征的分析、场景不确定性的处理、度量的应用体系结构分析和评价支持工具等，这些都影响和制约着分析评估技术的发展。Clement认为在未来的5～10年内，体系结构的分析是体系结构发展的5个方向之一。</p>
<h3 id="网课"><a href="#网课" class="headerlink" title="网课"></a>网课</h3><h4 id="软件架构的概念"><a href="#软件架构的概念" class="headerlink" title="软件架构的概念"></a>软件架构的概念</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906173009.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906173009.png';" /></details>

<p>架构把需求和设计衔接起来</p>
<h4 id="软件架构风格总概"><a href="#软件架构风格总概" class="headerlink" title="软件架构风格总概"></a>软件架构风格总概</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906173327.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906173327.png';" /></details>

<h4 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906173526.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906173526.png';" /></details>

<p>批处理：面向数据报，强调数据以一个 $\color{green}{\text{整体}}$ 来传递</p>
<p>管道过滤器：面向数据流</p>
<h4 id="调用-返回风格"><a href="#调用-返回风格" class="headerlink" title="调用/返回风格"></a>调用/返回风格</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906173833.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906173833.png';" /></details>

<h4 id="独立构件风格"><a href="#独立构件风格" class="headerlink" title="独立构件风格"></a>独立构件风格</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174034.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174034.png';" /></details>

<ul>
<li>事件驱动（又叫隐式调用风格，2013年真题），强调一个事件的触发导致了另一个中的过程调用</li>
</ul>
<h4 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174124.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174124.png';" /></details>

<h4 id="仓库风格"><a href="#仓库风格" class="headerlink" title="仓库风格"></a>仓库风格</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174147.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174147.png';" /></details>


<h4 id="CS架构"><a href="#CS架构" class="headerlink" title="CS架构"></a>CS架构</h4><h5 id="两层架构"><a href="#两层架构" class="headerlink" title="两层架构"></a>两层架构</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174309.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174309.png';" /></details>

<h5 id="三层CS"><a href="#三层CS" class="headerlink" title="三层CS"></a>三层CS</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174428.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174428.png';" /></details>


<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174441.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174441.png';" /></details>

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174504.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174504.png';" /></details>

<h4 id="BS架构"><a href="#BS架构" class="headerlink" title="BS架构"></a>BS架构</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174535.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174535.png';" /></details>


<h4 id="混合架构"><a href="#混合架构" class="headerlink" title="混合架构"></a>混合架构</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174726.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174726.png';" /></details>

<h4 id="富互联网应用"><a href="#富互联网应用" class="headerlink" title="富互联网应用"></a>富互联网应用</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906174837.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906174837.png';" /></details>


<h5 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906175000.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906175000.png';" /></details>

<h5 id="mushup"><a href="#mushup" class="headerlink" title="mushup"></a>mushup</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906175011.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906175011.png';" /></details>

<h4 id="基于服务的架构-SOA"><a href="#基于服务的架构-SOA" class="headerlink" title="基于服务的架构(SOA)"></a>基于服务的架构(SOA)</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906175153.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906175153.png';" /></details>


<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906175229.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906175229.png';" /></details>


<h4 id="SOA的实现方式-web-service"><a href="#SOA的实现方式-web-service" class="headerlink" title="SOA的实现方式:web service"></a>SOA的实现方式:web service</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906180244.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906180244.png';" /></details>

<h4 id="SOA的实现方式-ESB"><a href="#SOA的实现方式-ESB" class="headerlink" title="SOA的实现方式-ESB"></a>SOA的实现方式-ESB</h4><p>ESB：企业服务组件</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906180112.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906180112.png';" /></details>


<h4 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906225253.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906225253.png';" /></details>

<p>可靠性：用次数</p>
<p>可用性：比例</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906225426.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906225426.png';" /></details>

<p>可修改性：维护，变量名，文档</p>
<p>功能性：  </p>
<h4 id="软件架构评估方法"><a href="#软件架构评估方法" class="headerlink" title="软件架构评估方法"></a>软件架构评估方法</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906225609.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906225609.png';" /></details>

<p>问卷调查：主观性太强</p>
<p>度量:最客观</p>
<p>基于场景：输入输出+系统</p>
<p>敏感点:值改变对系统的输出影响很大</p>
<p>权衡点:影响到很多个敏感点，（安全性-&gt;性能）</p>
<p>风险点:没有明确需求</p>
<h4 id="软件架构评估方法-ATAM"><a href="#软件架构评估方法-ATAM" class="headerlink" title="软件架构评估方法(ATAM)"></a>软件架构评估方法(ATAM)</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906225958.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906225958.png';" /></details>

<h5 id="ATAM"><a href="#ATAM" class="headerlink" title="ATAM"></a>ATAM</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906230032.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906230032.png';" /></details>


<h4 id="SAAM-1"><a href="#SAAM-1" class="headerlink" title="SAAM"></a>SAAM</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906230321.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906230321.png';" /></details>

<h4 id="软件产品线技术"><a href="#软件产品线技术" class="headerlink" title="软件产品线技术"></a>软件产品线技术</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906230459.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906230459.png';" /></details>

<ul>
<li>领域工程</li>
</ul>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906230546.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906230546.png';" /></details>

<h5 id="SEI模型"><a href="#SEI模型" class="headerlink" title="SEI模型"></a>SEI模型</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906230617.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906230617.png';" /></details>

<h5 id="三生命周期模型"><a href="#三生命周期模型" class="headerlink" title="三生命周期模型"></a>三生命周期模型</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906230645.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906230645.png';" /></details>

<h5 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906230702.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906230702.png';" /></details>


<h5 id="建立方式"><a href="#建立方式" class="headerlink" title="建立方式"></a>建立方式</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906230804.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906230804.png';" /></details>



<h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231016.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231016.png';" /></details>

<h5 id="主要的中间件"><a href="#主要的中间件" class="headerlink" title="主要的中间件"></a>主要的中间件</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231047.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231047.png';" /></details>

<h5 id="Corba"><a href="#Corba" class="headerlink" title="Corba"></a>Corba</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231108.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231108.png';" /></details>

<h4 id="J2EE与NET"><a href="#J2EE与NET" class="headerlink" title="J2EE与NET"></a>J2EE与NET</h4><h5 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231224.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231224.png';" /></details>

<h5 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231340.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231340.png';" /></details>

<h5 id="J2EE与NET区别"><a href="#J2EE与NET区别" class="headerlink" title="J2EE与NET区别"></a>J2EE与NET区别</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231408.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231408.png';" /></details>

<p>.NET可以执行较差</p>
<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231441.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231441.png';" /></details>


<p>ASP可复用性的功能和不可复用的页面耦合性较高</p>
<p>像层次性架构</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231755.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231755.png';" /></details>


<h4 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210906231817.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210906231817.png';" /></details>

<p>P层可以做业务逻辑</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/index/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/index/">1</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/index/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/35/">35</a><a class="extend next" rel="next" href="/index/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">344</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
