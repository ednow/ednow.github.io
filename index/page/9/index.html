<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="ednow">
<meta property="og:url" content="http://ednow.github.io/index/page/9/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ednow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ednow.github.io/index/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">系统架构设计师教程-ch2-操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-19 11:16:59 / 修改时间：11:52:21" itemprop="dateCreated datePublished" datetime="2021-07-19T11:16:59+08:00">2021-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/19/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/19/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B-ch1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">系统架构设计师教程-ch1-计算机组成与体系结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 11:16:40" itemprop="dateCreated datePublished" datetime="2021-07-19T11:16:40+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-28 22:02:13" itemprop="dateModified" datetime="2021-08-28T22:02:13+08:00">2021-08-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/12/php/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/12/php/" class="post-title-link" itemprop="url">php</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-12 16:32:36 / 修改时间：19:33:48" itemprop="dateCreated datePublished" datetime="2021-07-12T16:32:36+08:00">2021-07-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>用别人的软件遇到了bug，这个软件是用php写的，</p>
<h2 id="发现问题所在"><a href="#发现问题所在" class="headerlink" title="发现问题所在"></a>发现问题所在</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/1626079095.jpg&quot; title=&quot;image.jpg&quot; alt=&quot;image.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/1624878909(1).jpg&quot; alt=&quot;Image not found&quot; onerror=&quot;this.onerror=null;this.src=&#x27;https://image.haiqingd.top/githubio/1624878909(1).jpg&#x27;;&quot; /&gt;&#x27; | clip</span><br></pre></td></tr></table></figure>
<p>原因是因为我custom link的时候格式有误<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210712165724.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210712165724.png';" /></p>
<p>在cmd中执行该命令，时遇到的同样的bug</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210712165936.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210712165936.png';" /></p>
<h2 id="尝试解决问题"><a href="#尝试解决问题" class="headerlink" title="尝试解决问题"></a>尝试解决问题</h2><ul>
<li>找到自定义链接配置所在的位置<code>PicUploader\config\.settings</code></li>
<li>出问题的代码：执行shell命令的地方<code>uploader/Common.php</code>，第446行</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>直接echo原字符<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/42801769/batch-auto-escape-special-characters">参考文献</a></p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html">执行shell命令的漏洞</a></p>
<h2 id="phpstorm"><a href="#phpstorm" class="headerlink" title="phpstorm"></a>phpstorm</h2><h2 id="开启调试"><a href="#开启调试" class="headerlink" title="开启调试"></a>开启调试</h2><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210712163413.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210712163413.png';" /></p>
<p>用phpstorm 调试的时候报下面这个错</p>
<blockquote>
<p>Connection was not established.Debug extension is not installed</p>
</blockquote>
<p>原因是没有装调试的插件</p>
<h3 id="装调试插件"><a href="#装调试插件" class="headerlink" title="装调试插件"></a>装调试插件</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41991476/article/details/102893931">参考文献</a></p>
<h4 id="xdebug"><a href="#xdebug" class="headerlink" title="xdebug"></a>xdebug</h4><p><a target="_blank" rel="noopener" href="https://www.php.cn/php-weizijiaocheng-387522.html">参考文献</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/08/notes-for-introduction-to-algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/08/notes-for-introduction-to-algorithms/" class="post-title-link" itemprop="url">notes-for-introduction-to-algorithms</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-08 15:30:54 / 修改时间：15:44:10" itemprop="dateCreated datePublished" datetime="2021-07-08T15:30:54+08:00">2021-07-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Foundations"><a href="#Foundations" class="headerlink" title="Foundations"></a>Foundations</h1><h2 id="The-Role-of-Algorithms-in-Computing"><a href="#The-Role-of-Algorithms-in-Computing" class="headerlink" title="The Role of Algorithms in Computing"></a>The Role of Algorithms in Computing</h2><h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><h3 id="Algorithms-as-a-technology"><a href="#Algorithms-as-a-technology" class="headerlink" title="Algorithms as a technology"></a>Algorithms as a technology</h3><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="Insertion-sort"><a href="#Insertion-sort" class="headerlink" title="Insertion sort"></a>Insertion sort</h3><h3 id="Analyzing-algorithms"><a href="#Analyzing-algorithms" class="headerlink" title="Analyzing algorithms"></a>Analyzing algorithms</h3><blockquote>
<p>Before we can analyze an algorithm, we must have a $\color{red}{\text{model}}$ of the implementation technology that we will use, including a model for the resources of that technology and their costs.<br>The running $\color{green}{\text{time}}$ of an algorithm on a particular input is the number of $\color{green}{\text{primitive operations}}$ or $\color{green}{\text{“steps”}}$ executed<br>A $\color{green}{\text{constant}}$ amount of time is required to execute $\color{green}{\text{each line}}$ of our pseudocode.</p>
</blockquote>
<h3 id="Designing-algorithms"><a href="#Designing-algorithms" class="headerlink" title="Designing algorithms"></a>Designing algorithms</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/youtube/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/youtube/" class="post-title-link" itemprop="url">youtube</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 21:33:30" itemprop="dateCreated datePublished" datetime="2021-06-30T21:33:30+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-23 18:40:47" itemprop="dateModified" datetime="2021-10-23T18:40:47+08:00">2021-10-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="youtube循环播放视频"><a href="#youtube循环播放视频" class="headerlink" title="youtube循环播放视频"></a>youtube循环播放视频</h1><p><a target="_blank" rel="noopener" href="https://www.wikihow.com/Loop-YouTube-Videos">参考文献</a></p>
<h1 id="youtube-dl"><a href="#youtube-dl" class="headerlink" title="youtube-dl"></a>youtube-dl</h1><h2 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a><a target="_blank" rel="noopener" href="https://github.com/ytdl-org/youtube-dl">github仓库</a></h2><h2 id="下载某一个playlist"><a href="#下载某一个playlist" class="headerlink" title="下载某一个playlist"></a>下载某一个playlist</h2><p><code>youtube-dl -i PLwJ2VKmefmxpUJEGB1ff6yUZ5Zd7Gegn2</code></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48422377/youtube-downloading-a-playlist-youtube-dl">参考文献</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E4%B9%A0%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E4%B9%A0%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">习题-计算机组成原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 10:42:30" itemprop="dateCreated datePublished" datetime="2021-06-30T10:42:30+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-04 00:40:50" itemprop="dateModified" datetime="2021-10-04T00:40:50+08:00">2021-10-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="凑数"><a href="#凑数" class="headerlink" title="凑数"></a>凑数</h1><h2 id="凑数-1"><a href="#凑数-1" class="headerlink" title="凑数"></a>凑数</h2><h3 id="凑数-2"><a href="#凑数-2" class="headerlink" title="凑数"></a>凑数</h3><h4 id="凑数-3"><a href="#凑数-3" class="headerlink" title="凑数"></a>凑数</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/30/%E4%B9%A0%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch7-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch7-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch7-输入/输出系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 10:00:37" itemprop="dateCreated datePublished" datetime="2021-06-30T10:00:37+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-03 18:57:36" itemprop="dateModified" datetime="2021-10-03T18:57:36+08:00">2021-10-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入/输出系统"></a>输入/输出系统</h2><p>【考纲内容】<br>（一）1O系统基本概念</p>
<p>（二）外部设备</p>
<p>输入设备:键盘、鼠标</p>
<p>输出设备:显示器、打印机</p>
<p>外存储器:硬盘存储器、磁盘阵列</p>
<p>（三）I/O接口（I/O控制器）</p>
<p>I/O接口的功能和基本结构;I/O端口及其编址</p>
<p>（四）I/O方式</p>
<p>程序查询方式</p>
<p>程序中断方式</p>
<p>中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念</p>
<p>DMA方式</p>
<p>DMA控制器的组成，DMA传送过程</p>
<p>【复习提示】<br>I/O方式是本章的重点和难点，每年不仅会以选择题的形式考查基本概念和原理，而且可能会以综合题的形式考查，特别是各种I/O方式效率的相关计算，中断方式的各种原理、特点、处理过程、中断屏蔽，DMA方式的特点、传输过程、与中断方式的区别等。</p>
<p>在学习本章时，请读者思考以下问题:</p>
<p>1）I/O设备有哪些编址方式?各有何特点?</p>
<p>2）CPU响应中断应具备哪些条件?</p>
<p>请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。</p>
<h3 id="I-O系统基本概念"><a href="#I-O系统基本概念" class="headerlink" title="I/O系统基本概念"></a>I/O系统基本概念</h3><h4 id="输入-输出系统-1"><a href="#输入-输出系统-1" class="headerlink" title="输入/输出系统"></a>输入/输出系统</h4><p>输入/输出是以主机为中心而言的，将信息从外部设备传送到主机称为输入，反之称为输出。输入/输出系统解决的主要问题是对各种形式的信息进行输入和输出的控制。</p>
<p>I/O 系统中的几个基本概念如下:</p>
<p>1） $\color{green}{\text{外部设备}}$ 。包括输入/输出设备及通过输入/输出接口才能访问的外存储设备。</p>
<p>2） $\color{green}{\text{接口}}$ 。在各个外设与主机之间传输数据时进行各种协调工作的逻辑部件。协调包括传输过程中速度的匹配、电平和格式转换等。</p>
<p>3） $\color{green}{\text{输入设备}}$ 。用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。</p>
<p>4） $\color{green}{\text{输出设备}}$ 。用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。</p>
<p>5） $\color{green}{\text{外存设备}}$ 。指除计算机内存及CPU 缓存等外的存储器。硬磁盘、光盘等是最基本的外存设备。</p>
<p>一般来说，I/O系统由I/O软件和I/O硬件两部分构成:</p>
<p>1）I/O  $\color{green}{\text{软件}}$ 。包括驱动程序、用户程序、管理程序、升级补丁等。通常采用I/O 指令和通道指令实现CPU与I/O设备的信息交换。</p>
<p>2）I/O  $\color{green}{\text{硬件}}$ 。包括外部设备、设备控制器和接口、I/O总线等。通过设备控制器来控制I/O设备的具体动作;通过I/O接口与主机（总线）相连。</p>
<h4 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h4><p>在输入/输出系统中，经常需要进行大量的数据传输，而传输过程中有各种不同的I/O 控制方式，基本的控制方式主要有以下4种:</p>
<p>1） $\color{green}{\text{程序查询方式}}$ 。由CPU通过程序不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息。</p>
<p>2） $\color{green}{\text{程序中断方式}}$ 。只在I/O设备准备就绪并向CPU发出中断请求时才予以响应。</p>
<p>3） $\color{green}{\text{DMA方式}}$ 。主存和I/O设备之间有一条直接数据通路，当主存和I/O设备交换信息时，无须调用中断服务程序。</p>
<p>4） $\color{green}{\text{通道方式}}$ 。在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I/O命令时，只需启动有关通道，通道将执行通道程序，从而完成I/O操作。</p>
<p>其中，方式1）和方式2）主要用于数据传输率较低的外部设备，方式3）和方式4）主要用于数据传输率较高的设备。</p>
<h3 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h3><p>外部设备也称外围设备，是除主机外的能直接或间接与计算机交换信息的装置。最基本的外部设备主要有键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器等。</p>
<h4 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h4><h5 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h5><p>键盘是最常用的输入设备，通过它可发出命令或输入数据。</p>
<p>键盘通常以矩阵的形式排列按键，每个键用符号标明其含义和作用。每个键相当于一个开关，按下键时，电信号连通;松开键时，弹簧弹起键，电信号断开。</p>
<p>键盘输入信息可分为3个步骤:①查出按下的是哪个键;②将该键翻译成能被主机接收的编码，如ASCII码;③将编码传送给主机。</p>
<h5 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h5><p>鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系。常用的鼠标有 $\color{green}{\text{机械式}}$ 和 $\color{green}{\text{光电式}}$ 两种。</p>
<p>工作原理:鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动。</p>
<h4 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h4><h5 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h5><p>显示设备种类繁多，按显示设备所用的显示器件分类，有阴极射线管（CRT）显示器、液晶显示器（LCD）、发光二极管（LED）显示器等。按所显示的信息内容分类，有字符显示器、图形显示器和图像显示器3大类。显示器属于用点阵方式运行的设备，有以下主要参数。</p>
<p>$\color{green}{\text{屏幕大小}}$ :以对角线长度表示，常用的有12～29英寸等。</p>
<p>$\color{green}{\text{分辨率}}$ :所能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素数的乘积表示，如800×600、1024×768和1280×1024等。</p>
<p>$\color{green}{\text{灰度级}}$ :灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚、逼真，典型的有8位（256级）、16位等。</p>
<p>$\color{green}{\text{刷新}}$ :光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。</p>
<p>$\color{green}{\text{刷新频率}}$ :指单位时间内扫描整个屏幕内容的次数。按照人的视觉生理，刷新频率大于30Hz时才不会感到闪烁，通常显示器的刷新频率为60～120Hz。</p>
<p>$\color{green}{\text{显示存储器}}$ （VRAM）:也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</p>
<p>$$<br>\text{VRAM容量} = \text{分辨率} \times \text{灰度级位数}<br>$$</p>
<p>$$<br>\text{VRAM容量} = \text{分辨率} \times \text{灰度级位数}<br>$$</p>
<p>（1）阴极射线管（CRT）显示器</p>
<p>CRT 显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极、荧光粉涂层和玻璃外壳5部分组成，具有可视角度大、无坏点、色彩还原度高、色度均匀、可调节的多分辨率模式、响应时间极短等目前LCD难以超过的优点。</p>
<p>按显示信息内容不同，可分为字符显示器、图形显示器和图像显示器;按扫描方式不同，可分为光栅扫描和随机扫描两种显示器。下面简要介绍字符显示器和图形显示器。</p>
<p>${\textstyle\unicode{x2460}}$ 字符显示器。显示字符的方法以点阵为基础。点阵是指由m×n个点组成的阵列。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数，它包括字符显示点阵和字符间隔。</p>
<p>将点阵存入由ROM构成的字符发生器中，在CRT进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中О和1代码的不同控制扫描电子束的开或关，从而在屏幕上显示字符。对应于每个字符窗口，所需显示字符的ASCII 代码被存放在视频存储器VRAM中，以备刷新。</p>
<p>${\textstyle\unicode{x2461}}$ 图形显示器。将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中，缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接控制电子束在屏幕上的移动。为在屏幕上保留持久稳定的图像，需按一定的频率对屏幕反复刷新。这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器采用这种随机扫描方式。缺点是当显示复杂图形时，会有闪烁感。</p>
<p>（2）液晶显示器（LCD）</p>
<p>原理:利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再间接控制液晶分子的光学特性来实现图像的显示。</p>
<p>特点:体积小、重量轻、省电、无辐射、绿色环保、画面柔和、不伤眼等。</p>
<p>（3）LED（发光二极管）显示器</p>
<p>原理:通过控制半导体发光二极管来显示文字、图形、图像等各种信息。</p>
<p>LCD与LED是两种不同的显示技术。LCD是由液态晶体组成的显示屏，而LED 则是由发光二极管组成的显示屏。与LCD相比，LED 显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势。</p>
<h5 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h5><p>打印机是计算机的输出设备之一，用于将计算机的处理结果打印在相关介质上。</p>
<p>按工作原理，打印机分为击打式和非击打式两大类;按工作方式，打印机分为点阵打印机、针式打印机、喷墨式打印机、激光打印机等。</p>
<p>（1）针式打印机</p>
<p>原理:在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需的内容。</p>
<p>特点:针式打印机擅长“多层复写打印”，实现各种票据或蜡纸等的打印。其工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。</p>
<p>（2）喷墨式打印机</p>
<p>原理:带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射3种颜色的墨滴，按一定的比例混合出所要求的颜色。</p>
<p>特点:打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快;但防水性差，高质量打印需要专用打印纸。</p>
<p>（3）激光打印机</p>
<p>原理:计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转印和定影，在纸上得到所需的字符或图像。</p>
<p>特点:打印质量高、速度快、噪声小、处理能力强;但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。</p>
<p>激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓（也称硒鼓）是激光打印机的核心部件。</p>
<h4 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a>外存储器</h4><p>计算机的外存储器又称辅助存储器，目前主要使用磁表面存储器。</p>
<p>所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。</p>
<p>磁表面存储器的优点:①存储容量大，位价格低;②记录介质可重复使用;记录信息可长期保存而不丢失，甚至可脱机存档;④非破坏性读出，读出时不需要再生。缺点:存取速度慢，机械结构复杂，对工作环境要求较高。</p>
<p>（1）磁盘设备的组成</p>
<p>${\textstyle\unicode{x2460}}$  存储区域。一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划分为若干扇区，扇区（也称块）是磁盘读写的最小单位，即磁盘按块存取。</p>
<ul>
<li> $\color{green}{\text{磁头数}}$ （Heads）:即记录 $\color{green}{\text{面数}}$ ，表示硬盘共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。</li>
<li> $\color{green}{\text{柱面数}}$ （Cylinders）:表示硬盘每面盘片上有多少条 $\color{green}{\text{磁道}}$ 。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面。</li>
<li> $\color{green}{\text{扇区数}}$ （Sectors）:表示每条磁道上有多少个 $\color{green}{\text{扇区}}$ 。</li>
</ul>
<p>${\textstyle\unicode{x2461}}$ 硬盘存储器的组成。 $\color{red}{\text{硬盘存储器}}$ 由 $\color{green}{\text{磁盘驱动器}}$ 、 $\color{green}{\text{磁盘控制器}}$ 和 $\color{green}{\text{盘片}}$ 组成。</p>
<ul>
<li>磁盘 $\color{green}{\text{驱动器}}$ 。核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动磁头固定盘片的硬盘存储器。</li>
<li>磁盘 $\color{green}{\text{控制器}}$ 。硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA等。</li>
</ul>
<p>（2）磁记录原理</p>
<p>原理:磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作。</p>
<p>编码方法:按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠地实现转换。</p>
<p>磁记录方式:通常采用 $\color{green}{\text{调频制}}$ （FM）和 $\color{green}{\text{改进型调频制}}$ （MFM）的记录方式。</p>
<p>（3）磁盘的性能指标</p>
<p>① $\color{red}{\text{磁盘的容量}}$ 。磁盘容量有 $\color{green}{\text{非格式化}}$ 容量和 $\color{green}{\text{格式化}}$ 容量之分。非格式化容量是指磁记录表面可利用的磁化单元总数，它由道密度和位密度计算而来;格式化容量是指按照某种特定的记录格式所能存储信息的总量。格式化后的容量比非格式化容量要小。</p>
<p>${\textstyle\unicode{x2461}}$   $\color{red}{\text{记录密度}}$ 。记录密度是指盘片单位面积上记录的二进制信息量，通常以 $\color{green}{\text{道密度}}$ 、 $\color{green}{\text{位密度}}$ 和 $\color{green}{\text{面密度}}$ 表示。道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数，面密度是位密度和道密度的乘积。</p>
<p>${\textstyle\unicode{x2462}}$  $\color{red}{\text{平均存取时间}}$ 。 $\color{green}{\text{平均存取时间由寻道时间}}$ （磁头移动到目的磁道的时间）、 $\color{green}{\text{旋转延迟时间}}$ （磁头定位到要读写扇区的时间，取旋转一周时间的一半）和 $\color{green}{\text{传输时间}}$ （传输数据所花费的时间）三部分构成。由于寻道和找扇区的距离远近不一，因此前两部分通常取平均值。</p>
<p>④ $\color{red}{\text{数据传输率}}$ 。磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。假设磁盘转数为r转/秒，每条磁道容量为N字节，则数据传输率为</p>
<p>$$<br>D_r=rN<br>$$</p>
<p>（4）磁盘地址</p>
<p>主机向磁盘控制器发送寻址信息，磁盘的地址一般如图7.1所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716194212.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716194212.png';" /></details>

<p>若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码，其格式如图7.2所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716194259.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716194259.png';" /></details>

<p>（5）硬盘的工作过程</p>
<p>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。</p>
<p>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p>
<h5 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h5><p>RAID（廉价冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</p>
<p>RAID 的分级如下所示。在 RAID1~RAID5几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。</p>
<ul>
<li>RAID0:无冗余和无校验的磁盘阵列。</li>
<li>RAID1:镜像磁盘阵列。</li>
<li>RAID2:采用纠错的海明码的磁盘阵列。 </li>
<li>RAID3:位交叉奇偶校验的磁盘阵列</li>
<li>RAID4:块交叉奇偶校验的磁盘阵列。·</li>
<li>RAID5:无独立校验的奇偶校验磁盘阵列。</li>
</ul>
<p>RAID0把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但RAID0没有容错能力。</p>
<p>为了提高可靠性，RAID1使两个磁盘同时进行读写，互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。</p>
<p>总之，RAID通过同时使用多个磁盘，提高了传输率;通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量;通过镜像功能，提高安全可靠性;通过数据校验，提供容错能力。</p>
<h5 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="*光盘存储器"></a>*光盘存储器</h5><p>光盘存储器是利用光学原理读/写信息的存储装置，它采用聚焦激光束对盘式介质以非接触方式记录信息。</p>
<p>完整的光盘存储系统由光盘片、光盘驱动器、光盘控制器和光盘驱动软件组成。光盘片由透明的聚合物基片、铝合金反射层、漆膜保护层的固盘构成。</p>
<p>特点:具有存储密度高、携带方便、成本低、容量大、存储期限长和容易保存等优点。光盘的类型如下:</p>
<p>光盘的类型如下:</p>
<ul>
<li>CD-ROM:只读型光盘，只能读出其中的内容，不能写入或修改。</li>
<li>CD-R:只可写入一次信息，之后不可修改。</li>
<li>CD-RW:可读可写光盘，可以重复读写。</li>
<li>DVD-ROM:高容量的CD-ROM，DVD表示通用数字化多功能光盘。</li>
</ul>
<h5 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h5><p>微小型高档笔记本计算机采用高性能Flash Memory作为硬盘来记录数据，这种“硬盘”称固态硬盘。固态硬盘除需要Flash Memory外，还需要其他硬件和软件的支持。</p>
<h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h3><p>I/O接口（I/O控制器）是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。主机和外设具有各自的工作特点，它们在信息形式和工作速度上具有很大的差异，接口正是为了解决这些差异而设置的。</p>
<h4 id="I-O接口的功能"><a href="#I-O接口的功能" class="headerlink" title="I/O接口的功能"></a>I/O接口的功能</h4><p>I/O接口的主要功能如下:</p>
<p>1）实现主机和外设的 $\color{green}{\text{通信联络控制}}$ 。解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。</p>
<p>2）进行 $\color{green}{\text{地址译码}}$ 和 $\color{green}{\text{设备选择}}$ 。CPU送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息。</p>
<p>3）实现 $\color{green}{\text{数据缓冲}}$ 。CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。</p>
<p>4）信号 $\color{green}{\text{格式的转换}}$ 。外设与主机两者的电平、数据格式都可能存在差异，接口应提供计算机与外设的信号格式的转换功能，如电平转换、并/串或串/并转换、模/数或数/模转换等。</p>
<p>5）传送 $\color{green}{\text{控制命令}}$ 和 $\color{green}{\text{状态信息}}$ 。CPU要启动某一外设时，通过接口中的命令寄存器向外设发出启动命令;外设准备就绪时，则将“准备好”状态信息送回接口中的状态寄存器，并反馈给CPU。外设向CPU提出中断请求时，CPU也应有相应的响应信号反馈给外设。</p>
<h4 id="I-O接口的基本结构"><a href="#I-O接口的基本结构" class="headerlink" title="I/O接口的基本结构"></a>I/O接口的基本结构</h4><p>如图7.3所示，I/O接口在主机侧通过I/O总线与内存、CPU相连。通过 $\color{green}{\text{数据总线}}$ ，在 $\color{green}{\text{数据缓冲寄存器}}$ 与内存或CPU的寄存器之间进行数据传送。同时接口和设备的状态信息被记录在 $\color{green}{\text{状态寄存器}}$ 中，通过数据线将状态信息送到CPU。CPU对外设的控制命令也通过数据线传送，一般将其送到I/O接口的控制寄存器。状态寄存器和控制寄存器在传送方向上是相反的。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716195002.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716195002.png';" /></details>

<p>接口中的地址线用于给出要访问的I/O接口中的寄存器的地址，它和读/写控制信号一起被送到I/O接口的控制逻辑部件，其中地址信息用以选择和主机交换信息的寄存器，通过控制线传送来的读/写信号确认是读寄存器还是写寄存器，此外控制线还会传送一些仲裁信号和握手信号。</p>
<p>接口中的I/O控制逻辑还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。另外，它还要具有收集外设状态到状态寄存器的功能。</p>
<p>对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为I/O指令，I/O指令只能在操作系统内核的底层I/O软件中使用，它们是一种 $\color{green}{\text{特权指令}}$ 。</p>
<blockquote>
<p>注意:接口和端口是两个不同的概念。端口是指接口电路中可以进行读/写的寄存器，若干端口加上相应的控制逻辑才可以组成接口。</p>
</blockquote>
<h4 id="I-O接口的类型"><a href="#I-O接口的类型" class="headerlink" title="I/O接口的类型"></a>I/O接口的类型</h4><p>从不同的角度看，I/O接口可以分为不同的类型。</p>
<p>1）按数据传送方式可分为 $\color{green}{\text{并行接口}}$ （一字节或一个字的所有位同时传送）和 $\color{green}{\text{串行接口}}$ （一位一位地传送），接口要完成数据格式的转换。</p>
<blockquote>
<p>注意:这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，数据总是并行传送的。</p>
</blockquote>
<p>2）按主机访问I/O设备的控制方式可分为 $\color{green}{\text{程序查询接口}}$ 、 $\color{green}{\text{中断接口}}$ 和 $\color{green}{\text{DMA接口}}$ 等。</p>
<p>3）按功能选择的灵活性可分为 $\color{green}{\text{可编程接口}}$ 和 $\color{green}{\text{不可编程接口}}$ 。</p>
<h4 id="I-O端口及其编址"><a href="#I-O端口及其编址" class="headerlink" title="I/O端口及其编址"></a>I/O端口及其编址</h4><p>I/O端口是指接口电路中可被CPU直接访问的寄存器，主要有 $\color{green}{\text{数据端口}}$ 、 $\color{green}{\text{状态端口}}$ 和 $\color{green}{\text{控制端口}}$ ，若干端口加上相应的控制逻辑电路组成接口。通常，CPU能对数据端口执行读写操作，但对状态端口只能执行读操作，对控制端口只能执行写操作。</p>
<p>I/O端口要想能够被CPU访问，就必须要对各个端口进行编号，每个端口对应一个端口地址。而对I/O端口的编址方式有与存储器统一编址和独立编址两种。</p>
<p>1） $\color{green}{\text{统一编址}}$ ，又称存储器映射方式，是指把I/O端口当作存储器的单元进行地址分配，这种方式CPU不需要设置专门的I/O指令，用统一的 $\color{green}{\text{访存指令}}$ 就可以访问I/O端口。优点:不需要专门的输入/输出指令，可使CPU访问UO 的操作更灵活、更方便，还可使端口有较大的编址空间。缺点:端口占用存储器地址，使内存容量变小，而且利用存储器编址的VO设备进行数据输入/输出操作，执行速度较慢。</p>
<p>2） $\color{green}{\text{独立编址}}$ ，又称I/O映射方式，I/O端口的地址空间与主存地址空间是两个独立的地址空间，因而无法从地址码的形式上区分，需要设置专门的 $\color{green}{\text{I/O指令}}$ 来访问I/O端口。优点:输入/输出指令与存储器指令有明显区别，程序编制清晰，便于理解。缺点:输入/输出指令少，一般只能对端口进行传送操作，尤其需要CPU提供存储器读/写、I/O设备读/写两组控制信号，增加了控制的复杂性。</p>
<h3 id="I-O-方式"><a href="#I-O-方式" class="headerlink" title="I/O 方式"></a>I/O 方式</h3><p>输入/输出系统实现主机与I/O设备之间的数据传送，可以采用不同的控制方式，各种方式在代价、性能、解决问题的着重点等方面各不相同，常用的I/O方式有 $\color{green}{\text{程序查询}}$ 、 $\color{green}{\text{程序中断}}$ 、 $\color{green}{\text{DMA}}$ 和 $\color{green}{\text{通道}}$ 等，其中前两种方式更依赖于CPU中程序指令的执行。</p>
<h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。主机进行I/O操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。</p>
<p>程序查询方式的工作流程如下（见图7.4）</p>
<p>${\textstyle\unicode{x2460}}$  CPU执行初始化程序，并预置传送参数。</p>
<p>②向I/O接口发出命令字，启动I/O设备。</p>
<p>${\textstyle\unicode{x2462}}$ 从外设接口读取其状态信息。</p>
<p>${\textstyle\unicode{x2463}}$ CPU 不断查询I/O设备状态，直到外设准备就绪。</p>
<p>${\textstyle\unicode{x2464}}$ 传送一次数据。</p>
<p>⑥修改地址和计数器参数。</p>
<p>${\textstyle\unicode{x2466}}$ 判断传送是否结束，若未结束转第 ${\textstyle\unicode{x2462}}$  步，直到计数器为0。</p>
<details style="width:250px"><summary>图7.4 程序查询方式流程图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716195423.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716195423.png';"/></details>

<p>在这种控制方式下，CPU一旦启动I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序。程序查询方式的主要特点是CPU有“踏步”等待现象，CPU与I/O串行工作。这种方式的接口设计简单、设备量少，但CPU 在信息传送过程中要花费很多时间来查询和等待，而且在 $\color{green}{\text{一段时间}}$ 内只能和 $\color{green}{\text{一台}}$ 外设交换信息，效率大大降低。</p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p>现代计算机系统中都配有完善的异常和中断处理系统，CPU的数据通路中有相应的异常和中断的检测和响应逻辑，在外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序。这些中断硬件线路和中断服务程序有机结合，共同完成异常和中断的处理过程。</p>
<h5 id="异常和中断"><a href="#异常和中断" class="headerlink" title="异常和中断"></a>异常和中断</h5><p>（1）异常</p>
<p>异常是指由 $\color{green}{\text{CPU内部}}$ 异常引起的意外事件，分为 $\color{green}{\text{硬故障中断}}$ 和 $\color{green}{\text{程序性异常}}$ 。 $\color{red}{\text{硬故障中断}}$ 是由硬连线出现异常引起的，如 $\color{green}{\text{电源掉电}}$ 、 $\color{green}{\text{存储器线路错}}$ 等。 $\color{red}{\text{程序性异常}}$ 也称 $\color{red}{\text{软中断}}$ ，是指在CPU内部因执行指令而引起的异常事件。如 $\color{green}{\text{整除0}}$ 、 $\color{green}{\text{溢出}}$ 、 $\color{green}{\text{断点}}$ 、 $\color{green}{\text{单步跟踪}}$ 、 $\color{green}{\text{非法指令}}$ 、 $\color{green}{\text{栈溢出}}$ 、 $\color{green}{\text{地址越界}}$ 、 $\color{green}{\text{缺页}}$ 、分时系统中的 $\color{green}{\text{时间片中断}}$ 及用户态到核心态的 $\color{green}{\text{切换}}$ 等。按发生异常的报告方式和返回方式不同， $\color{red}{\text{内部异常}}$ 可分为 $\color{green}{\text{故障}}$ （Fault）、 $\color{green}{\text{自陷}}$ （Trap）和 $\color{green}{\text{终止}}$ （Abort）三类。</p>
<p>${\textstyle\unicode{x2460}}$  故障（Fault）</p>
<p>指在引起故障等指令启动后、执行结束前被检测到的异常事件。例如，指令译码时，出现“非法操作码”;取数据时，发生“缺段”或“缺页”;执行整数除法指令时，发现“除数为0”等。对于“缺段”“缺页”等异常处理后，已将所需的段或页面从磁盘调入主存，可回到发生故障的指令继续执行，断点为当前发生故障的指令;对于“非法操作码”“除数为0”等， 因为无法通过异常处理程序恢复故障 ，因此不能回到原断点执行，必须终止进程的执行。</p>
<p>${\textstyle\unicode{x2461}}$ 自陷（Trap）</p>
<p>自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。通常的做法是:事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”，当执行到被设置了“陷阱”的指令时，CPU在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。注意，当自陷指令是转移指令时，并不是返回到下一条指令执行，而是返回到转移目标指令执行。</p>
<p>在80x86中，用于程序调试的“ $\color{green}{\text{断点设置}}$ ”功能就是通过 $\color{green}{\text{自陷}}$ 方式实现的。此外，系统调用指令、条件自陷指令（如MIPS 中 teq、teqi、tne、tnei等一组按条件进入陷阱的指令）等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动调出操作系统内核程序进行执行。</p>
<p>③终止（Abort）</p>
<p>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，如电源掉电、线路故障等，那么程序将无法继续执行，只能终止，此时，调出中断服务程序来重启系统。这种异常与故障和自陷不同，不是由特定指令产生的，而是 $\color{green}{\text{随机}}$ 发生的。</p>
<p>（2）外部中断</p>
<p> $\color{red}{\text{外中断}}$ 是指来自CPU外部、与CPU执行指令无关的事件引起的中断，包括 $\color{green}{\text{I/O设备}}$ 发出的I/O 中断（如键盘输入、打印机缺纸等）、 $\color{green}{\text{外部信号中断}}$ （如用户按Esc键），以及各种定时器引起的时钟中断等。外中断在狭义上一般称为中断（书中若未说明，一般是指外中断）。</p>
<p>外中断和内部异常在本质上是一样的，但它们之间有以下两个重要的不同点:</p>
<p>1）“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。</p>
<p>2）异常的检测是由CPU自身完成的，不必通过外部的某个信号通知CPU。对于中断，CPU必须通过总线获取中断源的标识信息，才能获知哪个设备发生了何种中断。</p>
<p>有些教材也将异常和中断统称为中断，将由CPU内部产生的异常称为内中断，将通过中断请求线INTR和 NMI 从 CPU 外部发出的中断请求称为外中断。</p>
<h5 id="中断的基本概念"><a href="#中断的基本概念" class="headerlink" title="中断的基本概念"></a>中断的基本概念</h5><p>程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU 暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。</p>
<p>程序中断的作用如下:</p>
<p>${\textstyle\unicode{x2460}}$  实现CPU与I/O设备的并行工作。</p>
<p>② $\color{green}{\text{处理}}$ 硬件故障和软件错误。</p>
<p>③实现人机交互，用户 $\color{green}{\text{干预}}$ 机器需要用到中断系统。</p>
<p>④实现多道程序、 $\color{green}{\text{分时操作}}$ ， $\color{green}{\text{多道程序}}$ 的切换需借助于中断系统。</p>
<p>⑤实时处理需要借助中断系统来实现 $\color{green}{\text{快速响应}}$ 。</p>
<p>⑥实现应用程序和操作系统（管态程序）的切换，称为“ $\color{green}{\text{软中断}}$ ”。</p>
<p>⑦多处理器系统中各处理器之间的 $\color{green}{\text{信息交流}}$ 和 $\color{green}{\text{任务切换}}$ 。</p>
<p>程序中断方式的思想:CPU在程序中安排好于某个时刻启动某台外设，然后CPU继续执行原来的程序，不需要像查询方式那样一直等待外设准备就绪。一旦外设完成数据传送的准备工作，就主动向CPU发出中断请求，请求CPU为自己服务。在可以响应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序，如图7.5所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716210133.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716210133.png';" /></details>

<h5 id="程序中断方式工作流程"><a href="#程序中断方式工作流程" class="headerlink" title="程序中断方式工作流程"></a>程序中断方式工作流程</h5><p>（1）中断请求</p>
<p>中断源是请求CPU中断的设备或事件，一台计算机允许有多个中断源。每个中断源向CPU发出中断请求的时间是随机的。为记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器INTR，当其状态为“1”时，表示中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。</p>
<p>内中断皆为 $\color{green}{\text{不可屏蔽中断}}$ 。通过INTR信号线发出的外中断是 $\color{green}{\text{可屏蔽中断}}$ ，在关中断（IF =1）的情况下不会被响应;而通过NMI信号发出的是不可屏蔽中断，即使在关中断（IF=0）的情况下也会被响应。不可屏蔽中断的处理优先级最高，任何时候只要发生不可屏蔽中断，都要中止现行程序的执行，转到不可屏蔽中断处理程序执行。</p>
<p>（2）中断判优</p>
<p>中断系统在任一瞬间只能响应一个中断源的请求。由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过中断判优逻辑确定响应哪个中断源的请求，例如故障中断的优先级别较高，然后是I/O中断。</p>
<p>中断判优既可以用硬件实现，又可用软件实现。硬件实现是通过 $\color{green}{\text{硬件排队器}}$ 实现的，它既可以设置在CPU中，又可以分散在各个中断源中，软件实现是通过 $\color{green}{\text{查询程序}}$ 实现的。</p>
<p>一般来说，硬件故障中断属于最高级，其次是软件中断，不可屏蔽中断优于可屏蔽中断，DMA 请求优于I/O 设备传送的中断请求，高速设备优于低速设备，输入设备优于输出设备，实时设备优于普通设备等。</p>
<p>（3 ）CPU 响应中断的条件</p>
<p>CPU在满足一定的条件下响应中断源发出的中断请求，并经过一些特定的操作，转去执行中断服务程序。CPU响应中断必须满足以下3个条件:</p>
<p>①中断源有中断请求。</p>
<p>${\textstyle\unicode{x2461}}$  CPU允许中断及开中断。</p>
<p>${\textstyle\unicode{x2462}}$ 一条指令执行完毕，且没有更紧迫的任务。</p>
<blockquote>
<p>注意:I/O设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取I/O 的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指外中断，内中断不属于此类情况。</p>
</blockquote>
<p>（4）中断响应</p>
<p>CPU 响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，我们将它称为 $\color{red}{\text{中断隐指令}}$ 。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下:</p>
<p>${\textstyle\unicode{x2460}}$   $\color{green}{\text{关中断}}$ 。CPU响应中断后，首先要保护程序的断点和现场信息，在保护断点和现场的过程中，CPU不能响应更高级中断源的中断请求。</p>
<p>②  $\color{green}{\text{保存断点}}$ 。为保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（指令无法直接读取的 $\color{green}{\text{PC}}$ 和PSWR $\color{green}{\text{等的内容）保存起来。<br> }}$<br>${\textstyle\unicode{x2462}}$  $\color{green}{\text{引出中断服务程序}}$ 。实质是取出中断服务程序的入口地址并传送给程序计数器（PC）。</p>
<p>（5）中断向量</p>
<p>每个中断都有一个类型号，每个中断类型号都对应一个中断服务程序，每个中断服务程序都有一个入口地址，CPU必须找到入口地址，即中断向量，把系统中的全部中断向量集中存放到存储器的某个区域内，这个存放中断向量的存储区就称为中断向量表。</p>
<p>CPU 响应中断后，中断硬件会自动将中断向量地址传送到CPU，由 CPU实现程序的切换，这种方法称为中断向量法，采用中断向量法的中断称为向量中断。</p>
<blockquote>
<p>注意: $\color{red}{\text{中断向量}}$ 是 $\color{green}{\text{中断服务程序的入口地址}}$ ， $\color{red}{\text{中断向量地址}}$ 是指 $\color{green}{\text{中断服务程序的入口地址的地址}}$ 。</p>
</blockquote>
<p>（6）中断处理过程</p>
<p>不同计算机的中断处理过程各具特色，就其多数而论，中断处理流程如图7.6所示。</p>
<p>中断处理流程如下:</p>
<p>${\textstyle\unicode{x2460}}$   $\color{green}{\text{关中断}}$ 。在保护断点和现场期间不能被新的中断所打断，必须关中断。否则，若断点或现场保存不完整，在中断服务程序结束后，就不能正确地恢复并继续执行现行程序。</p>
<p>${\textstyle\unicode{x2461}}$  $\color{green}{\text{保存断点}}$ 。断点可以压入堆栈，也可以存入主存的特定单元中。</p>
<p>${\textstyle\unicode{x2462}}$   $\color{green}{\text{引出中断服务程序}}$ 。通常有两种方法寻址中断服务程序的入口地址: $\color{green}{\text{硬件向量法}}$ 和 $\color{green}{\text{软件查询法}}$ 。硬件向量法通过硬件产生中断向量地址，再由中断向量地址找到中断服务程序的入口地址。软件查询法用软件编程的办法寻找入口地址。</p>
<blockquote>
<p>注意:硬件产生的实际上是中断类型号，而中断类型号指出了中断向量存放的地址，因此能产生中断向量地址。</p>
</blockquote>
<p>${\textstyle\unicode{x2463}}$   $\color{green}{\text{保存现场和屏蔽字}}$ 。进入中断服务程序后首先要保存现场和中断屏蔽字，现场信息是指用户可见的工作寄存器的内容，它存放着程序执行到断点处的现行值。</p>
<blockquote>
<p>注意:现场和断点，这两类信息都不能被中断服务程序破坏。现场信息因为用指令可直接访问，所以通常在中断服务程序中通过指令把它们保存到栈中，即由软件实现;而断点信息由CPU在中断响应开始时自动保存到栈或专门的寄存器中，即由硬件实现。</p>
</blockquote>
<p>⑤ $\color{green}{\text{开中断}}$ 。允许更高级中断请求得到响应，实现中断嵌套。</p>
<p>⑥ $\color{green}{\text{执行中断服务程序}}$ 。这是中断请求的目的。</p>
<p>⑦ $\color{green}{\text{关中断}}$ 。保证在恢复现场和屏蔽字时不被中断。</p>
<p>⑧ $\color{green}{\text{恢复现场和屏蔽字}}$ 。将现场和屏蔽字恢复到原来的状态。</p>
<p>${\textstyle\unicode{x2468}}$   $\color{green}{\text{开中断、中断返回}}$ 。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p>
<p>其中，①<del>③在CPU进入中断周期后，由中断隐指令（硬件自动）完成;④</del>⑨由中断服务程序完成。</p>
<blockquote>
<p>注意:恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作由中断服务程序完成。中断返回由中断服务程序的最后一条中断返回指令完成。</p>
</blockquote>
<details style="width:300px"><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716210821.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716210821.png';" /></details>


<h5 id="多重中断和中断屏蔽技术"><a href="#多重中断和中断屏蔽技术" class="headerlink" title="多重中断和中断屏蔽技术"></a>多重中断和中断屏蔽技术</h5><p>若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而CPU对新的中断请求不予响应，则这种中断称为 $\color{green}{\text{单重中断}}$ ，如图7.7（a）所示。若CPU 暂停现行的中断服务程序，转去处理新的中断请求，则这种中断称为 $\color{green}{\text{多重中断}}$ ，又称 $\color{green}{\text{中断嵌套}}$ ，如图7.7（b）所示。</p>
<p>中断屏蔽技术主要用于多重中断。CPU要具备多重中断的功能，必须满足下列条件:</p>
<p>①在中断服务程序中提前设置开中断指令。</p>
<p>②优先级别高的中断源有权中断优先级别低的中断源。</p>
<p>每个中断源都有一个 $\color{red}{\text{屏蔽触发器}}$ ， $\color{green}{\text{1}}$ 表示 $\color{green}{\text{屏蔽该中断源}}$ 的请求， $\color{green}{\text{0}}$ 表示可以 $\color{green}{\text{正常申请}}$ ，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。</p>
<p>关于中断屏蔽字的设置及多重中断程序执行的轨迹，下面通过实例说明。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716211109.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211109.png';" /></details>



<details><summary>例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716211251.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211251.png';" /></details>

<ul>
<li>中断屏蔽字为什么是这样求</li>
</ul>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>DMA方式是一种 $\color{green}{\text{完全由硬件}}$ 进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU与外设并行工作。DMA方式在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过CPU，降低了CPU 在传送数据时的开销，因此称为 $\color{green}{\text{直接存储器存取}}$ 方式。由于数据传送不经过CPU，也就不需要保护、恢复CPU现场等烦琐操作。</p>
<p>这种方式适用于磁盘机、磁带机等高速设备大批量数据的传送，它的硬件开销比较大。在DMA方式中，中断的作用仅限于 $\color{green}{\text{故障}}$ 和 $\color{green}{\text{正常传送结束时的处理}}$ 。</p>
<h5 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h5><p>主存和 DMA接口之间有一条直接数据通路。由于 DMA方式传送数据不需要经过CPU,因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。</p>
<p>DMA方式具有下列特点:</p>
<p>①它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。</p>
<p>${\textstyle\unicode{x2461}}$  在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</p>
<p>③主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p>
<p>${\textstyle\unicode{x2463}}$  DMA传送速度快，CPU和外设并行工作，提高了系统效率。</p>
<p>${\textstyle\unicode{x2464}}$  DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p>
<h5 id="DMA控制器的组成"><a href="#DMA控制器的组成" class="headerlink" title="DMA控制器的组成"></a>DMA控制器的组成</h5><p>在DMA方式中，对数据传送过程进行控制的硬件称为DMA控制器（DMA接口）。当I/O 设备需要进行数据传送时，通过DMA控制器向CPU提出DMA传送请求，CPU响应之后将让出系统总线，由DMA控制器接管总线进行数据传送。其主要功能如下:</p>
<p>1）接受外设发出的DMA请求，并向CPU发出总线请求。</p>
<p>2） CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期。</p>
<p>3）确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数。</p>
<p>4）规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。</p>
<p>5）向CPU报告DMA操作的结束。</p>
<p>图7.10给出了一个简单的DMA控制器。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716211543.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211543.png';" /></details>


<ul>
<li>主存地址计数器:存放要交换数据的主存地址。</li>
<li>传送长度计数器:记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。</li>
<li>数据缓冲寄存器:暂存每次传送的数据。</li>
<li>DMA请求触发器:每当I/O设备准备好数据后，给出一个控制信号，使 DMA请求触发器置位。</li>
<li>“控制/状态”逻辑:由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对 DMA请求信号和CPU响应信号进行协调和同步。</li>
<li>中断机构:当一个数据块传送完毕后触发中断机构，向CPU提出中断请求。</li>
</ul>
<p>在 DMA传送过程中，DMA 控制器将接管CPU的地址总线、数据总线和控制总线，CPU的主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。由此可见，DMA控制器必须具有控制系统总线的能力。</p>
<h5 id="DMA的传送方式"><a href="#DMA的传送方式" class="headerlink" title="DMA的传送方式"></a>DMA的传送方式</h5><p>主存和I/O设备之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA控制器与CPU通常采用以下3种方式使用主存:</p>
<p>1）停止CPU访存。当I/O设备有DMA请求时，由DMA 控制器向CPU发送一个停止信号，使 CPU 脱离总线，停止访问主存，直到 DMA传送一块数据结束。数据传送结束后，DMA控制器通知CPU可以使用主存，并把总线控制权交还给CPU。</p>
<p>2）周期挪用（或周期窃取）。当I/O设备有 DMA请求时，会遇到3种情况:①是此时CPU 不在访存（如CPU正在执行乘法指令），因此 I/O 的访存请求与CPU未发生冲突;②是CPU正在访存，此时必须待存取周期结束后，CPU 再将总线占有权让出;③是I/O和 CPU同时请求访存，出现访存冲突，此时CPU 要暂时放弃总线占有权。I/O访存优先级高于CPU访存，因为I/O不立即访存就可能丢失数据，此时由I/O设备挪用一个或几个存取周期，传送完一个数据后立即释放总线，是一种单字传送方式。</p>
<p>3）DMA与CPU交替访存。这种方式适用于CPU 的工作周期比主存存取周期长的情况。例如，若CPU的工作周期是 1.2$\mu$s，主存的存取周期小于0.6$\mu$s，则可将一个CPU周期分为$C_1$和$C_2$,两个周期，其中 $C_1$专供 DMA 访存，$C_2$专供 CPU访存。这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过$C_1$和$C_2$分时控制的。</p>
<h5 id="DMA的传送过程"><a href="#DMA的传送过程" class="headerlink" title="DMA的传送过程"></a>DMA的传送过程</h5><p>DMA的数据传送过程分为预处理、数据传送和后处理3个阶段:</p>
<p>1） $\color{green}{\text{预处理}}$ 。由CPU 完成一些必要的准备工作。首先，CPU执行几条I/O 指令，用以测试I/O设备状态，向 DMA 控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU 发送总线请求（有时将这两个过程统称为DMA请求），用以传输数据。</p>
<p>2） $\color{green}{\text{数据传送}}$ 。DMA的数据传输可以以单字节（或字）为基本单位，也可以以数据块为基本单位。对于以数据块为单位的传送（如硬盘），DMA占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器（而非通过CPU执行程序）实现的，即数据传送阶段完全由DMA（硬件）控制。</p>
<p>3） $\color{green}{\text{后处理}}$ 。DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括校验送入主存的数据是否正确、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用DMA传送其他数据块等。DMA 的传送流程如图7.11所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716211945.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211945.png';" /></details>


<h5 id="DMA方式和中断方式的区别"><a href="#DMA方式和中断方式的区别" class="headerlink" title="DMA方式和中断方式的区别"></a>DMA方式和中断方式的区别</h5><p>DMA方式和中断方式的重要区别如下:</p>
<p>${\textstyle\unicode{x2460}}$  中断方式是程序的切换，需要保护和恢复现场;而DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源。</p>
<p>${\textstyle\unicode{x2461}}$ 对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期后）;而对DMA请求的响应可以发生在每个机器周期结束时（在取指周期、间址周期、执行周期后均可），只要CPU不占用总线就可被响应。</p>
<p>${\textstyle\unicode{x2462}}$ 中断传送过程需要CPU的干预;而 DMA传送过程不需要CPU 的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。</p>
<p>${\textstyle\unicode{x2463}}$ DMA请求的优先级高于中断请求。</p>
<p>${\textstyle\unicode{x2464}}$ 中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的I/O操作。</p>
<p>${\textstyle\unicode{x2465}}$ 从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><h4 id="I-O设备有哪些编址方式-各有何特点"><a href="#I-O设备有哪些编址方式-各有何特点" class="headerlink" title="I/O设备有哪些编址方式?各有何特点?"></a>I/O设备有哪些编址方式?各有何特点?</h4><p>$\color{green}{\text{统一编址}}$ 和 $\color{green}{\text{独立编址}}$ 。统一编址是在主存地址中划出一定的范围作为I/O地址，以便通过访存指令即可实现对I/O 的访问，但主存的容量相应减少。独立编址是指I/O 地址和主存是分开的，I/O地址不占主存空间，但访存需专门的I/O指令。</p>
<h4 id="CPU响应中断应具备哪些条件"><a href="#CPU响应中断应具备哪些条件" class="headerlink" title="CPU响应中断应具备哪些条件?"></a>CPU响应中断应具备哪些条件?</h4><p>在CPU内部设置的中断屏蔽触发器必须是开放的。</p>
<p>${\textstyle\unicode{x2460}}$  外设有中断请求时，中断请求触发器必须处于“1”状态，保持中断请求信号。</p>
<p>${\textstyle\unicode{x2461}}$ 外设（接口）中断允许触发器必须为“1”，这样才能把外设中断请求送至CPU.</p>
<p>${\textstyle\unicode{x2462}}$ 具备上述三个条件时，CPU在现行指令结束的最后一个状态周期响应中断。</p>
<h3 id="常见问题和易混淆知识点"><a href="#常见问题和易混淆知识点" class="headerlink" title="常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h3><h4 id="中断响应优先级和中断处理优先级分别指什么"><a href="#中断响应优先级和中断处理优先级分别指什么" class="headerlink" title="中断响应优先级和中断处理优先级分别指什么?"></a>中断响应优先级和中断处理优先级分别指什么?</h4><p>中断响应优先级是由硬件排队线路或中断查询程序的查询顺序决定的，不可动态改变;而中断处理优先级可以由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为“0”，对新中断开放），若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。</p>
<h4 id="向量中断、中断向量、向量地址三个概念是什么关系"><a href="#向量中断、中断向量、向量地址三个概念是什么关系" class="headerlink" title="向量中断、中断向量、向量地址三个概念是什么关系?"></a>向量中断、中断向量、向量地址三个概念是什么关系?</h4><p>中断向量:每个中断源都有对应的处理程序，这个处理程序称为 $\color{green}{\text{中断服务程序}}$ ，其入口地址称为 $\color{green}{\text{中断向量}}$ 。所有中断的中断服务程序入口地址构成一个表，称为 $\color{green}{\text{中断向量表}}$ ;也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表。</p>
<p>$\color{green}{\text{向量地址}}$ :中断向量表或中断向量跳转表中每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。</p>
<p>$\color{green}{\text{向量中断}}$ :指一种识别中断源的技术或方式。识别中断源的目的是找到中断源对应的中断服务程序的入口地址的地址，即获得向量地址。</p>
<h4 id="程序中断和调用子程序有何区别"><a href="#程序中断和调用子程序有何区别" class="headerlink" title="程序中断和调用子程序有何区别?"></a>程序中断和调用子程序有何区别?</h4><p>两者的根本区别主要表现在服务时间和服务对象上不一样。</p>
<p>1）调用子程序过程发生的时间是已知的和固定的，即在主程序中的调用指令（CALL）执行时发生主程序调用子程序过程，调用指令所在位置是已知的和固定的。而中断过程发生的时间一般是随机的，CPU在执行某个主程序时收到中断源提出的中断申请，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的。也可以说，调用子程序是程序设计者事先 $\color{green}{\text{安排}}$ 的，而执行中断服务程序是由系统工作环境 $\color{green}{\text{随机}}$ 决定的。</p>
<p>2）子程序完全为主程序服务，两者属于 $\color{green}{\text{主从关系}}$ 。主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序二者一般是无关的，不存在谁为谁服务的问题，两者是 $\color{green}{\text{平行关系}}$ 。</p>
<p>3）主程序调用子程序的过程完全属于 $\color{green}{\text{软件}}$ 处理过程，不需要专门的硬件电路;而中断处理系统是一个 $\color{green}{\text{软/硬件}}$ 结合的系统，需要专门的硬件电路才能完成中断处理的过程。</p>
<p>4）子程序嵌套可实现 $\color{green}{\text{若干级}}$ ，嵌套的最多级数受计算机内存开辟的堆栈大小限制;而中断嵌套级数主要由中断优先级来决定，一般优先级数不会很大。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch6-%E6%80%BB%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch6-%E6%80%BB%E7%BA%BF/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch6-总线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 10:00:19" itemprop="dateCreated datePublished" datetime="2021-06-30T10:00:19+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-02 16:55:14" itemprop="dateModified" datetime="2021-10-02T16:55:14+08:00">2021-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>【考纲内容】</p>
<p>(一）总线概述</p>
<p>总线的基本概念;总线的分类;总线的组成及性能指标</p>
<p>(二）总线操作和定时</p>
<p>同步定时方式;异步定时方式</p>
<p>(三)总线标准</p>
<p>【复习提示】</p>
<p>本章的知识点较少，其中总线仲裁及总线操作和定时方式是难点。本章内容通常以选择题的形式出现，特别是系统总线的特点、性能指标、各种仲裁方式的特点、异步定时方式及常见的总线标准和特点等。总线带宽的计算也可能结合其他章节出综合题。</p>
<p>在学习本章时，请读者思考以下问题:</p>
<p>1)引入总线结构有什么好处?</p>
<p>2）引入总线结构会导致什么问题?如何解决?</p>
<p>请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。</p>
<h3 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h3><p>随着计算机的发展和应用领域的不断扩大，IO 设备的种类和数量也越来越多。为了更好地解决IO设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。为了进一步简化设计，又提出了各类总线标准。</p>
<h4 id="总线基本概念"><a href="#总线基本概念" class="headerlink" title="总线基本概念"></a>总线基本概念</h4><h5 id="总线的定义"><a href="#总线的定义" class="headerlink" title="总线的定义"></a>总线的定义</h5><p>总线是一组能为多个部件分时共享的公共信息传送线路。分时和共享是总线的两个特点。</p>
<p>$\color{green}{\text{分时}}$ 是指同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息。</p>
<p>$\color{green}{\text{共享}}$ 是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享。在某一时刻只允许有一个部件向总线发送信息，但多个部件可同时从总线上接收相同的信息。</p>
<h5 id="总线设备"><a href="#总线设备" class="headerlink" title="总线设备"></a>总线设备</h5><p>总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种。</p>
<p>$\color{green}{\text{主设备}}$ ：总线的主设备是指获得总线控制权的设备。</p>
<p>$\color{green}{\text{从设备}}$ ：总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。</p>
<h5 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h5><p>总线特性是指 $\color{green}{\text{机械特性}}$ （尺寸、形状)、 $\color{green}{\text{电气特性}}$ （传输方向和有效的电平范围)、 $\color{green}{\text{功能特性}}$ （每根传输线的功能）和 $\color{green}{\text{时间特性}}$ （信号和时序的关系)。</p>
<h5 id="总线的猝发传输方式"><a href="#总线的猝发传输方式" class="headerlink" title="总线的猝发传输方式"></a><a href="/2021/06/17/习题-王道-计算机组成原理-ch6-总线/#【2012统考真题】某同步总线的时钟频率为100MHz，宽度为32位，地址-数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线支持突发（猝发）传输方式，则一次“主存写”总线事务传输128位数据所需要的时间至少是（）">总线的猝发传输方式</a></h5><p>在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为 $\color{green}{\text{猝发传送}}$ 。</p>
<ul>
<li>又称突发传输</li>
<li>传送一个起始地址之后，可以连续读取连续的地址的内容</li>
<li>没有突发传输的话，后面的内容每一次都要传送地址</li>
</ul>
<h4 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h4><p>计算机系统中的总线，按功能划分为以下3类。</p>
<h5 id="color-green-text-片内总线"><a href="#color-green-text-片内总线" class="headerlink" title="$\color{green}{\text{片内总线}}$"></a>$\color{green}{\text{片内总线}}$</h5><p>片内总线是芯片内部的总线，它是CPU 芯片内部寄存器与寄存器之间、寄存器与ALU 之间的公共连接线。</p>
<h5 id="color-green-text-系统总线"><a href="#color-green-text-系统总线" class="headerlink" title="$\color{green}{\text{系统总线}}$"></a>$\color{green}{\text{系统总线}}$</h5><p>系统总线是计算机系统内各功能部件(CPU、主存、I/O接口)之间相互连接的总线。按系统总线传输信息内容的不同，又可分为3类：数据总线、地址总线和控制总线。</p>
<p>1）$\color{green}{\text{数据总线}}$ 用来传输各功能部件之间的数据信息，它是双向传输总线，其位数与 $\color{green}{\text{机器字长}}$ 、 $\color{green}{\text{存储字长}}$ 有关。</p>
<p>2）$\color{green}{\text{地址总线}}$ 用来指出数据总线上的源数据或目的数据所在的 $\color{green}{\text{主存单元}}$ 或 $\color{green}{\text{I/O端口的地址}}$ ，它是单向传输总线，地址总线的位数与主存地址空间的大小有关。</p>
<p>3）$\color{green}{\text{控制总线}}$ 传输的是控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信号。</p>
<blockquote>
<p>注意区分数据通路和数据总线:各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流经的路径，而 $\color{green}{\text{数据总线}}$ 是承载的媒介。</p>
</blockquote>
<h5 id="color-green-text-通信总线"><a href="#color-green-text-通信总线" class="headerlink" title="$\color{green}{\text{通信总线}}$"></a>$\color{green}{\text{通信总线}}$</h5><p>通信总线是在计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。</p>
<p>此外，按时序控制方式可将总线划分为 $\color{green}{\text{同步总线}}$ 和 $\color{green}{\text{异步总线}}$ ，还可按数据传输格式将总线划分为 $\color{green}{\text{并行总线}}$ 和 $\color{green}{\text{串行总线}}$ 。</p>
<h4 id="系统总线的结构"><a href="#系统总线的结构" class="headerlink" title="系统总线的结构"></a>系统总线的结构</h4><p>总线结构通常分为单总线结构、双总线结构和三总线结构等。</p>
<h5 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h5><p>单总线结构将CPU、主存、IO设备（通过IO接口）都挂在一组总线上，允许IO设备之间、IO设备与主存之间直接交换信息，如图6.1所示。CPU与主存、CPU与外设之间可直接进行信息交换，而无须经过中间设备的干预。</p>
<p>注意，单总线并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。</p>
<p>优点:结构简单，成本低，易于接入新的设备;缺点:带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。</p>
<details><summary>图6.1单总线结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211002141738.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211002141738.png';" /></details>

<h5 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h5><p>双总线结构有两条总线:一条是 $\color{green}{\text{主存总线}}$ ，用于在CPU、主存和通道之间传送数据;另一条是 $\color{green}{\text{IO总线}}$ ，用于在多个外部设备与通道之间传送数据，如图6.2所示。</p>
<p>优点:将低速IO设备从单总线上分离出来，实现了存储器总线和IO总线分离。缺点:需要增加通道等硬件设备。</p>
<h5 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h5><p>三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为 $\color{green}{\text{主存总线}}$ 、 $\color{green}{\text{IO总线}}$ 和 $\color{green}{\text{直接内存访问（DMA)总线}}$ ，如图6.3所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716190047.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716190047.png';" /></details>

<p>主存总线用于在CPU和内存之间传送地址、数据和控制信息。IO总线用于在CPU和各类外设之间通信。DMA总线用于在内存和高速外设之间直接传送数据。</p>
<p>优点:提高了IO设备的性能，使其更快地响应命令，提高系统吞吐量。缺点:系统工作效率较低。</p>
<h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4><p>1）总线的 $\color{green}{\text{传输周期}}$ 。指一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段)，简称总线周期。总线传输周期通常由若干总线时钟周期构成。</p>
<p>2）总线 $\color{green}{\text{时钟周期}}$ 。即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。</p>
<p>3）总线的 $\color{green}{\text{工作频率}}$ 。总线上各种操作的频率，为总线周期的倒数。实际上指1秒内传送几次数据。若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。</p>
<p>4）总线的 $\color{green}{\text{时钟频率}}$ 。即机器的时钟频率，它为时钟周期的倒数。</p>
<p>5）总线 $\color{green}{\text{宽度}}$ 。又称总线位宽，它是总线上同时能够传输的数据位数，通常指 $\color{green}{\text{数据总线}}$ 的根数，如32根称为32位总线。</p>
<p>6）总线 $\color{green}{\text{带宽}}$ 。可理解为总线的 $\color{green}{\text{数据传输率}}$ ，即单位时间内总线上可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。总线带宽=总线工作频率×(总线宽度/8)。</p>
<blockquote>
<p>注意:总线带宽和总线宽度应加以区别。</p>
</blockquote>
<p>7)总线 $\color{green}{\text{复用}}$ 。总线复用是指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。</p>
<p>8）信号 $\color{red}{\text{线数}}$ 。 $\color{green}{\text{地址总线}}$ 、 $\color{green}{\text{数据总线}}$ 和 $\color{green}{\text{控制总线}}$ 3种总线数的总和称为信号线数。其中，总线的最主要性能指标为总线宽度、总线（工作）频率、总线带宽，总线带宽是指总线本身所能达到的最高传输速率，它是衡量总线性能的重要指标。</p>
<p>三者关系:总线带宽=总线宽度×总线频率。</p>
<p>例如，总线工作频率为22MHz，总线宽度为16位，则总线带宽=22×(16/8)=44MB/s。</p>
<h3 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="*总线仲裁"></a>*总线仲裁</h3><p>为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权。只有获得了总线控制权的设备，才能开始传送数据。</p>
<p>总线仲裁方式按其仲裁控制机构的设置可分为集中仲裁方式和分布仲裁方式两种。</p>
<h4 id="集中仲裁方式"><a href="#集中仲裁方式" class="headerlink" title="集中仲裁方式"></a>集中仲裁方式</h4><p>总线控制逻辑基本上集中于一个设备（如CPU)中。将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决，称为集中仲裁方式。集中仲裁方式有链式查询方式、计数器定时查询方式和独立请求方式三种。</p>
<h5 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h5><p>链式查询方式如图6.4所示。总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器。由总线控制器检查总线是否忙，若总线不忙，则立即发总线响应信号，经总线响应线BG串行地从一个部件传送到下一个部件，依次查询。若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件;若响应信号到达的部件有总线请求，则信号被截住，不再传下去。</p>
<details><summary>图6.4 链式查询方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716190533.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716190533.png';" /></details>

<p>在链式查询中，部件离总线控制器越近，其优先级越高;部件离总线控制器越远，其优先级越低。</p>
<p>优点:链式查询方式优先级固定。此外，只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。</p>
<p>缺点:对硬件电路的故障敏感，且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线。</p>
<h5 id="计数器定时查询方式"><a href="#计数器定时查询方式" class="headerlink" title="计数器定时查询方式"></a>计数器定时查询方式</h5><p>计数器定时查询方式如图6.5所示。它采用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线，少了一根总线响应线BG。它仍共用一根总线请求线，当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时中止计数器的计数及查询。</p>
<details><summary>图6.5计数器定时查询方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716190741.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716190741.png';" /></details>

<p>优点:计数可从“0”开始，此时一旦设备的优先次序被固定，设备的优先级就按0,1,$\cdots$,n的顺序降序排列，而且固定不变;计数也可从上一次的终点开始，即采用一种循环方法，此时设备使用总线的优先级相等;计数器的初值还可由程序设置，因此优先次序可以改变，且这种方式对电路的故障没有链式查询方式敏感。</p>
<p>缺点:增加了控制线数（若设备有n个，则大致需要 $\lceil log_2n \rceil$+2条控制线)，控制也比相对链式查询要复杂。</p>
<h5 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h5><p>独立请求方式如图6.6所示。每个设备均有一对总线请求线BR,和总线允许线BG;。当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队，当总线控制器按一定的优先次序决定批准某个部件的请求时，给该部件发送总线响应信号，该部件接到此信号后就获得了总线使用权，开始传送数据。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716191554.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716191554.png';" /></details>

<p>优点:响应速度快，总线允许信号BG直接从控制器发送到有关设备，而不必在设备间传递或查询,而且对优先次序的控制相当灵活。</p>
<p>缺点:控制线数量多（设备有n个，需要2n+1条控制线，其中加的那条控制线为BS线，基作用是让设备向总线控制部件反馈已使用完总线)，总线控制逻辑更复杂。<br>为方便记忆，下面归纳了3种集中仲裁方式的区别与联系（假设设备有n 个)，如表6.1所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716191643.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716191643.png';" /></details>

<h4 id="分布仲裁方式"><a href="#分布仲裁方式" class="headerlink" title="分布仲裁方式"></a>分布仲裁方式</h4><p>分布仲裁方式不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器。当它们有总线请求时，就会把它们各自唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较。若仲裁总线上的仲裁号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。</p>
<h3 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h3><p>总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则，主要有同步和异步两种基本定时方式。</p>
<h4 id="总线传输的4个阶段"><a href="#总线传输的4个阶段" class="headerlink" title="总线传输的4个阶段"></a>总线传输的4个阶段</h4><p>一个总线周期通常可分为以下4个阶段:</p>
<p>1） $\color{green}{\text{申请分配阶段}}$ 。由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为传输请求和总线仲裁两个阶段。</p>
<p>2） $\color{green}{\text{寻址阶段}}$ 。取得使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。</p>
<p>3） $\color{green}{\text{传输阶段}}$ 。主模块和从模块进行数据交换，可单向或双向进行数据传送。</p>
<p>4） $\color{green}{\text{结束阶段}}$ 。主模块的有关信息均从系统总线上撤除，让出总线使用权。</p>
<h4 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h4><p>所谓同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。</p>
<p>优点:传送速度快，具有较高的传输速率;总线控制逻辑简单。</p>
<p>缺点:主从设备属于强制性同步;不能及时进行数据通信的有效性检验，可靠性较差。</p>
<p>同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。</p>
<h4 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h4><p>在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备;从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</p>
<p>优点:总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。</p>
<p>缺点:比同步控制方式稍复杂一些，速度比同步定时方式慢。</p>
<p>根据“请求”和“回答”信号的撤销是否互锁，异步定时方式又分为以下3种类型。</p>
<p>1) $\color{green}{\text{不互锁方式}}$ 。主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间后自动撤销“回答”信号。双方不存在互锁关系，如图6.7(a)所示。</p>
<p>2） $\color{green}{\text{半互锁方式}}$ 。主设备发出“请求”信号后，必须在接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。半互锁方式如图6.7(b)所示。</p>
<p>3） $\color{green}{\text{全互锁方式}}$ 。主设备发出“请求”信号后，必须在从设备“回答”后才撤销“请求”信号;从设备发出“回答”信号后，必须在获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系，如图6.7(c)所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716191950.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716191950.png';" /></details>

<h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><p>总线标准是国际上公布或推荐的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范。按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。</p>
<h4 id="常见的总线标准"><a href="#常见的总线标准" class="headerlink" title="常见的总线标准"></a>常见的总线标准</h4><p>目前，典型的总线标准有ISA、EISA、VESA、PCI、PCI-Express、AGP、RS-232C、USB等。它们的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。</p>
<p>1)ISA。ISA (Industry Standard Architecture，工业标准体系结构）总线是最早出现的微型计算机的系统总线，应用在IBM的AT机上。</p>
<p>2）EISA。EISA (Extended Industry Standard Architecture，扩展的ISA）总线是为配合32位CPU而设计的扩展总线，EISA对ISA完全兼容。</p>
<p>3）VESA。VESA (Video Electronics Standards Association，视频电子标准协会）总线是一个32位标准的计算机局部总线，是针对多媒体PC要求高速传送活动图像的大量数据应运而生的。</p>
<p>4) PCI。PCI (Peripheral Component Interconnect，外部设备互连）总线是高性能的32位或64 位总线，是专为高度集成的外围部件、扩充插板和处理器/存储器系统设计的互连机制。目前常用的PCI适配器有显卡、声卡、网卡等。PCI总线支持即插即用。PCI总线是一个与处理器时钟频率无关的高速外围总线，属于局部总线。PCI总线可通过桥连接实现多层PCI总线。</p>
<p>5)PCI-Express (PCI-E)。PCI-Express是最新的总线和接口标准，它将全面取代现行的PCI和AGP，最终统一总线标准。</p>
<p>6）AGP。AGP (Accelerated Graphics Port，加速图形接口）是一种视频接口标准，专用于连接主存和图形存储器，属于局部总线。AGP技术为传输视频和三维图形数据提供了切实可行的解决方案。</p>
<p>7) RS-232C。RS-232C (Recommended Standard，RS）是由美国电子工业协会（EIA）推荐的一种串行通信总线，是应用于串行二进制交换的数据终端设备（DTE）和数据通信设备(DCE）之间的标准接口。</p>
<p>8）USB。USB (Universal Serial Bus，通用串行总线）是一种连接外部设备的IO总线，属于设备总线。具有即插即用、热插拔等优点，有很强的连接能力。</p>
<p>9)PCMCIA。PCMCIA (Personal Computer Memory Card International Association）是广泛应用于笔记本电脑的一种接口标准，是一个用于扩展功能的小型插槽。PCMCIA具有即插即用功能。</p>
<p>10）IDE。IDE (Integrated Drive Electronics，集成设备电路)，更准确地称为ATA，是一种IDE接口磁盘驱动器接口类型，硬盘和光驱通过IDE接口与主板连接。</p>
<p>11)SCSI。SCSI (Small Computer System Interface，小型计算机系统接口）是一种用于计算机和智能设备之间（硬盘、软驱、光驱、打印机等）系统级接口的独立处理器标准。SCSI是一种智能的通用接口标准。</p>
<p>12)SATA。SATA (Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和 Seagate公司共同提出的硬盘接口规范。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><h4 id="引入总线结构有什么好处"><a href="#引入总线结构有什么好处" class="headerlink" title="引入总线结构有什么好处?"></a>引入总线结构有什么好处?</h4><p>引入总线结构主要有以下优点:</p>
<p>${\textstyle\unicode{x2460}}$ 简化了系统结构，便于系统设计制造。</p>
<p>②大大减少了连线数目，便于布线，减小体积，提高系统的可靠性。</p>
<p>③便于接口设计，所有与总线连接的设备均采用类似的接口。</p>
<p>${\textstyle\unicode{x2463}}$  便于系统的扩充、更新与灵活配置，易于实现系统的模块化。</p>
<p>⑤便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。</p>
<p>${\textstyle\unicode{x2465}}$  便于故障诊断和维修，同时也能降低成本。</p>
<h4 id="引入总线会导致什么问题-如何解决"><a href="#引入总线会导致什么问题-如何解决" class="headerlink" title="引入总线会导致什么问题?如何解决?"></a>引入总线会导致什么问题?如何解决?</h4><p>引入总线后，总线上的各个设备分时共享同一总线，当总线上多个设备同时要求使用总线时就会导致总线的冲突。为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权，只有获得了总线控制权的设备才能开始数据传送。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch5-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch5-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch5-中央处理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 10:00:10" itemprop="dateCreated datePublished" datetime="2021-06-30T10:00:10+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-04 14:38:52" itemprop="dateModified" datetime="2021-10-04T14:38:52+08:00">2021-10-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><p>p202</p>
<p>【考纲内容】</p>
<p>(一）CPU的功能和基本结构</p>
<p>(二）指令执行过程</p>
<p>(三）数据通路的功能和基本结构</p>
<p>(四）控制器的功能和工作原理</p>
<p>硬布线控制器</p>
<p>微程序控制器:微程序、微指令和微命令，微指令格式，微命令的编码方式，微地址的形成方式</p>
<p>(五）指令流水线</p>
<p>指令流水线的基本概念;指令流水线的基本实现</p>
<p>超标量和动态流水线的基本概念</p>
<p>【复习提示】</p>
<p>中央处理器是计算机的中心，也是本书的难点。其中，数据通路的分析、指令执行阶段的节拍与控制信号的安排、流水线技术与性能分析易出综合题。而关于各种寄存器的特点、指令执行的各种周期与特点、控制器的相关概念、流水线的相关概念也极易出选择题。</p>
<p>在学习本章时，请读者思考以下问题;</p>
<p>1)CPU分为哪几部分?分别实现什么功能?</p>
<p>2）指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据?</p>
<p>3）什么是指令周期、机器周期和时钟周期?它们之间有何关系?</p>
<p>4）指令周期是否有一个固定值?为什么?</p>
<p>5）什么是微指令？它和第4章谈到的指令有什么关系?</p>
<p>6）什么是指令流水线?指令流水线相对于传统计算机体系结构的优势是什么?如何计算指令流水线的加速比?</p>
<p>请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。</p>
<blockquote>
<p>总结一下， $\color{red}{\text{寄存器与字长之间的关系}}$<br> $\color{red}{\text{指令周期分为哪几个阶段，哪几个阶段会修改PC寄存器的值}}$<br> $\color{red}{\text{各种标志位的作用是啥，产生的时机又是啥}}$<br> $\color{red}{\text{哪些寄存器是透明的}}$ </p>
</blockquote>
<table>
<thead>
<tr>
<th>组件</th>
<th>是否透明</th>
</tr>
</thead>
<tbody><tr>
<td>暂存寄存器</td>
<td></td>
</tr>
<tr>
<td>累加寄存器</td>
<td></td>
</tr>
<tr>
<td>程序计数器</td>
<td>$\color{red}{\times}$</td>
</tr>
<tr>
<td>通用寄存器组</td>
<td>$\color{red}{\times}$</td>
</tr>
<tr>
<td>程序状态字寄存器</td>
<td>$\color{red}{\times}$</td>
</tr>
<tr>
<td>指令寄存器</td>
<td>$\color{green}{\checkmark}$</td>
</tr>
<tr>
<td>指令译码器</td>
<td></td>
</tr>
<tr>
<td>存储器地址寄存器</td>
<td></td>
</tr>
<tr>
<td>存储器数据寄存器</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p> 全部习题之间增加分割线<br><code>(^##### )</code><br><code>----------\n$1</code></p>
</blockquote>
<h3 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h3><h4 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h4><p>$\color{red}{\text{中央处理器}}$ （CPU）由 $\color{green}{\text{运算器}}$ 和 $\color{green}{\text{控制器}}$ 组成。其中， $\color{red}{\text{控制器}}$ 的功能是负责协调并控制计算机各部件执行程序的指令序列，包括 $\color{green}{\text{取指令}}$ 、 $\color{green}{\text{分析指令}}$ 和 $\color{green}{\text{执行指令}}$ ; $\color{red}{\text{运算器}}$ 的功能是 $\color{green}{\text{对数据进行加工}}$ 。CPU的具体功能包括:</p>
<p>1）指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制。</p>
<p>2）操作控制。一条指令的功能往往由若干操作信号的组合来实现。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。</p>
<p>3）时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。</p>
<p>4）数据加工。对数据进行算术和逻辑运算。</p>
<p>5）中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。</p>
<h4 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h4><p>在计算机系统中，中央处理器主要由运算器和控制器两大部分组成，如图5.1所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715140209.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715140209.png';" /></details>

<h5 id="color-red-text-运算器"><a href="#color-red-text-运算器" class="headerlink" title="$\color{red}{\text{运算器}}$"></a>$\color{red}{\text{运算器}}$</h5><p>运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。运算器是计算机对数据进行加工处理的中心，它主要由算术逻辑单元(ALU)、暂存寄存器、累加寄存器(ACC)、通用寄存器组、程序状态字寄存器(PSW)、移位器、计数器（CT)等组成。</p>
<p>1） $\color{green}{\text{算术逻辑单元}}$ 。主要功能是进行算术/逻辑运算。</p>
<p>2） $\color{green}{\text{暂存寄存器}}$ 。用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的。</p>
<p>3） $\color{green}{\text{累加寄存器}}$ 。它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。</p>
<p>4） $\color{green}{\text{通用寄存器组}}$ 。如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。</p>
<p>5） $\color{green}{\text{程序状态字寄存器}}$ 。保留田昇个之西界R标志(ZF)、进位标志（CF）等。PSW 中息，如溢出标志（OF)、符号标志（SF)、零标志（ZF)、进位标志（CF）等。PSW中的这些位参与并决定微操作的形成。</p>
<p>6） $\color{green}{\text{移位器}}$ 。对操作数或运算结果进行移位运算。</p>
<p>7） $\color{green}{\text{计数器}}$ 。控制乘除运算的操作步数。</p>
<h5 id="color-red-text-控制器"><a href="#color-red-text-控制器" class="headerlink" title="$\color{red}{\text{控制器}}$"></a>$\color{red}{\text{控制器}}$</h5><p>控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。控制器的基本功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。</p>
<p>控制器有硬布线控制器和微程序控制器两种类型（见5.4节)。</p>
<p>控制器由程序计数器（PC)、指令寄存器（IR)、指令译码器、存储器地址寄存器(MAR)、存储器数据寄存器(MDR)、时序系统和微操作信号发生器等组成。</p>
<p>1） $\color{green}{\text{程序计数器}}$ 。用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令（通常）是顺序执行的，所以PC有自增功能。</p>
<p>2） $\color{green}{\text{指令寄存器}}$ 。用于保存当前正在执行的那条指令。</p>
<p>3） $\color{green}{\text{指令译码器}}$ 。仅对操作码字段进行译码，向控制器提供特定的操作信号。</p>
<p>4） $\color{green}{\text{存储器地址寄存器}}$ 。用于存放要访问的主存单元的地址。</p>
<p>5） $\color{green}{\text{存储器数据寄存器}}$ 。用于存放向主存写入的信息或从主存读出的信息。</p>
<p>6） $\color{green}{\text{时序系统}}$ 。用于产生各种时序信号，它们都由统一时钟(CLOCK）分频得到。</p>
<p>7） $\color{green}{\text{微操作信号发生器}}$ 。根据R的内容（指令)、PSW的内容（状态信息）及时序信号产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。</p>
<p>控制器的工作原理是，根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。计算机整机各硬件系统在这些控制信号的控制下协同运行，产生预期的执行结果。</p>
<blockquote>
<p>注意:CPU内部寄存器大致可分为两类:一类是用户可见的寄存器，可对这类寄存器编程，如通用寄存器组、程序状态字寄存器;另一类是用户不可见的寄存器，对用户是透明的，不可对这类寄存器编程，如存储器地址寄存器、存储器数据寄存器、指令寄存器。</p>
</blockquote>
<h3 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h3><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>CPU从主存中 $\color{green}{\text{取出并执行一条指令的时间称为指令周期}}$ ，不同指令的指令周期可能不同。指令周期常用若干机器周期来表示，一个机器周期又包含若干 $\color{yellow}{\text{时钟周期}}$ （也称 $\color{yellow}{\text{节拍}}$ 或T周期，它是CPU操作的最基本单位)。每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。图5.2反映了上述关系。图5.2(a)为定长的机器周期，每个机器周期包含4个节拍（T);图5.2(b)所示为不定长的机器周期，每个机器周期包含的节拍数可以为4个，也可以为3个。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715140540.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715140540.png';" /></details>

<p>对于无条件转移指令JMP X，在执行时不需要访问主存，只包含取指阶段（包括取指和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。</p>
<p>对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后访问主存，取出操作数，所以还需包括间址周期。间址周期介于取指周期和执行周期之间。</p>
<p>当CPU采用中断方式实现主机和I/O设备的信息交换时，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段，又称中断周期。这样，一个完整的 $\color{red}{\text{指令周期}}$ 应包括 $\color{green}{\text{取指}}$ 、 $\color{green}{\text{间址}}$ 、 $\color{green}{\text{执行}}$ 和 $\color{green}{\text{中断}}$ 4个周期，如图5.3所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715140642.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715140642.png';" /></details>

<p>上述4个工作周期都有CPU访存操作，只是访存的目的不同。取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。</p>
<p>为了区别不同的工作周期，在CPU内设置4个标志触发器FE、IND、EX和 INT，它们分别对应取指、间址、执行和中断周期，并以“1”状态表示有效，分别由1→FE、1→ND、1→EX和1→INT这4个信号控制。</p>
<blockquote>
<p>注意:中断周期中的进栈操作是将SP减1，这和传统意义上的进栈操作相反，原因是计算机的堆栈中都是向低地址增加，所以进栈操作是减1而不是加1。</p>
</blockquote>
<h4 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h4><p>数据流是根据指令要求依次访问的数据序列。在指令执行的不同阶段，要求依次访问的数据序列是不同的。而且对于不同的指令，它们的数据流往往也是不同的。</p>
<ul>
<li> $\color{red}{\text{注意到}}$ ：虽然有三种总线，每种寄存器和内存之间的通信，只能经过一种特定的总线</li>
</ul>
<h5 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h5><p>取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中。</p>
<p>取指周期的数据流如图5.4所示。PC 中存放的是指令的地址，根据此地址从内存单元中取出的是指令，并放在指令寄存器IR中，取指令的同时，PC加1。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715140835.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715140835.png';" /></details>

<p>取指周期的数据流向如下:</p>
<p>1）PC①MAR②地址总线 ${\textstyle\unicode{x2462}}$   主存。</p>
<p>2）CU 发出控制信号④控制总线⑤主存。</p>
<p>3）主存⑥数据总线⑦MDR⑧IR（存放指令)。</p>
<p>4）CU发出读命令⑨PC内容加1。</p>
<h5 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h5><p>间址周期的任务是取操作数有效地址。以一次间址为例（见图5.5)，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR.</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715141007.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715141007.png';" /></details>


<p>间址周期的数据流向如下:</p>
<p>1）Ad(IR)（或MDR① MAR②地址总线③主存。</p>
<p>2）CU 发出读命令④控制总线⑤主存。</p>
<p>3）主存⑥数据总线⑦MDR（存放有效地址)。</p>
<p>其中，Ad(IR)表示取出IR中存放的指令字的地址字段。</p>
<h5 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h5><p>执行周期的任务是根据IR中的指令字的操作码和操作数通过 ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。</p>
<h5 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h5><p>中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据，数据流如图5.6所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715141143.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715141143.png';" /></details>

<p>中断周期的数据流向如下:</p>
<p>1）CU控制将SP减1，SP ①  MAR②地址总线③主存。</p>
<p>2）CU发出写命令④控制总线⑤主存。</p>
<p>3）PC⑥ MDR⑦数据总线⑧主存（程序断点存入主存)。</p>
<p>4）CU(中断服务程序的入口地址）⑨PC。</p>
<h4 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h4><p>一个指令周期通常要包括几个时间段(执行步骤)，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。出于性能和硬件成本等考虑，可以选用3种不同的方案来安排指令的执行步骤。</p>
<ul>
<li> $\color{green}{\text{单}}$ 指令周期，周期只有 $\color{green}{\text{一}}$ 种情况</li>
<li> $\color{green}{\text{多}}$ 指令周期，周期有 $\color{green}{\text{多}}$ 种情况</li>
</ul>
<h5 id="单指令周期"><a href="#单指令周期" class="headerlink" title="单指令周期"></a>单指令周期</h5><p>对所有指令都选用 $\color{green}{\text{相同的执行时间}}$ 来完成，称为单指令周期方案。此时每条指令都在固定的时钟周期内完成，指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。因此，指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。</p>
<h5 id="多指令周期"><a href="#多指令周期" class="headerlink" title="多指令周期"></a>多指令周期</h5><p>对不同类型的指令选用不同的执行步骤来完成，称为 $\color{green}{\text{多指令周期方案}}$ 。指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。但可选用不同个数的时钟周期来完成不同指令的执行过程，指令需要几个周期就为其分配几个周期，而不再要求所有指令占用相同的执行时间。</p>
<h5 id="流水线方案"><a href="#流水线方案" class="headerlink" title="流水线方案"></a>流水线方案</h5><p>指令之间可以并行执行的方案，称为流水线方案，其追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程（只在理想情况下才能达到该效果)。这种方案通过在每个时钟周期启动一条指令， $\color{green}{\text{尽量让多条指令同时运行，但各自处在不同的执行步骤中}}$ 。</p>
<h3 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h3><h4 id="数据通路的功能"><a href="#数据通路的功能" class="headerlink" title="数据通路的功能"></a>数据通路的功能</h4><p>数据在功能部件之间传送的路径称为 $\color{red}{\text{数据通路}}$ 。路径上的部件称为 $\color{red}{\text{数据通路部件}}$ ，如 $\color{green}{\text{ALU}}$ 、 $\color{green}{\text{通用寄存器}}$ 、 $\color{green}{\text{状态寄存器}}$ 、 $\color{green}{\text{异常}}$ 和 $\color{green}{\text{中断处理逻辑}}$ 等。数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制。</p>
<p>数据通路中专门进行数据运算的部件称为 $\color{red}{\text{执行部件}}$ 或 $\color{red}{\text{功能部件}}$ 。数据通路由 $\color{red}{\text{控制部件}}$ 控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号，并正确控制指令的执行流程。数据通路的功能是 $\color{green}{\text{实现CPU内部的运算器与寄存器及寄存器之间的数据交换}}$ 。</p>
<h4 id="数据通路的基本结构"><a href="#数据通路的基本结构" class="headerlink" title="数据通路的基本结构"></a>数据通路的基本结构</h4><p>数据通路的基本结构主要有以下几种:</p>
<p>1） $\color{green}{\text{CPU 内部单总线方式}}$ 。将所有寄存器的输入端和输出端都连接到一条公共通路上，这种结构比较简单，但数据传输存在较多的冲突现象，性能较低。连接各部件的总线只有一条时，称为单总线结构;CPU中有两条或更多的总线时，构成双总线结构或多总线结构。图5.7所示为CPU内部总线的数据通路和控制信号。</p>
<p>2） $\color{green}{\text{CPU内部三总线方式}}$ 。将所有寄存器的输入端和输出端都连接到多条公共通路上，相比之下单总线中一个时钟内只允许传一个数据，因而指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。</p>
<p>3） $\color{green}{\text{专用数据通路方式}}$ 。根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大。</p>
<p>在图5.7中，规定各部件用大写字母表示，字母加“in”表示该部件的允许输入控制信号;字母加“out”表示该部件的允许输出控制信号。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715141630.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715141630.png';" /></details>


<blockquote>
<p>注意: $\color{red}{\text{内部总线}}$ 是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线; $\color{red}{\text{系统总线}}$ 是指同一台计算机系统的各部件，如CPU、内存、通道和各类IO接口间互相连接的总线。</p>
</blockquote>
<h5 id="寄存器之间的数据传送"><a href="#寄存器之间的数据传送" class="headerlink" title="寄存器之间的数据传送"></a>寄存器之间的数据传送</h5><p>寄存器之间的数据传送可通过CPU内部总线完成。在图5.7中，某寄存器AX的输出和输入分别由AXout 和AXin控制。这里以PC寄存器为例，把PC内容送至MAR，实现传送操作的流程及控制信号为</p>
<p>PC→Bus   PCout有效，PC内容送总线</p>
<p>Bus→MAR  MARin有效，总线内容送MAR</p>
<h5 id="主存与CPU之间的数据传送"><a href="#主存与CPU之间的数据传送" class="headerlink" title="主存与CPU之间的数据传送"></a>主存与CPU之间的数据传送</h5><p>主存与CPU之间的数据传送也要借助CPU内部总线完成。现以CPU 从主存读取指令为例说明数据在数据通路中的传送过程。实现传送操作的流程及控制信号为</p>
<p>PC→Bus→MAR       PCout 和 MARin有效，现行指令地址→MAR<br>1→R              CU发读命令<br>MEM(MAR)→MDR     MDRin有效<br>MDR→BuS→IR       MDRout和 IRin有效，现行指令→IR</p>
<h5 id="执行算术或逻辑运算"><a href="#执行算术或逻辑运算" class="headerlink" title="执行算术或逻辑运算"></a>执行算术或逻辑运算</h5><p>执行算术或逻辑操作时，由于ALU本身是没有内部存储功能的组合电路，因此如要执行加法运算，相加的两个数必须在 ALU的两个输入端同时有效。图5.7中的暂存器Y即用于该目的。先将一个操作数经CPU内部总线送入暂存器Y保存，Y的内容在 ALU的左输入端始终有效，再将另一个操作数经总线直接送到ALU的右输入端。这样两个操作数都送入了ALU，运算结果暂存在暂存器Z中。</p>
<p>Ad(IR)→Bus→MAR        MDRout和 MARin有效<br>1→R                   CU发读命令<br>MEM→数据线→MDR         操作数从存储器→数据线→MDR<br>MDR→Bus→Y             MDRout 和 Yin有效，操作数→Y<br>(ACC)+(Y)→Z           ACCout 和 ALUin有效，CU向ALU发加命令，结果→Z<br>Z→ACC                 Zout和 ACCin有效，结果→ACC</p>
<p>数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它关系着微操作信号形成部件的设计。</p>
<h3 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h3><h4 id="控制器的结构和功能"><a href="#控制器的结构和功能" class="headerlink" title="控制器的结构和功能"></a>控制器的结构和功能</h4><p>从图5.8可以看到计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起，其中点画线框内的是控制器部件。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715150655.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715150655.png';" /></details>

<p>现对其主要连接关系简单说明如下:</p>
<p>1）运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据。2）输入设备和输出设备通过接口电路与总线相连接。</p>
<p>3）内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据。</p>
<p>4）控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号。控制器是计算机系统的指挥中心，控制器的主要功能有:</p>
<p>1)从主存中取出一条指令，并指出下一条指令在主存中的位置。</p>
<p>2）对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</p>
<p>3）指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。</p>
<p>根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器，两类控制器中的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的。</p>
<h4 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h4><p>硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。它由复杂的组合逻辑门电路和一些触发器构成，因此又称组合逻辑控制器。</p>
<ul>
<li> $\color{green}{\text{组合逻辑电路}}$ 和 $\color{green}{\text{时序逻辑电路}}$ </li>
</ul>
<h5 id="硬布线控制单元图"><a href="#硬布线控制单元图" class="headerlink" title="硬布线控制单元图"></a>硬布线控制单元图</h5><p>指令的操作码是决定控制单元发出不同操作命令(控制信号）的关键。为了简化控制单元(CU)的逻辑，将指令的操作码译码和节拍发生器从CU分离出来，便可得到简化的控制单元图，如图5.9所示。</p>
<p>CU的输入信号来源如下:</p>
<p>1）经指令译码器译码产生的指令信息。现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，因此指令的 $\color{green}{\text{操作码}}$ 字段是控制单元的输入信号，它与时钟配合产生不同的控制信号。</p>
<p>2)时序系统产生的机器周期信号和节拍信号。为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制，即一个时钟脉冲使控制单元发送一个操作命令，或发送一组需要同时执行的操作命令。</p>
<p>3）来自执行单元的反馈信息即标志。控制单元有时需依赖CPU当前所处的状态产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为负来产生不同的控制信号。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715150917.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715150917.png';" /></details>

<p>图5.9 中，节拍发生器产生各机器周期中的节拍信号，使不同的微操作命令$C_i$(控制信号）按时间的先后发出。个别指令的操作不仅受操作码控制，还受状态标志控制，因此CU的输入来自操作码译码电路ID、节拍发生器及状态标志，其输出到CPU内部或外部控制总线上。</p>
<blockquote>
<p>注意:控制单元还接收来自系统总线（控制总线）的控制信号，如中断请求、DMA请求。</p>
</blockquote>
<h5 id="硬布线控制器的时序系统及微操作"><a href="#硬布线控制器的时序系统及微操作" class="headerlink" title="硬布线控制器的时序系统及微操作"></a>硬布线控制器的时序系统及微操作</h5><p>1）时钟周期。用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。在每个节拍内机器可完成一个或几个需同时执行的操作。</p>
<p>2）机器周期。机器周期可视为所有指令执行过程中的一个基准时间。不同指令的操作不同，指令周期也不同。访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期。在存储字长等于指令字长的前提下，取指周期也可视为机器周期。</p>
<p>在一个机器周期里可完成若干微操作，每个微操作都需一定的时间，可用时钟信号来控制产生每个微操作命令。</p>
<p>3）指令周期。指令周期详见5.2.1节。</p>
<p>4）微操作命令分析。控制单元具有发出各种操作命令（控制信号）序列的功能。这些命令与指令有关，而且必须按一定次序发出，才能使机器有序地工作。</p>
<p>执行程序的过程中，对于不同的指令，控制单元需发出各种不同的微操作命令。一条指令分为3个工作周期:取指周期、间址周期和执行周期。下面分析各个子周期的微操作命令。</p>
<!-- 
①取指周期的微操作命令。无论是什么指令，取指周期都需有下列微操作命令:

PC→MAR      现行指令地址→MAR

1→R         命令存储器读

M(MAR)→MDR  现行指令从存储器中读至MDR

MDR→IR      现行指令→IR

OP(IR)→CU   指令的操作码→CU译码

(PC)+1→PC   形成下一条指令的地址

②间址周期的微操作命令。间址周期完成取操作数地址的任务，具体微操作命令如下:

Ad(IR)→MAR   将指令字中的地址码（形式地址）→MAR

1→R          命令存储器读

M(MAR)→MDR   将有效地址从存储器读至MDR

③执行周期的微操作命令。执行周期的微操作命令视不同指令而定。

a．非访存指令。

CLA  清ACC     0→ACC

COM  取反      $\overline{ACC}$→ACC

SHR  算术右移  L(ACC)→R(ACC)，$ACC_0$→$ACC_0$

CSL  循环左移  R(ACC)→L(ACC)，$ACC_0$→$ACC_n$

STP  停机指令  0→G

b.访存指令

ADD X    加法指令  Ad(IR)→MAR

1→R

M(MAR)→MDR

(ACC)+ (MDR)→ACC

STA X    存数指令  Ad(IR)→MAR

1→w

ACC→MDR

MDR→M(MAR)

LDAX     取数指令  Ad(IR)→MAR

1→R

M(MAR)→MDR

MDR→ACC

c.转移指令

JMP X   无条件转移          Ad(IR)→PC

BAN X   条件转移（负则转)   $A_0 \cdot$Ad(IR)+$\overline{A_0} \cdot$(PC)→PC -->

<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210930183346.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210930183346.png';" /></details>


<h5 id="CPU-的控制方式"><a href="#CPU-的控制方式" class="headerlink" title="CPU 的控制方式"></a>CPU 的控制方式</h5><p>控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程。由于不同指令所对应的微操作数及复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。主要有以下3种控制方式。</p>
<p>1） $\color{green}{\text{同步控制方式}}$ 。所谓同步控制方式，是指系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号。通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。同步控制方式的优点是控制电路简单，缺点是运行速度慢。</p>
<p>2） $\color{green}{\text{异步控制方式}}$ 。异步控制方式不存在基准时标信号，各部件按自身固有的速度工作，通过应答方式进行联络。异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。</p>
<p>3） $\color{green}{\text{联合控制方式}}$ 。联合控制方式是介于同步、异步之间的一种折中。这种方式对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法。</p>
<h5 id="硬布线控制单元设计步骤"><a href="#硬布线控制单元设计步骤" class="headerlink" title="硬布线控制单元设计步骤"></a>硬布线控制单元设计步骤</h5><p>硬布线控制单元设计步骤包括:</p>
<p>1）列出微操作命令的操作时间表。先根据微操作节拍安排，列出微操作命令的操作时间表。操作时间表中包括各个机器周期、节拍下的每条指令完成的微操作控制信号。表5.1列出了CLA、COM、SHR等10条机器指令微操作命令的操作时间表。表中FE、IND 和EX为CPU 工作周期标志，$T_0～T_2$,为节拍，Ⅰ为间址标志，在取指周期的$T_2$时刻，若测得I=1，则IND触发器置“1”，标志进入间址周期;若I=0，则EX触发器置“1”，标志进入执行周期。同理，在间址周期的$T_2$时刻，若测得IND=0(表示一次间接寻址)，则EX触发器置“1”，进入执行周期;若测得IND= 1(表示多次间接寻址)，则继续间接寻址。在执行周期的$T_2$时刻，CPU 要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则INT触发器置“1”，标志进入中断周期。表中未列出INT触发器置“1”的操作和中断周期的微操作。表中第一行对应10条指令的操作码，代表不同的指令。若某指令有表中所列出的微操作命令，其对应的单元格内为1。</p>
<p>2）进行微操作信号综合。在列出微操作时间表后，即可对它们进行综合分析、归类，根据<br>微操作时间表可写出各微操作控制信号的逻辑表达式并进行适当的简化。表达式一般包括下列因素:</p>
<p>微操作控制信号=机器周期$\wedge$节拍$\wedge$脉冲$\wedge$操作码$\wedge$机器状态条件</p>
<p>根据表5.1便可列出每个微操作命令的初始逻辑表达式，经化简、整理可获得能用现有门电路实现的微操作命令逻辑表达式。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716142423.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716142423.png';" /></details>

<p>例如，根据表5.1可写出 M(MAR)–MDR微操作命令的逻辑表达式:</p>
<p>M(MAR)→MDR</p>
<p>=FE$\cdot T_1$+IND$\cdot T_1$;(ADD + STA + LDA + JMP + BAN)+EX$\cdot T_1$;(ADD +LDA)=$T_1${FE+ IND(ADD + STA+ LDA＋JMP+BAN)+EX(ADD +LDA)}</p>
<p>式中，ADD、STA、LDA、JMP、BAN均来自操作码译码器的输出。</p>
<p>3）画出微操作命令的逻辑图。根据逻辑表达式可画出对应每个微操作信号的逻辑电路图，<br>并用逻辑门电路实现。</p>
<p>例如，M(MAR)-MDR的逻辑表达式所对应的逻辑图如图5.10 所示，图中未考虑门的扇入系数。</p>
<blockquote>
<p>$\color{red}{\text{Q}}$ :什么是扇入系数</p>
</blockquote>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716142756.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716142756.png';" /></details>


<h4 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h4><p>微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。</p>
<h5 id="微程序控制的基本概念"><a href="#微程序控制的基本概念" class="headerlink" title="微程序控制的基本概念"></a>微程序控制的基本概念</h5><p>微程序设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。目前，大多数计算机都采用微程序设计技术。</p>
<p>微程序设计技术涉及的基本术语如下:</p>
<p>1） $\color{green}{\text{微命令与微操作}}$ 。一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作。在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为 $\color{red}{\text{微命令}}$ ，它是构成控制序列的最小单位。例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。</p>
<p>微命令有相容性和互斥性之分。相容性微命令是指那些可以同时产生、共同完成某一些微操作的微命令;而互斥性微命令是指在机器中不允许同时出现的微命令。相容和互斥都是相对的，一个微命令可以和一些微命令相容，和另一些微命令互斥。</p>
<p>注意:在组合逻辑控制器中也存在微命令与微操作这两个概念，它们并非只是微程序控制器的专有概念。</p>
<p>2） $\color{green}{\text{微指令与微周期}}$ 。微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称为微地址。一条微指令通常至少包含两大部分信息:</p>
<p>①  $\color{green}{\text{操作控制字段}}$ ，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。</p>
<p>${\textstyle\unicode{x2461}}$   $\color{green}{\text{顺序控制字段}}$ ，又称微地址码字段，用于控制产生下一条要执行的微指令地址。微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p>
<p>3）主存储器与控制存储器。主存储器用于存放程序和数据，在CPU外部，用RAM 实现;控制存储器（CM）用于存放微程序，在CPU内部，用ROM实现。</p>
<p>4）程序与微程序。 $\color{red}{\text{程序}}$ 是 $\color{green}{\text{指令的有序集合}}$ ，用于完成特定的功能; $\color{red}{\text{微程序}}$ 是 $\color{green}{\text{微指令的有序集合}}$ ，<strong>一条指令的功能由一段微程序来实现</strong>。</p>
<p>微程序和程序是两个不同的概念。微程序是由微指令组成的，用于描述机器指令。微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，计算机系统中微程序的结构和功能是透明的，无须知道。而程序最终由机器指令组成，是由软件设计人员事先编制好并存放在主存或辅存中的。</p>
<p>读者应注意区分以下寄存器:</p>
<p>①地址寄存器(MAR)。用于存放主存的读/写地址。</p>
<p>${\textstyle\unicode{x2461}}$  微地址寄存器(CMAR)。用于存放控制存储器的读/写微指令的地址。</p>
<p>③指令寄存器（IR)。用于存放从主存中读出的指令。</p>
<p>④微指令寄存器（CMDR或uIR)。用于存放从控制存储器中读出的微指令。</p>
<h5 id="微程序控制器组成和工作过程"><a href="#微程序控制器组成和工作过程" class="headerlink" title="微程序控制器组成和工作过程"></a>微程序控制器组成和工作过程</h5><h6 id="微程序控制器的基本组成"><a href="#微程序控制器的基本组成" class="headerlink" title="微程序控制器的基本组成"></a>微程序控制器的基本组成</h6><p>图5.11所示为一个微程序控制器的基本结构，主要画出了微程序控制器比组合逻辑控制器多出的部件，包括:</p>
<p>${\textstyle\unicode{x2460}}$  控制存储器。它是微程序控制器的核心部件，用于存放各指令对应的微程序，控制存储器可用只读存储器ROM构成。</p>
<p>${\textstyle\unicode{x2461}}$ 微指令寄存器。用于存放从CM中取出的微指令，它的位数同微指令字长相等。</p>
<p>${\textstyle\unicode{x2462}}$ 微地址形成部件。用于产生初始微地址和后继微地址,以保证微指令的连续执行。</p>
<p>${\textstyle\unicode{x2463}}$ 微地址寄存器。接收微地址形成部件送来的微地址，为在CM中读取微指令作准备。</p>
<details><summary>图5.11微程序控制器的基本结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210930184630.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210930184630.png';" /></details>

<h6 id="微程序控制器的工作过程"><a href="#微程序控制器的工作过程" class="headerlink" title="微程序控制器的工作过程"></a>微程序控制器的工作过程</h6><p>微程序控制器的工作过程实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可以描述如下:</p>
<p>${\textstyle\unicode{x2460}}$  执行取微指令公共操作。具体的执行是:在机器开始运行时，自动将取指微程序的入口地址送入CMAR，并从CM 中读出相应的微指令送入CMDR。取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。</p>
<p>${\textstyle\unicode{x2461}}$  由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地<br>址，并送入CMAR。</p>
<p>③从CM中逐条取出对应的微指令并执行。</p>
<p>④执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第①<br>步，以完成取下一条机器指令的公共操作。</p>
<p>以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕。</p>
<h6 id="微程序和机器指令"><a href="#微程序和机器指令" class="headerlink" title="微程序和机器指令"></a>微程序和机器指令</h6><p>通常，一条机器指令对应一个微程序。由于任何一条机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。</p>
<p>此外，也可编出对应间址周期的微程序和中断周期的微程序。这样，控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等共用的微程序数。</p>
<blockquote>
<p>注意:若指令系统中具有$n$种机器指令，则控制存储器中的微程序数至少是$n +1 $(1为公共的取指微程序)。</p>
</blockquote>
<h5 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h5><p>微指令的编码方式又称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。</p>
<h6 id="直接编码（直接控制）方式"><a href="#直接编码（直接控制）方式" class="headerlink" title="直接编码（直接控制）方式"></a>直接编码（直接控制）方式</h6><p>微指令的直接编码方式如图5.12所示。直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0即可。每个微命令对应并控制数据通路中的一个微操作。</p>
<p>这种编码的优点是简单、直观，执行速度快，操作并行性好;缺点是微指令字长过长，$n$个微命令就要求微指令的操作字段有$n$位，造成控制存储器容量极大。</p>
<details><summary>图5.12微指令的直接编码方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716143824.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716143824.png';" /></details>


<h6 id="字段直接编码方式"><a href="#字段直接编码方式" class="headerlink" title="字段直接编码方式"></a>字段直接编码方式</h6><p>将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式，如图5.13所示。</p>
<p>这种方式可以缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢。</p>
<p>微命令字段分段的原则:</p>
<p>${\textstyle\unicode{x2460}}$  互斥性微命令分在同一段内，相容性微命令分在不同段内。</p>
<p>${\textstyle\unicode{x2461}}$ 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。</p>
<p>${\textstyle\unicode{x2462}}$  一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。</p>
<details><summary>图5.13微指令的字段直接编码方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210930185025.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210930185025.png';" /></details>

<h6 id="字段间接编码方式"><a href="#字段间接编码方式" class="headerlink" title="字段间接编码方式"></a>字段间接编码方式</h6><p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐式编码。这种方式可进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。</p>
<h5 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h5><p>后继微地址的形成主要有以下两大基本类型:</p>
<p>1)直接由微指令的下地址字段指出。微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称断定方式。</p>
<p>2）根据机器指令的操作码形成。机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</p>
<p>实际上，微指令序列地址的形成方式还有以下几种:</p>
<p>①增量计数器法，即(CMAR)+1→CMAR，适用于后继微指令的地址连续的情况。</p>
<p>${\textstyle\unicode{x2461}}$  根据各种标志决定微指令分支转移的地址。</p>
<p>③通过网络测试形成。</p>
<p>④由硬件直接产生微程序入口地址。</p>
<p>电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向CMAR输入微指令的地址，这个地址即为取指周期微程序的入口地址。</p>
<h5 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h5><p>微指令格式与微指令的编码方式有关，通常分水平型微指令和垂直型微指令两种。</p>
<p>1)水平型微指令。从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令。水平型微指令的基本指令格式如图5.14所示，指令字中的一位对应-一个控制信号，有输出时为1，否则为0。一条水平型微指令定义并执行几种并行的基本操作。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716144416.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716144416.png';" /></details>

<p>水平型微指令的优点是微程序短，执行速度快;缺点是微指令长，编写微程序较麻烦。</p>
<p>2）垂直型微指令。垂直型微指令的特点是采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能，其基本的指令格式如图5.15所示。一条垂直型微指令只能定义并执行一种基本操作。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716144502.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716144502.png';" /></details>

<p>垂直型微指令格式的优点是微指令短、简单、规整，便于编写微程序;缺点是微程序长，执行速度慢，工作效率低。</p>
<p>3）混合型微指令。在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写;微程序也不长，执行速度加快。</p>
<p>4）水平型微指令和垂直型微指令的比较如下:</p>
<p>${\textstyle\unicode{x2460}}$  水平型微指令并行操作能力强、效率高、灵活性强;垂直型微指令则较差。</p>
<p>${\textstyle\unicode{x2461}}$ 水平型微指令执行一条指令的时间短;垂直型微指令执行的时间长。</p>
<p>${\textstyle\unicode{x2462}}$ 由水平型微指令解释指令的微程序，具有微指令字较长但微程序短的特点;垂直型<br>微指令则与之相反，其微指令字较短而微程序长。</p>
<p>④水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对容易掌握。</p>
<h5 id="微程序控制单元的设计步骤"><a href="#微程序控制单元的设计步骤" class="headerlink" title="微程序控制单元的设计步骤"></a>微程序控制单元的设计步骤</h5><p>微程序控制单元设计的主要任务是编写各条机器指令所对应的微程序。具体的设计步骤如下:</p>
<p>1）写出对应机器指令的微操作命令及节拍安排。无论是组合逻辑设计还是微程序设计，对应相同的CPU 结构，两种控制单元的微操作命令和节拍安排都是极相似的。如微程序控制单元在取指阶段发出的微操作命令及节拍安排如下:</p>
<p>$T_0$    PC→MAR，1→R<br>$T_1$    M(MAR)→MDR，(PC)+1-→PC<br>$T_2$    MDR→IR，OP(IR)→微地址形成部件</p>
<p>与硬布线控制单元相比，只在$T_2$节拍内的微操作命令不同。微程序控制单元在$T_2$节拍内要将指令的操作码送至微地址形成部件，即OP(IR)→微地址形成部件，以形成该条机器指令的微程序首地址。而硬布线控制单元在$T_2$,节拍内要将指令的操作码送至指令译码器，以控制CU 发出相应的微命令，即 OP(IR)→ID。</p>
<p>若把一个节拍T内的微操作安排在一条微指令中完成，上述微操作对应3条微指令。但由于微程序控制的所有控制信号都来自微指令，而微指令又存在控制存储器中，因此欲完成上述这些微操作，必须先将微指令从控制存储器中读出，即必须先给出这些微指令的地址。在取指微程序中，除第一条微指令外，其余微指令的地址均由上一条微指令的下地址字段直接给出，因此上述每条微指令都需增加一个将微指令下地址字段送至CMAR 的微操作，记为 Ad(CMDR)→CMAR。取指微程序的最后一条微指令，其后继微指令的地址是由微地址形成部件形成的，即微地址形成部件→CMAR。为了反映该地址与操作码有关，因此记为OP(IR)→微地址形成部件→CMAR。</p>
<p>综上所述，考虑到需要形成后继微指令地址，上述分析的取指操作共需6条微指令完成:</p>
<p>$T_0$   PC→MAR，1→R<br>$T_1$   Ad(CMDR)→CMAR<br>$T_2$   M(MAR)→MDR，(PC)+1→PC<br>$T_3$   Ad(CMDR)→CMAR<br>$T_4$   MDR→IR<br>$T_5$   OP(IR)→微地址形成部件→CMAR</p>
<p>执行阶段的微操作命令及节拍安排，分配原则类似。与硬布线控制单元微操作命令的节拍安排相比，多了将下一条微指令地址送至CMAR 的微操作命令，即 Ad(CMDR)→CMAR。其余的微操作命令与硬布线控制单元相同。</p>
<blockquote>
<p>注意:这里为了理解，应将微指令和机器指令相联系，因为每执行完一条微指令后要得到下一条微指令的地址。</p>
</blockquote>
<p>2）确定微指令格式。微指令格式包括微指令的编码方式、后继微指令地址的形成方式和微指令字长等。</p>
<p>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。由微指令数确定微指令的顺序控制字段的位数。最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。</p>
<p>3）编写微指令码点。根据操作控制字段每位代表的微操作命令，编写每条微指令的码点。</p>
<h5 id="动态微程序设计和毫微程序设计"><a href="#动态微程序设计和毫微程序设计" class="headerlink" title="动态微程序设计和毫微程序设计"></a>动态微程序设计和毫微程序设计</h5><p>1）动态微程序设计。在一台微程序控制的计算机中，假如能根据用户的要求改变微程序，则这台机器就具有动态微程序设计功能。</p>
<p>动态微程序的设计需要可写控制寄存器的支持，否则难以改变微程序的内容。实现动态微程序设计可采用可擦除可编程只读存储器（EPROM)。</p>
<p>2）毫微程序设计。在普通的微程序计算机中，从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制。</p>
<p>若硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的，这个第二级控制存储器就称为毫微存储器，直接控制硬件的是毫微微指令。</p>
<h5 id="硬布线和微程序控制器的特点"><a href="#硬布线和微程序控制器的特点" class="headerlink" title="硬布线和微程序控制器的特点"></a>硬布线和微程序控制器的特点</h5><p>1）硬布线控制器的特点。硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快;缺点是由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，一旦设计完成，就不可能通过其他额外修改添加新功能。</p>
<p>2）微程序控制器的特点。微程序控制器的优点是同组合逻辑控制器相比，微程序控制器具有规整性、灵活性、可维护性等一系列优点;缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响速度。</p>
<p>为便于比较，下面以表格的形式对比二者的不同,见表5.2。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716150404.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716150404.png';" /></details>




<h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><h4 id="指令流水线的基本概念"><a href="#指令流水线的基本概念" class="headerlink" title="指令流水线的基本概念"></a>指令流水线的基本概念</h4><p>一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术。</p>
<h5 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a>指令流水的定义</h5><p>根据计算机的不同，具体的分法也不同。例如，图5.16把一条指令的执行过程分为如下 $\color{red}{\text{三}}$ 个阶段（或过程)。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716181707.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716181707.png';" /></details>


<p> $\color{green}{\text{取指}}$ :根据PC内容访问主存储器，取出一条指令送到IR中。</p>
<p> $\color{green}{\text{分析}}$ :对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA，并从有效地址EA中取出操作数。</p>
<p> $\color{green}{\text{执行}}$ :根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。</p>
<p>当多条指令在处理器中执行时,可以采用以下两种方式。</p>
<p>1）顺序执行方式。前一条指令执行完后，才启动下一条指令，如图5.17(a)所示。假设取指、分析、执行三个阶段的时间都相等，用t表示，顺序执行n条指令所用时间T为</p>
<p>$$<br>T=3nt<br>$$</p>
<p>传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。其优点是控制简单，硬件代价小;缺点是执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。例如取指时内存是忙碌的，而指令执行部件是空闲的。</p>
<p>2）流水线执行方式。为了提高指令的执行速度，可以把取k＋1条指令提前到分析第k条指令的期间完成，而将分析第k＋1条指令与执行第k条指令同时进行，如图5.17(b)所示。采用此种方式时，执行n条指令所用的时间为</p>
<p>$$<br>T=(2 + n)t<br>$$</p>
<p>与顺序执行方式相比，采用流水线执行方式能使指令的执行时间缩短近2/3，各功能部件的利用率明显提高。但为此需要付出硬件上较大开销的代价，控制过程也更复杂。在理想情况下，每个时钟周期都有一条指令进入流水线，处理机中同时有3条指令在执行，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即 CPI）都为1。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716182135.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716182135.png';" /></details>

<p>为了进一步获得更高的执行速度，还可以将流水段进一步细分。如将一条指令的执行过程分为 $\color{green}{\text{取指令}}$ 、 $\color{green}{\text{指令译码}}$ 、 $\color{green}{\text{执行}}$ 和 $\color{green}{\text{写回}}$ 四个阶段，就形成了 $\color{red}{\text{四级流水}}$ ;还可进一步分为 $\color{green}{\text{取指令(IF)}}$ 、 $\color{green}{\text{指令译码(ID)}}$ 、 $\color{green}{\text{取操作数(OF)}}$ 、 $\color{green}{\text{执行(EX)}}$ 和 $\color{green}{\text{写回(WB)}}$ ，就形成了 $\color{red}{\text{五级流水}}$ 。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ask.csdn.net/questions/692846">各缩写的全称</a></li>
<li>IF：instruction fetch</li>
<li>ID：instruction decode</li>
<li>EX：execute</li>
<li>M：memory</li>
<li>WB：write back</li>
</ul>
<p>流水线设计的原则是如下:指令流水段个数以最复杂指令所用的功能段个数为准;流水段的长度以最复杂的操作所花的时间为准。假设某条指令的3个阶段所花的时间分别如下。①取指:200ps;分析:100ps;③执行: 150ps。不考虑数据通路中的各种延迟，该指令的总执行时间为450ps。按照流水线设计原则，每个流水段的长度为200ps，所以每条指令的执行时间为600ps，反正比串行执行时增加了150ps。因此，流水线方式并不能缩短一条指令的执行时间，但是，对于整个程序来说，可以大大增加指令执行的吞吐率。</p>
<p>为了利于实现指令流水线，指令集应具有如下特征:</p>
<p>1）指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花时间长短不易，使取指部件极其复杂，且也不利于指令译码。</p>
<p>2）指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。</p>
<p>3）采用Load/Store 指令，其他指令（如运算指令）都不能访问存储器，这样可把Load/Store指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。</p>
<p>4）数据和指令在存储器中“对齐”存放。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。</p>
<h5 id="流水线的表示方法"><a href="#流水线的表示方法" class="headerlink" title="流水线的表示方法"></a>流水线的表示方法</h5><p>通常用时空图来直观地描述流水线的工作过程，如图5.18所示。</p>
<p>在时空图中，横坐标表示时间，即输入流水线中的各个任务在流水线中所经过的时间。流水线中各个流水段的执行时间都相等时，横坐标就被分割成相等长度的时间段。纵坐标表示空间，即流水线的每个流水段（对应各执行部件)。</p>
<p>在图5.18中，第一条指令$\text{I}_1$在时刻$t_0$进入流水线，在时刻$t_4$流出流水线。第二条指令$\text{I}——2$在时刻$t_1$进入流水线，在时刻$t_5$流出流水线。以此类推，每经过一个$\Delta t$时间，便有一条指令进入流水线，从时刻t4开始有一条指令流出流水线。</p>
<p>从图5.18中可以看出，当$t_8$ =$8\Delta t$ 时，流水线上便有5条指令流出。若采用串行方式执行指令，当$t_8$ =$8\Delta t$时，只能执行2条指令，可见使用流水线方式成倍地提高了计算机的速度。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716182718.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716182718.png';" /></details>


<h5 id="流水线方式的特点"><a href="#流水线方式的特点" class="headerlink" title="流水线方式的特点"></a>流水线方式的特点</h5><p>与传统的串行执行方式相比，采用流水线方式具有如下特点:</p>
<p>1）把一个任务（一条指令或一个操作）分解为几个有联系的子任务，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短程序的执行时间。</p>
<p>2）流水线每个功能段部件后面都要有一个缓冲寄存器，或称锁存器，其作用是保存本流水段的执行结果，供给下一流水段使用。</p>
<p>3）流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流。</p>
<p>4)只有连续不断地提供同一种任务时才能发挥流水线的效率，所以在流水线中处理的必须是连续任务。在采用流水线方式工作的处理机中，要在软件和硬件设计等多方面尽量为流水线提供连续的任务。</p>
<p>5）流水线需要有装入时间和排空时间。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。</p>
<h4 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h4><p>按照不同的分类标准，可以把流水线分成多种不同的种类。下面从几个不同的角度介绍流水线的基本分类方法。</p>
<h5 id="部件功能级、处理机级和处理机间级流水线"><a href="#部件功能级、处理机级和处理机间级流水线" class="headerlink" title="部件功能级、处理机级和处理机间级流水线"></a>部件功能级、处理机级和处理机间级流水线</h5><p>根据流水线使用级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。</p>
<p> $\color{red}{\text{部件功能级流水}}$ 将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加及结果规格化等4个子过程。</p>
<p>$\color{red}{\text{处理机级流水}}$ 把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存和写回5个子过程。</p>
<p>处理机间流水是一种宏流水，其中每个处理机完成某一专门任务，各个处理机得到的结果需存放在与下一个处理机共享的存储器中。</p>
<h5 id="单功能流水线和多功能流水线"><a href="#单功能流水线和多功能流水线" class="headerlink" title="单功能流水线和多功能流水线"></a>单功能流水线和多功能流水线</h5><p>按可以完成的功能，流水线可分为单功能流水线和多功能流水线。</p>
<p>$\color{red}{\text{单功能流水线}}$ 是指只能实现一种固定的专门功能的流水线; $\color{red}{\text{多功能流水线}}$ 是指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。</p>
<h5 id="动态流水线和静态流水线"><a href="#动态流水线和静态流水线" class="headerlink" title="动态流水线和静态流水线"></a>动态流水线和静态流水线</h5><p>按同一时间内各段之间的连接方式，流水线可分为静态流水线和动态流水线。</p>
<p>$\color{red}{\text{静态流水线}}$ 指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</p>
<p>$\color{red}{\text{动态流水线}}$ 指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</p>
<h5 id="线性流水线和非线性流水线"><a href="#线性流水线和非线性流水线" class="headerlink" title="线性流水线和非线性流水线"></a>线性流水线和非线性流水线</h5><p>按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。</p>
<p> $\color{red}{\text{线性流水线}}$ 中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。 $\color{red}{\text{非线性流水线}}$ 存在反馈回路，从输入到输出的过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</p>
<p>流水线的每个子过程由专用的功能段实现，各功能段所需的时间应尽量相等。否则，时间长的功能段将成为流水线的瓶颈。</p>
<h4 id="影响流水线的因素"><a href="#影响流水线的因素" class="headerlink" title="影响流水线的因素"></a>影响流水线的因素</h4><p>在指令流水线中，可能会遇到一些情况使得流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象称为流水线冲突（冒险)。导致流水线冲突的原因主要有3种: $\color{green}{\text{资源冲突}}$ (结构冒险)、 $\color{green}{\text{数据冲突}}$ （数据冒险）和 $\color{green}{\text{控制冲突}}$ （控制冒险)。</p>
<h5 id="资源冲突"><a href="#资源冲突" class="headerlink" title="资源冲突"></a>资源冲突</h5><p>由于多条指令在同一时刻争用同一资源而形成的冲突称为资源冲突，即由硬件资源竞争造成的冲突，有以下两种解决办法:</p>
<p>1）前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期。</p>
<p>2）单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行。</p>
<p>事实上，现代计算机都引入了Cache机制，而L1 Cache通常采用数据Cache和指令Cache分离的方式，因而也就避免了资源冲突的发生。</p>
<h5 id="数据冲突"><a href="#数据冲突" class="headerlink" title="数据冲突"></a>数据冲突</h5><p>在一个程序中，下一条指令会用到当前指令计算出的结果，此时这两条指令即为数据冲突。当多条指令重叠处理时就会发生冲突，数据冲突可分为三类（结合综合题3理解):</p>
<p>1） $\color{green}{\text{写后读}}$ (Read After Write，RAW)相关:表示当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据。否则，先读后写，读到的就是错误（旧）数据。</p>
<p>2） $\color{green}{\text{读后写}}$ (Write After Read，WAR）相关:表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误（新）数据。</p>
<p>3） $\color{green}{\text{写后写}}$ (Write After Write，WAW)相关:表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值。解决的办法有以下几种:</p>
<p>1）把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为硬件阻塞(stall）和软件插入“NOP”指令两种方法。</p>
<p>2）设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令的 ALU的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这称为数据旁路技术。</p>
<p>3）通过编译器对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关。</p>
<p>解决的办法有以下几种:</p>
<p>1）把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为硬件阻塞(stall）和软件插入“NOP”指令两种方法。</p>
<p>2）设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令的 ALU的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这称为数据旁路技术。</p>
<p>3）通过编译器对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关。</p>
<h5 id="控制冲突"><a href="#控制冲突" class="headerlink" title="控制冲突"></a>控制冲突</h5><p>一条指令要确定下一条指令的位置，例如在执行转移、调用或返回等指令时会改变PC值，而造成断流,会引起控制冒险。解决的办法有以下几种:</p>
<p>1）对转移指令进行分支预测，尽早生成转移目标地址。分支预测分为简单（静态）预测和动态预测。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率。</p>
<p>2）预取转移成功和不成功两个控制流方向上的目标指令。</p>
<p>3）加快和提前形成条件码。</p>
<p>4）提高转移方向的猜准率。</p>
<blockquote>
<p>注意:Cache缺失的处理过程也会引起流水线阻塞。在不过多增加硬件成本的情况下，如何尽可能地提高指令流水线的运行效率是选用指令流水线技术必须解决的关键问题。</p>
</blockquote>
<h4 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h4><ul>
<li>$\color{red}{\text{Q}}$ ：没怎么看懂</li>
</ul>
<p>衡量流水线性能的主要指标有吞吐率、加速比和效率。下面以线性流水线为例分析流水线的主要性能指标，其分析方法和有关公式也适用于非线性流水线。</p>
<p>$$<br>TP=\dfrac{n}{T_k}<br>$$</p>
<p>式中，$n$是任务数，$T_k$是处理完$n$个任务所用的时间。下面以流水线中各段执行时间都相等为例来讨论流水线的 $\color{green}{\text{吞吐率}}$ 。</p>
<p>图5.19所示为各段执行时间均相等的流水线时空图。在输入流水线中的任务连续的理想情况下，一条k段线性流水线能够在k+n-1个时钟周期内完成n个任务。在图5.19中，k为流水线的段数，△t为时钟周期。得出流水线的实际吞吐率为</p>
<p>$$<br>TP = \dfrac{n}{(k+n-1) \Delta}  t<br>$$</p>
<p>连续输入的任务数$n\to \infty$时，得最大吞吐率为$TP_{max}= 1/\Delta t$ 。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716183823.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716183823.png';" /></details>

<p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比，称为流水线的 $\color{green}{\text{加速比}}$ 。</p>
<p>设$T_0$表示不使用流水线时的执行时间，即顺序执行所用的时间;$T_k$表示使用流水线时的执行时间，则计算流水线加速比(S)的基本公式为</p>
<p>$$<br>S=\dfrac{T_0}{T_k}<br>$$</p>
<p>若流水线各段执行的时间都相等，则一条k段流水线完成n个任务所需的时间为$T_k=(k + n-1)\Delta t$。而不使用流水线，即顺序执行$n$个任务时，所需的时间为$T_0= kn\Delta t$。将$T_0$和$T_k$值代入上式，得实际加速比为</p>
<p>$$<br>S=\dfrac{kn\Delta t}{(k+n-1)\Delta t}=\dfrac{kn}{(k+n-1)}<br>$$</p>
<h5 id="流水线的效率"><a href="#流水线的效率" class="headerlink" title="流水线的效率"></a>流水线的效率</h5><p>流水线的设备利用率称为流水线的 $\color{green}{\text{效率}}$ 。在时空图上，流水线的效率定义为完成$n$个任务占用的时空区有效面积，与$n$ 个任务所用的时间及$k$ 个流水段所围成的时空区总面积之比。因此，流水线的效率包含了时间和空间两个因素。</p>
<ul>
<li> $\color{red}{\text{Q}}$ ：啥玩意儿为啥还有空间的说法</li>
</ul>
<p>$n$个任务占用的时空区有效面积就是顺序执行n个任务所使用的总时间$T_0$，而n 个任务所用的时间与k个流水段所围成的时空区总面积为 $kT_k$，其中$T_k$是流水线完成n个任务所使用的总时间，因此计算流水线效率（E)的一般公式为</p>
<p>$$<br>E = \dfrac{n\text{个任务占用的时空区有效面积}}{n个任务所用的时间与k个流水段所围成的时空区总面积} = \dfrac{T_0}{kT_k}<br>$$</p>
<p>若流水线的各段执行时间相等，上式中的分子部分是n 个任务实际占用的有效面积，分母部分是完成n个任务所用的时间与k个流水段所围成的总面积。因此，通过时空图来计算流水线的效率非常方便。</p>
<p>流水线的各段执行时间均相等，当连续输入的任务数$n \to \infty$时，最高效率为$E_{max}=1$。</p>
<h4 id="超标量流水线的基本概念"><a href="#超标量流水线的基本概念" class="headerlink" title="超标量流水线的基本概念"></a>超标量流水线的基本概念</h4><h5 id="超标量流水线技术"><a href="#超标量流水线技术" class="headerlink" title="超标量流水线技术"></a>超标量流水线技术</h5><p>每个时钟周期内可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件。</p>
<p>超标量计算机不能调整指令的执行顺序，因此通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性，如图5.20所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716184812.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716184812.png';" /></details>

<h5 id="超流水线技术"><a href="#超流水线技术" class="headerlink" title="超流水线技术"></a>超流水线技术</h5><p>在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次。</p>
<p>不能调整指令的执行顺序，靠编译程序解决优化问题，如图5.21所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716184857.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716184857.png';" /></details>

<h5 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h5><p>由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位)，为此需要采用多个处理部件。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><h4 id="CPU分为哪几部分-分别实现什么功能"><a href="#CPU分为哪几部分-分别实现什么功能" class="headerlink" title="CPU分为哪几部分?分别实现什么功能?"></a>CPU分为哪几部分?分别实现什么功能?</h4><p>CPU分为运算器和控制器。其中运算器主要负责数据的加工，即对数据进行算术和逻辑运算。控制器是整个系统的指挥中枢，对整个计算机系统进行有效的控制，包括指令控制、操作控制、时间控制和中断处理。</p>
<h4 id="指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据"><a href="#指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据" class="headerlink" title="指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据?"></a>指令和数据均存放在内存中，计算机如何从时间和空间上区分它们是指令还是数据?</h4><p>从时间上讲，取指令事件发生在“取指周期”，取数据事件发生在“执行周期”。从空间上讲，从内存读出的指令流流向控制器（指令寄存器)，从内存读出的数据流流向运算器（通用寄存器)。</p>
<h4 id="什么是指令周期、机器周期和时钟周期-它们之间有何关系"><a href="#什么是指令周期、机器周期和时钟周期-它们之间有何关系" class="headerlink" title="什么是指令周期、机器周期和时钟周期?它们之间有何关系?"></a>什么是指令周期、机器周期和时钟周期?它们之间有何关系?</h4><p>CPU每取出并执行一条指令所需的全部时间称为指令周期;机器周期是在同步控制的机器中，执行指令周期中一步相对完整的操作（指令步）所需的时间，通常安排机器周期长度=主存周期;时钟周期是指计算机主时钟的周期时间，它是计算机运行时最基本的时序单位，对应完成一个微操作所需的时间，通常时钟周期=计算机主频的倒数。</p>
<h4 id="指令周期是否有一个固定值-为什么"><a href="#指令周期是否有一个固定值-为什么" class="headerlink" title="指令周期是否有一个固定值?为什么?"></a>指令周期是否有一个固定值?为什么?</h4><p>由于计算机中各种指令执行所需的时间差异很大，因此为了提高CPU的运行效率，即使在同步控制的机器中，不同指令的指令周期长度都是不一致的，即指令周期对不同的指令来说不是一个固定值。</p>
<h4 id="什么是微指令-它和上一章谈到的指令有什么关系"><a href="#什么是微指令-它和上一章谈到的指令有什么关系" class="headerlink" title="什么是微指令?它和上一章谈到的指令有什么关系?"></a>什么是微指令?它和上一章谈到的指令有什么关系?</h4><p>控制部件通过控制线向执行部件发出各种控制命令，通常把这种控制命令称为微命令，而一组实现一定操作功能的微命令的组合，构成一条微指令。许多条微指令组成的序列构成微程序，微程序完成对指令的解释执行。指令，即指机器指令。每条指令可以完成一个独立的算术运算或逻辑运算操作。在采用微程序控制器的CPU中，一条指令对应一个微程序，一个微程序由许多微指令构成，一条微指令会发出很多不同的微命令。</p>
<h4 id="什么是指令流水线-指令流水线相对于传统计算机体系结构的优势是什么-如何计算指令流水线的加速比"><a href="#什么是指令流水线-指令流水线相对于传统计算机体系结构的优势是什么-如何计算指令流水线的加速比" class="headerlink" title="什么是指令流水线?指令流水线相对于传统计算机体系结构的优势是什么?如何计算指令流水线的加速比?"></a>什么是指令流水线?指令流水线相对于传统计算机体系结构的优势是什么?如何计算指令流水线的加速比?</h4><p>指令流水线是把指令分解为若干子过程，通过将每个子过程与其他子过程并行执行，来提高计算机的吞吐率的技术。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术，通过在同一个时间段使用各功能部件，使得利用率明显提高。</p>
<p>流水线的加速比指的是完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。一条k段流水线理论上的最大加速比为 $S_{max}$  = k。因此，在现代计算机中提高流水线段数有利于提高计算机的吞吐量。具体的加速比要使用时空图来计算。</p>
<h3 id="常见问题和易混淆知识点"><a href="#常见问题和易混淆知识点" class="headerlink" title="常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h3><h4 id="流水线越多，并行度就越高。是否流水段越多，指令执行越快"><a href="#流水线越多，并行度就越高。是否流水段越多，指令执行越快" class="headerlink" title="流水线越多，并行度就越高。是否流水段越多，指令执行越快?"></a>流水线越多，并行度就越高。是否流水段越多，指令执行越快?</h4><p>$\color{red}{\text{错误}}$ ，因为如下:</p>
<p>1）流水段缓冲之间的额外开销增大。每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一-条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大。</p>
<p>2）流水段间控制逻辑变多、变复杂。用于流水线优化和存储器（或寄存器）冲突处理的控制逻辑将随流水段的增加而大增，这可能导致用于流水段之间控制的逻辑比段本身的控制逻辑更复杂。</p>
<h4 id="有关指令相关、数据相关的几个概念"><a href="#有关指令相关、数据相关的几个概念" class="headerlink" title="有关指令相关、数据相关的几个概念"></a>有关指令相关、数据相关的几个概念</h4><p>1）两条连续的指令读取相同的寄存器时，会产生读后读(Read After Read,RAR）相关，这种相关不会影响流水线。</p>
<p>2）某条指令要读取上一条指令所写入的寄存器时，会产生写后读(Read After Write,RAW)相关，它称数据相关或真相关，影响流水线。按序流动的流水线只可能出现RAW相关。</p>
<p>3）某条指令的上条指令要读/写该指令的输出寄存器时，会产生读后写(Write After Read,WAR）和写后写(Write After Write, WAW)相关。在非按序流动的流水线中，既可能发生RAW相关，又可能发生WAR相关和 WAW相关。</p>
<p>对流水线影响最严重的指令相关是数据相关。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch4-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch4-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">王道-计算机组成原理-ch4-指令系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 09:59:59" itemprop="dateCreated datePublished" datetime="2021-06-30T09:59:59+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-29 20:33:25" itemprop="dateModified" datetime="2021-09-29T20:33:25+08:00">2021-09-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>p165</p>
<p>【考纲内容】</p>
<p>(一）指令格式</p>
<p>指令的基本格式</p>
<p>定长操作码指令格式</p>
<p>扩展操作码指令格式</p>
<p>(二)指令的寻址方式</p>
<p>有效地址的概念</p>
<p>数据寻址和指令寻址</p>
<p>常见寻址方式</p>
<p>(三)CISC和 RISC的基本概念</p>
<p>【复习提示】<br>指令系统是表征一台计算机性能的重要因素。读者应注意扩展操作码技术，各种寻址方式的特点及有效地址的计算，相对寻址有关的计算，CISC与RISC 的特点与区别。本章知识点出选择题的概率较大，但也有可能结合其他章节出有关指令的综合题。2014年、2015年已连续两次出现指令系统和指令流水线的大题。指令系统格式和指令寻址方式与CPU指令执行过程部分紧密结合，希望读者引起重视。</p>
<p>在学习本章时，请读者思考以下问题:</p>
<p>1）什么是指令?什么是指令系统?为什么要引入指令系统?</p>
<p>2）一般来说，指令分为哪些部分?每部分有什么用处?</p>
<p>3）对于一个指令系统来说，寻址方式多和少有什么影响?</p>
<p>请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。</p>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p>指令（机器指令）是指示计算机执行某种操作的命令。一台计算机的所有指令的集合构成该机的指令系统，也称指令集。 $\color{red}{\text{指令系统}}$ 是计算机的主要属性， $\color{green}{\text{位于硬件和软件的交界面上}}$ 。</p>
<h4 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h4><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条 $\color{red}{\text{指令}}$ 通常包括 $\color{green}{\text{操作码}}$ 字段和 $\color{green}{\text{地址码}}$ 字段两部分:</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713161448.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713161448.png';" /></details>

<p>其中，操作码指出指令中该指令应该执行什么性质的操作以及具有何种功能。操作码是识别指令、了解指令功能及区分操作数地址内容的组成和使用方法等的关键信息。例如，指出是算术加运算还是算术减运算，是程序转移还是返回操作。</p>
<p>地址码给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。</p>
<p>指令的长度是指一条指令中所包含的二进制代码的位数。指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数。指令长度与机器字长没有固定的关系，它可以等于机器字长，也可以大于或小于机器字长。通常，把指令长度等于机器字长的指令称为 $\color{green}{\text{单字长指令}}$ ，指令长度等于半个机器字长的指令称为 $\color{green}{\text{半字长指令}}$ ，指令长度等于两个机器字长的指令称为 $\color{green}{\text{双字长指令}}$ 。</p>
<p>在一个指令系统中，若所有指令的长度都是相等的，则称为 $\color{green}{\text{定长指令字结构}}$ 。定字长指令的执行速度快，控制简单。若各种指令的长度随指令功能而异，则称为 $\color{green}{\text{变长指令字结构}}$ 。然而，因为主存一般是按字节编址的，所以指令字长多为字节的整数倍。</p>
<p>根据指令中操作数地址码的数目的不同，可将指令分成以下几种格式。</p>
<h5 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715111354.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715111354.png';" /></details>

<p>只给出操作码OP，没有显式地址。这种指令有两种可能:</p>
<p>1)不需要操作数的指令，如空操作指令、停机指令、关中断指令等。</p>
<p>2）零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。</p>
<h5 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715111432.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715111432.png';" /></details>

<p>这种指令也有两种常见的形态，要根据操作码的含义确定究竟是哪一种。</p>
<p>1)只有目的操作数的单操作数指令，按 $A_1$ 地址读取操作数，进行OP操作后，结果存回原地址。</p>
<p>指令含义：$\text{OP}(\text{A}_1) \to \text{A}_1$</p>
<p>如操作码含义是加1、减1、求反、求补等。</p>
<p>2）隐含约定目的地址的双操作数指令，按指令地址A、可读取源操作数，指令可隐含约定另一个操作数由ACC（累加器）提供，运算结果也将存放在ACC中。</p>
<p>指令含义：$\text{(ACC)OP}(\text{A}_1) \to \text{ACC}$</p>
<p>若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为$2^{24}=16\text{M}$</p>
<h5 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715111737.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715111737.png';" /></details>


<p>指令含义：$(\text{A}_1)\text{OP}(\text{A}_2)\to \text{A}_1$</p>
<p>若指令字长为32位，操作码占8位，两个地址码字段各占12位，则指令操作数的直接寻址范围为$2^{12}=4\text{K}$</p>
<h5 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715112026.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715112026.png';" /></details>

<p>指令含义：$(\text{A}_1)\text{OP}(\text{A}_2) \to \text{A}_3$</p>
<p>若指令字长为32位，操作码占8位，3个地址码字段各占8位，则指令操作数的直接寻址范围为$2^8=256$若地址字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令1次，取两个操作数2次，存放结果1次)。</p>
<h5 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715112155.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715112155.png';" /></details>

<p>指令含义：$(\text{A}_1)\text{OP}(\text{A}_2) \to \text{A}_3, \text{A}_4$=下一条将要执行指令的地址。</p>
<p>若指令字长为32位，操作码占8位，4个地址码字段各占6位，则指令操作数的直接寻址范围为$2^6=64$</p>
<h4 id="定长操作码指令格式"><a href="#定长操作码指令格式" class="headerlink" title="定长操作码指令格式"></a>定长操作码指令格式</h4><p>定长操作码指令在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般$n$位操作码字段的指令系统最大能够表示$2^n$条指令。定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。当计算机字长为32位或更长时，这是常规用法。</p>
<h4 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h4><p>为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。</p>
<p>最常见的变长操作码方法是扩展操作码，它使操作码的长度随地址码的减少而增加，不同地址数的指令可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。图4.1所示即为一种扩展操作码的安排方式。</p>
<p>再图4.1中，指令字长为16位，其中4位为基本操作码字段$\text{OP}$，另有3个4位长的地址字段$A_1,A_2\text{和}A_3$。四位操作码若全部用于三地址指令，则有16条。图4.1中所示的三地址指令为15条，1111留作扩展操作码之用;二地址指令为15条，1111 1111留作扩展操作码之用;一地址指令为15条，1111 1111 1111留作扩展操作码之用;零地址指令为16条。</p>
<p>除这种安排外，还有其他多种扩展方法，如形成15条三地址指令、12条二地址指令、63条一地址指令和16条零地址指令，共106条指令，请读者自行分析。</p>
<p>在设计扩展操作码指令格式时，必须注意以下两点:</p>
<p>1)不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。</p>
<p>2）各指令的操作码一定不能重复。通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。</p>
<details><summary>图4.1 扩展操作码技术</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715112513.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715112513.png';" /></details>

<h4 id="指令的操作类型"><a href="#指令的操作类型" class="headerlink" title="指令的操作类型"></a>指令的操作类型</h4><p>设计指令系统时必须考虑应提供哪些操作类型，指令操作类型按功能可分为以下几种。</p>
<h5 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h5><p>传送指令通常有寄存器之间的传送（MOV)、从内存单元读取数据到CPU寄存器(LOAD)、从CPU寄存器写数据到内存单元(STORE)）等。</p>
<h5 id="算术和逻辑运算"><a href="#算术和逻辑运算" class="headerlink" title="算术和逻辑运算"></a>算术和逻辑运算</h5><p>这类指令主要有加（ADD)、减(SUB)、比较（CMP)、乘(MUL)、除（DIV)、加1(INC)、减1 (DEC)、与(AND)、或（OR)、取反(NOT)、异或(XOR）等。</p>
<h5 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h5><p>移位指令主要有算法移位、逻辑移位、循环移位等。</p>
<h5 id="转移操作"><a href="#转移操作" class="headerlink" title="转移操作"></a>转移操作</h5><p>转移指令主要有无条件转移(JMP)、条件转移（BRANCH)、调用(CALL )、返回(RET)、陷阱（TRAP)等。无条件转移指令在任何情况下都执行转移操作，而条件转移指令仅在特定条件满足时才执行转移操作，转移条件一般是某个标志位的值，或两个或两个以上的标志位组合。</p>
<p>调用指令和转移指令的区别:执行调用指令时必须保存下一条指令的地址（返回地址)，当子程序执行结束时，根据返回地址返回到主程序继续执行;而转移指令则不返回执行。</p>
<h5 id="输入输出操作"><a href="#输入输出操作" class="headerlink" title="输入输出操作"></a>输入输出操作</h5><p>这类指令用于完成CPU 与外部设备交换数据或传送控制命令及状态信息。</p>
<h3 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h3><p>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为 $\color{green}{\text{指令寻址}}$ 和 $\color{green}{\text{数据寻址}}$ 两大类。</p>
<p>指令中的地址码字段并不代表操作数的真实地址，这种地址称为 $\color{green}{\text{形式地址}}$ (A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为 $\color{green}{\text{有效地址}}$ （EA)。</p>
<p>注意，(A)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。对应的(A)就是寄存器中的数值，或相应内存单元的数值。例如，EA=(A)意思是有效地址是地址A中的数值。</p>
<h4 id="指令寻址和数据寻址"><a href="#指令寻址和数据寻址" class="headerlink" title="指令寻址和数据寻址"></a>指令寻址和数据寻址</h4><p>寻址方式分为指令寻址和数据寻址两大类。寻找下一条将要执行的指令地址称为指令寻址;寻找操作数的地址称为数据寻址。</p>
<h5 id="color-red-text-指令寻址"><a href="#color-red-text-指令寻址" class="headerlink" title="$\color{red}{\text{指令寻址}}$"></a>$\color{red}{\text{指令寻址}}$</h5><p>指令寻址方式有两种:一种是顺序寻址方式，另一种是跳跃寻址方式。</p>
<p>1） $\color{green}{\text{顺序寻址}}$ 可通过程序计数器（PC)加1(1个指令字长)，自动形成下一条指令的地址。</p>
<p>2） $\color{green}{\text{跳跃寻址}}$ 通过转移类指令实现。所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。注意，是否跳跃可能受到状态寄存器和操作数的控制，而跳跃到的地址分为绝对地址（由标记符直接得到)和相对地址（相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过程序计数器（PC）给出。</p>
<h5 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h5><p>数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。</p>
<p>数据寻址的方式较多，为区别各种方式，通常在指令字中设一个字段，用来指明属于哪种寻址方式，由此可得指令的格式如下所示:</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113222.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113222.png';" /></details>


<h4 id="常见的数据寻址方式"><a href="#常见的数据寻址方式" class="headerlink" title="常见的数据寻址方式"></a>常见的数据寻址方式</h4><h5 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h5><p>这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。例如，单地址的指令格式就不明显地在地址字段中指出第二操作数的地址，而规定累加器（ACC）作为第二操作数地址，指令格式明显指出的仅是第一操作数的地址。因此，累加器(ACC）对单地址指令格式来说是隐含寻址，如图4.2所示。</p>
<p>隐含寻址的优点是有利于缩短指令字长;缺点是需增加存储操作数或隐含地址的硬件。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113315.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113315.png';" /></details>


<h5 id="立即-数-寻址"><a href="#立即-数-寻址" class="headerlink" title="立即(数)寻址"></a>立即(数)寻址</h5><p>这种类型的指令的地址字段指出的不是操作数的地址，而是操作数本身，又称立即数。数据采用补码形式存放。图4.3所示为立即寻址示意图，图中#表示立即寻址特征，A就是操作数本身。</p>
<p>立即寻址的优点是指令在执行阶段不访问主存，指令执行时间最短;缺点是A 的位数限制了立即数的范围。</p>
<details><summary>立即(数)寻址</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113408.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113408.png';" /></details>

<h5 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h5><p>指令字中的形式地址A是操作数的真实地址:EA，即EA=A，如图4.4所示。</p>
<details><summary>直接寻址</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113501.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113501.png';" /></details>

<p>直接寻址的优点是简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址;缺点是A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。</p>
<h5 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h5><p>间接寻址是相对于直接寻址而言的，指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即 EA =(A)，如图4.5所示。间接寻址可以是一次间接寻址，还可以是多次间接寻址。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113543.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113543.png';" /></details>

<p>在图4.5中，主存字第一位为1时，表示取出的仍不是操作数的地址，即多次间址;主存字第一位为0时，表示取得的是操作数的地址。</p>
<p>间接寻址的优点是可扩大寻址范围（有效地址EA 的位数大于形式地址A的位数)，便于编制程序（用间接寻址可方便地完成子程序返回);缺点是指令在执行阶段要多次访存（一次间接寻址需两次访存，多次间接寻址需根据存储字的最高位确定访存次数)。由于访问速度过慢，这种寻址方式并不常用。一般问到扩大寻址范围时，通常指的是寄存器间接寻址。</p>
<h5 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h5><p>寄存器寻址是指在指令字中直接给出操作数所在的寄存器编号，即EA = $R_i$，其操作数在由R;所指的寄存器内，如图4.6所示。</p>
<p>寄存器寻址的优点是指令在执行阶段不访问主存，只访问寄存器，因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量/矩阵运算;缺点是寄存器价格昂贵，计算机中的寄存器个数有限。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113638.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113638.png';" /></details>


<h5 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h5><p>寄存器间接寻址是指在寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址，即 EA=($R_i$)，如图4.7所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715113701.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715113701.png';" /></details>

<p>寄存器间接寻址的特点是，与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中)。</p>
<h5 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h5><p>相对寻址是把程序计数器(PC)的内容加上指令格式中的形式地址A而形成操作数的有效地址，即 EA= (PC)+A，其中A是相对于当前指令地址的位移量，可正可负，补码表示，如图4.8所示。</p>
<p>在图4.8中，A的位数决定操作数的寻址范围。</p>
<p>相对寻址的优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。相对寻址广泛应用于转移指令。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114009.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114009.png';" /></details>

<p>注意，对于转移指令JMP A，当CPU从存储器中取出一字节时，会自动执行(PC)＋1→PC。若转移指令的地址为X，且占2B，在取出该指令后，PC的值会增2，即$(\text{PC})=X+1$,这样在执行完该指令后，会自动跳转到$\text{X+2+A}$的地址继续执行。</p>
<h5 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h5><p>基址寻址是指将CPU 中基址寄存器（BR）的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA =(BR)+ A。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器，如图4.9所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114333.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114333.png';" /></details>

<p>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。在程序执行过程中，基址寄存器的内容不变（作为基地址)，形式地址可变（作为偏移量)。采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。</p>
<p>基址寻址的优点是可扩大寻址范围（基址寄存器的位数大于形式地址A的位数);用户不必考虑自己的程序存于主存的哪个空间区域，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址A）的位数较短。</p>
<h5 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h5><p>变址寻址是指有效地址EA 等于指令字中的形式地址A与变址寄存器IX的内容之和，即EA = (IX)+ A，其中为变址寄存器（专用)，也可用通用寄存器作为变址寄存器。图4.10所示为采用专用寄存器IX的变址寻址示意图。</p>
<p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量)，形式地址A不变(作为基地址)。</p>
<p>变址寻址的优点是可扩大寻址范围（变址寄存器的位数大于形式地址A的位数);在数组处理过程中，可设定A 为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。偏移量（变址寄存器IX）的位数足以表示整个存储空间。</p>
<p>显然，变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上讲，两者有较大区别。基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的A是可变的;变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的A是不可变的。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114444.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114444.png';" /></details>

<h5 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h5><p>堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出（LIFO）原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP)。 $\color{red}{\text{堆栈}}$ 可分为 $\color{green}{\text{硬堆栈}}$ 与 $\color{green}{\text{软堆栈}}$ 两种。</p>
<p>寄存器堆栈又称硬堆栈。寄存器堆栈的成本较高，不适合做大容量的堆栈;而从主存中划出一段区域来做堆栈是最合算且最常用的方法，这种堆栈称为软堆栈。</p>
<p>在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。</p>
<p>下面简单总结寻址方式、有效地址及访存次数（不包含为了取本条指令而做的访存)，见表4.1。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114703.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114703.png';" /></details>

<ul>
<li>$\mho$(为什么隐含寻址的访存次数是0，他不是向 $\color{green}{\text{内存}}$ 取操作数就算一次访存吗，否则变址寻址这些凭什么是1次)</li>
</ul>
<h4 id="X86汇编指令入门"><a href="#X86汇编指令入门" class="headerlink" title="X86汇编指令入门"></a>X86汇编指令入门</h4><p>近几年的408真题频繁涉及X86汇编指令和机器代码相关的知识，这部分内容并不在考纲范围内，但如果对汇编知识和程序在机内执行的原理毫无了解，那么解题可能会难以下手。</p>
<h5 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h5><p>X86处理器中有8个32位的通用寄存器，各寄存器及说明如图4.11所示。为了向后兼容，EAX、EBX、ECX和 EDX 的高两位字节和低两位字节可以独立使用，E为Extended，表示32位的寄存器。例如，EAX的低两位字节称为AX，而AX的高低字节又可分别作为两个8位寄存器，分别称为AH和AL。寄存器的名称与大小写无关，既可以用EAX，又可以用eax。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715114758.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715114758.png';" /></details>

<ul>
<li>$\blacktriangleright$(图中的BAX应该是EAX吧)</li>
</ul>
<p>除EBP和 ESP外，其他几个寄存器的用途是比较任意的。</p>
<h5 id="寻址模式和内存分配"><a href="#寻址模式和内存分配" class="headerlink" title="寻址模式和内存分配"></a>寻址模式和内存分配</h5><p>1)寻址模式</p>
<p>X86提供了一种灵活的内存寻址方式，这里以mov指令为例。mov用于在内存和寄存器之间移动数据，它有两个参数:第一个是目的地址，第二个是源地址。</p>
<p>下面的例子是汇编程序中常见的方式:</p>
<details>
  <summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]  <span class="comment">;将ebx值指示的内存地址中的4字节传送到eax</span></span><br><span class="line"><span class="keyword">mov</span> [var],<span class="built_in">ebx</span>  <span class="comment">;将ebx值传送到var的值指示的内存地址中</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>-<span class="number">4</span>]  <span class="comment">;将esi-4值指示的内存地址中的4字节传送到eax</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">esi</span>+<span class="built_in">eax</span>],<span class="built_in">cl</span>  <span class="comment">;将c1值传送到esi+eax值指示的内存地址中</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>,[<span class="built_in">esi</span>+<span class="number">4</span>*<span class="built_in">ebx</span>] <span class="comment">;将esi+4*ebx值指示的内存中的4字节传送到edx</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>



<p>最多只能利用两个32位寄存器和一个32位的有符号常数相加计算出一个内存地址，下面是两个违反规则的例子:</p>
<details>
  <summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>-<span class="built_in">ecx</span>] <span class="comment">;错误,只能用加法</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">eax</span>+<span class="built_in">esi</span>+<span class="built_in">edi</span>], <span class="built_in">ebx</span> <span class="comment">;错误,最多只能有两个寄存器参与运算</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>



<p>2）数据类型长度规定</p>
<p>在汇编语言中声明内存大小时，一般显式地使用DB(字母D表示 Data，字母B表示Byte)、DW(字母W表示Word，2Bytes）和DD(第二个字母D表示Double Word，4Bytes)，这样就能很好地指导编译器分配内存空间，但是对于</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> [<span class="built_in">ebx</span>], <span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</details>

<p>若无特殊标识，则不确定常数⒉是单字节、双字节还是双字。对于这种情况，X86提供了三个指示规则标记，分别为BYTE PTR、WORD PTR和 DWORD PTR，如将上例写成</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>],<span class="number">2</span>  <span class="comment">;将2以单字节形式传送到ebx值指示的内存地址中</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>], <span class="number">2</span>  <span class="comment">;将2以双字节形式传送到ebx值指示的内存地址中</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebx</span>],<span class="number">2</span>  <span class="comment">;将2以四字节形式传送到ebx值指示的内存地址中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h5 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h5><p>汇编指令通常可以分为数据传送指令、逻辑计算指令和控制流指令，本节将讲述其中最重要的指令。以下用于操作数的标记分别表示寄存器、内存和常数。</p>
<p><code>&lt;reg&gt;</code>:表示任意寄存器，若其后带有数字，则指定其位数，如<code>&lt;reg32&gt;</code>表示32位寄存器(EAX、EBX、ECX、EDX、ESI、EDI、ESP或EBP);<code>&lt;reg16&gt;</code>表示16位寄存器(AX、 BX、CX或 DX);<code>&lt;reg8&gt;</code>表示8位寄存器(AH、AL、BH、BL、CH、CL、DH、DL )。</p>
<p><code>&lt;mem&gt;</code>:表示内存地址（如[ eax ]、[ var+4 ]或dword ptr [ eax+ebx ])。</p>
<p><code>&lt;con&gt;</code>:表示8位、16位或32位常数。<code>&lt;con8&gt;</code>表示8位常数;<code>&lt;con16&gt;</code>表示16位常数;<code>&lt;con32&gt;</code>表示32位常数。（constant）</p>
<p>X86中的指令机器码长度为1字节，对同一指令的不同用途有多种编码方式，比如 mov指令就有28种机内编码，用于不同操作数类型或用于特定寄存器，例如，</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,&lt;con16&gt;<span class="comment">;机器码为B8H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,&lt;con8&gt;<span class="comment">;机器码为BOH</span></span><br><span class="line"><span class="keyword">mov</span> &lt;reg16&gt;/&lt;mem16&gt;,&lt;reg16&gt;<span class="comment">;机器码为89H</span></span><br><span class="line"><span class="keyword">mov</span> &lt;reg8&gt;, &lt;reg8&gt;/&lt;mem <span class="number">8</span>&gt;<span class="comment">;机器码为8AH</span></span><br><span class="line"><span class="keyword">mov</span> &lt;reg16&gt;,&lt;reg16&gt;/&lt;mem16&gt;  <span class="comment">;机器码为8BH</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h6 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h6><p><strong>mov指令</strong></p>
<p>mov指令将第二个操作数（寄存器的内容、内存中的内容或常数值）复制到第一个操作数(寄存器或内存)。但不能用于直接从内存复制到内存，其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;reg&gt;,mem&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;reg&gt;, &lt;con&gt;</span><br><span class="line"><span class="keyword">mov</span> &lt;mem&gt;,&lt;con&gt;</span><br></pre></td></tr></table></figure>
</details>

<p>举例:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span><span class="comment">;将ebx值复制到eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [var], <span class="number">5</span><span class="comment">;将5保存到var值指示的内存地址的一字节中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>push指令</strong></p>
<p>push 指令将操作数压入内存的栈，常用于函数调用。ESP是栈顶，压栈前先将 $\color{green}{\text{ESP值减4}}$ (栈增长方向与内存地址增长方向相反)，然后将操作数压入ESP指示的地址。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> &lt;reg32&gt;</span><br><span class="line"><span class="keyword">push</span> &lt;mem&gt;</span><br><span class="line"><span class="keyword">push</span> &lt;con32&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例（注意， $\color{green}{\text{栈中元素固定为32位}}$ ):</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">eax</span><span class="comment">;将eax值压栈</span></span><br><span class="line"><span class="keyword">push</span> [var]<span class="comment">;将var值指示的内存地址的4字节值压栈</span></span><br></pre></td></tr></table></figure>
</details>

<p><strong>pop指令</strong></p>
<p>与push指令相反，pop 指令执行的是出栈工作，出栈前先将ESP指示的地址中的内容出栈，然后将ESP值加4。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">edi</span> <span class="comment">;弹出栈顶元素送到edi</span></span><br><span class="line"><span class="keyword">pop</span> [<span class="built_in">ebx</span>] <span class="comment">;弹出栈顶元素送到ebx值指示的内存地址的4字节中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h6 id="算术和逻辑运算指令"><a href="#算术和逻辑运算指令" class="headerlink" title="算术和逻辑运算指令"></a>算术和逻辑运算指令</h6><p><strong>add/sub指令</strong></p>
<p>add指令将两个操作数相加，相加的结果保存到第一个操作数中。sub指令用于两个操作数相减，相减的结果保存到第一个操作数中。它们的语法格式类似，语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> &lt;reg&gt;,&lt;reg&gt; / <span class="keyword">sub</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;reg&gt;,&lt;mem&gt; / <span class="keyword">sub</span> &lt;reg&gt;,mem&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;mem&gt;,&lt;reg&gt; / <span class="keyword">sub</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;reg&gt;,&lt;con&gt; / <span class="keyword">sub</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">add</span> &lt;mem&gt;,&lt;con&gt; / <span class="keyword">sub</span> &lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">10</span><span class="comment">;eaxeax-10</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [var],<span class="number">10</span><span class="comment">;10与 var值指示的内存地址的一字节值相加，并将结果保存在var值指示的内存地址的字节中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>inc/dec指令</strong></p>
<p>inc、dec指令分别表示将操作数自加1、自减1，其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inc</span> &lt;reg&gt; / <span class="keyword">dec</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">inc</span> &lt;mem&gt; / <span class="keyword">dec</span> &lt;mem&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dec</span> <span class="built_in">eax</span><span class="comment">; eax值自减1</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [var]<span class="comment">; var值指示的内存地址的4字节值自加1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>imul指令</strong></p>
<p>带符号整数乘法指令，它有两种格式:①两个操作数，将两个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器;②三个操作数，将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,&lt;reg32&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,mem&gt;</span><br><span class="line"><span class="keyword">imul</span>&lt;reg32&gt;, &lt;reg32&gt;, &lt;con&gt;</span><br><span class="line"><span class="keyword">imul</span> &lt;reg32&gt;,&lt;mem&gt;, &lt;con&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">imul</span> <span class="built_in">eax</span>, [var]<span class="comment">;eaxeax*[var]</span></span><br><span class="line"><span class="keyword">imul</span> <span class="built_in">esi</span>, <span class="built_in">edi</span>, <span class="number">25</span><span class="comment">;esi edi *25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>乘法操作结果可能溢出，则编译器置溢出标志OF=1，以使CPU调出溢出异常处理程序。</p>
<p><strong>idiv指令</strong></p>
<p>idiv是带符号整数除法指令，它只有一个操作数，即除数，而被除数则为edx:eax 中的内容(64位整数)，操作结果有两部分:商和余数，商送到eax，余数则送到edx。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">idiv</span> &lt;reg32&gt;</span><br><span class="line"><span class="keyword">idiv</span> &lt;mem&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">idiv</span> <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">idiv</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [var]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>and/or/xor指令</strong></p>
<p>and、or、xor指令分别是逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> &lt;reg&gt;,&lt;reg&gt; / <span class="keyword">or</span> &lt;reg&gt;,&lt;reg&gt; / <span class="keyword">xor</span> &lt;reg&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;reg&gt;,&lt;mem&gt; / <span class="keyword">or</span> &lt;reg&gt;,&lt;mem&gt; / <span class="keyword">xor</span> &lt;reg&gt;, &lt;mem&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;mem&gt;,&lt;reg&gt; / <span class="keyword">or</span> &lt;mem&gt;,&lt;reg&gt; / <span class="keyword">xor</span> &lt;mem&gt;, &lt;reg&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;reg&gt;,&lt;con&gt; / <span class="keyword">or</span> &lt;reg&gt;,&lt;con&gt; / <span class="keyword">xor</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"><span class="keyword">and</span> &lt;mem&gt;,&lt;con&gt; / <span class="keyword">or</span> &lt;mem&gt;,&lt;con&gt; / <span class="keyword">xor</span> &lt;mem&gt;,&lt;con&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="built_in">eax</span>,OfH<span class="comment">;将eax中的前28位全部置为0，最后4位保持不变</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span><span class="comment">;置edx中的内容为0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>not指令</strong></p>
<p>not指令是位翻转指令，将操作数中的每一位翻转，即0→1、1→0。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span>&lt;reg&gt;</span><br><span class="line"><span class="keyword">not</span>&lt;mem&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [var]<span class="comment">;将var值指示的内存地址的一字节的所有位翻转</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>neg指令</strong></p>
<p>neg是取负指令。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">neg</span> &lt;reg&gt;</span><br><span class="line"><span class="keyword">neg</span> &lt;mem&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">neg</span> <span class="built_in">eax</span> <span class="comment">;eax &lt;- -eax</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>shl/shr指令</strong></p>
<p>shl、shr是逻辑移位指令，shl为逻辑左移，shr为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> &lt;reg&gt;,&lt;con8&gt; / <span class="keyword">shr</span> &lt;reg&gt;,&lt;con8&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;mem&gt;,&lt;con8&gt; / <span class="keyword">shr</span> &lt;mem&gt;,&lt;con8&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;reg&gt;,&lt;<span class="built_in">cl</span>&gt; / <span class="keyword">shr</span> &lt;reg&gt;,&lt;<span class="built_in">cl</span>&gt;</span><br><span class="line"><span class="keyword">shl</span> &lt;mem&gt;,&lt;<span class="built_in">cl</span>&gt; / <span class="keyword">shr</span> &lt;mem&gt;,&lt;<span class="built_in">cl</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shl</span> <span class="built_in">eax</span>,<span class="number">1</span><span class="comment">;将eax值左移1位，相当于乘以2</span></span><br><span class="line"><span class="keyword">shr</span> <span class="built_in">ebx</span>,<span class="built_in">cl</span><span class="comment">;将 ebx值右移n位（n为c1中的值)，相当于除以2^n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h6 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h6><p>X86 处理器维持着一个指示当前执行指令的指令指针(P)，当一条指令执行后，此指针自动指向下一条指令。IP寄存器不能直接操作，但可以用控制流指令更新。通常用标签（label)指示程序中的指令地址，在X86汇编代码中，可在任何指令前加入标签。例如,</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">mov</span> <span class="built_in">esi</span>, [<span class="built_in">ebp</span>+<span class="number">8</span>]</span><br><span class="line"><span class="symbol">begin:</span>  <span class="keyword">xor</span> <span class="built_in">ecx</span>, <span class="built_in">ecx</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esi</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>这样就用begin指示了第二条指令，控制流指令通过标签就可以实现程序指令的跳转。</p>
<p><strong>jmp指令</strong></p>
<p>jmp指令控制I转移到label所指示的地址（从label中取出指令执行)。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> &lt;label&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> begin <span class="comment">;转跳到begin标记的指令执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>jcondition指令</strong></p>
<p>条件转移指令，它依据处理机状态字中的一系列条件状态转移。处理机状态字中包括指示最后一个算术运算结果是否为0，运算结果是否为负数等。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">je</span>  &lt;label&gt; (jump when equal)</span><br><span class="line"><span class="keyword">jne</span> &lt;label&gt; (jump when <span class="keyword">not</span> equal)</span><br><span class="line"><span class="keyword">jz</span>  &lt;label&gt; (jump when last result was <span class="meta">zero</span>)</span><br><span class="line"><span class="keyword">jg</span>  &lt;label&gt; (jump when greater than)</span><br><span class="line"><span class="keyword">jge</span> &lt;label&gt; (jump when greater than <span class="keyword">or</span> equal to)</span><br><span class="line">j1  &lt;label&gt; jump when less than)</span><br><span class="line"><span class="keyword">jle</span> &lt;label&gt;（jump when less than <span class="keyword">or</span> equal to)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>举例：</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">jle</span> done <span class="comment">;如果eax的值小于等于ebx值，跳转到done指示的指令执行，否则执行下一条指令。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>cmp指令</strong></p>
<p>cmp 指令用于比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码。其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;,reg&gt;</span><br><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;,&lt;mem&gt;</span><br><span class="line"><span class="keyword">cmp</span> &lt;mem&gt;,&lt;reg&gt;</span><br><span class="line"><span class="keyword">cmp</span> &lt;reg&gt;,&lt;con&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p>cmp指令通常和jcondition指令搭配使用，举例:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> [var],<span class="number">10</span></span><br><span class="line"><span class="keyword">jne</span> <span class="keyword">loop</span><span class="comment">;如果var指示的内存地址的4字节内容等于10,则继续执行下一条指令;否则跳转到loop指示的指令执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><strong>call/ret指令</strong></p>
<p>call 和 ret这两条指令分别实现子程序（过程、函数等）的调用及返回。call 指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。与其他简单的跳转指令不同，call指令保存调用之前的地址信息（当call 指令结束后，返回调用之前的地址)。ret指令实现子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。call和ret是函数调用中最关键的两条指令，其语法如下:</p>
<details><summary>代码详情</summary>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> &lt;label&gt;</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
</details>

<p>理解上述指令的语法和用途，可以更好地帮助读者解答相关题型。汇编语言虽不在考纲范围，但计算机组成原理是一门和硬件紧密关联的学科，涉及编译、指令、内存、处理机等方方面面。读者在上机调试℃程序代码时，也可以尝试用编译器调试，以便更好地帮助理解机器指令的执行，这也从侧面说明了408真题越来越重视考查学生的综合能力。</p>
<h3 id="CISC和-RISC的基本概念"><a href="#CISC和-RISC的基本概念" class="headerlink" title="CISC和 RISC的基本概念"></a>CISC和 RISC的基本概念</h3><p>指令系统朝两个截然不同的方向的发展:一是增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC)，典型的有采用X86架构的计算机;二是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机（RISC)，典型的有ARM、MIPS 架构的计算机。</p>
<h4 id="复杂指令系统计算机-CISC"><a href="#复杂指令系统计算机-CISC" class="headerlink" title="复杂指令系统计算机(CISC)"></a>复杂指令系统计算机(CISC)</h4><p>随着VLSI 技术的发展，硬件成本不断下降，软件成本不断上升，促使人们在指令系统中增加更多、更复杂的指令，以适应不同的应用领域，这样就构成了复杂指令系统计算机(CISC)。</p>
<p>CISC的主要特点如下:</p>
<p>1）指令系统复杂庞大，指令数目一般为200条以上。</p>
<p>2） $\color{green}{\text{指令的长度不固定}}$，指令格式多，寻址方式多。</p>
<p>3）可以访存的指令不受限制。</p>
<p>4）各种指令使用频度相差很大。</p>
<p>5）各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。</p>
<p>6）控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。</p>
<p>7）难以用优化编译生成高效的目标代码程序。</p>
<p>如此庞大的指令系统，对指令的设计提出了极高的要求，研制周期变得很长。后来人们发现，一味地追求指令系统的复杂和完备程度不是提高计算机性能的唯一途径。对传统CISC指令系统的测试表明，各种指令的使用频率相差悬殊，大概只有20%的比较简单的指令被反复使用，约占整个程序的80%;而 80%左右的指令则很少使用，约占整个程序的20%。从这一事实出发，人们开始了对指令系统合理性的研究，于是 RISC随之诞生。</p>
<h4 id="精简指令系统计算机-RISC"><a href="#精简指令系统计算机-RISC" class="headerlink" title="精简指令系统计算机(RISC)"></a>精简指令系统计算机(RISC)</h4><p>精简指令系统计算机（RISC）的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。RISC的主要特点如下:</p>
<p>1）选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。</p>
<p>2） $\color{green}{\text{指令长度固定}}$ ，指令格式种类少，寻址方式种类少。</p>
<p>3)只有Load/Store(取数/存数）指令访存，其余指令的操作都在寄存器之间进行。</p>
<p>4)CPU中通用寄存器的数量相当多。</p>
<p>5）RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</p>
<p>6）以硬布线控制为主，不用或少用微程序控制。</p>
<p>7）特别重视编译优化工作，以减少程序执行时间。</p>
<p>值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。由于 RISC具有更强的实用性，因此应该是未来处理器的发展方向。但事实上，当今时代Intel 几乎一统江湖，且早期很多软件都是根据CISC 设计的，单纯的RISC将无法兼容。此外，现代CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。CISC可以提供更多的功能，这是程序设计所需要的。</p>
<h4 id="CISC和-RISC的比较"><a href="#CISC和-RISC的比较" class="headerlink" title="CISC和 RISC的比较"></a>CISC和 RISC的比较</h4><p>和 CISC相比，RISC的优点主要体现在以下几点:</p>
<p>1)RISC 更能充分利用VLSI芯片的面积。CISC的控制器大多采用微程序控制，其控制存储器在CPU芯片内所占的面积达50%以上，而RISC控制器采用组合逻辑控制，其硬布线逻辑只占CPU芯片面积的10%左右。</p>
<p>2)RISC 更能提高运算速度。RISC 的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成</p>
<p>3)RISC便于设计，可降低成本，提高可靠性。RISC指令系统简单，因此机器设计周期短;其逻辑简单，因此可靠性高。</p>
<p>4)RISC有利于编译程序代码优化。RISC 指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化。</p>
<p>CISC和 RISC的对比见表4.2。</p>
<details><summary>4.2 CISC和 RISC的比较</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210715135937.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210715135937.png';" /></details>


<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><h4 id="什么是指令-什么是指令系统-为什么要引入指令系统"><a href="#什么是指令-什么是指令系统-为什么要引入指令系统" class="headerlink" title="什么是指令?什么是指令系统?为什么要引入指令系统?"></a>什么是指令?什么是指令系统?为什么要引入指令系统?</h4><p>指令就是要计算机执行某种操作的命令。一台计算机中所有机器指令的集合，称为这台计算机的指令系统。引入指令系统后，避免了用户与二进制代码直接接触，使得用户编写程序更为方便。另外，指令系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。</p>
<h4 id="一般来说，指令分为哪些部分-每部分有什么用处"><a href="#一般来说，指令分为哪些部分-每部分有什么用处" class="headerlink" title="一般来说，指令分为哪些部分?每部分有什么用处?"></a>一般来说，指令分为哪些部分?每部分有什么用处?</h4><p>一条指令通常包括操作码字段和地址码字段两部分。其中，操作码指出指令中该指令应该执行什么性质的操作和具有何种功能，它是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。地址码用于给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。</p>
<h4 id="对于一个指令系统来说，寻址方式多和少有什么影响"><a href="#对于一个指令系统来说，寻址方式多和少有什么影响" class="headerlink" title="对于一个指令系统来说，寻址方式多和少有什么影响?"></a>对于一个指令系统来说，寻址方式多和少有什么影响?</h4><p>寻址方式的多样化能让用户编程更为方便，但多重寻址方式会造成CPU结构的复杂化（详见下章)，也不利于指令流水线的运行。而寻址方式太少虽然能够提高CPU的效率，但对于用户而言，少数几种寻址方式会使编程变得复杂，很难满足用户的需求。</p>
<h3 id="常见问题和易混淆知识点"><a href="#常见问题和易混淆知识点" class="headerlink" title="常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h3><h4 id="简述各常见指令寻址方式的特点和适用情况。"><a href="#简述各常见指令寻址方式的特点和适用情况。" class="headerlink" title="简述各常见指令寻址方式的特点和适用情况。"></a>简述各常见指令寻址方式的特点和适用情况。</h4><p>立即寻址操作数获取便捷，通常用于给寄存器赋初值。</p>
<p>直接寻址相对于立即寻址，缩短了指令长度。</p>
<p>间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回。</p>
<p>寄存器寻址的指令字较短，指令执行速度较快。</p>
<p>寄存器间接寻址扩大了寻址范围。</p>
<p>基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。</p>
<p>变址寻址主要用于处理数组问题，适合编制循环程序。相对寻址用于控制程序的执行顺序、转移等。</p>
<p>基址寻址和变址寻址的区别:两种方式有效地址的形成都是寄存器内容＋偏移地址，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的;而在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。</p>
<h4 id="一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址"><a href="#一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址" class="headerlink" title="一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址?"></a>一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址?</h4><p>现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数(如char、int、float、double）可能是8位、16位、32位或64位等，因此可能占用1个、2个、4个或8个内存单元。也就是说，一个操作数可能有多个内存地址对应。</p>
<p>有两种不同的地址指定方式:大端方式和小端方式。</p>
<p>大端方式:指令中给出的地址是操作数最高有效字节(MSB）所在的地址。</p>
<p>小端方式:指令中给出的地址是操作数最低有效字节(LSB）所在的地址。</p>
<h4 id="装入-存储-Load-Store-型指令有什么特点"><a href="#装入-存储-Load-Store-型指令有什么特点" class="headerlink" title="装入/存储(Load/Store)型指令有什么特点?"></a>装入/存储(Load/Store)型指令有什么特点?</h4><p>装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格。这种指令风格在RISC 指令系统中较为常见。为了规整指令格式，使指令具有相同的长度，规定只有Load/Store指令才能访问内存。而运算指令不能直接访问内存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致。</p>
<p>这种装入/存储型风格的指令系统的最大特点是，指令格式规整，指令长度一致，一般为32位。由于只有Load/Store指令才能访问内存，程序中可能会包含许多装入指令和存储指令，与一般通用寄存器型指令风格相比，其程序长度会更长。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/index/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/index/">1</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/index/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/31/">31</a><a class="extend next" rel="next" href="/index/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">309</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
