<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="王道输入&#x2F;输出系统【考纲内容】（一）1O系统基本概念 （二）外部设备 输入设备:键盘、鼠标 输出设备:显示器、打印机 外存储器:硬盘存储器、磁盘阵列 （三）I&#x2F;O接口（I&#x2F;O控制器） I&#x2F;O接口的功能和基本结构;I&#x2F;O端口及其编址 （四）I&#x2F;O方式 程序查询方式 程序中断方式 中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念 DMA方式 DMA控制器的组成，DMA传送过程 【复">
<meta property="og:type" content="article">
<meta property="og:title" content="王道-计算机组成原理-ch7-输入&#x2F;输出系统">
<meta property="og:url" content="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch7-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:description" content="王道输入&#x2F;输出系统【考纲内容】（一）1O系统基本概念 （二）外部设备 输入设备:键盘、鼠标 输出设备:显示器、打印机 外存储器:硬盘存储器、磁盘阵列 （三）I&#x2F;O接口（I&#x2F;O控制器） I&#x2F;O接口的功能和基本结构;I&#x2F;O端口及其编址 （四）I&#x2F;O方式 程序查询方式 程序中断方式 中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念 DMA方式 DMA控制器的组成，DMA传送过程 【复">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716194212.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716194259.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716195002.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716195423.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716210133.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716210821.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211109.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211251.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211543.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211945.png">
<meta property="article:published_time" content="2021-06-30T02:00:37.000Z">
<meta property="article:modified_time" content="2021-10-03T10:57:36.102Z">
<meta property="article:author" content="ednow">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716194212.png">

<link rel="canonical" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch7-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>王道-计算机组成原理-ch7-输入/输出系统 | ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch7-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          王道-计算机组成原理-ch7-输入/输出系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 10:00:37" itemprop="dateCreated datePublished" datetime="2021-06-30T10:00:37+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-03 18:57:36" itemprop="dateModified" datetime="2021-10-03T18:57:36+08:00">2021-10-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入/输出系统"></a>输入/输出系统</h2><p>【考纲内容】<br>（一）1O系统基本概念</p>
<p>（二）外部设备</p>
<p>输入设备:键盘、鼠标</p>
<p>输出设备:显示器、打印机</p>
<p>外存储器:硬盘存储器、磁盘阵列</p>
<p>（三）I/O接口（I/O控制器）</p>
<p>I/O接口的功能和基本结构;I/O端口及其编址</p>
<p>（四）I/O方式</p>
<p>程序查询方式</p>
<p>程序中断方式</p>
<p>中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念</p>
<p>DMA方式</p>
<p>DMA控制器的组成，DMA传送过程</p>
<p>【复习提示】<br>I/O方式是本章的重点和难点，每年不仅会以选择题的形式考查基本概念和原理，而且可能会以综合题的形式考查，特别是各种I/O方式效率的相关计算，中断方式的各种原理、特点、处理过程、中断屏蔽，DMA方式的特点、传输过程、与中断方式的区别等。</p>
<p>在学习本章时，请读者思考以下问题:</p>
<p>1）I/O设备有哪些编址方式?各有何特点?</p>
<p>2）CPU响应中断应具备哪些条件?</p>
<p>请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。</p>
<h3 id="I-O系统基本概念"><a href="#I-O系统基本概念" class="headerlink" title="I/O系统基本概念"></a>I/O系统基本概念</h3><h4 id="输入-输出系统-1"><a href="#输入-输出系统-1" class="headerlink" title="输入/输出系统"></a>输入/输出系统</h4><p>输入/输出是以主机为中心而言的，将信息从外部设备传送到主机称为输入，反之称为输出。输入/输出系统解决的主要问题是对各种形式的信息进行输入和输出的控制。</p>
<p>I/O 系统中的几个基本概念如下:</p>
<p>1） $\color{green}{\text{外部设备}}$ 。包括输入/输出设备及通过输入/输出接口才能访问的外存储设备。</p>
<p>2） $\color{green}{\text{接口}}$ 。在各个外设与主机之间传输数据时进行各种协调工作的逻辑部件。协调包括传输过程中速度的匹配、电平和格式转换等。</p>
<p>3） $\color{green}{\text{输入设备}}$ 。用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。</p>
<p>4） $\color{green}{\text{输出设备}}$ 。用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。</p>
<p>5） $\color{green}{\text{外存设备}}$ 。指除计算机内存及CPU 缓存等外的存储器。硬磁盘、光盘等是最基本的外存设备。</p>
<p>一般来说，I/O系统由I/O软件和I/O硬件两部分构成:</p>
<p>1）I/O  $\color{green}{\text{软件}}$ 。包括驱动程序、用户程序、管理程序、升级补丁等。通常采用I/O 指令和通道指令实现CPU与I/O设备的信息交换。</p>
<p>2）I/O  $\color{green}{\text{硬件}}$ 。包括外部设备、设备控制器和接口、I/O总线等。通过设备控制器来控制I/O设备的具体动作;通过I/O接口与主机（总线）相连。</p>
<h4 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h4><p>在输入/输出系统中，经常需要进行大量的数据传输，而传输过程中有各种不同的I/O 控制方式，基本的控制方式主要有以下4种:</p>
<p>1） $\color{green}{\text{程序查询方式}}$ 。由CPU通过程序不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息。</p>
<p>2） $\color{green}{\text{程序中断方式}}$ 。只在I/O设备准备就绪并向CPU发出中断请求时才予以响应。</p>
<p>3） $\color{green}{\text{DMA方式}}$ 。主存和I/O设备之间有一条直接数据通路，当主存和I/O设备交换信息时，无须调用中断服务程序。</p>
<p>4） $\color{green}{\text{通道方式}}$ 。在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I/O命令时，只需启动有关通道，通道将执行通道程序，从而完成I/O操作。</p>
<p>其中，方式1）和方式2）主要用于数据传输率较低的外部设备，方式3）和方式4）主要用于数据传输率较高的设备。</p>
<h3 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h3><p>外部设备也称外围设备，是除主机外的能直接或间接与计算机交换信息的装置。最基本的外部设备主要有键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器等。</p>
<h4 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h4><h5 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h5><p>键盘是最常用的输入设备，通过它可发出命令或输入数据。</p>
<p>键盘通常以矩阵的形式排列按键，每个键用符号标明其含义和作用。每个键相当于一个开关，按下键时，电信号连通;松开键时，弹簧弹起键，电信号断开。</p>
<p>键盘输入信息可分为3个步骤:①查出按下的是哪个键;②将该键翻译成能被主机接收的编码，如ASCII码;③将编码传送给主机。</p>
<h5 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h5><p>鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系。常用的鼠标有 $\color{green}{\text{机械式}}$ 和 $\color{green}{\text{光电式}}$ 两种。</p>
<p>工作原理:鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动。</p>
<h4 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h4><h5 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h5><p>显示设备种类繁多，按显示设备所用的显示器件分类，有阴极射线管（CRT）显示器、液晶显示器（LCD）、发光二极管（LED）显示器等。按所显示的信息内容分类，有字符显示器、图形显示器和图像显示器3大类。显示器属于用点阵方式运行的设备，有以下主要参数。</p>
<p>$\color{green}{\text{屏幕大小}}$ :以对角线长度表示，常用的有12～29英寸等。</p>
<p>$\color{green}{\text{分辨率}}$ :所能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素数的乘积表示，如800×600、1024×768和1280×1024等。</p>
<p>$\color{green}{\text{灰度级}}$ :灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚、逼真，典型的有8位（256级）、16位等。</p>
<p>$\color{green}{\text{刷新}}$ :光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。</p>
<p>$\color{green}{\text{刷新频率}}$ :指单位时间内扫描整个屏幕内容的次数。按照人的视觉生理，刷新频率大于30Hz时才不会感到闪烁，通常显示器的刷新频率为60～120Hz。</p>
<p>$\color{green}{\text{显示存储器}}$ （VRAM）:也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</p>
<p>$$<br>\text{VRAM容量} = \text{分辨率} \times \text{灰度级位数}<br>$$</p>
<p>$$<br>\text{VRAM容量} = \text{分辨率} \times \text{灰度级位数}<br>$$</p>
<p>（1）阴极射线管（CRT）显示器</p>
<p>CRT 显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极、荧光粉涂层和玻璃外壳5部分组成，具有可视角度大、无坏点、色彩还原度高、色度均匀、可调节的多分辨率模式、响应时间极短等目前LCD难以超过的优点。</p>
<p>按显示信息内容不同，可分为字符显示器、图形显示器和图像显示器;按扫描方式不同，可分为光栅扫描和随机扫描两种显示器。下面简要介绍字符显示器和图形显示器。</p>
<p>${\textstyle\unicode{x2460}}$ 字符显示器。显示字符的方法以点阵为基础。点阵是指由m×n个点组成的阵列。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数，它包括字符显示点阵和字符间隔。</p>
<p>将点阵存入由ROM构成的字符发生器中，在CRT进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中О和1代码的不同控制扫描电子束的开或关，从而在屏幕上显示字符。对应于每个字符窗口，所需显示字符的ASCII 代码被存放在视频存储器VRAM中，以备刷新。</p>
<p>${\textstyle\unicode{x2461}}$ 图形显示器。将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中，缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接控制电子束在屏幕上的移动。为在屏幕上保留持久稳定的图像，需按一定的频率对屏幕反复刷新。这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器采用这种随机扫描方式。缺点是当显示复杂图形时，会有闪烁感。</p>
<p>（2）液晶显示器（LCD）</p>
<p>原理:利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再间接控制液晶分子的光学特性来实现图像的显示。</p>
<p>特点:体积小、重量轻、省电、无辐射、绿色环保、画面柔和、不伤眼等。</p>
<p>（3）LED（发光二极管）显示器</p>
<p>原理:通过控制半导体发光二极管来显示文字、图形、图像等各种信息。</p>
<p>LCD与LED是两种不同的显示技术。LCD是由液态晶体组成的显示屏，而LED 则是由发光二极管组成的显示屏。与LCD相比，LED 显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势。</p>
<h5 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h5><p>打印机是计算机的输出设备之一，用于将计算机的处理结果打印在相关介质上。</p>
<p>按工作原理，打印机分为击打式和非击打式两大类;按工作方式，打印机分为点阵打印机、针式打印机、喷墨式打印机、激光打印机等。</p>
<p>（1）针式打印机</p>
<p>原理:在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需的内容。</p>
<p>特点:针式打印机擅长“多层复写打印”，实现各种票据或蜡纸等的打印。其工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。</p>
<p>（2）喷墨式打印机</p>
<p>原理:带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射3种颜色的墨滴，按一定的比例混合出所要求的颜色。</p>
<p>特点:打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快;但防水性差，高质量打印需要专用打印纸。</p>
<p>（3）激光打印机</p>
<p>原理:计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转印和定影，在纸上得到所需的字符或图像。</p>
<p>特点:打印质量高、速度快、噪声小、处理能力强;但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。</p>
<p>激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓（也称硒鼓）是激光打印机的核心部件。</p>
<h4 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a>外存储器</h4><p>计算机的外存储器又称辅助存储器，目前主要使用磁表面存储器。</p>
<p>所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。</p>
<p>磁表面存储器的优点:①存储容量大，位价格低;②记录介质可重复使用;记录信息可长期保存而不丢失，甚至可脱机存档;④非破坏性读出，读出时不需要再生。缺点:存取速度慢，机械结构复杂，对工作环境要求较高。</p>
<p>（1）磁盘设备的组成</p>
<p>${\textstyle\unicode{x2460}}$  存储区域。一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划分为若干扇区，扇区（也称块）是磁盘读写的最小单位，即磁盘按块存取。</p>
<ul>
<li> $\color{green}{\text{磁头数}}$ （Heads）:即记录 $\color{green}{\text{面数}}$ ，表示硬盘共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。</li>
<li> $\color{green}{\text{柱面数}}$ （Cylinders）:表示硬盘每面盘片上有多少条 $\color{green}{\text{磁道}}$ 。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面。</li>
<li> $\color{green}{\text{扇区数}}$ （Sectors）:表示每条磁道上有多少个 $\color{green}{\text{扇区}}$ 。</li>
</ul>
<p>${\textstyle\unicode{x2461}}$ 硬盘存储器的组成。 $\color{red}{\text{硬盘存储器}}$ 由 $\color{green}{\text{磁盘驱动器}}$ 、 $\color{green}{\text{磁盘控制器}}$ 和 $\color{green}{\text{盘片}}$ 组成。</p>
<ul>
<li>磁盘 $\color{green}{\text{驱动器}}$ 。核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动磁头固定盘片的硬盘存储器。</li>
<li>磁盘 $\color{green}{\text{控制器}}$ 。硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA等。</li>
</ul>
<p>（2）磁记录原理</p>
<p>原理:磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作。</p>
<p>编码方法:按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠地实现转换。</p>
<p>磁记录方式:通常采用 $\color{green}{\text{调频制}}$ （FM）和 $\color{green}{\text{改进型调频制}}$ （MFM）的记录方式。</p>
<p>（3）磁盘的性能指标</p>
<p>① $\color{red}{\text{磁盘的容量}}$ 。磁盘容量有 $\color{green}{\text{非格式化}}$ 容量和 $\color{green}{\text{格式化}}$ 容量之分。非格式化容量是指磁记录表面可利用的磁化单元总数，它由道密度和位密度计算而来;格式化容量是指按照某种特定的记录格式所能存储信息的总量。格式化后的容量比非格式化容量要小。</p>
<p>${\textstyle\unicode{x2461}}$   $\color{red}{\text{记录密度}}$ 。记录密度是指盘片单位面积上记录的二进制信息量，通常以 $\color{green}{\text{道密度}}$ 、 $\color{green}{\text{位密度}}$ 和 $\color{green}{\text{面密度}}$ 表示。道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数，面密度是位密度和道密度的乘积。</p>
<p>${\textstyle\unicode{x2462}}$  $\color{red}{\text{平均存取时间}}$ 。 $\color{green}{\text{平均存取时间由寻道时间}}$ （磁头移动到目的磁道的时间）、 $\color{green}{\text{旋转延迟时间}}$ （磁头定位到要读写扇区的时间，取旋转一周时间的一半）和 $\color{green}{\text{传输时间}}$ （传输数据所花费的时间）三部分构成。由于寻道和找扇区的距离远近不一，因此前两部分通常取平均值。</p>
<p>④ $\color{red}{\text{数据传输率}}$ 。磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。假设磁盘转数为r转/秒，每条磁道容量为N字节，则数据传输率为</p>
<p>$$<br>D_r=rN<br>$$</p>
<p>（4）磁盘地址</p>
<p>主机向磁盘控制器发送寻址信息，磁盘的地址一般如图7.1所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716194212.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716194212.png';" /></details>

<p>若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码，其格式如图7.2所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716194259.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716194259.png';" /></details>

<p>（5）硬盘的工作过程</p>
<p>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。</p>
<p>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p>
<h5 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h5><p>RAID（廉价冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</p>
<p>RAID 的分级如下所示。在 RAID1~RAID5几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。</p>
<ul>
<li>RAID0:无冗余和无校验的磁盘阵列。</li>
<li>RAID1:镜像磁盘阵列。</li>
<li>RAID2:采用纠错的海明码的磁盘阵列。 </li>
<li>RAID3:位交叉奇偶校验的磁盘阵列</li>
<li>RAID4:块交叉奇偶校验的磁盘阵列。·</li>
<li>RAID5:无独立校验的奇偶校验磁盘阵列。</li>
</ul>
<p>RAID0把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但RAID0没有容错能力。</p>
<p>为了提高可靠性，RAID1使两个磁盘同时进行读写，互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。</p>
<p>总之，RAID通过同时使用多个磁盘，提高了传输率;通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量;通过镜像功能，提高安全可靠性;通过数据校验，提供容错能力。</p>
<h5 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="*光盘存储器"></a>*光盘存储器</h5><p>光盘存储器是利用光学原理读/写信息的存储装置，它采用聚焦激光束对盘式介质以非接触方式记录信息。</p>
<p>完整的光盘存储系统由光盘片、光盘驱动器、光盘控制器和光盘驱动软件组成。光盘片由透明的聚合物基片、铝合金反射层、漆膜保护层的固盘构成。</p>
<p>特点:具有存储密度高、携带方便、成本低、容量大、存储期限长和容易保存等优点。光盘的类型如下:</p>
<p>光盘的类型如下:</p>
<ul>
<li>CD-ROM:只读型光盘，只能读出其中的内容，不能写入或修改。</li>
<li>CD-R:只可写入一次信息，之后不可修改。</li>
<li>CD-RW:可读可写光盘，可以重复读写。</li>
<li>DVD-ROM:高容量的CD-ROM，DVD表示通用数字化多功能光盘。</li>
</ul>
<h5 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h5><p>微小型高档笔记本计算机采用高性能Flash Memory作为硬盘来记录数据，这种“硬盘”称固态硬盘。固态硬盘除需要Flash Memory外，还需要其他硬件和软件的支持。</p>
<h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h3><p>I/O接口（I/O控制器）是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。主机和外设具有各自的工作特点，它们在信息形式和工作速度上具有很大的差异，接口正是为了解决这些差异而设置的。</p>
<h4 id="I-O接口的功能"><a href="#I-O接口的功能" class="headerlink" title="I/O接口的功能"></a>I/O接口的功能</h4><p>I/O接口的主要功能如下:</p>
<p>1）实现主机和外设的 $\color{green}{\text{通信联络控制}}$ 。解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。</p>
<p>2）进行 $\color{green}{\text{地址译码}}$ 和 $\color{green}{\text{设备选择}}$ 。CPU送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息。</p>
<p>3）实现 $\color{green}{\text{数据缓冲}}$ 。CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。</p>
<p>4）信号 $\color{green}{\text{格式的转换}}$ 。外设与主机两者的电平、数据格式都可能存在差异，接口应提供计算机与外设的信号格式的转换功能，如电平转换、并/串或串/并转换、模/数或数/模转换等。</p>
<p>5）传送 $\color{green}{\text{控制命令}}$ 和 $\color{green}{\text{状态信息}}$ 。CPU要启动某一外设时，通过接口中的命令寄存器向外设发出启动命令;外设准备就绪时，则将“准备好”状态信息送回接口中的状态寄存器，并反馈给CPU。外设向CPU提出中断请求时，CPU也应有相应的响应信号反馈给外设。</p>
<h4 id="I-O接口的基本结构"><a href="#I-O接口的基本结构" class="headerlink" title="I/O接口的基本结构"></a>I/O接口的基本结构</h4><p>如图7.3所示，I/O接口在主机侧通过I/O总线与内存、CPU相连。通过 $\color{green}{\text{数据总线}}$ ，在 $\color{green}{\text{数据缓冲寄存器}}$ 与内存或CPU的寄存器之间进行数据传送。同时接口和设备的状态信息被记录在 $\color{green}{\text{状态寄存器}}$ 中，通过数据线将状态信息送到CPU。CPU对外设的控制命令也通过数据线传送，一般将其送到I/O接口的控制寄存器。状态寄存器和控制寄存器在传送方向上是相反的。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716195002.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716195002.png';" /></details>

<p>接口中的地址线用于给出要访问的I/O接口中的寄存器的地址，它和读/写控制信号一起被送到I/O接口的控制逻辑部件，其中地址信息用以选择和主机交换信息的寄存器，通过控制线传送来的读/写信号确认是读寄存器还是写寄存器，此外控制线还会传送一些仲裁信号和握手信号。</p>
<p>接口中的I/O控制逻辑还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。另外，它还要具有收集外设状态到状态寄存器的功能。</p>
<p>对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为I/O指令，I/O指令只能在操作系统内核的底层I/O软件中使用，它们是一种 $\color{green}{\text{特权指令}}$ 。</p>
<blockquote>
<p>注意:接口和端口是两个不同的概念。端口是指接口电路中可以进行读/写的寄存器，若干端口加上相应的控制逻辑才可以组成接口。</p>
</blockquote>
<h4 id="I-O接口的类型"><a href="#I-O接口的类型" class="headerlink" title="I/O接口的类型"></a>I/O接口的类型</h4><p>从不同的角度看，I/O接口可以分为不同的类型。</p>
<p>1）按数据传送方式可分为 $\color{green}{\text{并行接口}}$ （一字节或一个字的所有位同时传送）和 $\color{green}{\text{串行接口}}$ （一位一位地传送），接口要完成数据格式的转换。</p>
<blockquote>
<p>注意:这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，数据总是并行传送的。</p>
</blockquote>
<p>2）按主机访问I/O设备的控制方式可分为 $\color{green}{\text{程序查询接口}}$ 、 $\color{green}{\text{中断接口}}$ 和 $\color{green}{\text{DMA接口}}$ 等。</p>
<p>3）按功能选择的灵活性可分为 $\color{green}{\text{可编程接口}}$ 和 $\color{green}{\text{不可编程接口}}$ 。</p>
<h4 id="I-O端口及其编址"><a href="#I-O端口及其编址" class="headerlink" title="I/O端口及其编址"></a>I/O端口及其编址</h4><p>I/O端口是指接口电路中可被CPU直接访问的寄存器，主要有 $\color{green}{\text{数据端口}}$ 、 $\color{green}{\text{状态端口}}$ 和 $\color{green}{\text{控制端口}}$ ，若干端口加上相应的控制逻辑电路组成接口。通常，CPU能对数据端口执行读写操作，但对状态端口只能执行读操作，对控制端口只能执行写操作。</p>
<p>I/O端口要想能够被CPU访问，就必须要对各个端口进行编号，每个端口对应一个端口地址。而对I/O端口的编址方式有与存储器统一编址和独立编址两种。</p>
<p>1） $\color{green}{\text{统一编址}}$ ，又称存储器映射方式，是指把I/O端口当作存储器的单元进行地址分配，这种方式CPU不需要设置专门的I/O指令，用统一的 $\color{green}{\text{访存指令}}$ 就可以访问I/O端口。优点:不需要专门的输入/输出指令，可使CPU访问UO 的操作更灵活、更方便，还可使端口有较大的编址空间。缺点:端口占用存储器地址，使内存容量变小，而且利用存储器编址的VO设备进行数据输入/输出操作，执行速度较慢。</p>
<p>2） $\color{green}{\text{独立编址}}$ ，又称I/O映射方式，I/O端口的地址空间与主存地址空间是两个独立的地址空间，因而无法从地址码的形式上区分，需要设置专门的 $\color{green}{\text{I/O指令}}$ 来访问I/O端口。优点:输入/输出指令与存储器指令有明显区别，程序编制清晰，便于理解。缺点:输入/输出指令少，一般只能对端口进行传送操作，尤其需要CPU提供存储器读/写、I/O设备读/写两组控制信号，增加了控制的复杂性。</p>
<h3 id="I-O-方式"><a href="#I-O-方式" class="headerlink" title="I/O 方式"></a>I/O 方式</h3><p>输入/输出系统实现主机与I/O设备之间的数据传送，可以采用不同的控制方式，各种方式在代价、性能、解决问题的着重点等方面各不相同，常用的I/O方式有 $\color{green}{\text{程序查询}}$ 、 $\color{green}{\text{程序中断}}$ 、 $\color{green}{\text{DMA}}$ 和 $\color{green}{\text{通道}}$ 等，其中前两种方式更依赖于CPU中程序指令的执行。</p>
<h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p>信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。主机进行I/O操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。</p>
<p>程序查询方式的工作流程如下（见图7.4）</p>
<p>${\textstyle\unicode{x2460}}$  CPU执行初始化程序，并预置传送参数。</p>
<p>②向I/O接口发出命令字，启动I/O设备。</p>
<p>${\textstyle\unicode{x2462}}$ 从外设接口读取其状态信息。</p>
<p>${\textstyle\unicode{x2463}}$ CPU 不断查询I/O设备状态，直到外设准备就绪。</p>
<p>${\textstyle\unicode{x2464}}$ 传送一次数据。</p>
<p>⑥修改地址和计数器参数。</p>
<p>${\textstyle\unicode{x2466}}$ 判断传送是否结束，若未结束转第 ${\textstyle\unicode{x2462}}$  步，直到计数器为0。</p>
<details style="width:250px"><summary>图7.4 程序查询方式流程图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716195423.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716195423.png';"/></details>

<p>在这种控制方式下，CPU一旦启动I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序。程序查询方式的主要特点是CPU有“踏步”等待现象，CPU与I/O串行工作。这种方式的接口设计简单、设备量少，但CPU 在信息传送过程中要花费很多时间来查询和等待，而且在 $\color{green}{\text{一段时间}}$ 内只能和 $\color{green}{\text{一台}}$ 外设交换信息，效率大大降低。</p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p>现代计算机系统中都配有完善的异常和中断处理系统，CPU的数据通路中有相应的异常和中断的检测和响应逻辑，在外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序。这些中断硬件线路和中断服务程序有机结合，共同完成异常和中断的处理过程。</p>
<h5 id="异常和中断"><a href="#异常和中断" class="headerlink" title="异常和中断"></a>异常和中断</h5><p>（1）异常</p>
<p>异常是指由 $\color{green}{\text{CPU内部}}$ 异常引起的意外事件，分为 $\color{green}{\text{硬故障中断}}$ 和 $\color{green}{\text{程序性异常}}$ 。 $\color{red}{\text{硬故障中断}}$ 是由硬连线出现异常引起的，如 $\color{green}{\text{电源掉电}}$ 、 $\color{green}{\text{存储器线路错}}$ 等。 $\color{red}{\text{程序性异常}}$ 也称 $\color{red}{\text{软中断}}$ ，是指在CPU内部因执行指令而引起的异常事件。如 $\color{green}{\text{整除0}}$ 、 $\color{green}{\text{溢出}}$ 、 $\color{green}{\text{断点}}$ 、 $\color{green}{\text{单步跟踪}}$ 、 $\color{green}{\text{非法指令}}$ 、 $\color{green}{\text{栈溢出}}$ 、 $\color{green}{\text{地址越界}}$ 、 $\color{green}{\text{缺页}}$ 、分时系统中的 $\color{green}{\text{时间片中断}}$ 及用户态到核心态的 $\color{green}{\text{切换}}$ 等。按发生异常的报告方式和返回方式不同， $\color{red}{\text{内部异常}}$ 可分为 $\color{green}{\text{故障}}$ （Fault）、 $\color{green}{\text{自陷}}$ （Trap）和 $\color{green}{\text{终止}}$ （Abort）三类。</p>
<p>${\textstyle\unicode{x2460}}$  故障（Fault）</p>
<p>指在引起故障等指令启动后、执行结束前被检测到的异常事件。例如，指令译码时，出现“非法操作码”;取数据时，发生“缺段”或“缺页”;执行整数除法指令时，发现“除数为0”等。对于“缺段”“缺页”等异常处理后，已将所需的段或页面从磁盘调入主存，可回到发生故障的指令继续执行，断点为当前发生故障的指令;对于“非法操作码”“除数为0”等， 因为无法通过异常处理程序恢复故障 ，因此不能回到原断点执行，必须终止进程的执行。</p>
<p>${\textstyle\unicode{x2461}}$ 自陷（Trap）</p>
<p>自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。通常的做法是:事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”，当执行到被设置了“陷阱”的指令时，CPU在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。注意，当自陷指令是转移指令时，并不是返回到下一条指令执行，而是返回到转移目标指令执行。</p>
<p>在80x86中，用于程序调试的“ $\color{green}{\text{断点设置}}$ ”功能就是通过 $\color{green}{\text{自陷}}$ 方式实现的。此外，系统调用指令、条件自陷指令（如MIPS 中 teq、teqi、tne、tnei等一组按条件进入陷阱的指令）等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动调出操作系统内核程序进行执行。</p>
<p>③终止（Abort）</p>
<p>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，如电源掉电、线路故障等，那么程序将无法继续执行，只能终止，此时，调出中断服务程序来重启系统。这种异常与故障和自陷不同，不是由特定指令产生的，而是 $\color{green}{\text{随机}}$ 发生的。</p>
<p>（2）外部中断</p>
<p> $\color{red}{\text{外中断}}$ 是指来自CPU外部、与CPU执行指令无关的事件引起的中断，包括 $\color{green}{\text{I/O设备}}$ 发出的I/O 中断（如键盘输入、打印机缺纸等）、 $\color{green}{\text{外部信号中断}}$ （如用户按Esc键），以及各种定时器引起的时钟中断等。外中断在狭义上一般称为中断（书中若未说明，一般是指外中断）。</p>
<p>外中断和内部异常在本质上是一样的，但它们之间有以下两个重要的不同点:</p>
<p>1）“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。</p>
<p>2）异常的检测是由CPU自身完成的，不必通过外部的某个信号通知CPU。对于中断，CPU必须通过总线获取中断源的标识信息，才能获知哪个设备发生了何种中断。</p>
<p>有些教材也将异常和中断统称为中断，将由CPU内部产生的异常称为内中断，将通过中断请求线INTR和 NMI 从 CPU 外部发出的中断请求称为外中断。</p>
<h5 id="中断的基本概念"><a href="#中断的基本概念" class="headerlink" title="中断的基本概念"></a>中断的基本概念</h5><p>程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU 暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。</p>
<p>程序中断的作用如下:</p>
<p>${\textstyle\unicode{x2460}}$  实现CPU与I/O设备的并行工作。</p>
<p>② $\color{green}{\text{处理}}$ 硬件故障和软件错误。</p>
<p>③实现人机交互，用户 $\color{green}{\text{干预}}$ 机器需要用到中断系统。</p>
<p>④实现多道程序、 $\color{green}{\text{分时操作}}$ ， $\color{green}{\text{多道程序}}$ 的切换需借助于中断系统。</p>
<p>⑤实时处理需要借助中断系统来实现 $\color{green}{\text{快速响应}}$ 。</p>
<p>⑥实现应用程序和操作系统（管态程序）的切换，称为“ $\color{green}{\text{软中断}}$ ”。</p>
<p>⑦多处理器系统中各处理器之间的 $\color{green}{\text{信息交流}}$ 和 $\color{green}{\text{任务切换}}$ 。</p>
<p>程序中断方式的思想:CPU在程序中安排好于某个时刻启动某台外设，然后CPU继续执行原来的程序，不需要像查询方式那样一直等待外设准备就绪。一旦外设完成数据传送的准备工作，就主动向CPU发出中断请求，请求CPU为自己服务。在可以响应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序，如图7.5所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716210133.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716210133.png';" /></details>

<h5 id="程序中断方式工作流程"><a href="#程序中断方式工作流程" class="headerlink" title="程序中断方式工作流程"></a>程序中断方式工作流程</h5><p>（1）中断请求</p>
<p>中断源是请求CPU中断的设备或事件，一台计算机允许有多个中断源。每个中断源向CPU发出中断请求的时间是随机的。为记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器INTR，当其状态为“1”时，表示中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。</p>
<p>内中断皆为 $\color{green}{\text{不可屏蔽中断}}$ 。通过INTR信号线发出的外中断是 $\color{green}{\text{可屏蔽中断}}$ ，在关中断（IF =1）的情况下不会被响应;而通过NMI信号发出的是不可屏蔽中断，即使在关中断（IF=0）的情况下也会被响应。不可屏蔽中断的处理优先级最高，任何时候只要发生不可屏蔽中断，都要中止现行程序的执行，转到不可屏蔽中断处理程序执行。</p>
<p>（2）中断判优</p>
<p>中断系统在任一瞬间只能响应一个中断源的请求。由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过中断判优逻辑确定响应哪个中断源的请求，例如故障中断的优先级别较高，然后是I/O中断。</p>
<p>中断判优既可以用硬件实现，又可用软件实现。硬件实现是通过 $\color{green}{\text{硬件排队器}}$ 实现的，它既可以设置在CPU中，又可以分散在各个中断源中，软件实现是通过 $\color{green}{\text{查询程序}}$ 实现的。</p>
<p>一般来说，硬件故障中断属于最高级，其次是软件中断，不可屏蔽中断优于可屏蔽中断，DMA 请求优于I/O 设备传送的中断请求，高速设备优于低速设备，输入设备优于输出设备，实时设备优于普通设备等。</p>
<p>（3 ）CPU 响应中断的条件</p>
<p>CPU在满足一定的条件下响应中断源发出的中断请求，并经过一些特定的操作，转去执行中断服务程序。CPU响应中断必须满足以下3个条件:</p>
<p>①中断源有中断请求。</p>
<p>${\textstyle\unicode{x2461}}$  CPU允许中断及开中断。</p>
<p>${\textstyle\unicode{x2462}}$ 一条指令执行完毕，且没有更紧迫的任务。</p>
<blockquote>
<p>注意:I/O设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取I/O 的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指外中断，内中断不属于此类情况。</p>
</blockquote>
<p>（4）中断响应</p>
<p>CPU 响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，我们将它称为 $\color{red}{\text{中断隐指令}}$ 。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下:</p>
<p>${\textstyle\unicode{x2460}}$   $\color{green}{\text{关中断}}$ 。CPU响应中断后，首先要保护程序的断点和现场信息，在保护断点和现场的过程中，CPU不能响应更高级中断源的中断请求。</p>
<p>②  $\color{green}{\text{保存断点}}$ 。为保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（指令无法直接读取的 $\color{green}{\text{PC}}$ 和PSWR $\color{green}{\text{等的内容）保存起来。<br> }}$<br>${\textstyle\unicode{x2462}}$  $\color{green}{\text{引出中断服务程序}}$ 。实质是取出中断服务程序的入口地址并传送给程序计数器（PC）。</p>
<p>（5）中断向量</p>
<p>每个中断都有一个类型号，每个中断类型号都对应一个中断服务程序，每个中断服务程序都有一个入口地址，CPU必须找到入口地址，即中断向量，把系统中的全部中断向量集中存放到存储器的某个区域内，这个存放中断向量的存储区就称为中断向量表。</p>
<p>CPU 响应中断后，中断硬件会自动将中断向量地址传送到CPU，由 CPU实现程序的切换，这种方法称为中断向量法，采用中断向量法的中断称为向量中断。</p>
<blockquote>
<p>注意: $\color{red}{\text{中断向量}}$ 是 $\color{green}{\text{中断服务程序的入口地址}}$ ， $\color{red}{\text{中断向量地址}}$ 是指 $\color{green}{\text{中断服务程序的入口地址的地址}}$ 。</p>
</blockquote>
<p>（6）中断处理过程</p>
<p>不同计算机的中断处理过程各具特色，就其多数而论，中断处理流程如图7.6所示。</p>
<p>中断处理流程如下:</p>
<p>${\textstyle\unicode{x2460}}$   $\color{green}{\text{关中断}}$ 。在保护断点和现场期间不能被新的中断所打断，必须关中断。否则，若断点或现场保存不完整，在中断服务程序结束后，就不能正确地恢复并继续执行现行程序。</p>
<p>${\textstyle\unicode{x2461}}$  $\color{green}{\text{保存断点}}$ 。断点可以压入堆栈，也可以存入主存的特定单元中。</p>
<p>${\textstyle\unicode{x2462}}$   $\color{green}{\text{引出中断服务程序}}$ 。通常有两种方法寻址中断服务程序的入口地址: $\color{green}{\text{硬件向量法}}$ 和 $\color{green}{\text{软件查询法}}$ 。硬件向量法通过硬件产生中断向量地址，再由中断向量地址找到中断服务程序的入口地址。软件查询法用软件编程的办法寻找入口地址。</p>
<blockquote>
<p>注意:硬件产生的实际上是中断类型号，而中断类型号指出了中断向量存放的地址，因此能产生中断向量地址。</p>
</blockquote>
<p>${\textstyle\unicode{x2463}}$   $\color{green}{\text{保存现场和屏蔽字}}$ 。进入中断服务程序后首先要保存现场和中断屏蔽字，现场信息是指用户可见的工作寄存器的内容，它存放着程序执行到断点处的现行值。</p>
<blockquote>
<p>注意:现场和断点，这两类信息都不能被中断服务程序破坏。现场信息因为用指令可直接访问，所以通常在中断服务程序中通过指令把它们保存到栈中，即由软件实现;而断点信息由CPU在中断响应开始时自动保存到栈或专门的寄存器中，即由硬件实现。</p>
</blockquote>
<p>⑤ $\color{green}{\text{开中断}}$ 。允许更高级中断请求得到响应，实现中断嵌套。</p>
<p>⑥ $\color{green}{\text{执行中断服务程序}}$ 。这是中断请求的目的。</p>
<p>⑦ $\color{green}{\text{关中断}}$ 。保证在恢复现场和屏蔽字时不被中断。</p>
<p>⑧ $\color{green}{\text{恢复现场和屏蔽字}}$ 。将现场和屏蔽字恢复到原来的状态。</p>
<p>${\textstyle\unicode{x2468}}$   $\color{green}{\text{开中断、中断返回}}$ 。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p>
<p>其中，①<del>③在CPU进入中断周期后，由中断隐指令（硬件自动）完成;④</del>⑨由中断服务程序完成。</p>
<blockquote>
<p>注意:恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作由中断服务程序完成。中断返回由中断服务程序的最后一条中断返回指令完成。</p>
</blockquote>
<details style="width:300px"><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716210821.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716210821.png';" /></details>


<h5 id="多重中断和中断屏蔽技术"><a href="#多重中断和中断屏蔽技术" class="headerlink" title="多重中断和中断屏蔽技术"></a>多重中断和中断屏蔽技术</h5><p>若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而CPU对新的中断请求不予响应，则这种中断称为 $\color{green}{\text{单重中断}}$ ，如图7.7（a）所示。若CPU 暂停现行的中断服务程序，转去处理新的中断请求，则这种中断称为 $\color{green}{\text{多重中断}}$ ，又称 $\color{green}{\text{中断嵌套}}$ ，如图7.7（b）所示。</p>
<p>中断屏蔽技术主要用于多重中断。CPU要具备多重中断的功能，必须满足下列条件:</p>
<p>①在中断服务程序中提前设置开中断指令。</p>
<p>②优先级别高的中断源有权中断优先级别低的中断源。</p>
<p>每个中断源都有一个 $\color{red}{\text{屏蔽触发器}}$ ， $\color{green}{\text{1}}$ 表示 $\color{green}{\text{屏蔽该中断源}}$ 的请求， $\color{green}{\text{0}}$ 表示可以 $\color{green}{\text{正常申请}}$ ，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。</p>
<p>关于中断屏蔽字的设置及多重中断程序执行的轨迹，下面通过实例说明。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716211109.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211109.png';" /></details>



<details><summary>例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716211251.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211251.png';" /></details>

<ul>
<li>中断屏蔽字为什么是这样求</li>
</ul>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>DMA方式是一种 $\color{green}{\text{完全由硬件}}$ 进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU与外设并行工作。DMA方式在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过CPU，降低了CPU 在传送数据时的开销，因此称为 $\color{green}{\text{直接存储器存取}}$ 方式。由于数据传送不经过CPU，也就不需要保护、恢复CPU现场等烦琐操作。</p>
<p>这种方式适用于磁盘机、磁带机等高速设备大批量数据的传送，它的硬件开销比较大。在DMA方式中，中断的作用仅限于 $\color{green}{\text{故障}}$ 和 $\color{green}{\text{正常传送结束时的处理}}$ 。</p>
<h5 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h5><p>主存和 DMA接口之间有一条直接数据通路。由于 DMA方式传送数据不需要经过CPU,因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。</p>
<p>DMA方式具有下列特点:</p>
<p>①它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。</p>
<p>${\textstyle\unicode{x2461}}$  在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</p>
<p>③主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p>
<p>${\textstyle\unicode{x2463}}$  DMA传送速度快，CPU和外设并行工作，提高了系统效率。</p>
<p>${\textstyle\unicode{x2464}}$  DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p>
<h5 id="DMA控制器的组成"><a href="#DMA控制器的组成" class="headerlink" title="DMA控制器的组成"></a>DMA控制器的组成</h5><p>在DMA方式中，对数据传送过程进行控制的硬件称为DMA控制器（DMA接口）。当I/O 设备需要进行数据传送时，通过DMA控制器向CPU提出DMA传送请求，CPU响应之后将让出系统总线，由DMA控制器接管总线进行数据传送。其主要功能如下:</p>
<p>1）接受外设发出的DMA请求，并向CPU发出总线请求。</p>
<p>2） CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期。</p>
<p>3）确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数。</p>
<p>4）规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。</p>
<p>5）向CPU报告DMA操作的结束。</p>
<p>图7.10给出了一个简单的DMA控制器。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716211543.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211543.png';" /></details>


<ul>
<li>主存地址计数器:存放要交换数据的主存地址。</li>
<li>传送长度计数器:记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。</li>
<li>数据缓冲寄存器:暂存每次传送的数据。</li>
<li>DMA请求触发器:每当I/O设备准备好数据后，给出一个控制信号，使 DMA请求触发器置位。</li>
<li>“控制/状态”逻辑:由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对 DMA请求信号和CPU响应信号进行协调和同步。</li>
<li>中断机构:当一个数据块传送完毕后触发中断机构，向CPU提出中断请求。</li>
</ul>
<p>在 DMA传送过程中，DMA 控制器将接管CPU的地址总线、数据总线和控制总线，CPU的主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。由此可见，DMA控制器必须具有控制系统总线的能力。</p>
<h5 id="DMA的传送方式"><a href="#DMA的传送方式" class="headerlink" title="DMA的传送方式"></a>DMA的传送方式</h5><p>主存和I/O设备之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA控制器与CPU通常采用以下3种方式使用主存:</p>
<p>1）停止CPU访存。当I/O设备有DMA请求时，由DMA 控制器向CPU发送一个停止信号，使 CPU 脱离总线，停止访问主存，直到 DMA传送一块数据结束。数据传送结束后，DMA控制器通知CPU可以使用主存，并把总线控制权交还给CPU。</p>
<p>2）周期挪用（或周期窃取）。当I/O设备有 DMA请求时，会遇到3种情况:①是此时CPU 不在访存（如CPU正在执行乘法指令），因此 I/O 的访存请求与CPU未发生冲突;②是CPU正在访存，此时必须待存取周期结束后，CPU 再将总线占有权让出;③是I/O和 CPU同时请求访存，出现访存冲突，此时CPU 要暂时放弃总线占有权。I/O访存优先级高于CPU访存，因为I/O不立即访存就可能丢失数据，此时由I/O设备挪用一个或几个存取周期，传送完一个数据后立即释放总线，是一种单字传送方式。</p>
<p>3）DMA与CPU交替访存。这种方式适用于CPU 的工作周期比主存存取周期长的情况。例如，若CPU的工作周期是 1.2$\mu$s，主存的存取周期小于0.6$\mu$s，则可将一个CPU周期分为$C_1$和$C_2$,两个周期，其中 $C_1$专供 DMA 访存，$C_2$专供 CPU访存。这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过$C_1$和$C_2$分时控制的。</p>
<h5 id="DMA的传送过程"><a href="#DMA的传送过程" class="headerlink" title="DMA的传送过程"></a>DMA的传送过程</h5><p>DMA的数据传送过程分为预处理、数据传送和后处理3个阶段:</p>
<p>1） $\color{green}{\text{预处理}}$ 。由CPU 完成一些必要的准备工作。首先，CPU执行几条I/O 指令，用以测试I/O设备状态，向 DMA 控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU 发送总线请求（有时将这两个过程统称为DMA请求），用以传输数据。</p>
<p>2） $\color{green}{\text{数据传送}}$ 。DMA的数据传输可以以单字节（或字）为基本单位，也可以以数据块为基本单位。对于以数据块为单位的传送（如硬盘），DMA占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器（而非通过CPU执行程序）实现的，即数据传送阶段完全由DMA（硬件）控制。</p>
<p>3） $\color{green}{\text{后处理}}$ 。DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括校验送入主存的数据是否正确、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用DMA传送其他数据块等。DMA 的传送流程如图7.11所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210716211945.png" alt="找不到图片（Image not found）" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210716211945.png';" /></details>


<h5 id="DMA方式和中断方式的区别"><a href="#DMA方式和中断方式的区别" class="headerlink" title="DMA方式和中断方式的区别"></a>DMA方式和中断方式的区别</h5><p>DMA方式和中断方式的重要区别如下:</p>
<p>${\textstyle\unicode{x2460}}$  中断方式是程序的切换，需要保护和恢复现场;而DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源。</p>
<p>${\textstyle\unicode{x2461}}$ 对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期后）;而对DMA请求的响应可以发生在每个机器周期结束时（在取指周期、间址周期、执行周期后均可），只要CPU不占用总线就可被响应。</p>
<p>${\textstyle\unicode{x2462}}$ 中断传送过程需要CPU的干预;而 DMA传送过程不需要CPU 的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。</p>
<p>${\textstyle\unicode{x2463}}$ DMA请求的优先级高于中断请求。</p>
<p>${\textstyle\unicode{x2464}}$ 中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的I/O操作。</p>
<p>${\textstyle\unicode{x2465}}$ 从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><h4 id="I-O设备有哪些编址方式-各有何特点"><a href="#I-O设备有哪些编址方式-各有何特点" class="headerlink" title="I/O设备有哪些编址方式?各有何特点?"></a>I/O设备有哪些编址方式?各有何特点?</h4><p>$\color{green}{\text{统一编址}}$ 和 $\color{green}{\text{独立编址}}$ 。统一编址是在主存地址中划出一定的范围作为I/O地址，以便通过访存指令即可实现对I/O 的访问，但主存的容量相应减少。独立编址是指I/O 地址和主存是分开的，I/O地址不占主存空间，但访存需专门的I/O指令。</p>
<h4 id="CPU响应中断应具备哪些条件"><a href="#CPU响应中断应具备哪些条件" class="headerlink" title="CPU响应中断应具备哪些条件?"></a>CPU响应中断应具备哪些条件?</h4><p>在CPU内部设置的中断屏蔽触发器必须是开放的。</p>
<p>${\textstyle\unicode{x2460}}$  外设有中断请求时，中断请求触发器必须处于“1”状态，保持中断请求信号。</p>
<p>${\textstyle\unicode{x2461}}$ 外设（接口）中断允许触发器必须为“1”，这样才能把外设中断请求送至CPU.</p>
<p>${\textstyle\unicode{x2462}}$ 具备上述三个条件时，CPU在现行指令结束的最后一个状态周期响应中断。</p>
<h3 id="常见问题和易混淆知识点"><a href="#常见问题和易混淆知识点" class="headerlink" title="常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h3><h4 id="中断响应优先级和中断处理优先级分别指什么"><a href="#中断响应优先级和中断处理优先级分别指什么" class="headerlink" title="中断响应优先级和中断处理优先级分别指什么?"></a>中断响应优先级和中断处理优先级分别指什么?</h4><p>中断响应优先级是由硬件排队线路或中断查询程序的查询顺序决定的，不可动态改变;而中断处理优先级可以由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为“0”，对新中断开放），若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。</p>
<h4 id="向量中断、中断向量、向量地址三个概念是什么关系"><a href="#向量中断、中断向量、向量地址三个概念是什么关系" class="headerlink" title="向量中断、中断向量、向量地址三个概念是什么关系?"></a>向量中断、中断向量、向量地址三个概念是什么关系?</h4><p>中断向量:每个中断源都有对应的处理程序，这个处理程序称为 $\color{green}{\text{中断服务程序}}$ ，其入口地址称为 $\color{green}{\text{中断向量}}$ 。所有中断的中断服务程序入口地址构成一个表，称为 $\color{green}{\text{中断向量表}}$ ;也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表。</p>
<p>$\color{green}{\text{向量地址}}$ :中断向量表或中断向量跳转表中每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。</p>
<p>$\color{green}{\text{向量中断}}$ :指一种识别中断源的技术或方式。识别中断源的目的是找到中断源对应的中断服务程序的入口地址的地址，即获得向量地址。</p>
<h4 id="程序中断和调用子程序有何区别"><a href="#程序中断和调用子程序有何区别" class="headerlink" title="程序中断和调用子程序有何区别?"></a>程序中断和调用子程序有何区别?</h4><p>两者的根本区别主要表现在服务时间和服务对象上不一样。</p>
<p>1）调用子程序过程发生的时间是已知的和固定的，即在主程序中的调用指令（CALL）执行时发生主程序调用子程序过程，调用指令所在位置是已知的和固定的。而中断过程发生的时间一般是随机的，CPU在执行某个主程序时收到中断源提出的中断申请，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的。也可以说，调用子程序是程序设计者事先 $\color{green}{\text{安排}}$ 的，而执行中断服务程序是由系统工作环境 $\color{green}{\text{随机}}$ 决定的。</p>
<p>2）子程序完全为主程序服务，两者属于 $\color{green}{\text{主从关系}}$ 。主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序二者一般是无关的，不存在谁为谁服务的问题，两者是 $\color{green}{\text{平行关系}}$ 。</p>
<p>3）主程序调用子程序的过程完全属于 $\color{green}{\text{软件}}$ 处理过程，不需要专门的硬件电路;而中断处理系统是一个 $\color{green}{\text{软/硬件}}$ 结合的系统，需要专门的硬件电路才能完成中断处理的过程。</p>
<p>4）子程序嵌套可实现 $\color{green}{\text{若干级}}$ ，嵌套的最多级数受计算机内存开辟的堆栈大小限制;而中断嵌套级数主要由中断优先级来决定，一般优先级数不会很大。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%80%83%E7%A0%94/" rel="tag"># 考研</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag"># 计算机组成原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch6-%E6%80%BB%E7%BA%BF/" rel="prev" title="王道-计算机组成原理-ch6-总线">
      <i class="fa fa-chevron-left"></i> 王道-计算机组成原理-ch6-总线
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/30/%E4%B9%A0%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="next" title="习题-计算机组成原理">
      习题-计算机组成原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%8B%E9%81%93"><span class="nav-text">王道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="nav-text">输入&#x2F;输出系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">I&#x2F;O系统基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F-1"><span class="nav-text">输入&#x2F;输出系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">I&#x2F;O控制方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87"><span class="nav-text">外部设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87"><span class="nav-text">输入设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="nav-text">输出设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">外存储器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E6%8E%A5%E5%8F%A3"><span class="nav-text">I&#x2F;O接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">I&#x2F;O接口的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">I&#x2F;O接口的基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">I&#x2F;O接口的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%85%B6%E7%BC%96%E5%9D%80"><span class="nav-text">I&#x2F;O端口及其编址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-%E6%96%B9%E5%BC%8F"><span class="nav-text">I&#x2F;O 方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="nav-text">程序查询方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="nav-text">程序中断方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DMA%E6%96%B9%E5%BC%8F"><span class="nav-text">DMA方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-text">本章小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E8%AE%BE%E5%A4%87%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F-%E5%90%84%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9"><span class="nav-text">I&#x2F;O设备有哪些编址方式?各有何特点?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD%E5%BA%94%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E6%9D%A1%E4%BB%B6"><span class="nav-text">CPU响应中断应具备哪些条件?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">常见问题和易混淆知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E5%88%AB%E6%8C%87%E4%BB%80%E4%B9%88"><span class="nav-text">中断响应优先级和中断处理优先级分别指什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E4%B8%AD%E6%96%AD%E3%80%81%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E3%80%81%E5%90%91%E9%87%8F%E5%9C%B0%E5%9D%80%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="nav-text">向量中断、中断向量、向量地址三个概念是什么关系?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E5%92%8C%E8%B0%83%E7%94%A8%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="nav-text">程序中断和调用子程序有何区别?</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '04b9fe1c5636beb4acc4',
      clientSecret: '8ccb8829887eac219a8fdb018878fd0cf088a7ac',
      repo        : 'gittalk-comment',
      owner       : 'ednow',
      admin       : ['ednow'],
      id          : '67ff8b860616877506f5f67529b68200',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
