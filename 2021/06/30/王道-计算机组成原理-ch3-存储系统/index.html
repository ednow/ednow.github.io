<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="王道存储系统p101 (一）存储器的分类 (二）存储器的层次化结构 (三）半导体随机存取存储器 SRAM、DRAM、只读存储器、Flash存储器(四）主存储器与CPU的连接 (五）双口 RAM和多模块存储器 (六）高速缓冲存储器(Cache) Cache的基本工作原理 Cache和主存之间的映射方式 Cache 中主存块的替换算法 Cache 写策略 (七）虚拟存储器 虚拟存储器的基本概念;页式虚">
<meta property="og:type" content="article">
<meta property="og:title" content="王道-计算机组成原理-ch3-存储系统">
<meta property="og:url" content="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:description" content="王道存储系统p101 (一）存储器的分类 (二）存储器的层次化结构 (三）半导体随机存取存储器 SRAM、DRAM、只读存储器、Flash存储器(四）主存储器与CPU的连接 (五）双口 RAM和多模块存储器 (六）高速缓冲存储器(Cache) Cache的基本工作原理 Cache和主存之间的映射方式 Cache 中主存块的替换算法 Cache 写策略 (七）虚拟存储器 虚拟存储器的基本概念;页式虚">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210916171617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706191304.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706191358.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210915223746.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210915223832.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210915223902.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192109.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192257.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192339.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192659.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143016.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143129.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143317.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143507.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713144506.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713144828.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713145516.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713145913.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150108.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150634.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150701.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210924152123.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150844.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713151122.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713151848.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210917222222.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713152631.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713152658.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713153647.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713153710.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210917223507.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154134.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154218.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154314.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154336.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154711.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713155910.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160100.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160354.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160635.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160731.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160922.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160956.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713161018.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713161116.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210917223553.png">
<meta property="article:published_time" content="2021-06-30T01:59:38.000Z">
<meta property="article:modified_time" content="2021-09-24T14:53:03.709Z">
<meta property="article:author" content="ednow">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20210916171617.png">

<link rel="canonical" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>王道-计算机组成原理-ch3-存储系统 | ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch3-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          王道-计算机组成原理-ch3-存储系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-30 09:59:38" itemprop="dateCreated datePublished" datetime="2021-06-30T09:59:38+08:00">2021-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-24 22:53:03" itemprop="dateModified" datetime="2021-09-24T22:53:03+08:00">2021-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p>p101</p>
<p>(一）存储器的分类</p>
<p>(二）存储器的层次化结构</p>
<p>(三）半导体随机存取存储器</p>
<p>SRAM、DRAM、只读存储器、Flash存储器(四）主存储器与CPU的连接</p>
<p>(五）双口 RAM和多模块存储器</p>
<p>(六）高速缓冲存储器(Cache)</p>
<p>Cache的基本工作原理</p>
<p>Cache和主存之间的映射方式</p>
<p>Cache 中主存块的替换算法</p>
<p>Cache 写策略</p>
<p>(七）虚拟存储器</p>
<p>虚拟存储器的基本概念;页式虚拟存储器</p>
<p>段式虚拟存储器;段页式虚拟存储器;TLB（快表)</p>
<p>【复习提示】</p>
<p>本章是历年命题重点，特别是有关Cache和虚拟存储器的考点容易出综合题。此外，存储器的分类与特点，存储器的扩展（芯片选择、连接方式、地址范围等)，低位交叉存储器，Cache 的相关计算与替换算法，虚拟存储器与快表也容易出选择题。读者应在掌握基本原理和理论的基础上，多结合习题进行反复训练，以加深巩固。另外，读者需掌握存在Cache和TLB的计算机中的地址翻译与Cache 映射问题，也建议结合《操作系统考研复习指导》复习。</p>
<p>本章有两个难点:一是Cache 映射规律、容量计算及替换特性;二是交叉存储器访问时间和访问效率。二者都可与第5章的大题综合，或与第6章总线访问内存时间的计算问题综合。</p>
<p>在学习本章时，请读者思考以下问题:</p>
<p>1）存储器的层次结构主要体现在何处?为何要分这些层次﹖计算机如何管理这些层次?</p>
<p>2）存取周期和存取时间有何区别?</p>
<p>3）在虚拟存储器中，页面是设置得大一些好还是设置得小一些好?请读者在学习本章的过程中寻找答案，本章末尾会给出参考答案。</p>
<p>存储器与CPU的连接(天勤)</p>
<ul>
<li>门电路的小圆圈代表对信号取反</li>
<li>74138译码器的小圆圈代表低电平有效</li>
</ul>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210916171617.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210916171617.png';" /></details>

<p> $\overline{MREQ}$ 访存控制信号</p>
<ul>
<li>存储单元是一个字</li>
<li>存储元是一个位</li>
<li>$\mho$(cache里面到底放的什么，地址映射由谁来完成的)</li>
</ul>
<h3 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h3><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><p>存储器种类繁多，可从不同角度对存储器进行分类。</p>
<h5 id="按在计算机中的作用（层次）分类"><a href="#按在计算机中的作用（层次）分类" class="headerlink" title="按在计算机中的作用（层次）分类"></a>按在计算机中的作用（层次）分类</h5><p>1)）主存储器。简称主存，又称内存储器（内存)，用来存放计算机运行期间所需的大量程序和数据，CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器(Cache）及辅助存储器交换数据。其特点是容量较小、存取速度较快、每位价格较高。</p>
<p>2）辅助存储器。简称辅存，又称外存储器（外存)，是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，它不能与CPU直接交换信息。其特点是容量极大、存取速度较慢、单位成本低。</p>
<p>3）高速缓冲存储器。简称Cache，位于主存和CPU之间，用来存放正在执行的程序段和数据，以便CPU能高速地使用它们。Cache的存取速度可与CPU的速度相匹配，但存储容量小、价格高。现代计算机通常将它们制作在CPU 中。</p>
<h5 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h5><p>按存储介质，存储器可分为磁表面存储器（磁盘、磁带)、磁心存储器半导体存储器（MOS型存储器、双极型存储器）和光存储器（光盘)。</p>
<h5 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h5><p>1）随机存储器(RAM)。存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。其优点是读写方便、使用灵活，主要用作主存或高速缓冲存储器。RAM又分为静态RAM和动态RAM（第3节会详细介绍)。</p>
<p>2）只读存储器（ROM)。存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉字字库等。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。由ROM派生出的存储器也包含可反复重写的类型，ROM和RAM 的存取方式均为随机存取。注意广义上的只读存储器已可通过电擦除等方式进行写入，其“只读”的概念没有保留，但仍保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多。</p>
<p>3）串行访问存储器。对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括.顺序存取存储器（如磁带）与直接存取存储器（如磁盘、光盘)。</p>
<p>顺序存取存储器的内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关，其特点是存取速度慢。直接存取存储器既不像 RAM 那样随机地访问任何一个存储单元，又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。存取信息时通常先寻找整个存储器中的某个小区域(如磁盘上的磁道)，再在小区域内顺序查找。</p>
<h5 id="按信息的可保存性分类"><a href="#按信息的可保存性分类" class="headerlink" title="按信息的可保存性分类"></a>按信息的可保存性分类</h5><p>断电后，存储信息即消失的存储器，称为易失性存储器，如 RAM。断电后信息仍然保持的存储器，称为非易失性存储器，如ROM、磁表面存储器和光存储器。若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出;若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。</p>
<h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><p>存储器有3个主要性能指标，即存储容量、单位成本和存储速度。这3个指标相互制约，设计存储器系统所追求的目标就是大容量、低成本和高速度。</p>
<p>1)存储容量=存储字数×字长（如1M×8位)。单位换算: 1B(Byte，字节)= 8b (bit,位)。存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。</p>
<p>2）单位成本:每位价格=总成本/总容量。</p>
<p>3）存储速度:数据传输率=数据的宽度/存储周期。<br>${\textstyle\unicode{x2460}}$  存取时间($T_a$):存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</p>
<p>${\textstyle\unicode{x2461}}$ 存取周期（$T_m$):存取周期又称读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。</p>
<p>${\textstyle\unicode{x2462}}$ 主存带宽（$B_m$):主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（B/s）或位/秒(b/s)。</p>
<p>存取时间不等于存储周期，通常存储周期大于存取时间。这是因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达$T_m = 2T_a$，因为存储器中的信息读出后需要马上进行再生。</p>
<p>存取时间与存取周期的关系如图3.1所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706191304.png"></p>
<h3 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h3><h4 id="多级存储系统"><a href="#多级存储系统" class="headerlink" title="多级存储系统"></a>多级存储系统</h4><p>为了解决存储系统大容量、高速度和低成本3个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构，如图3.2所示。在图中由上至下，位价越来越低，速度越来越慢，容量越来越大，CPU 访问的频度也越来越低。</p>
<p>实际上，存储系统层次结构主要体现在“Cache-主存”层次和“主存-辅存”层次。前者主要解决CPU 和主存速度不匹配的问题，后者主要解决存储系统的容量问题。在存储体系中，Cache、主存能与CPU直接交换信息，辅存则要通过主存与CPU交换信息;主存与CPU、Cache、辅存都能交换信息，如图3.3所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706191358.png"></p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。从 CPU 的角度看，“Cache-主存”层次速度接近于Cache，容量和位价却接近于主存。从“主存-辅存”层次分析，其速度接近于主存，容量和位价却接近于辅存。这就解决了速度、容量、成本这三者之间的矛盾，现代计算机系统几乎都采用这种三级存储系统。需要注意的是，主存和 Cache 之间的数据调动是由硬件自动完成的，对所有程序员均是透明的;而主存和辅存之间的数据调动则是由硬件和操作系统共同完成的，对应用程序员是透明的。</p>
<p>在“主存-辅存”这一层次的不断发展中，逐渐形成了虚拟存储系统，在这个系统中程序员编程的地址范围与虚拟存储器的地址空间相对应。对具有虚拟存储器的计算机系统而言，编程时可用的地址空间远大于主存空间。</p>
<blockquote>
<p>注意:在“Cache-主存”和“主存-辅存”层次中，上一层中的内容都只是下一层中的内容的副本，也即Cache (或主存）中的内容只是主存（或辅存）中的内容的一部分。</p>
</blockquote>
<h3 id="半导体随机存储器"><a href="#半导体随机存储器" class="headerlink" title="半导体随机存储器"></a>半导体随机存储器</h3><p>p107</p>
<p>主存储器由DRAM 实现，靠处理器的那一层(Cache）则由 SRAM 实现它们都属于易失性存储器，只要电源被切断，原来保存的信息便会丢失。DRAM的每比特成本低于SRAM，速度也慢于SRAM，价格差异主要是因为制造DRAM需要更多的硅。而ROM属于非易失性存储器。</p>
<h4 id="SRAM和-DRAM"><a href="#SRAM和-DRAM" class="headerlink" title="SRAM和 DRAM"></a>SRAM和 DRAM</h4><h5 id="SRAM的工作原理"><a href="#SRAM的工作原理" class="headerlink" title="SRAM的工作原理"></a>SRAM的工作原理</h5><p>通常把存放一个二进制位的物理器件称为存储元，它是存储器的最基本的构件。地址码相同的多个存储元构成一个存储单元。若干存储单元的集合构成存储体。</p>
<p>静态随机存储器（SRAM）的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此即使信息被读出后，它仍保持其原状态而不需要再生（非破坏性读出)。</p>
<p>SRAM的存取速度快，但集成度低，功耗较大，所以一般用来组成高速缓冲存储器。</p>
<h5 id="DRAM的工作原理"><a href="#DRAM的工作原理" class="headerlink" title="DRAM的工作原理"></a>DRAM的工作原理</h5><p>与SRAM 的存储原理不同，动态随机存储器（DRAM）是利用存储元电路中栅极电容上的电荷来存储信息的，DRAM的基本存储元通常只使用一个晶体管，所以它比SRAM 的密度要高很多。DRAM 采用地址复用技术，地址线是原来的1/2，地址信号分行、列两次传送。</p>
<p>相对于SRAM 来说，DRAM具有容易集成、位价低、容量大和功耗低等优点，但 DRAM的存取速度比SRAM的慢，一般用来组成大容量主存系统。</p>
<p>DRAM 电容上的电荷一般只能维持1~2ms，因此即使电源不断电，信息也会自动消失。为此，每隔一定时间必须刷新，通常取2ms，称为刷新周期。常用的刷新方式有3种:</p>
<ul>
<li>唐朔飞.pp97</li>
</ul>
<p>1）集中刷新:指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”。优点是读写操作时不受刷新工作的影响;缺点是在集中刷新期间（死区）不能访问存储器。</p>
<details><summary>集中刷新时间分配示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210915223746.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210915223746.png';" /></details>

<p>2）分散刷新:把对每行的刷新分散到各个工作周期中。这样，一个存储器的系统工作周期分为两部分:前半部分用于正常读、写或保持;后半部分用于刷新。这种刷新方式增加了系统的存取周期，如存储芯片的存取周期为0.5us，则系统的存取周期为1us。优点是没有死区;缺点是加长了系统的存取周期，降低了整机的速度。</p>
<details><summary>分散刷新时间分配示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210915223832.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210915223832.png';" /></details>

<p>3）异步刷新:异步刷新是前两种方法的结合，它既可缩短“死时间”，又能充分利用最大刷新间隔为2ms的特点。具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求。这样可以避免使CPU连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的工作效率。</p>
<details><summary>异步刷新时间分配示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210915223902.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210915223902.png';" /></details>

<p>DRAM 的刷新需注意以下问题:①刷新对CPU是透明的，即刷新不依赖于外部的访问;②动态RAM 的刷新单位是行，由芯片内部自行生成行地址;③刷新操作类似于读操作，但又有所不同。另外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。</p>
<p>读者需要注意易失性存储器和刷新的区别，易失性存储器是指断电后数据丢失，SRAM 和DRAM都满足断电内容消失，但需要刷新的只有DRAM，而SRAM不需要刷新。</p>
<h5 id="存储器芯片的内部结构"><a href="#存储器芯片的内部结构" class="headerlink" title="存储器芯片的内部结构"></a>存储器芯片的内部结构</h5><p>如图3.4所示，存储器芯片由存储体、IO读写电路、地址译码和控制电路等部分组成。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192109.png"></p>
<p>1)存储体（存储矩阵)。存储体是存储单元的集合，它由行选择线(X）和列选择线(Y)来选择所访问单元，存储体的相同行、列上的位同时被读出或写入。</p>
<p>2）地址译码器。用来将地址转换为译码输出线上的高电平，以便驱动相应的读写电路。3)IO控制电路。用以控制被选中的单元的读出或写入，具有放大信息的作用。</p>
<p>4）片选控制信号。单个芯片容量太小，往往满足不了计算机对存储器容量的要求，因此需用一定数量的芯片进行存储器的扩展。在访问某个字时，必须“选中”该存储字所在的芯片，而其他芯片不被“选中”，因此需要有片选控制信号。</p>
<p>5）读/写控制信号。根据CPU给出的是读命令还是写命令，控制被选中单元进行读或写。</p>
<h5 id="存储器的读、写周期"><a href="#存储器的读、写周期" class="headerlink" title="存储器的读、写周期"></a>存储器的读、写周期</h5><p>(1) RAM的读周期</p>
<p>从给出有效地址开始，到读出所选中单元的内容并在外部数据总线上稳定地出现所需的时间，称为读出时间($t_A$)。地址片选信号$\bar{CS}$必须保持到数据稳定输出，$t_{CO}$为片选的保持时间，在读周期中$\bar{WE}$为高电平。RAM芯片的读周期时序图如图3.5所示。</p>
<p>读周期与读出时间是两个不同的概念，读周期时间（$t_{RC}$）表示存储芯片进行两次连续读操作时所必须间隔的时间，它总是大于等于读出时间。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192257.png"></p>
<p>(2）RAM的写周期</p>
<p>要实现写操作，要求片选信号$\bar{CS}$和写命令信号$\bar{WE}$必须都为低电平。为使数据总线上的信息能够可靠地写入存储器，要求$\bar{CS}$信号与$\bar{WE}$信号相“与”的宽度至少为$t_W$</p>
<p>为了保证在地址变化期间不会发生错误写入而破坏存储器的内容，$\bar{WE}$信号在地址变化期间必须为高电平。为了保证有效数据的可靠写入，地址有效的时间至少应为 $t_{WC} = t_{AW} + t_W +t_{WR}$。为了保证在$\bar{WE}$和$\bar{CS}$变为无效前能把数据可靠地写入，要求写入的数据必须在 $t_{DW}$以前在数据总线上已经稳定。RAM芯片的写周期时序图如图3.6所示。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192339.png"></p>
<h5 id="SRAM和DRAM的比较"><a href="#SRAM和DRAM的比较" class="headerlink" title="SRAM和DRAM的比较"></a>SRAM和DRAM的比较</h5><p>表3.1详细列出了SRAM 和 DRAM各自的特点。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210706192659.png"></p>
<h4 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h4><h5 id="只读存储器-ROM）的特点"><a href="#只读存储器-ROM）的特点" class="headerlink" title="只读存储器(ROM）的特点"></a>只读存储器(ROM）的特点</h5><p>ROM 和 RAM 都是支持随机存取的存储器，其中 SRAM和 DRAM均为易失性半导体存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电也不会丢失，它在计算机系统中是只供读出的存储器。ROM器件有两个显著的优点:</p>
<p>1）结构简单，所以位密度比可读写存储器的高。</p>
<p>2）具有非易失性，所以可靠性高。</p>
<h5 id="ROM的类型"><a href="#ROM的类型" class="headerlink" title="ROM的类型"></a>ROM的类型</h5><p>根据制造工艺的不同，ROM可分为掩模式只读存储器(MROM)、一次可编程只读存储器(PROM)、可擦除可编程只读存储器（EPROM)、闪速存储器（Flash Memory)和固态硬盘(Solid State Drives)。</p>
<p>(1）掩模式只读存储器</p>
<p>MROM 的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，写入以后任何人都无法改变其内容。优点是可靠性高，集成度高，价格便宜;缺点是灵活性差。</p>
<p>(2）一次可编程只读存储器</p>
<p>PROM 是可以实现一次性编程的只读存储器。允许用户利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。</p>
<p>(3）可擦除可编程只读存储器</p>
<p>EPROM不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写。需要修改EPROM 的内容时，先将其全部内容擦除，然后编程。EPROM 又可分为两种，即紫外线擦除(UVEPROM)和电擦除（$E^2PROM$)。EPROM 虽然既可读又可写，但它不能取代 RAM，因为EPROM 的编程次数有限，且写入时间过长。</p>
<p>(4）闪速存储器（Flash Memory)</p>
<p>Flash Memory是在EPROM与$E^2PROM$的基础上发展起来的，其主要特点是既可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写。闪速存储器既有EPROM 的价格便宜、集成度高的优点，又有$E^2PROM$电可擦除重写的特点，且擦除重写的速度快。</p>
<p>(5）固态硬盘(Solid State Drives，SSD)</p>
<p>基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元(FLASH 芯片）组成。保留了Flash Memory长期保存信息、快速擦除与重写的特性。对比传统硬盘也具有读写速度快、低功耗的特性，缺点是价格较高。</p>
<h4 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h4><p>图3.7是主存储器(Main Memory，MM）的基本组成框图，其中由一个个存储0或1的记忆单元（也称存储元件）构成的存储矩阵（也称存储体）是存储器的核心部分。记忆单元是具有两种稳态的能表示二进制0和1的物理器件。为了存取存储体中的信息，必须对存储单元编号（也称编址)。编址单位是指具有相同地址的那些存储元件构成的一个单位，可以按字节编址，也可以按字编址。现代计算机通常采用字节编址方式，此时存储体内的一个地址中有1字节。</p>
<p>指令执行过程中需要访问主存时，CPU 首先把被访问单元的地址送到MAR中，然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码选中相应单元，同时CPU将读写信号通过控制线送到主存的读写控制电路。如果是写操作，那么CPU同时将要写的信息送到 MDR中，在读写控制电路的控制下，经数据线将信号写入选中的单元;如果是读操作，那么主存读出选中单元的内容送到数据线，然后送到 MDR 中。数据线的宽度与MDR的苋度相同，地址线的宽度与 MAR 的宽度相同。图3.6采用64位 $\color{green}{\text{数据线}}$ ，所以在按字节编址方式下，每次最多可以存取8个单元的内容。$\color{green}{\text{地址线}}$ 的位数决定了主存地址空间的最大可寻址范围。例如，36位地址的最大寻址范围为0～$2^{36}$-1，即地址从О开始编号。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713143016.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143016.png';" /></details>


<p>数据线数和地址线数共同反映存储体容量的大小，图3.6中芯片的容量=$2^{36}×64$位。</p>
<h3 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h3><h4 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h4><p>1）主存储器通过数据总线、地址总线和控制总线与CPU连接。</p>
<p>2）数据总线的位数与工作频率的乘积正比于数据传输率。</p>
<p>3）地址总线的位数决定了可寻址的最大内存空间。4）控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻。</p>
<p>主存储器与CPU的连接如图3.8所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713143129.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143129.png';" /></details>

<h4 id="主存容量的扩展"><a href="#主存容量的扩展" class="headerlink" title="主存容量的扩展"></a>主存容量的扩展</h4><p>由于单个存储芯片的容量是有限的，它在字数或字长方面与实际存储器的要求都有差距，因此需要在字和位两方面进行扩充才能满足实际存储器的容量要求。通常采用位扩展法、字扩展法和字位同时扩展法来扩展主存容量。</p>
<h5 id="位扩展法"><a href="#位扩展法" class="headerlink" title="位扩展法"></a>位扩展法</h5><p>CPU 的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位（即进行位扩展，用多个存储器件对字长进行扩充，增加存储字长)，使其数据位数与CPU的数据线数相等。位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。</p>
<p>如图3.9所示，用8片8K×1位的RAM芯片组成8K×8位的存储器。8片RAM芯片的地址线$A_{12}\backsim A_0$、$\bar{CS}$、$\bar{WE}$都分别连在一起，每片的数据线依次作为CPU数据线的一位。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713143317.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143317.png';" /></details>

<blockquote>
<p>注意:仅采用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某一时刻选中所有的芯片，所以片选信号$\bar{CS}$要连接到所有芯片。</p>
</blockquote>
<h5 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h5><p>字扩展是指增加存储器中字的数量，而位数不变。字扩展将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。</p>
<p>如图3.10所示，用4片16K×8位的RAM芯片组成64K×8位的存储器。4片RAM芯片的数据线$D_0\backsim D_7$和$\bar{WE}$都分别连在一起。将$A_{15}A_{14}$用作片选信号，$A_{15}A_{14}$=00时，译码器输出端0有效，选中最左边的1号芯片;$A_{15}A_{14}$= 01时，译码器输出端1有效，选中2号芯片,以此类推（在同一时间内只能有一个芯片被选中)。各芯片的地址分配如下:</p>
<p>第1片，最低地址:$\mathbf{00}$00000000000000;最高地址:$\mathbf{00}$11111111111111 (16位)</p>
<p>第2片，最低地址:$\mathbf{01}$00000000000000;最高地址:$\mathbf{01}$11111111111111</p>
<p>第3片，最低地址:$\mathbf{10}$00000000000000;最高地址:$\mathbf{10}$11111111111111</p>
<p>第4片，最低地址:$\mathbf{11}$00000000000000;最高地址:$\mathbf{11}$11111111111111</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713143507.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713143507.png';" /></details>

<blockquote>
<p>注意:仅采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在某一时刻只需选中部分芯片，所以通过片选信号$\overline{CS}$或采用译码器设计连接到相应的芯片。</p>
</blockquote>
<h5 id="字位同时扩展法"><a href="#字位同时扩展法" class="headerlink" title="字位同时扩展法"></a>字位同时扩展法</h5><p>实际上，存储器往往需要同时扩充字和位。字位同时扩展是指既增加存储字的数量，又增加存储字长。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713144506.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713144506.png';" /></details>

<p>如图3.11所示，用8片16K×4位的 RAM芯片组成64K×8位的存储器。每两片构成一组16K×8位的存储器（位扩展)，4组便构成64K×8位的存储器（字扩展)。地址线$A_{15}A_{14}$经译码器得到4个片选信号，$A_{15}A_{14}$ = 00时，输出端0有效，选中第一组的芯片（①和②);$A_{15}A_{14}$ =01时，输出端1有效，选中第二组的芯片（③和④)，以此类推。</p>
<blockquote>
<p>注意:采用字位同时扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号$\overline{CS}$或采用译码器设计连接到相应的芯片。</p>
</blockquote>
<h4 id="存储芯片的地址分配和片选"><a href="#存储芯片的地址分配和片选" class="headerlink" title="存储芯片的地址分配和片选"></a>存储芯片的地址分配和片选</h4><p>CPU 要实现对存储单元的访问，首先要选择存储芯片，即进行片选;然后为选中的芯片依地址码选择相应的存储单元，以进行数据的存取，即进行字选。片内的字选通常是由CPU送出的N条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端(N由片内存储容量$2^N$决定)。片选信号的产生分为线选法和译码片选法。</p>
<h5 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h5><p>线选法用除片内寻址外的高位地址线直接（或经反相器）分别接至各个存储芯片的片选端，当某地址线信息为“0”时，就选中与之对应的存储芯片。这些片选地址线每次寻址时只能有一位有效，不允许同时有多位有效，这样才能保证每次只选中一个芯片（或芯片组)。假设4 片2K×8位存储芯片用线选法构成8K×8位存储器，各芯片的片选信号见表3.2，其中低位地址线$A_{10}～A_0$作为字选线，用于片内寻址。</p>
<p>优点:不需要地址译码器，线路简单。缺点:地址空间不连续，选片的地址线必须分时为低电平（否则不能工作)，不能充分利用系统的存储器空间，造成地址资源的浪费。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713144828.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713144828.png';" /></details>

<h5 id="译码片选法"><a href="#译码片选法" class="headerlink" title="译码片选法"></a>译码片选法</h5><p>译码片选法用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号。如用8片8K×8位的存储芯片组成64K×8位存储器（地址线为16位，数据线为8位)，需要8个片选信号;若采用线选法，除去片内寻址的13位地址线，仅余高3位，不足以产生8个片选信号。因此，采用译码片选法，即用一片74LS138作为地址译码器，则$A_{15}A_{14}A_{13}$ = 000时选中第一片，$A_{15}A_{14}A_{13}$ = 001时选中第二片，以此类推（即3位二进制编码)。</p>
<h4 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h4><h5 id="合理选择存储芯片"><a href="#合理选择存储芯片" class="headerlink" title="合理选择存储芯片"></a>合理选择存储芯片</h5><p>要组成一个主存系统，选择存储芯片是第一步，主要指存储芯片的类型(RAM 或ROM)和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数，RAM 则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单、方便。</p>
<h5 id="地址线的连接"><a href="#地址线的连接" class="headerlink" title="地址线的连接"></a>地址线的连接</h5><p>存储芯片的容量不同，其地址线数也不同，而CPU的地址线数往往比存储芯片的地址线数要多。通常将CPU地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选)，这部分的译码是由芯片的片内逻辑完成的。而CPU地址线的高位则在扩充存储芯片时使用，用来选择存储芯片(片选)，这部分译码由外接译码器逻辑完成。</p>
<p>例如，设CPU地址线为16位，即$A_{15}～$A_0$$，1K×4位的存储芯片仅有10根地址线，此时可将CPU的低位地址$A_9～A_0$与存储芯片的地址线$A_9～A_0$相连。</p>
<h5 id="数据线的连接"><a href="#数据线的连接" class="headerlink" title="数据线的连接"></a>数据线的连接</h5><p>CPU的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连;在不等时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。</p>
<h5 id="读-写命令线的连接"><a href="#读-写命令线的连接" class="headerlink" title="读/写命令线的连接"></a>读/写命令线的连接</h5><p>CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。有些CPU的读/写命令线是分开的（读为$\overline{RD}$，写为$\overline{WE}$，均为低电平有效)，此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。</p>
<h5 id="片选线的连接"><a href="#片选线的连接" class="headerlink" title="片选线的连接"></a>片选线的连接</h5><p>片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端$\overline{CS}$是否能接收到来自CPU的片选有效信号。</p>
<p>片选有效信号与CPU的访存控制信号$\overline{MREQ}$（低电平有效）有关，因为只有当CPU要求访存时，才要求选中存储芯片。若CPU访问I/O，则$\overline{MREQ}$为高，表示不要求存储器工作。</p>
<h3 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h3><p>为了提高CPU 访问存储器的速度，可以采用双端口存储器、多模块存储器等技术,它们同属并行技术，前者为空间并行，后者为时间并行。</p>
<h4 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h4><p>双端口RAM是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元，如图3.12所示。当两个端口的地址不相同时，在两个端口上进行读写操作一定不会发生冲突。</p>
<p>两个端口同时存取存储器的同一地址单元时，会因数据冲突造成数据存储或读取错误。两个端口对同一主存操作有以下4种情况:</p>
<p>1)两个端口不同时对同一地址单元存取数据。</p>
<p>2）两个端口同时对同一地址单元读出数据。</p>
<p>3)两个端口同时对同一地址单元写入数据。</p>
<p>4）两个端口同时对同一地址单元操作，一个写入数据，另一个读出数据。</p>
<p>其中，第1）种和第2）种情况不会出现错误;第3）种情况会出现写入错误;第4)种情况会出现读出错误。</p>
<p>解决方法:置“忙”信号$\overline{BUSY}$为0，由判断逻辑决定暂时关闭一个端口（即被延时)，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713145516.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713145516.png';" /></details>



<h4 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h4><p>低位交叉和高位交叉存储器的区别：<a target="_blank" rel="noopener" href="http://www.cskaoyan.com/thread-25282-1-1.html">参考文献</a></p>
<blockquote>
<p>低地址交叉编址相当于—–横着读<br>高位交叉编址相当于——–竖着读</p>
</blockquote>
<p>为提高访存速度，常采用多模块存储器，常用的有单体多字存储器和多体低位交叉存储器。</p>
<blockquote>
<p>注意:CPU的速度比存储器的快，若同时从存储器中取出$n$条指令，就可充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想提出的。</p>
</blockquote>
<h5 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h5><p>单体多字系统的特点是存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。</p>
<p>单体多字系统在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每隔1/m存取周期，CPU向主存取一条指令。显然，这增大了存储器的带宽，提高了单体存储器的工作速度。</p>
<p>缺点:指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显。</p>
<h5 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h5><p>多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。</p>
<p>多体并行存储器分为高位交叉编址（顺序方式）和低位交叉编址（交叉方式)两种。</p>
<p>1)高位交叉编址:高位地址表示体号，低位地址为体内地址。如图 3.13所示，存储器共有4个模块$M_0～M_3$，每个模块有n个单元，各模块的地址范围如图中所示。</p>
<p>高位交叉编址方式下，总是把低位的体内地址达到出风也佑问完才转到下一个模块访问，问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，存储模块不能被并行访问，因而不能提高存储器的吞吐率。</p>
<blockquote>
<p>注意:模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器。</p>
</blockquote>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713145913.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713145913.png';" /></details>

<p>2）低位交叉编址:低位地址为体号，高位地址为体内地址。如图3.14所示，每个模块按“模m”交叉编址，模块号=单元地址%<br>m，假定m个模块，每个模块有k个单元，则0，m，$\cdots$,$(k-1)m$单元位于$M_0$;第1，m+1，$\cdots$,$(k-1)m+1$单元位于$M_1$；依次类推。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713150108.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150108.png';" /></details>

<p>低位交叉编址方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。采用低位交叉编址后，可在不改变每个模块存取周期的前提下,采用流水线的方式并行存取，提高存储器的带宽。</p>
<p>设模块字长等于数据总线宽度，模块存取一个字的存取周期为$T$，总线传送周期为$r$，为实现流水线方式存取，存储器交叉模块数应大于等于</p>
<p>$$<br>m=T/r<br>$$</p>
<p>式中，m称为交叉存取度。每经过r时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于等于m，以保证启动某模块后经过m×r的时间后再次启动该模块时，其上次的存取操作已经完成（即流水线不间断)。这样，连续存取m个字所需的时间为</p>
<p>$$<br>t_1 - T + (m-1)r<br>$$</p>
<p>而顺序方式连续读取m个字所需的时间为$t_2 = mT$。可见低位交叉存储器的带宽大大提高。模块数为4的流水线方式存取示意图如图3.15所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713150634.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150634.png';" /></details>


<details><summary>多体并行例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713150701.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150701.png';" /></details>


<h3 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h3><p>由于程序的转移概率不会很低，数据分布的离散性较大，所以单纯依靠并行主存系统提高主存系统的频宽是有限的。这就必须从系统结构上进行改进，即采用存储体系。通常将存储系统分为“Cache-主存”层次和“主存-辅存”层次。</p>
<ul>
<li> $\color{red}{\text{注意}}$ ：Cache是主存的副本</li>
</ul>
<details><summary>cache中标记项的组成</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210924152123.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210924152123.png';" /></details>

<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dcab978b8a25">有效位</a>：判断一个缓冲区有效（即存放有数据</li>
<li>脏位：跟主存中的内容一不一致</li>
<li>替换控制位</li>
</ul>
<h4 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h4><p>程序访问的局部性原理包括时间局部性和空间局部性。时间局部性是指在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环。空间局部性是指在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。</p>
<p>高速缓冲技术就是利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的Cache 中，使CPU的访存操作大多数针对Cache进行，从而大大提高程序的执行速度。</p>
<details><summary>局部性比较的例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713150844.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713150844.png';" /></details>


<h4 id="Cache-的基本工作原理"><a href="#Cache-的基本工作原理" class="headerlink" title="Cache 的基本工作原理"></a>Cache 的基本工作原理</h4><p>Cache位于存储器层次结构的顶层，通常由SR<br>AM构成，其基本结构如图3.17所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713151122.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713151122.png';" /></details>

<p>为便于Cache和主存之间交换信息，Cache和主存都被划分为相等的块，Cache块又称Cache 行，每块由若干字节组成，块的长度称为块长(Cache行长)。由于Cache 的容量远小于主存的容量，所以Cache 中的块数要远少于主存中的块数，它仅保存主存中最活跃的若干块的副本。因此Cache 按照某种策略，预测CPU在未来一段时间内欲访存的数据，将其装入Cache。</p>
<p>当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关;若Cache不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入Cache。若此时Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。值得注意的是，CPU与Cache之间的数据交换以字为单位，而Cache 与主存之间的数据交换则以Cache块为单位。</p>
<blockquote>
<p>注意:某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则主存访问终止;否则访问主存并替换Cache。</p>
</blockquote>
<p>当CPU发出写请求时，若 Cache命中，有可能会遇到Cache 与主存中的内容不一致的问题。例如，由于CPU 写Cache，把 Cache 某单元中的内容从X修改成了X’，而主存对应单元中的内容仍然是X，没有改变。所以若Cache命中，需要按照一定的写策略处理，常见的处理方法有全写法和写回法，详见本节的Cache 写策略部分。</p>
<p>CPU欲访问的信息已在Cache 中的比率称为Cache的命中率。设一个程序执行期间，Cache的总命中次数为$N_c$，访问主存的总次数为$N_m$，则命中率$H$为</p>
<p>$$<br>H=N_c/(N_c+N_m)<br>$$</p>
<p>可见为提高访问效率，命中率$H$越接近1越好。设$t_c$.为命中时的Cache访问时间，$t_m$为未命中时的访问时间，1-H表示未命中率，则Cache-主存系统的平均访问时间$T_a$为</p>
<p>$$<br>T_a = Ht_c+(1-H)t_m<br>$$</p>
<details><summary>平均访问时间计算的例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713151848.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713151848.png';" /></details>

<blockquote>
<p>这里的平均访问时间可以理解为，整个系统消耗在访存上的时间</p>
</blockquote>
<details><summary>$\mho$(为什么这里是每8次，一次未命中，而不是每4次)</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210917222222.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210917222222.png';" /></details>

<h4 id="Cache和主存的映射方式"><a href="#Cache和主存的映射方式" class="headerlink" title="Cache和主存的映射方式"></a>Cache和主存的映射方式</h4><p>Cache行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cache。</p>
<p>由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在 Cache 中，因此在Cache 中要为每块加一个标记，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明Cache行中的信息是否有效，每个Cache行需要一个有效位。</p>
<p>地址映射的方法有以下3种。</p>
<h5 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h5><p>主存中的每一块只能装入Cache 中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法)。直接映射实现简单，但不够灵活，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。</p>
<p>直接映射的关系可定义为</p>
<p>$$<br>j=i mod 2^c<br>$$</p>
<p>式中，$j$是Cache的块号（又称Cache行号），$i$是主存的块号，$2^c$是Cache中的总块数。在这种映射方式中，主存的第0块、第$2^c+1$块，第$2^{c+1}+1$块$\cdots$只能映射到Cache的第1行，以此类推。由映射函数可看出，主存块号的低$c$位正好是它要装入的Cache行号。给每个Cache行设置一个长为$t=m-c$的标记(tag),当主存某块调入Cache后，就将其块号的高t位设置在对应Cache行的标记中，如图3.18(a)所示。</p>
<p>直接映射的地址结构为</p>
<details><summary>直接映射的地址结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713152631.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713152631.png';" /></details>

<p>CPU放存过程如图3.18(b)所示。首先根据访存地址中间的c位，找到对应的Cache行，将对应Cache行中的标记和主存地址的高t位标记进行比较，若相等且有效位为1，则访问Cache“命中”，此时根据主存地址中低位的块内地址，在对应的Cache行中存取信息；若不相等或有效位为0，则“不命中”，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache行中，将有效位置1，并将标记设置为地址中的高t位，同时将该地址中的内容送CPU。</p>
<details><summary>图3.18 图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713152658.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713152658.png';" /></details>


<h5 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h5><p>主存中的每一块可以装入Cache 中的任何位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。全相联映射方式的优点是比较灵活，Cache 块的冲突概率低，空间利用率高，命中率也高;缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射，如图3.19所示。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713153647.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713153647.png';" /></details>

<p>全相联映射的地址结构为</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713153710.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713153710.png';" /></details>


<details><summary>相联存储器的特点：根据内容直接访问</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210917223507.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210917223507.png';" /></details>

<h5 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h5><ul>
<li>组间直接相联，组内全相联</li>
<li>组内有 $2^r$ 块，cache地址和主存地址相差 $t$ 位，则标记取 $t+r$ 位。 </li>
<li>如何理解这样拆分之后必然利用了全部的地址位数</li>
<li>首先（ $\color{green}{\text{组号}}$ + $\color{green}{\text{组内地址}}$ +  $\color{red}{\text{组内块号}}$ ）= cache地址</li>
<li>cache地址和主存地址的差，把 $\color{red}{\text{组内块号}}$ 的位数给减了，所以加上 $\color{red}{\text{组内块号}}$ 的位数，刚好为所有地址空间的位数</li>
</ul>
<p>将Cache 空间分成大小相同的组，主存的一个数据块可以装入一组内的任何一个位置，即组间采取直接映射，而组内采取全相联映射，如图 3.20所示。它是对直接映射和全相联映射的一种折中，当Q= 1时变为全相联映射，当Q = Cache块数时变为直接映射。假设每组有r个Cache行，则称之为r路组相联，图3.20的设置中每组有2个Cache行，因此称为2路组相联。</p>
<p>组相联映射的关系可以定义为</p>
<p>$$<br>j = i mod  Q<br>$$</p>
<p>式中，j式Cache行的组号，i是主存的块号，Q是Cache的组数。</p>
<p>路数越大，即每组 Cache 行的数量越大，发生块冲突的概率越低，但相联比较电路也越复杂。选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。</p>
<p>组相联映射的地址结构为</p>
<ul>
<li>地址结构各部分的英文为 tag(标记),Index(组号)，offset(组内地址)</li>
</ul>
<details><summary>组相联映射的地址结构</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154134.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154134.png';" /></details>

<p>CPU 访存过程如下:首先根据访存地址中间的组号找到对应的Cache组;将对应Cache组中每个行的标记与主存地址的高位标记进行比较;若有一个相等且有效位为1，则访问Cache命中，此时根据主存地址中的块内地址，在对应Cache行中存取信息;若都不相等或虽相等但有效位为0，则不命中，此时CPU 从主存中读出该地址所在的一块信息送到对应Cache 组的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154218.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154218.png';" /></details>

<details><summary>例题</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154314.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154314.png';" /><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154336.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154336.png';" /></details>



<h4 id="Cache-中主存块的替换算法"><a href="#Cache-中主存块的替换算法" class="headerlink" title="Cache 中主存块的替换算法"></a>Cache 中主存块的替换算法</h4><ul>
<li>直接相联映射不存在需要复杂算法的问题</li>
</ul>
<p>在采用全相联映射或组相联映射方式时，从主存向Cache传送一个新块，当Cache或Cache组中的空间已被占满时，就需要使用替换算法置换Cache行。而采用直接映射时，一个给定的主存块只能放到唯一的固定Cache行中，所以在对应 Cache 行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而无须考虑替换算法。</p>
<p>常用的替换算法有随机(RAND)算法、先进先出(FIFO）算法、近期最少使用（LRU)算法和最不经常使用(LFU)算法。其中最常考查的是LRU 算法。</p>
<p>1）随机算法:随机地确定替换的Cache块。它的实现比较简单，但未依据程序访问的局部性原理，因此可能命中率较低。</p>
<p>2）先进先出算法:选择最早调入的行进行替换。它比较容易实现，但也未依据程序访问的局部性原理，因为最早进入的主存块也可能是目前经常要用的。</p>
<p>3）近期最少使用算法:依据程序访问的局部性原理，选择近期内长久未访问过的Cache行作为替换的行，平均命中率要比FIFO的高，是堆栈类算法。</p>
<p>LRU算法对每个Cache行设置一个计数器，用计数值来记录主存块的使用情况，并根据计数值选择淘汰某个块，计数值的位数与Cache组大小有关，2路时有一位LRU位，4路时有两位LRU位。假定采用4路组相联，有5个主存块{1,2,3,4,5}映射到Cache 的同一组，对于主存访问序列{1,2,3,4,1,2,5,1,2,3,4,5}，采用LRU算法的替换过程如图3.23所示。图中左边阴<br>影的数字是对应Cache行的计数值，右边的数字是存放在该行中的主存块号。</p>
<details><summary>图3.23 LRU 算法的替换过程示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713154711.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713154711.png';" /></details>

<p>计数器的变化规则:①命中时，所命中的行的计数器清零，比其低的计数器加 1，<br>其余不<br>变;②未命中且还有空闲行时，新装入的行的计数器置0，其余全加1;③未命中且无空闲行时，计数值为3的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。<br>当集中访问的存储区超过Cache 组的大小时，命中率可能变得很低，如上例的访问序列变为1,2,3,4,5,1,2,3,4,5,…，而Cache每组只有4行，那么命中率为0，这种现象称为抖动。</p>
<p>4）最不经常使用算法:将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从О开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。这种算法与LRU类似，但不完全相同。</p>
<h4 id="Cache-写策略"><a href="#Cache-写策略" class="headerlink" title="Cache 写策略"></a>Cache 写策略</h4><p>因为Cache 中的内容是主存块副本，当对Cache 中的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保持一致。此时分两种情况。</p>
<p>对于Cache 写命中( write hit)，有两种处理方法。</p>
<p>1）全写法（写直通法、write-through)。当CPU对Cache写命中时，必须把数据同时写入Cache和主存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache 的效率。写缓冲:为减少全写法直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲（Write Buffer )，如下图所示。CPU同时写数据到Cache 和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个 FIFO 队列，写缓冲可以解决速度不兀配的问题。侣若出现频繁写时．会伸写缓冲饱和溢出。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713155910.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713155910.png';" /></details>

<p>2）写回法 ( write-back)。当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。这种方法减少了访存次数，但存在个一致的隐患。采用这种策略时，每个Cache 行必须设置一个标志位（脏位)，以反映此块是否被CPU修改过。</p>
<p>全写法和写回法都对应于Cache写命中（要被修改的单元在Cache中）时的情况。</p>
<p>对于Cache 写不命中，也有两种处理方法。</p>
<p>1)写分配法（write-allocate)。加载主存中的块到Cache 中，然后更新这个Cache 块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。</p>
<p>2）非写分配法(not-write-allocate）法。只写入主存，不进行调块。</p>
<p>非写分配法通常与全写法合用，写分配法通常和写回法合用。</p>
<ul>
<li> $\color{green}{\text{全}}$ 写法: cache命中时，主存和cache $\color{green}{\text{全}}$ 都写入内容</li>
<li> 写 $\color{green}{\text{分配}}$ 法：cache不命中时， $\color{green}{\text{分配}}$ 到cache中</li>
<li> $\mho$(为什么这么搭配)</li>
</ul>
<p>现代计算机的Cache通常设立多级Cache(通常为3级)，假定设3级Cache，按离CPU的远近可各自命名为L1 Cache、L2 Cache、L3 Cache，离CPU越远，访问速度越慢，容量越大。指令Cache 与数据Cache分离一般在L1级，此时通常为写分配法与写回法合用。</p>
<p>下图是一个含有两级Cache的系统，L1 Cache对 L2 Cache 使用全写法，L2 Cache对主存使用写回法，由于L2 Cache 的存在，其访问速度大于主存，因此避免了因频繁写时造成的写缓冲饱和溢出。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160100.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160100.png';" /></details>

<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ul>
<li>有效位到底是指存在于磁盘中还是存在于TLB中会发生冲突</li>
</ul>
<p>主存和联机工作的辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量，提高了存储系统的性价比。</p>
<h4 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h4><p>虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。</p>
<p>用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间。实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。虚地址比实地址要大很多。虚拟存储器的地址空间如图3.24所示。</p>
<p>CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个成地址对应的存储单元内容是否已装入主存。若已在主存中，则通过地址变换，CPU 可直接访问主仔指示的实际单元;若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU 访问。右主存已满，则采用替换算法置换主存中的一页或一段。</p>
<p>在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前运行所需要的部分调入主存，供CPU使用，其余暂不运行的部分则留在磁盘中。</p>
<details><summary>虚拟存储器的3个地址空间</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160354.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160354.png';" /></details>



<h4 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h4><p>以页为基本单位的虚拟存储器称为页式虚拟存储器。虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页。把虚拟地址分为两个字段:虚页号和页内地址。虚拟地址到物理地址的转换是由页表实现的。页表是一张存放在 $\color{green}{\text{主存}}$ 中的虚页号和实页号的对照表，它记录程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。</p>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><p>图3.25是一个页表示例。 $\color{red}{\text{有效位}}$ 也称 $\color{red}{\text{装入位}}$ ，用来 $\color{green}{\text{表示对应页面是否在主存}}$ ，若为 1，则表示该虚拟页已从外存调入主存，此时页表项存放该页旳物理页号;若为0，则表示没有调入主存，此时页表项可以存放该页的磁盘地址。脏位也称修改位，用来表示页面是否被修改过，虚存机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。引用位也称使用位，用来配合替换策略进行设置，例如是否实现最先调入(FIFO位）或最近最少用(LRU位）策略等。</p>
<details><summary>图3.25 主存中的页表示例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160635.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160635.png';" /></details>

<p>CPU 执行指令时，需要先将虚拟地址转换为主存物理地址。每个进程都有一个 $\color{green}{\text{页表基址寄存器}}$ ，存放该进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项，若装入位为1，则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址;若装入位为0，则说明缺页，需要操作系统进行缺页处理。地址变换的过程如图3.26所示。</p>
<p>页式虚拟存储器的优点是，页面的长度固定,页表简单，调入方便。缺点是，由于程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以 $\color{green}{\text{处理}}$ 、 $\color{green}{\text{保护}}$ 和 $\color{green}{\text{共享}}$ 都不及段式虚拟存储器方便。</p>
<details><summary>图3.26页式虚拟存储器的地址变换过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160731.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160731.png';" /></details>

<h5 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h5><p>由地址转换过程可知，访存时先访问一次主存去查页表，再访问主存才能取得数据。如果缺页，那么还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了。</p>
<p>依据程序执行的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的 $\color{green}{\text{页表项存放在高速缓冲器}}$ 组成的 $\color{red}{\text{快表}}$ （TLB）中，则可以明显提高效率。相应地把 $\color{green}{\text{放在主存中的页表}}$ 称为 $\color{red}{\text{慢表}}$ (Page)。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。</p>
<p>快表通常采用全相联或组相联方式。每个TLB项由页表表项内容加上一个TLB标记字段组成，TLB标记用来表示该表项取自页表中哪个虚页号对应的页表项，因此，TLB标记的内容在全相联方式下就是该页表项对应的虚页号;组相联方式下则是对应虚页号的高位部分，而虚页号的低位部分用于选择TLB组的组索引。</p>
<ul>
<li>$\mho$(TLB的全相联和组相联没怎么看懂)</li>
</ul>
<h5 id="具有TLB和Cache的多级存储系统"><a href="#具有TLB和Cache的多级存储系统" class="headerlink" title="具有TLB和Cache的多级存储系统"></a>具有TLB和Cache的多级存储系统</h5><p>图3.27是一个具有TLB和Cache的多级存储系统，其中Cache 采用二路组相联方式。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较，若有某一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换;若未命中，则TLB缺失，需要访问主存去查贝表。图中所示的定网级页表方式，虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB，若 TLB已满，则还需要采用替换策略。完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的Cache行或组，将对应Cache行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送CPU。</p>
<details><summary>图3.27 TLB和 Cache的访问过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160922.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160922.png';" /></details>

<p>查找时，快表和慢表也可以同步进行，若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。</p>
<p>在一个具有Cache和 TLB的虚拟存储系统中，CPU一次访存操作可能涉及TLB、页表、Cache、主存和磁盘的访问，访问过程如图3.28所示。可以看出，CPU访存过程中存在三种缺失情况:①TLB缺失:要访问的页面对应的页表项不在TLB中:②Cache 缺失:要访问的主存块不在Cache 中:③缺页(Page):要访问的页面不在主存中。这三种缺失的几种可能组合情况如表3.3所示。</p>
<p>最好的情况是第1种组合，此时无须访问主存;第2种和第3种组合都需要访问一次主存﹔第4种组合需要访问两次主存;第5种组合发生“缺页异常”，需要访问磁盘，并且至少访问两次主存。Cache 缺失处理由硬件完成;缺页处理由软件完成，操作系统通过“缺页异常处理程序”来实现;而TLB缺失既可以用硬件又可以用软件来处理，比如操作系统有专门的“TLB缺失异常处理”程序。</p>
<details><summary>图3.28 带TLB 虚拟存储器的CPU访存过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713160956.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713160956.png';" /></details>

<details><summary>TLB、Page、Cache三种缺失的可能组合情况
</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713161018.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713161018.png';" /></details>


<h4 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h4><p>段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两部分:段号和段内地址。虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。</p>
<p>CPU 根据虚拟地址访存时，首先根据段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存(装入位为“1”，表示该段已调入主存;装入位为“0”，表示该段不在主存中)。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。段式虚拟存储器的地址变换过程如图3.29所示。</p>
<p>段式虚拟存储器的优点是，段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享;缺点是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</p>
<details><summary>图3.29段式虚拟存储器的地址变换过程
</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210713161116.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210713161116.png';" /></details>




<h4 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h4><p>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器。在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。</p>
<p>虚地址分为段号、段内页号、页内地址三部分。CPU 根据虚地址访存时，首先根据段号得到段表地址;然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址;最后从页表中取出实页号，与页内地址拼接形成主存实地址。</p>
<p>段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。缺点是在地址变换过程中需要两次查表，系统开销较大。</p>
<h4 id="虚拟存储器与Cache的比较"><a href="#虚拟存储器与Cache的比较" class="headerlink" title="虚拟存储器与Cache的比较"></a>虚拟存储器与Cache的比较</h4><p>虚拟存储器与Cache既有很多相同之处，又有很多不同之处。</p>
<h5 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h5><p>1）最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。</p>
<p>2）都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大。</p>
<p>3）都有地址的映射、替换算法、更新策略等问题。</p>
<p>4)依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中</p>
<h5 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h5><ol>
<li><p>Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量。</p>
</li>
<li><p>Cache 全由硬件实现，是硬件存储器，对所有程序员透明;而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。</p>
</li>
<li><p>对于不命中性能影响，因为CPU的速度约为Cache 的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。</p>
</li>
<li><p>CPU 与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache;而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。</p>
</li>
</ol>
<details><summary>一道题总结写策略，cache，TLB，页式存储</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210917223553.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210917223553.png';" /></details>

<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><h4 id="存储器的层次结构主要体现在何处-为何要分这些层次-计算机如何管理这些层次"><a href="#存储器的层次结构主要体现在何处-为何要分这些层次-计算机如何管理这些层次" class="headerlink" title="存储器的层次结构主要体现在何处?为何要分这些层次?计算机如何管理这些层次?"></a>存储器的层次结构主要体现在何处?为何要分这些层次?计算机如何管理这些层次?</h4><p>存储器的层次结构主要体现在Cache-主存和主存-辅存这两个存储层次上。</p>
<p>Cache-主存层次在存储系统中主要对CPU访存起加速作用，即从整体运行的效果分析，CPU访存速度加快，接近于Cache 的速度，而寻址空间和位价却接近于主存。</p>
<p>主存-辅存层次在存储系统中主要起扩容作用，即从程序员的角度看，他所使用的存储器的容量和位价接近于辅存，而速度接近于主存。</p>
<p>综合上述两个存储层次的作用，从整个存储系统来看，就达到了速度快、容量大、位价低的优化效果。</p>
<p>主存与Cache 之间的信息调度功能全部由硬件自动完成。而主存与辅存层次的调度目前广泛采用虚拟存储技术实现，即将主存与辅存的一部分通过软/硬结合的技术组成虚拟存储器，程序员可用这个比主存实际空间（物理地址空间）大得多的虚拟地址空间（逻辑地址空间）编程，当程序运行时，再由软/硬件自动配合完成虚拟地址空间与主存实际物理空间的转换。因此，这两个层次上的调度或转换操作对于程序员来说都是透明的。</p>
<h4 id="存取周期和存取时间有何区别"><a href="#存取周期和存取时间有何区别" class="headerlink" title="存取周期和存取时间有何区别?"></a>存取周期和存取时间有何区别?</h4><p>存取周期和存取时间的主要区别是:存取时间仅为完成一次操作的时间;而存取周期不仅包含操作时间，而且包含操作后线路的恢复时间，即存取周期=存取时间＋恢复时间。</p>
<h4 id="在虚拟存储器中，页面是设置得大一些好还是设置得小一些好"><a href="#在虚拟存储器中，页面是设置得大一些好还是设置得小一些好" class="headerlink" title="在虚拟存储器中，页面是设置得大一些好还是设置得小一些好?"></a>在虚拟存储器中，页面是设置得大一些好还是设置得小一些好?</h4><p>页面不能设置得过大，也不能设置得过小。因为页面太小时，平均页内剩余空间较少，可节省存储空间，但会使得页表增大，而且页面太小时不能充分利用访存的空间局部性来提高命中率;页面太大时，可减少页表空间，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面调入/调出的时间较长。</p>
<h3 id="常见问题和易混淆知识点"><a href="#常见问题和易混淆知识点" class="headerlink" title="常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h3><h4 id="存取时间-T-a-就是存储周期-T-m-吗"><a href="#存取时间-T-a-就是存储周期-T-m-吗" class="headerlink" title="存取时间 $T_a$ 就是存储周期 $T_m$ 吗?"></a>存取时间 $T_a$ 就是存储周期 $T_m$ 吗?</h4><p>不是。存取时间 $T_a$ 是执行一次读操作或写操作的时间，分为读出时间和写入时间。读出时间是从主存接收到有效地址开始到数据稳定为止的时间;写入时间是从主存接收到有效地址开始到数据写入被写单元为止的时间。</p>
<p>存储周期 $T_m$ 是指存储器进行连续两次独立地读或写操作所需的最小时间间隔。所以存取时间 $T_a$ 不等于存储周期 $T_m$ 。通常存储周期 $T_m$ 大于存取时间 $T_a$ 。</p>
<h4 id="Cache行的大小和命中率之间有什么关系"><a href="#Cache行的大小和命中率之间有什么关系" class="headerlink" title="Cache行的大小和命中率之间有什么关系?"></a>Cache行的大小和命中率之间有什么关系?</h4><p>行的长度较大，可以充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cache 中，因而可以增加命中机会。但是，行长也不能太大，主要原因有两个:</p>
<p>1）行长大使失效损失变大。也就是说，若未命中，则需花更多时间从主存读块。</p>
<p>2）行长太大，Cache 项数变少，因而命中的可能性变小。</p>
<h4 id="发生取指令Cache-缺失的处理过程是什么"><a href="#发生取指令Cache-缺失的处理过程是什么" class="headerlink" title="发生取指令Cache 缺失的处理过程是什么?"></a>发生取指令Cache 缺失的处理过程是什么?</h4><p>1）程序计数器恢复当前指令的值。</p>
<p>2）对主存进行读的操作。</p>
<p>3）将读入的指令写入 Cache 中，更改有效位和标记位。</p>
<p>4)重新执行当前指令。</p>
<h4 id="关于Cache-的一些小知识。"><a href="#关于Cache-的一些小知识。" class="headerlink" title="关于Cache 的一些小知识。"></a>关于Cache 的一些小知识。</h4><p>1）多级Cache。现代计算机系统中，一般采用多级的Cache系统。CPU执行指令时，先到速度最快的一级Cache (Ll Cache）中寻找指令或数据，找不到时，再到速度次快的二级Cache (L2 Cache）中找最后到主存中找。</p>
<p>2）指令Cache和数据Cache。指令和数据可以分别存储在不同的Cache中 (L1 Cache一般会这么做)，这种结构也称哈佛Cache，其特点是允许CPU在同一个Cache 存储周期内同时提取指令和数据，由于指令执行过程取指和取数据都有可能访问Cache,因此这一特性可以保证不同的指令同时访存。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%80%83%E7%A0%94/" rel="tag"># 考研</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag"># 计算机组成原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch2-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/" rel="prev" title="王道-计算机组成原理-ch2-数据的表示与运算">
      <i class="fa fa-chevron-left"></i> 王道-计算机组成原理-ch2-数据的表示与运算
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/30/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-ch4-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" rel="next" title="王道-计算机组成原理-ch4-指令系统">
      王道-计算机组成原理-ch4-指令系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%8B%E9%81%93"><span class="nav-text">王道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text">存储器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">存储器的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">存储器的性能指标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%93%E6%9E%84"><span class="nav-text">存储器的层次化结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">多级存储系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8A%E5%AF%BC%E4%BD%93%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">半导体随机存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SRAM%E5%92%8C-DRAM"><span class="nav-text">SRAM和 DRAM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">只读存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="nav-text">主存储器的基本组成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-text">主存储器与CPU的连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="nav-text">连接原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-text">主存容量的扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%92%8C%E7%89%87%E9%80%89"><span class="nav-text">存储芯片的地址分配和片选</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-text">存储器与CPU的连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM%E5%92%8C%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">双端口RAM和多模块存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM"><span class="nav-text">双端口RAM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">多模块存储器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">高速缓冲存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-text">程序访问的局部性原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">Cache 的基本工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="nav-text">Cache和主存的映射方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache-%E4%B8%AD%E4%B8%BB%E5%AD%98%E5%9D%97%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">Cache 中主存块的替换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache-%E5%86%99%E7%AD%96%E7%95%A5"><span class="nav-text">Cache 写策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">虚拟存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">虚拟存储器的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">页式虚拟存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">段式虚拟存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">段页式虚拟存储器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECache%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">虚拟存储器与Cache的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-text">本章小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E4%B8%BB%E8%A6%81%E4%BD%93%E7%8E%B0%E5%9C%A8%E4%BD%95%E5%A4%84-%E4%B8%BA%E4%BD%95%E8%A6%81%E5%88%86%E8%BF%99%E4%BA%9B%E5%B1%82%E6%AC%A1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%BF%99%E4%BA%9B%E5%B1%82%E6%AC%A1"><span class="nav-text">存储器的层次结构主要体现在何处?为何要分这些层次?计算机如何管理这些层次?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%8F%96%E5%91%A8%E6%9C%9F%E5%92%8C%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="nav-text">存取周期和存取时间有何区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%EF%BC%8C%E9%A1%B5%E9%9D%A2%E6%98%AF%E8%AE%BE%E7%BD%AE%E5%BE%97%E5%A4%A7%E4%B8%80%E4%BA%9B%E5%A5%BD%E8%BF%98%E6%98%AF%E8%AE%BE%E7%BD%AE%E5%BE%97%E5%B0%8F%E4%B8%80%E4%BA%9B%E5%A5%BD"><span class="nav-text">在虚拟存储器中，页面是设置得大一些好还是设置得小一些好?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%98%93%E6%B7%B7%E6%B7%86%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">常见问题和易混淆知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4-T-a-%E5%B0%B1%E6%98%AF%E5%AD%98%E5%82%A8%E5%91%A8%E6%9C%9F-T-m-%E5%90%97"><span class="nav-text">存取时间 $T_a$ 就是存储周期 $T_m$ 吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache%E8%A1%8C%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%91%BD%E4%B8%AD%E7%8E%87%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="nav-text">Cache行的大小和命中率之间有什么关系?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E7%94%9F%E5%8F%96%E6%8C%87%E4%BB%A4Cache-%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">发生取指令Cache 缺失的处理过程是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8ECache-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E3%80%82"><span class="nav-text">关于Cache 的一些小知识。</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">294</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '04b9fe1c5636beb4acc4',
      clientSecret: '8ccb8829887eac219a8fdb018878fd0cf088a7ac',
      repo        : 'gittalk-comment',
      owner       : 'ednow',
      admin       : ['ednow'],
      id          : '2ae7884e449ee0d89dfb5e7be477f05a',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
