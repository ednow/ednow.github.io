<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="王道数据链路层【考纲内容】(一）数据链路层的功能 (二）组帧 (三）差错控制 检错编码;纠错编码 (四）流量控制与可靠传输机制 流量控制、可靠传输与滑动窗口机制;停止-等待协议 后退N帧协议(GBN);选择重传协议(SR) (五）介质访问控制 1．信道划分 频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理 2．随机访问 ALOHA协议;CSMA协议;CSMA&#x2F;CD协议;CSM">
<meta property="og:type" content="article">
<meta property="og:title" content="王道-计算机网络-ch3-数据链路层">
<meta property="og:url" content="http://ednow.github.io/2021/07/24/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:description" content="王道数据链路层【考纲内容】(一）数据链路层的功能 (二）组帧 (三）差错控制 检错编码;纠错编码 (四）流量控制与可靠传输机制 流量控制、可靠传输与滑动窗口机制;停止-等待协议 后退N帧协议(GBN);选择重传协议(SR) (五）介质访问控制 1．信道划分 频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理 2．随机访问 ALOHA协议;CSMA协议;CSMA&#x2F;CD协议;CSM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004082646.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004082806.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004082948.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004083032.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004083059.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004083438.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004083637.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004085724.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004085755.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004090226.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211005165256.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004091736.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004091942.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092047.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092217.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092236.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092423.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092447.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092751.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092821.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004093506.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004093604.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004093836.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004094127.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004095030.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004100829.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004101854.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004102806.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004103035.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004103430.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105112.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105232.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105346.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105547.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105653.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105913.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004110109.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004110413.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004111006.png">
<meta property="og:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004113302.png">
<meta property="article:published_time" content="2021-07-24T01:09:18.000Z">
<meta property="article:modified_time" content="2021-10-07T13:19:54.197Z">
<meta property="article:author" content="ednow">
<meta property="article:tag" content="考研">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004082646.png">

<link rel="canonical" href="http://ednow.github.io/2021/07/24/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>王道-计算机网络-ch3-数据链路层 | ednow</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XQGJ63ZD9Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XQGJ63ZD9Y');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?83f04257c97e81cca692d7c4c7fbbc9a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/07/24/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          王道-计算机网络-ch3-数据链路层
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-24 09:09:18" itemprop="dateCreated datePublished" datetime="2021-07-24T09:09:18+08:00">2021-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-07 21:19:54" itemprop="dateModified" datetime="2021-10-07T21:19:54+08:00">2021-10-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="王道"><a href="#王道" class="headerlink" title="王道"></a>王道</h1><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>【考纲内容】<br>(一）数据链路层的功能</p>
<p>(二）组帧</p>
<p>(三）差错控制</p>
<p>检错编码;纠错编码</p>
<p>(四）流量控制与可靠传输机制</p>
<p>流量控制、可靠传输与滑动窗口机制;停止-等待协议</p>
<p>后退N帧协议(GBN);选择重传协议(SR)</p>
<p>(五）介质访问控制</p>
<p>1．信道划分</p>
<p>频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理</p>
<p>2．随机访问</p>
<p>ALOHA协议;CSMA协议;CSMA/CD协议;CSMA/CA协议</p>
<p>3．轮询访问:令牌传递协议</p>
<p>(六）局域网<br>局域网的基本概念与体系结构;以太网与IEEE 802.3</p>
<p>IEEE 802.11;<del>令牌环网的基本原理（2022考纲已删除）</del>  $\color{red}{\text{无线局域网（2022新增）}}$ </p>
<p> $\color{red}{\text{VLAN基本概念与原理（2022新增）}}$ </p>
<p>(七）广域网</p>
<p>广域网的基本概念;PPP协议;<del>HDLC协议（2022考纲已删除）</del></p>
<p>(八）数据链路层设备</p>
<p><del>网桥的概念及其基本原理（2022考纲已删除）</del>;局域网交换机及其工作原理</p>
<p>【复习提示】</p>
<p>本章是历年考查的重点。要求在了解数据链路层基本概念和功能的基础上，重点掌握滑动窗口机制、三种可靠传输协议、各种 MAC协议、HDLC协议和PPP协议，特别是CSMA/CD协议和以太网帧格式，以及局域网的争用期和最小帧长的概念、二进制指数退避算法。此外，中继器、网卡、集线器、网桥和局域网交换机的原理及区别也要重点掌握。</p>
<h3 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h3><p>数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为 $\color{green}{\text{逻辑上无差错}}$ 的数据链路，使之对网络层表现为一条无差错的链路。下面具体介绍数据链路层的功能。</p>
<h4 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h4><p>对网络层而言，数据链路层的基本任务是将源机器中来自网络层的数据传输到目标机器的网络层。数据链路层通常可为网络层提供如下服务:</p>
<p>1） $\color{green}{\text{无确认的无连接服务}}$ 。源机器发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。适用于实时通信或误码率较低的通信信道，如以太网。</p>
<p>2） $\color{green}{\text{有确认的无连接服务}}$ 。源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。该服务适用于误码率较高的通信信道，如无线通信。</p>
<p>3） $\color{green}{\text{有确认的面向连接服务}}$ 。帧传输过程分为三个阶段:建立数据链路、传输帧、释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一-帧，因而该服务的可靠性最高。该服务适用于通信要求（可靠性、实时性）较高的场合。注意:有连接就一定要有确认，即不存在无确认的面向连接的服务。</p>
<h4 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h4><p>数据链路层连接的 $\color{green}{\text{建立}}$ 、 $\color{green}{\text{维持}}$ 和 $\color{green}{\text{释放}}$ 过程称为 $\color{red}{\text{链路管理}}$ ，它主要用于面向连接的服务。链路两端的结点要进行通信，必须首先确认对方已处于就绪状态，并交换一些必要的信息以对帧序号初始化，然后才能建立连接，在传输过程中则要能维持连接，而在传输完毕后要释放该连接。在多个站点共享同一物理信道的情况下（如在局域网中）如何在要求通信的站点间分配和管理信道也属于数据链路层管理的范畴。</p>
<h4 id="帧定界、帧同步与透明传输"><a href="#帧定界、帧同步与透明传输" class="headerlink" title="帧定界、帧同步与透明传输"></a>帧定界、帧同步与透明传输</h4><p>两台主机之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。将一段数据的前后分别添加 $\color{green}{\text{首部}}$ 和 $\color{green}{\text{尾部}}$ ，就构成了 $\color{red}{\text{帧}}$ 。因此，帧长等于数据部分的长度加上首部和尾部的长度。首部和尾部中含有很多控制信息，它们的一个重要作用是确定帧的界限，即 $\color{green}{\text{帧定界}}$ 。而帧同步指的是接收方应能从接收到的二进制比特流中区分出帧的起始与终止。如在HDLC协议中，用标识位F （01111110）来标识帧的开始和结束。通信过程中，检测到帧标识位F即认为是帧的开始，然后一旦检测到帧标识位F即表示帧的结束。HDLC标准帧格式如图3.1所示。为了提高帧的传输效率，应当使帧的数据部分的长度尽可能地大于首部和尾部的长度，但每种数据链路层协议都规定了帧的数据部分的长度上限— $\color{green}{\text{最大传送单元}}$ （MTU)。</p>
<details><summary>图3.1 HDLC标准帧格式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004082646.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004082646.png';" /></details>

<p>如果在数据中恰好出现与帧定界符相同的比特组合（会误认为“传输结束”而丢弃后面的数据)，那么就要采取有效的措施解决这个问题，即透明传输。更确切地说， $\color{red}{\text{透明传输}}$ 就是不管所传数据是什么样的比特组合，都应当能在链路上传送。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>由于收发双方各自的工作速率和缓存空间的差异，可能出现发送方的发送能力大于接收方的接收能力的现象，如若此时不适当限制发送方的发送速率（即链路上的信息流量)，前面来不及接收的帧将会被后面不断发送来的帧“淹没”，造成帧的丢失而出错。因此，流量控制实际上就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力。</p>
<p>这个过程需要通过某种反馈机制使发送方能够知道接收方是否能跟上自己，即需要有一些规则使得发送方知道在什么情况下可以接着发送下一帧，而在什么情况下必须暂停发送，以等待收到某种反馈信息后继续发送。</p>
<p>流量控制（见图3.2）并不是数据链路层特有的功能，许多高层协议中也提供此功能，只不过控制的对象不同而已。对于数据链路层来说，控制的是 $\color{green}{\text{相邻两结点}}$ 之间数据链路上的流量，而对于 $\color{red}{\text{运输层}}$ 来说，控制的则是从 $\color{green}{\text{源端}}$ 到 $\color{green}{\text{目的端}}$ 之间的流量。</p>
<details><summary>图3.2数据链路层的流量控制</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004082806.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004082806.png';" /></details>

<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>由于信道噪声等各种原因，帧在传输过程中可能会出现错误。用以使发送方确定接收方是否正确收到由其发送的数据的方法称为 $\color{green}{\text{差错控制}}$ 。通常，这些错误可分为位错和帧错。</p>
<p>位错指帧中某些位出现了差错。通常采用循环冗余校验（CRC)方式发现位错，通过 $\color{green}{\text{自动重传请求}}$ (Automatic Repeat reQuest，ARQ）方式来重传出错的帧。具体做法是:让发送方将要发送的数据帧附加一定的CRC冗余检错码一并发送，接收方则根据检错码对数据帧进行错误检测,若发现错误则丢弃，发送方超时重传该数据帧。这种差错控制方法称为ARQ法。ARQ法只需返回很少的控制信息就可有效地确认所发数据帧是否被正确接收。</p>
<p>帧错指帧的 $\color{green}{\text{丢失}}$ 、 $\color{green}{\text{重复}}$ 或 $\color{green}{\text{失序}}$ 等错误。在数据链路层引入定时器和编号机制，能保证每一帧最终都能有且仅有一次正确地交付给目的结点。</p>
<h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><p>数据链路层之所以要把比特组合成帧为单位传输，是为了在出错时只重发出错的帧，而不必重发全部数据，从而提高效率。为了使接收方能正确地接收并检查所传输的帧，发送方必须依据一定的规则把网络层递交的分组封装成帧（称为组帧)。组帧主要解决帧定界、帧同步、透明传输等问题。通常有以下4种方法实现组帧。</p>
<blockquote>
<p>注意:组帧时既要加首部，又要加尾部。原因是，在网络中信息是以帧为最小单位进行传输的，所以接收端要正确地接收帧，必须要清楚该帧在一串比特流中从哪里开始到哪里结束（因为接收端收到的是一串比特流，没有首部和尾部是不能正确区分帧的)。而分组（即IP数据报）仅是包含在帧中的数据部分（后面将详细讲解)，所以不需要加尾部来定界。</p>
</blockquote>
<h4 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h4><p>如图3.3所示，字符计数法是指在 $\color{red}{\text{帧头部}}$ 使用一个 $\color{green}{\text{计数字段}}$ 来标明 $\color{green}{\text{帧内字符数}}$ 。目的结点的数据链路层收到字节计数值时，就知道后面跟随的字节数，从而可以确定帧结束的位置（计数字段提供的字节数包含自身所占用的一个字节)。</p>
<details><summary>图3.3字符计数法</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004082948.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004082948.png';" /></details>

<p>这种方法最大的问题在于如果计数字段出错，即失去了帧边界划分的依据，那么接收方就无法判断所传输帧的结束位和下一帧的开始位，收发双方将失去同步，从而造成灾难性后果。</p>
<h4 id="字符填充的首尾定界符法"><a href="#字符填充的首尾定界符法" class="headerlink" title="字符填充的首尾定界符法"></a>字符填充的首尾定界符法</h4><p>字符填充法使用特定字符来定界一帧的开始与结束，在图3.4的例子中，控制字符SOH放在帧的最前面，表示帧的首部开始，控制字符EOT表示帧的结束。为了使信息位中出现的特殊字符不被误判为帧的首尾定界符，可在特殊字符前面填充一个转义字符（ESC)来加以区分（注意，转义字符是ASCII码中的控制字符，是一个字符，而非“E””S”“C”三个字符的组合)，以实现数据的透明传输。接收方收到转义字符后，就知道其后面紧跟的是数据信息，而不是控制信息。</p>
<p>如图3.4(a)所示的字符帧，帧的数据段中出现EOT或SOH字符，发送方在每个EOT或SOH字符前再插入一个ESC字符[ 见图3.4(b) ]，接收方收到数据后会自己删除这个插入的ESC字符，结果仍得到原来的数据[ 见图3.4(c) ]。这也正是字符填充法名称的 $\color{red}{\text{由来}}$ 。如果转义字符ESC $\color{green}{\text{也}}$ 出现在数据中，那么解决方法仍是在转义字符前 $\color{green}{\text{插入}}$ 一个转义字符。</p>
<details><summary>图3.4字符填充法</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004083032.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004083032.png';" /></details>

<h4 id="零比特填充的首尾标志法"><a href="#零比特填充的首尾标志法" class="headerlink" title="零比特填充的首尾标志法"></a>零比特填充的首尾标志法</h4><p>如图3.5所示，零比特填充法允许数据帧包含任意个数的比特，也允许每个字符的编码包含任意个数的比特。它使用一个特定的比特模式，即 01111110来标志一帧的开始和结束。为了不使信息位中出现的比特流01111110被误判为帧的首尾标志，发送方的数据链路层在信息位中遇到5个连续的“1”时，将自动在其后插入一个“0”，而接收方做该过程的逆操作，即每收到5个连续的“1”时，自动删除后面紧跟的“0”，以恢复原信息。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004083059.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004083059.png';" /></details>

<p>零比特填充法很容易由硬件来实现，性能优于字符填充法。</p>
<ul>
<li>$\color{red}{\text{Q}}$ ：怎么知道现在连续的1是在信息位中，还是结尾字符呢</li>
</ul>
<h4 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h4><p>在物理层进行比特编码时，通常采用违规编码法。例如，曼彻斯特编码方法将数据比特编码成“高-低”电平对，将数据比特“0”编码成“低-高”电平对，而“高-高”电平对和“低-低”电平对在数据比特中是违规的（即没有采用)。可以借用这些违规编码序列来定界帧的起始和终止。局域网IEEE 802标准就采用了这种方法。</p>
<p>违规编码法不需要采用任何填充技术，便能实现数据传输的透明性，但它只适用于采用 $\color{green}{\text{冗余编码}}$ 的特殊编码环境。</p>
<p>由于字节计数法中计数字段的脆弱性和字符填充法实现上的复杂性与不兼容性，目前较常用的组帧方法是比特填充法和违规编码法。</p>
<h3 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h3><p>实际通信链路都不是理想的，比特在传输过程中可能会产生差错，1可能会变成0，0也可能会变成1，这就是比特差错。比特差错是传输差错中的一种，本节仅讨论比特差错。</p>
<p>通常利用编码技术进行差错控制,主要有两类: $\color{green}{\text{自动重传请求ARQ}}$ 和 $\color{green}{\text{前向纠错FEC}}$ 。在ARQ方式中，接收端检测出差错时，就设法通知发送端重发，直到接收到正确的码字为止。在FEC方式中，接收端不但能发现差错，而且能确定比特串的错误位置，从而加以纠正。因此，差错控制又可分为检错编码和纠错编码。</p>
<h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><p>检错编码都采用冗余编码技术，其核心思想是在有效数据（信息位）被发送前，先按某种关系附加一定的冗余位，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时，相应的冗余位也随之变化，使得码字遵从不变的规则。接收端根据收到的码字是否仍符合原规则来判断是否出错。常见的检错编码有奇偶校验码和循环冗余码。</p>
<blockquote>
<p>注意:建议结合《计算机组成原理考研复习指导》第2章有关校验码的内容对比复习。</p>
</blockquote>
<h5 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h5><p>奇偶校验码是奇校验码和偶校验码的统称，是一种最基本的检错码。它由 $n$ -1位信息元和1位校验元组成，如果是奇校验码，那么在附加一个校验元后，码长为 $n$ 的码字中“1”的个数为奇数;如果是偶校验码，那么在附加一个校验元以后，码长为 $n$ 的码字中“1”的个数为偶数。它只能检测奇数位的出错情况，但并不知道哪些位错了，也不能发现偶数位的出错情况。</p>
<h5 id="循环冗余码"><a href="#循环冗余码" class="headerlink" title="循环冗余码"></a>循环冗余码</h5><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004083438.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004083438.png';" /></details>

<p>通过循环冗余码（CRC)的检错技术，数据链路层做到了对帧的无差错接收。也就是说，凡是接收端数据链路层接收的帧，我们都认为这些帧在传输过程中没有产生差错;而接收端丢弃的帧虽然也收到了，但最终因为有差错而被丢弃，即未被接受。</p>
<blockquote>
<p>注意:循环冗余码(CRC)是具有 $\color{green}{\text{纠错功能}}$ 的，只是 $\color{green}{\text{数据链路层}}$ 仅使用了它的 $\color{green}{\text{检错功能}}$ ，检测到帧出错则直接丢弃，因此本节将CRC放在检错编码中介绍。</p>
</blockquote>
<ul>
<li>重点在不 $\color{green}{\text{借位}}$ ， $\color{green}{\text{异或}}$ </li>
</ul>
<h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><p>在数据通信的过程中，解决差错问题的一种方法是在每个要发送的数据块上附加足够的冗余信息，使接收方能够推导出发送方实际送出的应该是什么样的比特串。最常见的纠错编码是 $\color{green}{\text{海明码}}$ ，其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，而且能指出错位的位置，为自动纠错提供依据。</p>
<p>现以数据码1010为例讲述海明码的编码原理和过程。</p>
<details><summary>海明码的编码原理和过程</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004083637.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004083637.png';" /></details>

<h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h3><h4 id="流量控制、可靠传输与滑动窗口机制"><a href="#流量控制、可靠传输与滑动窗口机制" class="headerlink" title="流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h4><p>流量控制涉及对链路上的帧的发送速率的控制，以使接收方有足够的缓冲空间来接收每个帧。例如，在面向帧的自动重传请求系统中，当待确认帧的数量增加时，有可能超出缓冲存储空间而造成过载。流量控制的基本方法是由接收方控制发送方发送数据的速率，常见的方式有两种:停止-等待协议和滑动窗口协议。</p>
<h5 id="停止-等待流量控制基本原理"><a href="#停止-等待流量控制基本原理" class="headerlink" title="停止-等待流量控制基本原理"></a>停止-等待流量控制基本原理</h5><p>发送方每发送一帧，都要等待接收方的应答信号，之后才能发送下一帧;接收方每接收一帧，都要反馈一个应答信号，表示可接收下一帧，如果接收方不反馈应答信号，那么发送方必须一直等待。每次只允许发送一帧，然后就陷入等待接收方确认信息的过程中，因而传输效率很低。</p>
<h5 id="滑动窗口流量控制基本原理"><a href="#滑动窗口流量控制基本原理" class="headerlink" title="滑动窗口流量控制基本原理"></a>滑动窗口流量控制基本原理</h5><p>在任意时刻，发送方都维持一组连续的允许发送的帧的序号，称为 $\color{green}{\text{发送窗口}}$ ﹔同时接收方也维持一组连续的允许接收帧的序号，称为 $\color{green}{\text{接收窗口}}$ 。发送窗口用来对发送方进行流量控制，而发送窗口的大小W代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之 $\color{green}{\text{外}}$ ，则 $\color{green}{\text{一律}}$ 将其 $\color{green}{\text{丢弃}}$ 。</p>
<p>图3.7给出了发送窗口的工作原理，图3.8给出了接收窗口的工作原理。</p>
<details><summary>图3.7发送窗口的工作原理</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004085724.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004085724.png';" /></details>

<details><summary>图3.8接收窗口的工作原理</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004085755.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004085755.png';" /></details>

<p>发送端每收到一个确认帧，发送窗口就向前滑动一个帧的位置，当发送窗口内没有可以发送的帧（即窗口内的帧全部是已发送但未收到确认的帧)时，发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧后，才开始继续发送。</p>
<p>接收端收到数据帧后，将窗口向前移一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。</p>
<p>滑动窗口有以下重要特性:</p>
<p>1）只有接收窗口向前滑动（同时接收方发送了确认帧）时，发送窗口才有可能（只有发送方收到确认帧后才一定）向前 $\color{green}{\text{滑动}}$ 。</p>
<p>2）从滑动窗口的概念看，停止-等待协议、后退N帧协议和选择重传协议只在发送窗口大小与接收窗口大小上有所差别:</p>
<p>$\color{green}{\text{停止-等待协议}}$ :发送窗口大小= 1，接收窗口大小=1。</p>
<p>$\color{green}{\text{后退N帧协议}}$ :发送窗口大小&gt;1，接收窗口大小=1。</p>
<p>$\color{green}{\text{选择重传协议}}$ :发送窗口大小&gt;1，接收窗口大小&gt;1。</p>
<p>3）接收窗口的大小为1时，可保证帧的 $\color{green}{\text{有序}}$ 接收。</p>
<p>4）数据链路层的滑动窗口协议中，窗口的大小在传输过程中是 $\color{green}{\text{固定的}}$ （注意与 $\color{red}{\text{第5章}}$ 传输层的滑动窗口协议的区别)。</p>
<h5 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h5><p>数据链路层的可靠传输通常使用 $\color{green}{\text{确认}}$ 和 $\color{green}{\text{超时重传}}$  两种机制来完成。确认是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为 $\color{green}{\text{捎带确认}}$ 。超时重传是指发送方在发送某个数据帧后就开启一个计时器，在一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧,直到发送成功为止。</p>
<p>自动重传请求（Auto Repeat reQuest，ARQ）通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一。传统 $\color{red}{\text{自动重传请求}}$ 分为三种，即 $\color{green}{\text{停止-等待}}$ (Stop-and-Wait）ARQ、 $\color{green}{\text{后退N帧}}$ (Go-Back-N)ARQ和 $\color{green}{\text{选择性重传}}$ (Selective Repeat)ARQ。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为 $\color{green}{\text{连续ARQ协议}}$ 。注意，在数据链路层中 $\color{green}{\text{流量控制机制}}$ 和 $\color{green}{\text{可靠传输机制}}$ 是 $\color{red}{\text{交织在一起}}$ 的。</p>
<blockquote>
<p>注意:现有的实际有线网络的数据链路层很少采用可靠传输(不同于OSI参考模型的思路),因此大多数教材把这部分内容放在第5章运输层中讨论，本书按照408考纲，不做变动。</p>
</blockquote>
<h4 id="单帧滑动窗口与停止-等待协议"><a href="#单帧滑动窗口与停止-等待协议" class="headerlink" title="单帧滑动窗口与停止-等待协议"></a>单帧滑动窗口与停止-等待协议</h4><p>在停止-等待协议中，源站发送单个帧后必须等待确认，在目的站的回答到达源站之前，源站不能发送其他的数据帧。从滑动窗口机制的角度看，停止-等待协议相当于发送窗口和接收窗口大小均为1的滑动窗口协议。</p>
<p>在停止-等待协议中，除数据 $\color{green}{\text{帧丢失}}$ 外，还可能出现以下两种差错。</p>
<p>到达目的站的 $\color{green}{\text{帧}}$ 可能已遭 $\color{green}{\text{破坏}}$ ，接收站利用前面讨论过的差错检测技术检出后，简单地将该帧丢弃。为了对付这种可能发生的情况，源站装备了计时器。在一个帧发送之后，源站等待确认,如果在计时器计满时仍未收到确认，那么再次发送相同的帧。如此重复，直到该数据帧无错误地到达为止。</p>
<p>另一种可能的差错是数据帧正确而 $\color{green}{\text{确认帧被破坏}}$ ，此时接收方已收到正确的数据帧，但发送方收不到确认帧，因此发送方会重传已被接收的数据帧，接收方收到同样的数据帧时会丢弃该帧,并重传一个该帧对应的确认帧。发送的帧交替地用0和1来标识,肯定确认分别用ACK0和 ACK1来表示，收到的确认有误时，重传已发送的帧。对于停止-等待协议，由于每发送一个数据帧就停止并等待,因此用1bit 来编号就已足够。在停止-等待协议中，若连续出现相同发送序号的数据帧,表明发送端进行了超时重传。连续出现相同序号的确认帧时，表明接收端收到了重复帧。</p>
<p>此外，为了超时重发和判定重复帧的需要，发送方和接收方都须设置一个帧缓冲区。发送端在发送完数据帧时，必须在其发送缓存中保留此数据帧的副本，这样才能在出差错时进行重传。只有在收到对方发来的确认帧ACK时，方可清除此副本。</p>
<p>由图3.9可知，停止-等待协议通信信道的利用率很低。为了克服这一缺点，就产生了另外两种协议，即后退N帧协议和选择重传协议。</p>
<details><summary>图3.9 停止-等待协议中数据帧和确认帧的发送时间关系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004090226.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004090226.png';" /></details>


<h4 id="多帧滑动窗口与后退N帧协议（GBN"><a href="#多帧滑动窗口与后退N帧协议（GBN" class="headerlink" title="多帧滑动窗口与后退N帧协议（GBN)"></a>多帧滑动窗口与后退N帧协议（GBN)</h4><p>在后退N帧式ARQ中，发送方无须在收到上一个帧的ACK后才能开始发送下一帧，而是可以连续发送帧。当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧;或者当发送方发送了N个帧后，若发现该N个帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重传该出错帧及随后的N个帧。换句话说，接收方只允许 $\color{green}{\text{按顺序接收帧}}$ 。</p>
<p>如图3.10 所示，源站向目的站发送数据帧。当源站发完0号帧后，可以继续发送后续的1号帧、2号帧等。源站每发送完一帧就要为该帧设置超时计时器。由于连续发送了许多帧，所以确认帧必须要指明是对哪一帧进行确认。为了减少开销，GBN协议还规定接收端不一定每收到一个正确的数据帧就必须立即发回一个确认帧，而可以在连续收到好几个正确的数据帧后，才对最后一个数据帧发确认信息，或者可在自己有数据要发送时才将对以前正确收到的帧加以 $\color{green}{\text{捎带确认}}$ 。这就是说，<strong>对某一数据帧的确认就表明该数据帧和 $\color{green}{\text{此前所有}}$ 的数据帧均已 $\color{green}{\text{正确无误}}$ 地收到</strong>。在图3.10中，ACK $n$ 表示对第 $n$ 号帧的确认，表示接收方已正确收到第 $n$ 号帧及以前的所有帧，下一次期望收到第 $n+1$ 号帧（也可能是第0号帧)。接收端只按序接收数据帧。虽然在有差错的2号帧之后接着又收到了正确的6个数据帧，但接收端都必须将这些帧丢弃。接收端虽然丢弃了这些不按序的无差错帧，但应 $\color{green}{\text{重复发送}}$ 已发送的 $\color{green}{\text{最后一个确认帧}}$ ACK1（这是为了防止已发送的确认帧ACK1丢失)。</p>
<p>后退N帧协议的接收窗口为1，可以保证按序接收数据帧。若采用 $n$ 比特对帧编号，则其 $\color{red}{\text{发送窗口的尺寸}}$  $W_T$ 应满足 $1 \leq W_T \leq 2^n-1$ 。若 $\color{red}{\text{发送窗口的尺寸}}$ 大于 $2^n-1$ ，则会造成接收方无法分辨新帧和旧帧（请参考本章疑难点3)。</p>
<p>从图3.10不难看出，后退N帧协议一方面因连续发送数据帧而提高了信道的利用率，另一方面在重传时又必须把原来已传送正确的数据帧进行重传（仅因这些数据帧的前面有一个数据帧出了错)，这种做法又使传送效率降低。由此可见，若信道的传输质量很差导致误码率较大时，后退N帧协议不一定优于停止-等待协议。</p>
<details><summary>图3.10 GBN协议的工作原理:对出错数据帧的处理
</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211005165256.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211005165256.png';" /></details>

<h4 id="多帧滑动窗口与选择重传协议-SR"><a href="#多帧滑动窗口与选择重传协议-SR" class="headerlink" title="多帧滑动窗口与选择重传协议(SR)"></a>多帧滑动窗口与选择重传协议(SR)</h4><p>为进一步提高信道的利用率，可设法只重传出现差错的数据帧或计时器超时的数据帧，但此时必须加大接收窗口，以便先收下发送序号不连续但仍处在接收窗口中的那些数据帧。等到所缺序号的数据帧收到后再一并送交主机。这就是选择重传ARQ协议。</p>
<p>在选择重传协议中，每个发送缓冲区对应一个计时器，当计时器超时时，缓冲区的帧就会重传。另外，该协议使用了比上述其他协议更有效的差错处理策略，即一旦接收方怀疑帧出错，就会发一个否定帧NAK给发送方，要求发送方对NAK中指定的帧进行重传，如图3.11所示。</p>
<p>选择重传协议的接收窗口尺寸 $W_R$ 和发送窗口尺寸 $W_T$ 都大于1,一次可以发送或接收多个帧。若采用 $n$ 比特对帧编号，为了保证接收方向前移动窗口后，新窗口序号与旧窗口序号没有重叠部分，需要满足条件:接收窗口 $W_R$ +发送窗口 $W_T \leq 2^n$ 。假定仍然采用 $\color{green}{\text{累计确认}}$ 的方法，并且接收窗口 $W_R$ 显然不应超过发送窗口 $W_T$ (否则无意义)，那么接收窗口尺寸不应超过序号范围的一半，即 $W_R \leq 2^{n-1}$ 。接收窗口为最大值时， $W_{Tmax}$ =  $W_{Rmax}=2^{(n-1)}$  。需要提醒读者的是，一般情况下，在SR协议中，接收窗口的大小和发送窗口的大小是相同的。</p>
<details><summary>图3.11选择重传协议</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004091736.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004091736.png';" /></details>

<p>选择重传协议可以避免重复传送那些本已正确到达接收端的数据帧，但在接收端要设置具有相当容量的缓冲区来暂存那些未按序正确收到的帧。接收端不能接收窗口下界以下或窗口上界以上的序号的帧，因此所需缓冲区的数目等于窗口的大小，而不是序号数目。</p>
<p>在往年统考真题中曾经出现过对“信道效率”“信道的吞吐率”等概念的考查，有些读者未接触过“通信原理”等相关的课程，可能对这些概念不太熟悉，在这里给读者补充一下。</p>
<p>信道的效率，也称信道利用率。可从不同的角度来定义 $\color{green}{\text{信道的效率}}$ ，这里给出一种从时间角度的定义:信道效率是对 $\color{green}{\text{发送方}}$ 而言的，是指发送方在一个 $\color{green}{\text{发送周期}}$ 的时间内， $\color{green}{\text{有效地}}$ 发送数据所需要的时间占整个发送周期的比率。</p>
<p>例如，发送方从开始发送数据到收到第一个确认帧为止，称为一个发送周期，设为T，发送方在这个周期内共发送L比特的数据，发送方的数据传输速率为C，则发送方用于发送有效数据的时间为L/C，在这种情况下，信道的利用率为(L/C)/T。</p>
<p>从上面的讨论可以发现，求信道的利用率主要是求周期时间T和有效数据发送时间L/C，在题目中，这两个量一般不会直接给出，需要读者根据题意自行计算。</p>
<p style='text-align:center'> $\color{green}{\text{信道吞吐率}}$ =信道利用率x发送方的发送速率。</p>

<p>本节习题有不少是关于信道利用率和信道吞吐率的，以帮助读者理解和记忆这两个概念。流量控制的三种滑动窗口协议的信道利用率是一个关键知识点，希望读者能结合习题，自行推导。</p>
<h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><p>介质访问控制所要完成的主要任务是，为使用介质的每个结点 $\color{green}{\text{隔离}}$ 来自同一信道上其他结点所传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为 $\color{green}{\text{介质访问控制}}$ (Medium Access Control，MAC）子层。</p>
<p>图3.12是广播信道的通信方式，结点A、B、C、D、E共享广播信道，假设A要与C发生通信，B要与D发生通信，由于它们共用一条信道，如果不加控制，那么两对结点间的通信可能会因为互相干扰而失败。介质访问控制的内容是，采取一定的措施，使得两对结点之间的通信不会发生互相干扰的情况。</p>
<p>常见的 $\color{red}{\text{介质访问控制方法}}$ 有 $\color{green}{\text{信道划分介质访问控制}}$ 、 $\color{green}{\text{随机访问介质访问控制}}$ 和 $\color{green}{\text{轮询访问介质访问控制}}$ 。其中前者是静态划分信道的方法，而后两者是动态分配信道的方法。</p>
<details><summary>图3.12广播信道的通信方式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004091942.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004091942.png';" /></details>

<h4 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h4><p>信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开来，把时域和频域资源合理地分配给网络上的设备。</p>
<p>下面介绍多路复用技术的概念。当传输介质的带宽超过传输单个信号所需的带宽时人们就通过在一条介质上同时携带多个传输信号的方法来提高传输系统的利用率，这就是所谓的多路复用，也是实现信道划分介质访问控制的途径。多路复用技术把多个信号组合在一条物理信道上进行传输，使多个计算机或终端设备共享信道资源，提高了信道的利用率。</p>
<p>采用多路复用技术可把多个输入通道的信息整合到一个复用通道中，在接收端把收到的信息分离出来并传送到对应的输出通道，如图3.13所示。</p>
<details><summary>图3.13多路复用原理示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004092047.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092047.png';" /></details>

<p>信道划分的实质就是通过分时、分频、分码等方法把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道，实际上就是把广播信道转变为点对点信道。</p>
<p>信道划分介质访问控制分为以下4种。</p>
<h5 id="color-green-text-频分多路复用-FDM"><a href="#color-green-text-频分多路复用-FDM" class="headerlink" title="$\color{green}{\text{频分多路复用}}$ (FDM)"></a>$\color{green}{\text{频分多路复用}}$ (FDM)</h5><p>频分多路复用是一种将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号的多路复用技术。在物理信道的可用带宽超过单个原始信号所需带宽的情况下，可将该物理信道的总带宽分割成若干与传输单个信号带宽相同（或略宽）的子信道，每个子信道传输一种信号，这就是频分多路复用，如图3.14所示。</p>
<p>每个子信道分配的带宽可不相同，但它们的总和必须不超过信道的总带宽。在实际应用中，为了防止子信道之间的干扰，相邻信道之间需要加入“保护频带”。</p>
<p>频分多路复用的优点在于充分利用了传输介质的带宽，系统效率较高;由于技术比较成熟，实现也较容易。</p>
<details><summary>图3.14 频分多路复用原理示意图
</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004092217.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092217.png';" /></details>

<h5 id="时分多路复用-TDM"><a href="#时分多路复用-TDM" class="headerlink" title="时分多路复用(TDM)"></a>时分多路复用(TDM)</h5><ul>
<li>time-division multiplexing, TDM</li>
</ul>
<p>时分多路复用是将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用。每个时间片由复用的一个信号占用，而不像 FDM那样，同一时间同时发送多路信号。这样，利用每个信号在时间上的交叉，就可以在一条物理信道上传输多个信号，如图3.15所示。</p>
<p>就某个时刻来看，时分多路复用信道上传送的仅是某一对设备之间的信号;就某段时间而言，传送的是按时间分割的多路复用信号。但由于计算机数据的突发性，一个用户对已经分配到的子信道的利用率一般不高。统计时分多路复用(STDM，又称异步时分多路复用）是TDM的一种改进，它采用STDM帧，STDM帧并不固定分配时隙，而按需动态地分配时隙，当终端有数据要传送时，才会分配到时间片，因此可以提高线路的利用率。例如，线路传输速率为8000b/s，4个用户的平均速率都为2000b/s，当采用TDM方式时，每个用户的最高速率为2000b/s，而在STDM方式下，每个用户的最高速率可达8000b/s。</p>
<details><summary>图3.15时分多路复用原理示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004092236.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092236.png';" /></details>

<h5 id="波分多路复用-WDM"><a href="#波分多路复用-WDM" class="headerlink" title="波分多路复用(WDM)"></a>波分多路复用(WDM)</h5><p>波分多路复用即光的频分多路复用，它在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。由于光波处于频谱的高频段，有很高的带宽，因而可以实现多路的波分复用，如图3.16所示。</p>
<details><summary>图3.16 波分多路复用原理示意图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004092423.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092423.png';" /></details>

<h5 id="码分多路复用-CDM"><a href="#码分多路复用-CDM" class="headerlink" title="码分多路复用(CDM)"></a>码分多路复用(CDM)</h5><p>码分多路复用是采用不同的编码来区分各路原始信号的一种复用方式。与FDM和TDM不同，它既共享信道的频率，又共享时间。下面举一个直观的例子来理解码分复用。</p>
<p>假设A站要向C站运输黄豆，B站要向C站运输绿豆，A与C、B与C之间有一条公共的道路，可以类比为广播信道，如图3.17所示。在频分复用方式下，公共道路被划分为两个牛道，分别提供给A到C的车和B到C的车行走，两类车可以同时行走，但只分到了公共车道的一半，因此频分复用(波分复用也一样）共享时间而不共享空间。在时分复用万式下，先让A到C的牛走一趟，再让B到C的车走一趟，两类车交替地占用公共车道。公共牛道没有划分，内此网千共享了空间，但不共享时间。码分复用与另外两种信道划分方式大为不同，在码分复用情况下，黄豆与绿豆放在同一辆车上运送，到达C后，由C站负责把车上的黄豆和绿豆分开。因此，黄豆和绿豆的运送，在码分复用的情况下，既共享了空间，也共享了时间。</p>
<details><summary>图3.17共享信道的传输</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004092447.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092447.png';" /></details>

<p>实际上，更常用的名词是 $\color{green}{\text{码分多址}}$ (Code Division Multiple Access，CDMA)，其原理是每个比特时间再划分成m个短的时间槽，称为码片(Chip)，通常m的值是64或128，下例中为简单起见，设m为8。每个站点被指派一个唯一的m位码片序列。发送1时，站点发送它的码片序列;发送0时，站点发送该码片序列的反码。当两个或多个站点同时发送时，各路数据在信道中线性相加。为从信道中分离出各路信号，要求各个站点的码片序列相互正交。</p>
<p>简单理解就是，A站向C站发出的信号用一个向量来表示，B站向C站发出的信号用另一个向量来表示，两个向量要求相互正交。向量中的分量，就是所谓的码片。</p>
<p>下面举例说明<a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/24552307">CDMA的原理</a>。</p>
<p>假如站点A的码片序列被指派为00011011，则A站发送00011011就表示发送比特1，发送11100100就表示发送比特0。为了方便，按惯例将码片中的0写为-1，将1写为+1，因此A站的码片序列是-1-1-1+1+1-1+1+1。</p>
<p>令向量S表示A站的码片向量，令T表示B站的码片向量。两个不同站的码片序列正交，即向量S和T的规格化内积（Inner Product）为0:</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004092751.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092751.png';" /></details>

<p>任何一个码片向量和该码片向量自身的规格化内积都是1，任何一个码片向量和该码片反码的向量的规格化内积是-1，如</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004092821.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004092821.png';" /></details>

<p>令向量T为(-1-1+1-1+1+1+1-1)。</p>
<p>当A站向C站发送数据1时，就发送了向量(-1-1-1+1 +1-1+1 +1)。</p>
<p>当B站向C站发送数据0时，就发送了向量(+1+1-1 +1-1-1-1 +1)。两个向量到了公共信道上就进行叠加，实际上就是线性相加，得到</p>
<p style='text-align:center'> $\mathbf{S}$ - $\mathbf{T}$  =(0 0 -2 2 0 -2 0 2)</p>

<p>到达C站后，进行数据分离，如果要得到来自A站的数据，C站就必须知道A站的码片序列，让S与S–T进行规格化内积。根据叠加原理，其他站点的信号都在内积的结果中被过滤掉了，内积的相关项都是0，而只剩下A站发送的信号。得到</p>
<p style='text-align:center'>S $\cdot$ (S-T)= 1</p>

<p>所以A站发出的数据是1。同理，如果要得到来自B站的数据，那么</p>
<p style='text-align:center'>T $\cdot$ (S-T) = -1</p>

<p>因此从B站发送过来的信号向量是一个反码向量，代表0。</p>
<p>规格化内积是线性代数中的内容，它是在得到两个向量的内积后再除以向量的分量的个数。</p>
<p>码分多路复用技术具有频谱利用率高、抗干扰能力强、保密性强、语音质量好等优点，还可以减少投资和降低运行成本，主要用于无线通信系统，特别是移动通信系统。</p>
<h4 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h4><p>在随机访问协议中，不采用集中控制方式解决发送信息的次序问题，所有用户能根据自己的意愿随机地发送信息，占用信道全部速率。在总线形网络中，当有两个或多个用户同时发送信息时，就会产生帧的冲突（碰撞，即前面所说的相互干扰)，导致所有冲突用户的发送均以失败告终。为了解决随机接入发生的碰撞，每个用户需要按照一定的规则反复地重传它的帧，直到该帧无碰撞地通过。这些规则就是随机访问介质访问控制协议，常用的协议有ALOHA协议、CSMA协议、CSMA/CD协议和 CSMA/CA 协议等，它们的核心思想都是:胜利者通过争用获得信道，从而获得信息的发送权。因此，随机访问介质访问控制协议又称 $\color{green}{\text{争用型协议}}$ 。</p>
<p>读者会发现，如果介质访问控制采用信道划分机制，那么结点之间的通信要么共享空间，要么共享时间，要么两者都共享;而如果采用随机访问控制机制，那么各结点之间的通信就可既不共享时间，也不共享空间。所以随机介质访问控制实质上是一种将 $\color{green}{\text{广播信道}}$ 转化为 $\color{green}{\text{点到点信道}}$ 的行为，如图3.18所示。</p>
<details><summary>图3.18共享信道举例</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004093506.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004093506.png';" /></details>

<h5 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h5><p>夏威夷大学早期研制的随机接入系统称为ALOHA,它是Additive Link On-line HAwaii system的缩写。ALOHA协议分为纯ALOHA协议和时隙ALOHA协议两种。</p>
<p>（1） $\color{green}{\text{纯ALOHA协议}}$ </p>
<p>纯ALOHA协议的基本思想是，当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据。如果在一段时间内未收到确认，那么该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后再发送数据，直至发送成功。图3.19所示的模型不仅可代表总线形网络的情况，而且可以代表无线信道的情况。</p>
<details><summary>图3.19ALOHA 协议的一般模型</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004093604.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004093604.png';" /></details>


<p>图3.20表示一个纯ALOHA协议的工作原理。每个站均自由地发送数据帧。为简化问题，不考虑由信道不良而产生的误码，并假定所有站发送的帧都是定长的，帧的长度不用比特而用发送这个帧所需的时间来表示，在图3.20中用 $T_0$ 表示这段时间。</p>
<p>在图3.20的例子中，当站1发送帧1时，其他站都未发送数据，所以站1的发送必定是成功的。但随后站2和站N-1发送的帧2和帧3在时间上重叠了一些(即发生了碰撞)。碰撞的结果是，碰撞双方(有时也可能是多方）所发送的数据出现了差错，因而都须进行重传。但是发生碰撞的各站并不能马上进行重传,因为这样做必然会继续发生碰撞。纯ALOHA系统采用的重传策略是让各站等待一段随机的时间,然后再进行重传。若再次发生碰撞，则需要再等待一段随机的时间，直到重传成功为止。图中其余一些帧的发送情况是帧4发送成功，而帧5和帧6发生碰撞。</p>
<details><summary>图3.20纯ALOHA 协议的工作原理</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004093836.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004093836.png';" /></details>

<p>假设网络负载（ $T_0$ 时间内所有站点发送成功的和未成功而重传的帧数）为G，则纯ALOHA网络的吞吐量（ $T_0$ )时间内成功发送的平均帧数）为 $S=Ge^{-2G}$ 。当G=0.5时，S=0.5 $e^{-1}$  $\approx$ 0.184,这是吞吐量S可能达到的极大值。可见，纯ALOHA网络的吞吐量很低。为了克服这一缺点，人们在原始的纯ALOHA 协议的基础上进行改进，产生了时隙ALOHA 协议。</p>
<p>(2） $\color{green}{\text{时隙ALOHA 协议}}$ </p>
<p>时隙ALOHA协议把所有各站在时间上同步起来,并将时间划分为一段段等长的 $\color{green}{\text{时隙}}$ (Slot)，规定只能在每个时隙开始时才能发送一个帧。从而避免了用户发送数据的随意性，减少了数据产生冲突的可能性，提高了信道的利用率。</p>
<p>图3.21为两个站的时隙ALOHA 协议的工作原理示意图。时隙的长度 $T_0$ 。使得每个帧正好在一个时隙内发送完毕。每个帧在到达后，一般都要在缓存中等待一段小于 $T_0$ 的时间，然后才能发送出去。在一个时隙内有两个或两个以上的帧到达时，在下一个时隙将产生碰撞。碰撞后重传的策略与纯ALOHA的情况是相似的。</p>
<details><summary>图3.21 时隙ALOHA 协议的工作原理</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004094127.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004094127.png';" /></details>

<p>时隙ALOHA网络的吞吐量S与网络负载G的关系是 $S=Ge^{-G}$ 。当G=1时, $S=e^{-1}$  $\approx$ 0.368。这是吞吐量S可能达到的极大值。可见，时隙ALOHA网络比纯ALOHA网络的吞吐量大了1倍。</p>
<h5 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h5><p>时隙ALOHA系统的效率虽然是纯ALOHA系统的两倍，但每个站点都是随心所欲地发送数据的，即使其他站点正在发送也照发不误，因此发送碰撞的概率很大。</p>
<p>若每个站点在发送前都先侦听一下共用信道，发现信道空闲后再发送，则就会大大降低冲突的可能，从而提高信道的利用率，载波侦听多路访问(Carrier Sense Multiple Access，CSMA）协议依据的正是这一思想。CSMA协议是在ALOHA协议基础上提出的一种改进协议,它与ALOHA协议的主要区别是多了一个载波侦听装置。</p>
<p>根据侦听方式和侦听到信道忙后的处理方式不同，CSMA 协议分为三种。</p>
<h6 id="color-green-text-1-坚持CSMA"><a href="#color-green-text-1-坚持CSMA" class="headerlink" title="$\color{green}{\text{1-坚持CSMA}}$"></a>$\color{green}{\text{1-坚持CSMA}}$</h6><p>1-坚持CSMA ( 1-persistent CSMA）的基本思想是:一个结点要发送数据时，首先侦听信道;如果信道空闲，那么立即发送数据;如果信道忙，那么等待，同时继续侦听直至信道空闲;如果发生冲突，那么随机等待一段时间后，再重新开始侦听信道。</p>
<p>“1-坚持”的含义是:侦听到信道忙后，继续坚持侦听信道;侦听到信道空闲后， $\color{green}{\text{发送帧的概率}}$ 为 $\color{green}{\text{1}}$ ，即立刻发送数据。</p>
<p>传播延迟对1-坚持CSMA 协议的性能影响较大。结点A开始发送数据时，结点B也正好有数据要发送，但这时结点A发出数据的信号还未到达结点B，结点B侦听到信道空闲，于是立即发送数据，结果必然导致冲突。即使不考虑延迟，1-坚持CSMA协议也可能产生冲突。例如，结点A正在发送数据时，结点B和C也准备发送数据，侦听到信道忙，于是坚持侦听，结果当结点A一发送完毕，结点B和C就会立即发送数据，同样导致冲突。</p>
<h6 id="color-green-text-非坚持CSMA"><a href="#color-green-text-非坚持CSMA" class="headerlink" title="$\color{green}{\text{非坚持CSMA}}$"></a>$\color{green}{\text{非坚持CSMA}}$</h6><p>非坚持CSMA (Non-persistent CSMA）的基本思想是:一个结点要发送数据时，首先侦听信道;如果信道空闲，那么立即发送数据;如果信道忙，那么放弃侦听，等待一个随机的时间后再重复上述过程。</p>
<p>非坚持CSMA协议在侦听到信道忙后就放弃侦听,因此降低了多个结点等待信道空闲后同时发送数据导致冲突的概率，但也会增加数据在网络中的平均延迟。可见，信道利用率的提高是以增加数据在网络中的延迟时间为代价的。</p>
<h6 id="color-green-text-p-坚持CSMA"><a href="#color-green-text-p-坚持CSMA" class="headerlink" title="$\color{green}{\text{p-坚持CSMA}}$"></a>$\color{green}{\text{p-坚持CSMA}}$</h6><p>p-坚持CSMA (P-persistent CSMA）用于时分信道，其基本思想是:一个结点要发送数据时,首先帧听信道;如果信道忙，就持续侦听，直至信道空闲;如果信道空闲，那么以概率p 发送数据，以概率1-p推迟到下一个时隙;如果在下一个时隙信道仍然空闲，那么仍以概率p 发送数据，以概率1-p推迟到下一个时隙;这个过程一直持续到数据发送成功或因其他结点发送数据而检测到信道忙为止，若是后者，则等待下一个时隙再重新开始帧听。</p>
<p>p-坚持CSMA 在检测到信道空闲后，以概率p发送数据，以概率1-p推迟到下一个时隙，其目的是降低1-坚持CSMA协议中多个结点检测到信道空闲后同时发送数据的冲突概率;采用坚持“帧听”的目的是，试图克服非坚持CSMA协议中由于随机等待而造成的延迟时间较长的缺点。因此，p-坚持CSMA协议是非坚持CSMA协议和1-坚持CSMA协议的折中方案。</p>
<p>三种不同类型的CSMA协议比较如表3.1所示。</p>
<details><summary>表3.1三种不同类型的CSMA 协议比较</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004095030.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004095030.png';" /></details>

<h5 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h5><p>载波侦听多路访问/碰撞检测(Carrier Sense Multiple Access with Collision Detection, CSMA/CD)协议是CSMA协议的改进方案，适用于总线形网络或半双工网络环境。“载波帧听”就是发送前先侦听，即每个站在发送数据之前先要检测一下总线上是否有其他站点正在发送数据，若有则暂时不发送数据，等待信道变为空闲时再发送。“碰撞检测”就是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站点是否也在发送数据。</p>
<p>CSMA/CD的工作流程可简单概括为“ $\color{green}{\text{先听后发}}$ ， $\color{green}{\text{边听边发}}$ ， $\color{green}{\text{冲突停发}}$ ， $\color{green}{\text{随机重发}}$ ”。</p>
<p>1）适配器从网络层获得一个分组，封装成以太网帧，放入适配器的缓存，准备发送。</p>
<p>2）如果适配器侦听到信道空闲，那么它开始发送该帧。如果适配器侦听到信道忙，那么它持续侦听直至信道上没有信号能量，然后开始发送该帧。</p>
<p>3）在发送过程中，适配器持续检测信道。若一直未检测到碰撞，则顺利地把这个帧发送完毕。若检测到碰撞，则中止数据的发送，并发送一个拥塞信号，以让所有用户都知道。</p>
<p>4）在中止发送后，适配器就执行 $\color{green}{\text{指数退避}}$ 算法，等待一段随机时间后返回到步骤2）。</p>
<p>电磁波在总线上的传播速率总是有限的，因此，当某个时刻发送站检测到信道空闲时，此时信道并不一定是空闲的。如图3.22所示，设 $\tau$ 为单程传播时延。在t=0时,A发送数据。在t=  $\tau - \sigma$ 时，A发送的数据还未到达B，由于B检测到信道空闲而发送数据。经过时间 $\sigma/2$ 后，即在t =  $\tau-\sigma$ /2时，A发送的数据和B发送的数据发生碰撞，但这时A和B都不知道。在t= $\tau$ 时，B检测到碰撞,于是停止发送数据。在 $t =2\tau-\sigma$ 时，A检测到碰撞，也停止发送数据。显然，CSMA/CD 中的站不可能同时进行发送和接收，因此采用CSMA/CD协议的 $\color{green}{\text{以太网}}$ 只能进行 $\color{green}{\text{半双工通信}}$ 。</p>
<p>由图3.22可知，站A在发送帧后至多经过时间2 $\tau$ (端到端传播时延的2倍）就能知道所发送的帧有没有发生碰撞（当 $\sigma \to 0$ 时)。因此把以太网端到端往返时间 $2\tau$ 称为 $\color{green}{\text{争用期}}$ (又称 $\color{green}{\text{冲突窗口}}$ 或 $\color{green}{\text{碰撞窗口}}$ )。每个站在自己发送数据之后的一小段时间内，存在发生碰撞的可能性，只有经过争用期这段时间还未检测到碰撞时，才能确定这次发送不会发生碰撞。</p>
<details><summary>图3.22 传播时延对载波帧听的影响</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004100829.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004100829.png';" /></details>

<p>为了确保发送站在发送数据的同时能检测到可能存在的碰撞，需要在发送完帧之前就能收到自己发送出去的数据，即帧的传输时延至少要两倍于信号在总线中的传播时延，所以CSMA/CD总线网中的所有数据帧都必须要大于一个 $\color{green}{\text{最小帧长}}$ 。任何站点收到帧长小于最小帧长的帧时，就把它当作无效帧立即丢弃。最小帧长的计算公式为</p>
<p style='text-align:center'>最小帧长=总线传播时延×数据传输速率×2</p>


<p>例如,以太网规定取51.2 $\mu$ s为争用期的长度。对于10Mb/s的以太网,在争用期内可发送512bit,即64B。在以太网发送数据时，如果前64B未发生冲突，那么后续数据也就不会发生冲突(表示已成功抢占信道)。换句话说，如果发生冲突，那么就一定在前64B。由于一旦检测到冲突就立即停止发送，因此这时发送出去的数据一定小于64B。因此，以太网规定最短帧长为64B，凡长度小于64B的帧都是由于冲突而异常中止的无效帧，收到这种无效帧时应立即 $\color{green}{\text{丢弃}}$ 。</p>
<p>如果只发送小于64B的帧，如40B的帧，那么需要在MAC子层中于数据字段的后面加入一个整数字节的填充字段，以保证以太网的MAC帧的长度不小于64B。</p>
<p>除检测冲突外，CSMA/CD还能从冲突中恢复。一旦发生了冲突，参与冲突的两个站点紧接着再次发送是没有意义的，如果它们这样做，那么将会导致无休止的冲突。CSMA/CD 采用 $\color{green}{\text{二进制指数退避算法}}$ 来解决碰撞问题。算法精髓如下:</p>
<p>1）确定基本退避时间，一般取两倍的总线端到端传播时延2 $\tau$ (即争用期)。</p>
<p>2）定义参数k，它等于重传次数，但k不超过10，即 k= min[重传次数,10]。当重传次数不超过10时，k等于重传次数;当重传次数大于10时，k就不再增大而 $\color{green}{\text{一直等于10}}$ (这个条件往往容易忽略，请读者注意)。</p>
<p>3)从离散的整数集合[0,1,…,  $2^k$ -1]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2r $\tau$ 。</p>
<p>4)当重传达 $\color{green}{\text{16次}}$ 仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出抛弃此帧并向高层报告出错（这个条件也容易忽略，请读者注意)。</p>
<p>现在来看一个例子。假设一个适配器首次试图传输一帧，当传输时，它检测到碰撞。第1次重传时，k= 1，随机数r从整数{0，1}中选择，因此适配器可选的重传推迟时间是0或2 $\tau$ 。若再次发送碰撞，则在第2次重传时，随机数r从整数{0,1,2,3}中选择，因此重传推迟时间是在0,2$\tau$,4$\tau$,6$\tau$这4个时间中随机地选取一个。以此类推。</p>
<p>使用二进制指数退避算法可使重传需要推迟的平均时间随重传次数的增大而增大(这也称 $\color{green}{\text{动态退避}}$ )，因而能降低发生碰撞的概率，有利于整个系统的稳定。</p>
<h5 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h5><p>CSMA/CD 协议已成功应用于使用有线连接的局域网，但在无线局域网环境下，却不能简单地搬用CSMA/CD协议，特别是碰撞检测部分。主要有两个原因:</p>
<p>1）接收信号的强度往往会远小于发送信号的强度，且在无线介质上信号强度的动态变化范围很大，因此若要实现碰撞检测，则硬件上的花费就会过大。</p>
<p>2）在无线通信中，并非所有的站点都能够听见对方，即存在“ $\color{green}{\text{隐蔽站}}$ ”问题。</p>
<p>为此，802.11标准定义了广泛应用于无线局域网的CSMA/CA协议，它对CSMA/CD协议进行了修改，把碰撞检测改为碰撞避免（Collision Avoidance，CA)。“碰撞避免”并不是指协议可以完全避免碰撞，而是指协议的设计要尽量降低碰撞发生的概率。由于802.11无线局域网不使用碰撞检测，一旦站点开始发送一个帧，就会完全地发送该帧，但碰撞存在时仍然发送整个数据帧(尤其是长数据帧）会严重降低网络的效率，因此要采用碰撞避免技术降低碰撞的可能性。</p>
<p>由于无线信道的通信质量远不如有线信道，802.11使用链路层 $\color{green}{\text{确认}}$ / $\color{green}{\text{重传}}$ （ARQ）方案，即站点每通过无线局域网发送完一帧，就要在收到对方的确认帧后才能继续发送下一帧。</p>
<p>为了尽量避免碰撞，802.11规定，所有的站完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧。这段时间称为 $\color{green}{\text{帧间间隔}}$ （InterFrame Space，IFS)。帧间间隔的长短取决于该站要发送的帧的类型。802.11使用了3种IFS:</p>
<p>1)SIFS(短 IFS):最短的IFS，用来分隔属于一次对话的各帧，使用SIFS的帧类型有ACK帧、CTS帧、分片后的数据帧，以及所有回答AP探询的帧等。</p>
<p>2）PIFS （点协调IFS):中等长度的IFS，在PCF操作中使用。</p>
<p>3）DIFS(分布式协调IFS):最长的IFS，用于异步帧竞争访问的时延。</p>
<p>CSMA/CA 的退避算法和CSMA/CD的稍有不同(见教材)。信道从忙态变为空闲态时，任何一个站要发送数据帧，不仅都要等待一个时间间隔，而且要进入争用窗口，计算随机退避时间以便再次试图接入信道，因此降低了碰撞发生的概率。当且仅当检测到信道空闲且这个数据帧是要发送的第一个数据帧时，才不使用退避算法。其他所有情况都必须使用退避算法，具体为:①在发送第一个帧前检测到信道忙;②每次重传;③每次成功发送后要发送下一帧。</p>
<p>CSMA/CA算法归纳如下:</p>
<p>1）若站点最初有数据要发送（而不是发送不成功再进行重传)，且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</p>
<p>2）否则，站点执行CSMA/CA退避算法，选取一个随机回退值。一旦检测到信道忙， $\color{green}{\text{退避计时器}}$ 就保持不变。只要信道空闲，退避计时器就进行倒计时。</p>
<p>3）当退避计时器减到0时（这时信道只可能是空闲的)，站点就发送整个帧并等待确认。</p>
<p>4)发送站若收到确认，就知道已发送的帧被目的站正确接收。这时如果要发送第二帧，就要从步骤2）开始。</p>
<p>若发送站在规定时间内没有收到确认帧ACK（由重传计时器控制)，就必须重传该帧，再次使用CSMA/CA协议争用该信道，直到收到确认，或经过若干次重传失败后放弃发送。</p>
<p>处理隐蔽站问题: $\color{green}{\text{RTS}}$（request to send,rts） 和 $\color{green}{\text{CTS}}$ （clear to send,cts）</p>
<p>在图3.23中，站A和B都在AP的覆盖范围内，但A和B相距较远，彼此都听不见对方。当A和B检测到信道空闲时，都向AP发送数据，导致碰撞的发生，这就是隐蔽站问题。</p>
<p>为了避免该问题，802.11允许发送站对信道进行预约，源站要发送数据帧之前先广播一个所持续的短请求发送 RTS 控制帧，它包括源地址、目的地址和这次通信（含相应的确认帧)时间，该帧能被其范围内包括AP在内的所有站点听到。若信道空闲，则 AP广播一个允许发送CTS 控制帧，它包括这次通信所需的持续时间（从RTS帧复制)，该帧也能被其范围内包括A和B在内的所有站点听到。B和其他站听到CTS后，在CTS帧中指明的时间内将抑制发送，如图3.24所示。CTS帧有两个目的:①给源站明确的发送许可;②指示其他站点在预约期内不要发送。</p>
<p>这种机制实质上是在发送数据帧之前先对信道进行预约。使用RTS和 CTS帧会使网络效率有所下降，但这两种帧都很短，与数据帧相比开销不算大。相反，若不使用这种控制帧，一旦发生碰撞而导致数据帧重发，则浪费的时间更多。因此，协议设有三种情况供用户选择:第一种是使用RTS和 CTS帧;第二种是只有当数据帧的长度超过某一阈值时才使用RTS和CTS帧（显然数据帧本身很短，再使用RTS和CTS帧只能增加开销);第三种是不使用RTS和CTS 帧。</p>
<details><summary>图3.23 A和B同时向AP发送信号，发生碰撞  图3.24 使用RTS和CTS帧的碰撞避免</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004101854.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004101854.png';" /></details>

<p>CSMA/CD与CSMA/CA主要有如下区别:</p>
<p>1）CSMA/CD可以检测冲突，但无法避免;CSMA/CA发送数据的同时不能检测信道上有无冲突，本结点处没有冲突并不意味着在接收结点处就没有冲突，只能尽量避免。</p>
<p>2） $\color{green}{\text{传输介质}}$ 不同。CSMA/CD 用于总线形以太网，CSMA/CA用于无线局域网802.11a/b/g/n等。</p>
<p>3） $\color{green}{\text{检测方式}}$ 不同。CSMA/CD通过电缆中的电压变化来检测;而CSMA/CA采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式。</p>
<p>总结:CSMA/CA 协议的基本思想是在发送数据时先广播告知其他结点，让其他结点在某段时间内不要发送数据，以免出现碰撞。CSMA/CD协议的基本思想是发送前侦听，边发送边侦听，一旦出现碰撞马上停止发送。</p>
<h4 id="轮询访问介质访问控制：令牌传递协议"><a href="#轮询访问介质访问控制：令牌传递协议" class="headerlink" title="*轮询访问介质访问控制：令牌传递协议"></a>*轮询访问介质访问控制：令牌传递协议</h4><p>在轮询访问中，用户不能随机地发送信息，而要通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配。当某结点使用信道时，其他结点都不能使用信道。典型的轮询访问介质访问控制协议是令牌传递协议，它主要用在令牌环局域网中。</p>
<p>在令牌传递协议中，一个令牌在各结点间以某个固定次序交换。令牌是由一组特殊的比特组合而成的帧。当环上的一个站希望传送帧时，必须等待令牌。一旦收到令牌，站点便可启动发送帧。帧中包括目的站的地址，以标识哪个站应接收此帧。帧在环上传送时，不管该帧是否是发给本站点的，所有站点都进行转发，直到该帧回到它的始发站，并由该始发站撤销该帧。帧的目的站除转发帧外，应针对该帧维持一个副本，并通过在帧的尾部设置“响应比特”来指示已收到此副本。站点在发送完一帧后，应释放令牌，以便让其他站使用。</p>
<p>当计算机都不需要发送数据时，令牌就在环形网上游荡，而需要发送数据的计算机只有在拿到该令牌后才能发送数据帧，因此不会发送冲突（因为令牌只有一个)。</p>
<p>在令牌传递网络中，传输介质的物理拓扑不必是一个环，但是为了把对介质访问的许可从一个设备传递到另一个设备，令牌在设备间的传递通路逻辑上必须是一个环。</p>
<p>轮询介质访问控制非常适合负载很高的广播信道。所谓负载很高的信道，是指多个结点在同一时刻发送数据概率很大的信道。可以想象，如果这样的广播信道采用随机介质访问控制，那么发生冲突的概率将会很大，而采用轮询介质访问控制则可以很好地满足各结点间的通信需求。</p>
<p>轮询介质访问控制既不共享时间,也不共享空间，它实际上是在随机介质访问控制的基础上，限定了有权力发送数据的结点只能有一个。</p>
<p>即使是广播信道也可通过介质访问控制机制使广播信道逻辑上变为点对点的信道，所以说数据链路层研究的是“点到点”之间的通信。</p>
<h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><h4 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h4><p>局域网（Local Area Network，LAN）是指在一个较小的地理范围(如一所学校)内，将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络。主要特点如下:</p>
<p>1)为一个单位所拥有，且地理范围和站点数目均有限。</p>
<p>2）所有站点共享较高的总带宽（即较高的数据传输速率)。</p>
<p>3)较低的时延和较低的误码率。</p>
<p>4)各站为平等关系而非主从关系。</p>
<p>5）能进行广播和组播。</p>
<p>局域网的特性主要由 $\color{red}{\text{三个要素}}$ 决定: $\color{green}{\text{拓扑结构}}$ 、 $\color{green}{\text{传输介质}}$ 、 $\color{green}{\text{介质访问控制方式}}$ ,其中最重要的是介质访问控制方式，它决定着局域网的技术特性。</p>
<p>常见的局域网拓扑结构主要有以下 $\color{red}{\text{4大类}}$ : $\color{green}{\text{①星形结构}}$ ; $\color{green}{\text{②环形结构}}$ ; $\color{green}{\text{③总线形结构}}$ ; $\color{green}{\text{④星形和总线形结合的复合型结构}}$ 。</p>
<p>局域网可以使用 $\color{green}{\text{双绞线}}$ 、 $\color{green}{\text{铜缆}}$ 和 $\color{green}{\text{光纤}}$ 等多种 $\color{red}{\text{传输介质}}$ ，其中双绞线为主流传输介质。</p>
<p>局域网的 $\color{red}{\text{介质访问控制方法}}$ 主要有 $\color{green}{\text{CSMA/CD}}$ 、 $\color{green}{\text{令牌总线}}$ 和 $\color{green}{\text{令牌环}}$ ，其中前两种方法主要用于总线形局域网，令牌环主要用于环形局域网。</p>
<p>三种特殊的局域网拓扑实现如下:</p>
<ul>
<li>$\color{green}{\text{以太网}}$ (目前使用范围最广的局域网)。 $\color{red}{\text{逻辑拓扑}}$ 是 $\color{green}{\text{总线形}}$ 结构， $\color{red}{\text{物理拓扑}}$ 是 $\color{green}{\text{星形}}$ 或拓展星形结构。</li>
<li>$\color{green}{\text{令牌环}}$ （Token Ring，IEEE 802.5)。逻辑拓扑是环形结构，物理拓扑是 $\color{green}{\text{星形结构}}$ 。</li>
<li>$\color{green}{\text{FDDI}}$ (光纤分布数字接口，IEEE 802.8)。逻辑拓扑是环形结构，物理拓扑是 $\color{green}{\text{双环结构}}$ 。</li>
</ul>
<p>IEEE 802标准定义的局域网参考模型只对应于OSI参考模型的 $\color{green}{\text{数据链路层}}$ 和 $\color{green}{\text{物理层}}$ ,并将数据链路层拆分为两个子层: $\color{green}{\text{逻辑链路控制}}$ （LLC)子层和 $\color{green}{\text{媒体接入控制}}$ (MAC)子层。与接入传输媒体有关的内容都放在MAC子层，它向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口，主要功能包括: $\color{green}{\text{组帧}}$ 和 $\color{green}{\text{拆卸帧}}$ 、比特传输 $\color{green}{\text{差错检测}}$ 、 $\color{green}{\text{透明传输}}$ 。LLC子层与传输媒体无关，它向网络层提供无确认无连接、面向连接、带确认无连接、高速传送4种不同的连接服务类型。</p>
<p>由于以太网在局域网市场中取得垄断地位，几乎成为局域网的代名词，而802委员会制定的LLC子层作用已经不大，因此现在许多网卡仅装有MAC协议而没有LLC协议。IEEE 802协议层与OSI参考模型的比较如图3.25所示。</p>
<p>需要提醒读者的是，局域网的各类协议和广域网的各类协议也是统考的重点，容易出选择题，需要大家认真记忆。</p>
<details><summary>图3.25 IEEE 802协议层与OSI模型的比较</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004102806.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004102806.png';" /></details>

<h4 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h4><p>IEEE 802.3标准是一种基带总线形的局域网标准，它描述物理层和数据链路层的MAC子层的实现方法。随着技术的发展，该标准又有了大量的补充与更新，以支持更多的传输介质和更高的传输速率。</p>
<p>以太网逻辑上采用总线形拓扑结构，以太网中的所有计算机共享同一条总线，信息以广播方式发送。为了保证数据通信的方便性和可靠性，以太网简化了通信流程并使用了CSMA/CD方式对总线进行访问控制。</p>
<p>严格来说，以太网应当是指符合DIX Ethernet V2标准的局域网，但 DIX Ethernet V2标准与IEEE 802.3标准只有很小的差别，因此通常将802.3局域网简称为 $\color{green}{\text{以太网}}$ 。</p>
<p>以太网采用两项措施以简化通信:①采用无连接的工作方式，不对发送的数据帧编号，也不要求接收方发送确认，即以太网尽最大努力交付数据，提供的是不可靠服务，对于差错的纠正则由高层完成;②发送的数据都使用曼彻斯特编码的信号，每个码元的中间出现一次电压转换，接收端利用这种电压转换方便地把位同步信号提取出来。</p>
<h5 id="以太网的传输介质与网卡"><a href="#以太网的传输介质与网卡" class="headerlink" title="以太网的传输介质与网卡"></a>以太网的传输介质与网卡</h5><p>以太网常用的传输介质有4种:粗缆、细缆、双绞线和光纤。各种传输介质的适用情况见表3.2。</p>
<details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004103035.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004103035.png';" /></details>

<blockquote>
<p>注意:10BASE-T非屏蔽双绞线以太网拓扑结构为星形网，星形网中心为集线器，但使用集线器的以太网在逻辑上仍然是一个总线网，属于一个冲突域。上表的内容是常识，例如题目中出现10BASE5时，是不会显式地告诉你它的传输媒体、编码方式、拓扑结构等信息的。</p>
</blockquote>
<p>计算机与外界局域网的连接是通过主机箱内插入的一块网络接口板「又称 $\color{green}{\text{网络适配器(Adapter)}}$ 或 $\color{green}{\text{网络接口卡(Network Interface Card，NIC)}}$ 」实现的。网卡上装有处理器和存储器，是工作在数据链路层的网络组件。网卡和局域网的通信是通过电缆或双绞线以串行方式进行的，而网卡和计算机的通信则是通过计算机主板上的IO总线以并行方式进行的。因此，网卡的重要功能就是进行数据的串并转换。网卡不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能等。</p>
<p>全世界的每块网卡在出厂时都有一个唯一的代码，称为介质访问控制(MAC)地址，这个地址用于控制主机在网络上的数据通信。数据链路层设备(网桥、交换机等）都使用各个网卡的MAC地址。另外，网卡控制着主机对介质的访问，因此网卡也工作在物理层，因为它只关注比特，而不关注任何地址信息和高层协议信息。</p>
<h5 id="以太网的MAC帧"><a href="#以太网的MAC帧" class="headerlink" title="以太网的MAC帧"></a>以太网的MAC帧</h5><p>每块网卡中的MAC地址也称物理地址;MAC地址长6字节，一般用由连字符(或冒号)分隔的12个十六进制数表示，如 02-60-8c-e4-b1-21。高24位为厂商代码，低24位为厂商自行分配的网卡序列号。严格来讲，局域网的“地址”应是每个站的“名字”或标识符。</p>
<p>由于总线上使用的是广播通信，因此网卡从网络上每收到一个MAC帧，首先要用硬件检查MAC帧中的 MAC地址。如果是发往本站的帧，那么就收下，否则丢弃。</p>
<p>以太网MAC帧格式有两种标准:DIX Ethernet V2标准（即以太网V2标准）和IEEE 802.3标准。这里先介绍最常用的以太网V2的 MAC帧格式，如图3.26所示。</p>
<p>$\color{green}{\text{前导码}}$ :使接收端与发送端时钟同步。在帧前面插入的8字节可再分为两个字段:第一个字段共7字节，是前同步码，用来快速实现MAC帧的比特同步;第二个字段是帧开始定界符，表示后面的信息就是MAC帧。</p>
<details><summary>图3.26以太网V2标准的MAC帧格式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004103430.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004103430.png';" /></details>

<blockquote>
<p>注意:MAC 帧并不需要帧结束符，因为以太网在传送帧时，各帧之间必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面连续到达的比特流就都属于同一个MAC 帧,所以图3.26只有帧开始定界符。但不要误以为以太网MAC帧不需要尾部，在数据链路层上，帧既要加首部，也要加尾部。</p>
</blockquote>
<p>$\color{green}{\text{地址}}$ :通常使用6字节(48bit）地址(MAC地址)。</p>
<p>$\color{green}{\text{类型}}$ :2字节，指出数据域中携带的数据应交给哪个协议实体处理。</p>
<p>$\color{green}{\text{数据}}$ :46～1500字节，包含高层的协议消息。由于CSMA/CD算法的限制，以太网帧必须满足最小长度要求64字节，数据较少时必须加以填充（0～46字节)。</p>
<blockquote>
<p>注意:46和1500是怎么来的?首先，由CSMA/CD算法可知以太网帧的最短帧长为64B，而MAC帧的首部和尾部的长度为18字节，所以数据字段最短为64-18=46字节。其次，最大的1500字节是规定的，没有为什么。</p>
</blockquote>
<p>$\color{green}{\text{填充}}$ :0～46字节，当帧长太短时填充帧，使之达到64字节的最小长度。</p>
<p>$\color{green}{\text{校验码（FCS）}}$ :4字节，校验范围从目的地址段到数据段的末尾，算法采用32位循环冗余码(CRC)，不但需要检验MAC帧的数据部分，还要检验目的地址、源地址和类型字段，但不校验前导码。</p>
<p>802.3帧格式与DIX以太帧格式的不同之处在于用长度域替代了DIX帧中的类型域，指出数据域的长度。在实践中，前述长度/类型两种机制可以并存，由于IEEE 802.3数据段的最大字节数是1500，所以长度段的最大值是1500，因此从1501到65535的值可用于类型段标识符。</p>
<h5 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h5><p>速率达到或超过100Mb/s的以太网称为高速以太网。</p>
<h6 id="color-green-text-100BASE-T以太网"><a href="#color-green-text-100BASE-T以太网" class="headerlink" title="$\color{green}{\text{100BASE-T以太网}}$"></a>$\color{green}{\text{100BASE-T以太网}}$</h6><p>100BASE-T以太网是在双绞线上传送100Mb/s基带信号的星形拓扑结构以太网，它使用CSMA/CD 协议。这种以太网既支持全双工方式，又支持半双工方式，可在全双工方式下工作而无冲突发生。因此，在全双工方式下不使用CSMA/CD协议。</p>
<p>MAC帧格式仍然是802.3标准规定的。保持最短帧长不变，但将一个网段的最大电缆长度减小到100m。帧间时间间隔从原来的9.6us改为现在的0.96us。</p>
<h6 id="color-green-text-吉比特以太网"><a href="#color-green-text-吉比特以太网" class="headerlink" title="$\color{green}{\text{吉比特以太网}}$"></a>$\color{green}{\text{吉比特以太网}}$</h6><p>吉比特以太网又称千兆以太网，允许在1Gb/s下用全双工和半双工两种方式工作。使用802.3协议规定的帧格式。在半双工方式下使用CSMA/CD协议（全双工方式不需要使用CSMA/CD协议)。与10BASE-T和100BASE-T技术向后兼容。</p>
<h6 id="10吉比特以太网"><a href="#10吉比特以太网" class="headerlink" title="10吉比特以太网"></a>10吉比特以太网</h6><p>10吉比特以太网与10Mb/s、100Mb/s和 1Gb/s以太网的帧格式完全相同。10吉比特以太网还保留了802.3标准规定的以太网最小和最大帧长，便于升级。10吉比特以太网不再使用铜线而只使用光纤作为传输媒体。10吉比特以太网只工作在 $\color{green}{\text{全双工}}$ 方式，因此没有争用问题，也不使用CSMA/CD 协议。</p>
<p>以太网从10Mb/s到10Gb/s的演进证明了以太网是可扩展的(从10Mb/s到10Gb/s)、灵活的(多种传输媒体、全/半双工、共享/交换)，易于安装，稳健性好。</p>
<h4 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h4><p>无线局域网可分为两大类:有固定基础设施无线局域网和无固定基础设施移动自组织网络。所谓“固定基础设施”，是指预先建立的、能覆盖一定地理范围的固定基站。</p>
<h5 id="有固定基础设施无线局域网"><a href="#有固定基础设施无线局域网" class="headerlink" title="有固定基础设施无线局域网"></a>有固定基础设施无线局域网</h5><p>对于有固定基础设施的无线局域网，IEEE制定了无线局域网的802.11系列协议标准，包括802.11a/b/g/n等。802.11使用星形拓扑，其中心称为 $\color{green}{\text{接入点}}$ (Access Point，AP)，在MAC层使用CSMA/CA协议。使用802.11系列协议的局域网又称Wi-Fi。</p>
<p>802.11标准规定无线局域网的最小构件是 $\color{green}{\text{基本服务集BSS}}$  (Basic Service Set，BSS)。一个基本服务集包括一个基站和若干移动站。所有的站在本 BSS内都可以直接通信，但在和本 BSS 外的站通信时都必须通过本BSS的基站。上面提到的AP就是基本服务集中的基站(base station)。安装AP时，必须为该AP分配一个不超过32字节的 $\color{green}{\text{服务集标识符}}$ (Service Set IDentifier，SSID)和一个信道。一个基本服务集覆盖的地理范围称为一个 $\color{green}{\text{基本服务区}}$ （Basic Service Area，BSA),无线局域网的基本服务区的直径一般不超过100m。</p>
<p>一个基本服务集可以是孤立的，也可通过AP连接到一个 $\color{green}{\text{分配系统}}$ （Distribution System，DS),然后连接到另一个基本服务集，构成一个 $\color{green}{\text{扩展的服务集}}$ (Extended Service Set，ESS)，ESS还可以通过一种称为Portal (门桥）的设备为无线用户提供到有线连接的以太网的接入。门桥的作用相当于一个网桥。在图3.27中，移动站A如果要和另一个基本服务集中的移动站B通信，就必须经过两个接入点 $AP_1$ 和  $AP_2$ ，即 A $\to$  $AP_1$   $\to$  $AP_2$  $\to$ B，注意 $AP_1$ 到 $AP_2$ 的通信是使用有线传输的。</p>
<details><summary>图3.27基本服务集和扩展服务集</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004105112.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105112.png';" /></details>

<p>移动站A从某个基本服务集漫游到另一个基本服务集时(图3.27中的A’)，仍然可保持与另一个移动站B的通信。但A在不同的基本服务集使用的AP改变了。</p>
<h5 id="无固定基础设施移动自组织网络"><a href="#无固定基础设施移动自组织网络" class="headerlink" title="无固定基础设施移动自组织网络"></a>无固定基础设施移动自组织网络</h5><p>另一种无线局域网是无固定基础设施的无线局域网，又称自组网络(ad hoc network )。自组网络没有上述基本服务集中的 AP，而是由一些平等状态的移动站相互通信组成的临时网络（见图3.28)。各结点之间地位平等，中间结点都为转发结点，因此都具有路由器的功能。</p>
<p>自组网络通常是这样构成的:一些可移动设备发现在它们附近还有其他的可移动设备，并且要求和其他移动设备进行通信。自组网络中的每个移动站都要参与网络中其他移动站的路由的发现和维护，同时由移动站构成的网络拓扑可能随时间变化得很快，因此在固定网络中行之有效的一些路由选择协议对移动自组网络已不适用，需引起特别的关注。</p>
<details><summary>图3.28 由一些处于平等状态的便携机构成的自组网络</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004105232.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105232.png';" /></details>

<p>自组网络和移动IP并不相同。移动IP技术使漫游的主机可以用多种方法连接到因特网，其核心网络功能仍然是基于固定网络中一直使用的各种路由选择协议。而自组网络是把移动性扩展到无线领域中的自治系统，具有自己特定的路由选择协议，并且可以不和因特网相连。</p>
<h4 id="令牌环网的基本原理"><a href="#令牌环网的基本原理" class="headerlink" title="令牌环网的基本原理"></a>令牌环网的基本原理</h4><p>令牌环网的基本原理如图3.29所示。令牌环网的每一站通过电缆与环接口干线耦合器(TCU)相连。TCU的主要作用是，传递所有经过的帧，为接入站发送和接收数据提供接口。与此对应，TCU的状态也有两个:收听状态和发送状态。数据总是在某个特定的方向上从一个TCU到下一个TCU逐比特地依次传送，每个TCU重新产生并重新传输每一比特。</p>
<details><summary>图3.29令牌环网的基本原理</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004105346.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105346.png';" /></details>

<p>令牌环网的媒体接入控制机制采用的是分布式控制模式的循环方法。在令牌环网中有一个令牌(Token）沿着环形总线在入网结点计算机间依次传递，令牌实际上是一个特殊格式的MAC控制帧，它本身并不包含信息，仅控制信道的使用，确保在同一时刻只有一个结点能够独占信道。站点只有取得令牌后才能发送数据帧，因此令牌环网不会发生碰撞。由于令牌在网环上是按顺序依次传递的，因此对所有入网计算机而言，访问权是公平的。</p>
<p>令牌环网中令牌和数据的传递过程如下:</p>
<p>1）网络空闲时，环路中只有令牌帧在循环传递。</p>
<p>2）令牌传递到有数据要发送的站点处时，该站点就修改令牌中的一个标志位，并在令牌中附加自己需要传输的数据，将令牌变成一个数据帧，然后将这个数据帧发送出去。</p>
<p>3）数据帧沿着环路传输，接收到的站点一边转发数据，一边查看帧的目的地址。如果目的地址和自己的地址相同，那么接收站就复制该数据帧以便进一步处理。</p>
<p>4）数据帧沿着环路传输，直到到达该帧的源站点，源站点接收到自己发出去的数据帧后便不再进行转发。同时，发送方可以通过检验返回的数据帧来查看数据传输过程中是否有错，若有错则重传该帧。</p>
<p>5）源站点传送完数据后，重新产生一个令牌，并将令牌传递给下一个站点，以交出对媒体<br>的访问权限。</p>
<p>令牌环网在物理上采用星形拓扑结构，但逻辑上仍是环形拓扑结构，其标准由IEEE 802.5定义。图3.29中的环并不是由通信线路连接而成的物理环。</p>
<h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><h4 id="广域网的基本概念"><a href="#广域网的基本概念" class="headerlink" title="广域网的基本概念"></a>广域网的基本概念</h4><p>广域网通常是指覆盖范围很广（远超一个城市的范围）的长距离网络。广域网是因特网的核心部分，其任务是长距离运送主机所发送的数据。连接广域网各结点交换机的链路都是高速链路，它可以长达几千千米的光缆线路，也可以是长达几万千米的点对点卫星链路。因此广域网首要考虑的问题是通信容量必须足够大，以便支持日益增长的通信量。</p>
<p>广域网不等于互联网，互联网可以连接不同类型的网络（既可以连接 $\color{green}{\text{局域网}}$ ，又可以连接 $\color{green}{\text{广域网}}$ )，通常使用 $\color{green}{\text{路由器}}$ 来连接。图3.30显示了由相距较远的局域网通过路由器与厂域网相连而成的一个覆盖范围很广的互联网。因此，局域网可以通过广域网与另一个相隔很远的局域网通信。</p>
<details><summary>图3.30由局域网和广域网组成的互联网</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004105547.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105547.png';" /></details>

<p>从层次上考虑，广域网和局域网的区别很大，因为局域网使用的协议主要在数据链路层（还有少量在物理层)，而广域网使用的协议主要在网络层。怎么理解“局域网使用的协议主要在数据链路层，而广域网使用的协议主要在网络层”这句话呢？如果网络中的两个结点要进行数据交换，那么结点除要给出数据外，还要给数据“包装”上一层控制信息，用于实现检错纠错等功能。如果这层控制信息是数据链路层协议的控制信息，那么就称使用了数据链路层协议，如果这层控制信息是网络层的控制信息，那么就称使用了网络层协议。</p>
<p>它们的区别与联系见表3.3。</p>
<details><summary>表3.3广域网和局域网的区别与联系</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004105653.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105653.png';" /></details>

<p>广域网中的一个重要问题是路由选择和分组转发。路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组是通过转发表进行转发的。</p>
<p>PPP协议和HDLC 协议是目前最常用的两种广域网数据链路层控制协议。</p>
<h4 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h4><p>PPP (Point-to-Point Protocol)是使用串行线路通信的面向字节的协议，该协议应用在直接连接两个结点的链路上。设计的目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共同的解决方案。</p>
<p>PPP协议是在 $\color{green}{\text{SLIP}}$  协议的基础上发展而来的，它既可以在异步线路上传输，又可在同步线路上使用;不仅用于Modem链路，也用于租用的路由器到路由器的线路。</p>
<p>背景:SLIP主要完成数据报的传送，但没有寻址、数据检验、分组类型识别和数据压缩等功能，只能传送IP分组。如果上层不是IP协议，那么无法传输，并且此协议对一些高层应用也不支持，但实现比较简单。为了改进SLIP 的缺点，于是制定了点对点协议（PPP)。</p>
<p>PPP协议有三个组成部分:</p>
<p>1） $\color{green}{\text{链路控制协议}}$ (LCP)。一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。</p>
<p>2） $\color{green}{\text{网络控制协议}}$ (NCP)。PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</p>
<p>3）一个将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元（MTU）的限制。</p>
<p>PPP帧的格式如图3.31所示。PPP帧的前3个字段和最后2个字段与HDLC帧是一样的， $\color{green}{\text{标志字段}}$ (F)仍为7E(01111110)，前后各占1字节，若它出现在信息字段中，就必须做 $\color{green}{\text{字节填充}}$ ，使用的控制转义字节是7D（01111101)。但在PPP中， $\color{green}{\text{地址字段(A)}}$ 占1字节，规定为0xFF， $\color{green}{\text{控制字段(C)}}$ 占1字节，规定为0x03，两者的内容始终是固定不变的。PPP是面向字节的，因而所有PPP帧的长度都是整数个字节。</p>
<details><summary>图3.31 PPP帧的格式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004105913.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004105913.png';" /></details>

<p>第4个字段是 $\color{green}{\text{协议段}}$ ，占2字节，在HDLC中没有该字段，它是说明信息段中运载的是什么种类的分组。以比特0开始的是诸如IP、IPX和AppleTalk 这样的网络层协议;以比特1开始的被用来协商其他协议，包括LCP及每个支持的网络层协议的一个不同的NCP。</p>
<p>第5段 $\color{green}{\text{信息段}}$ 的长度是可变的，大于等于0且小于等于1500B。为了实现透明传输，当信息段中出现和标志字段一样的比特组合时，必须采用一些措施来改进。</p>
<blockquote>
<p>注意:因为PPP是点对点的，并不是总线形，所以无须采用CSMA/CD协议，自然就没有最短帧，所以信息段占0~1500字节，而不是46~1500字节。另外，当数据部分出现和标志位一样的比特组合时,就需要采用一些措施来实现透明传输。</p>
</blockquote>
<p>第6个字段是 $\color{green}{\text{帧检验序列}}$ (FCS,Frame Check Sequence)，占2字节，即循环冗余码检验中的冗余码。检验区包括地址字段、控制字段、协议字段和信息字段。</p>
<p>图3.32给出了PPP链路建立、使用、撤销所经历的状态图。当线路处于静止状态时，不存在物理层连接。当线路检测到载波信号时，建立物理连接，线路变为建立状态。此时，LCP开始选项商定，商定成功后就进入身份验证状态。双发身份验证通过后，进入网络状态。这时，采用NCP配置网络层，配置成功后，进入打开状态，然后就可进行数据传输。当数据传输完成后，线路转为终止状态。载波停止后则回到静止状态。</p>
<details><summary>图3.32 PPP协议的状态图</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004110109.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004110109.png';" /></details>

<p>注意:</p>
<p>1) PPP提供差错检测但不提供纠错功能，只保证无差错接收（通过硬件进行CRC校验)它是不可靠的传输协议，因此也不使用序号和确认机制。</p>
<p>2）它仅支持 $\color{green}{\text{点对点}}$ 的链路通信，不支持多点线路。</p>
<p>3 ) PPP只支持 $\color{green}{\text{全双工}}$ 链路。</p>
<p>4）PPP的两端可以运行不同的网络层协议，但仍然可使用同一个PPP进行通信。</p>
<p>5）PPP是面向字节的，当信息字段出现和标志字段一致的比特组合时，PPP有两种不同的处理方法:若PPP用在异步线路（默认)，则采用 $\color{green}{\text{字节填充法}}$ ;若 PPP用在SONET/SDH等同步线路，则协议规定采用硬件来完成 $\color{green}{\text{比特填充}}$ （和HDLC的做法一样)。</p>
<h4 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="*HDLC协议"></a>*HDLC协议</h4><p>高级数据链路控制（High-level Data Link Control，HDLC）协议是ISO制定的面向比特（记住PPP协议是面向字节的）的数据链路层协议。该以以个依簇了HT个T丁通信。有较高的数据可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现;全双工通信，有较高的数据链路传输效率;所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重发，传输可靠性高;传输控制功能与处理功能分离，具有较大的灵活性。</p>
<p>HDLC适用于链路的两种基本配置:非平衡配置和平衡配置。</p>
<p>1）非平衡配置的特点是由一个主站控制整个链路的工作。</p>
<p>2）平衡配置的特点是链路两端的两个站都是复合站，每个复合站都可以平等地发起数据传输，而不需要得到对方复合站的允许。</p>
<h5 id="站"><a href="#站" class="headerlink" title="站"></a>站</h5><p>HDLC有3种站类型:主站、从站和复合站。主站负责控制链路的操作，主站发出的帧称为命令帧。从站受控于主站，按主站的命令进行操作;发出的帧称为响应帧。另外，有些站既具有主站的功能，又具有从站的功能，所以这类站称为复合站，它可以发出命令帧和响应帧。</p>
<h5 id="数据操作方式"><a href="#数据操作方式" class="headerlink" title="数据操作方式"></a>数据操作方式</h5><p>HDLC有3种数据操作方式:</p>
<p>1） $\color{green}{\text{正常响应方式}}$ 。这是一种非平衡结构操作方式，即主站向从站传输数据，从站响应传输但从站只有在收到主站的许可后，才可进行响应。</p>
<p>2） $\color{green}{\text{异步平衡方式}}$ 。这是一种平衡结构操作方式。在这种方式中，每个复合站都可以进行对另一站的数据传输。</p>
<p>3） $\color{green}{\text{异步响应方式}}$ 。这是一种非平衡结构操作方式。在这种方式中，从站即使未受到主站的允许，也可进行传输。</p>
<h5 id="HDLC帧"><a href="#HDLC帧" class="headerlink" title="HDLC帧"></a>HDLC帧</h5><p>图3.33所示为HDLC的帧格式，它由标志、地址、控制、信息和帧校验序列(FCS）等字段构成。</p>
<details><summary>图3.33 HDLC的帧格式</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004110413.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004110413.png';" /></details>

<p>标志字段F，为01111110。在接收端只要找到标志字段就可确定一个帧的位置。HDLC 协议采用比特填充的首尾标志法实现透明传输。在发送端，当一串比特流数据中有5个连续的1时，就立即在其后填入一个0。接收帧时，先找到F字段以确定帧的边界，接着对比特流进行扫描。每当发现5个连续的1时，就将其后的一个0删除，以还原成原来的比特流。</p>
<p>地址字段A，共8位，在使用非平衡方式传送数据时，站地址字段总是写入从站的地址;在使用平衡方式传送数据时，站地址字段填入的是应答站的地址。</p>
<p>控制字段C，共8位，是最复杂的字段。HDLC的许多重要功能都靠控制字段来实现。根据其第1位或第1、2位的取值，可将HDLC 帧划分为三类:</p>
<p>1）信息帧(I)，第1位为0，用来传输数据信息，或使用捎带技术对数据进行确认。</p>
<p>2）监督帧(S)，第1、2位分别为1、0，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能;</p>
<p>3）无编号帧(U)，第1、2位均为1，用于提供对链路的建立、拆除等多种控制功能。由图3.31和图3.33可知，PPP帧和 HDLC帧的格式很相似。但两者有以下几点不同:</p>
<p>由图3.31和图3.33可知，PPP帧和HDLC帧的格式很相似。但两者有以下几点不同:</p>
<p>1）PPP协议是面向字节的，HDLC协议是面向比特的。</p>
<p>2）PPP帧比HDLC帧多一个2字节的协议字段。当协议字段值为0x0021时，表示信息字段<br>是P数据报。</p>
<p>3）PPP协议不使用序号和确认机制，只保证无差错接收（通过硬件进行CRC检验)，而端<br>到端差错检测由高层协议负责。HDLC 协议的信息帧使用了编号和确认机制，能够提供可靠传输。</p>
<h3 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h3><h4 id="网桥的概念及其基本原理"><a href="#网桥的概念及其基本原理" class="headerlink" title="*网桥的概念及其基本原理"></a>*网桥的概念及其基本原理</h4><p>两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就称为一个网段。网桥工作在链路层的MAC子层，可以使以太网各网段成为隔离开的碰撞域。如果把网桥换成工作在物理层的转发器，那么就没有这种过滤通信量的功能。由于各网段相对独立，因此一个网段的故障不会影响到另一个网段的运行。</p>
<blockquote>
<p>注意:网桥处理数据的对象是帧，所以它是工作在数据链路层的设备，中继器、放大器处理数据的对象是信号,所以它是工作在物理层的设备。</p>
</blockquote>
<p>网络1和网络2通过网桥连接后，网桥接收网络1发送的数据帧，检查数据帧中的地址，如果是网络2的地址，那么就转发给网络2;如果是网络1的地址，那么就将其丢弃，因为源站和目的站处在同一个网段，目的站能够直接收到这个帧而不需要借助网桥转发。</p>
<p>如图3.34所示，设每个网段的数据率都是10Mb/s，那么三个网段合起来的最大吞吐量就变成了30Mb/s。如果把两个网桥换成集线器或转发器,那么整个网络仍然是一个碰撞域(即冲突域)，当A和B通信时，所有其他站点都不能通信，整个碰撞域的最大吞吐量仍然是10Mb/s。</p>
<p>网桥的基本特点:①网桥必须具备寻址和路径选择能力，以确定帧的传输方向;②从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧;③网桥在不同或相同类型的LAN之间存储并转发帧，必要时还进行链路层上的协议转换。注意，一股情况下，仔T投反尖仅奋排能进行协议转换，即连接的两个网段可以使用不同的协议;④网桥对接收到的帧个似仕何修以，或只对帧的封装格式做很少的修改;⑤网桥可以通过执行帧翻译互联不同类型的局域网，即把原协议的信息段的内容作为另一种协议的信息部分封装在帧中;⑥网桥应有足够大的缓冲空间，因为在短时间内帧的到达速率可能高于转发速率。</p>
<details><summary>图3.34网桥使各网段成为隔离开的碰撞域</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004111006.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004111006.png';" /></details>

<p>网桥的优点:①能过滤通信量;②扩大了物理范围;③可使用不同的物理层;④可互联不同类型的局域网;⑤提高了可靠性;⑥性能得到改善。</p>
<p>网桥的缺点:①增大了时延;②MAC子层没有流量控制功能（流量控制需要用到编号机制,编号机制的实现在LLC子层);③不同MAC子层的网段桥接在一起时，需要进行帧格式的转换;④网桥只适合于用户数不多和通信量不大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞，这就是所谓的广播风暴。</p>
<p>网桥必须具有路径选择的功能，接收到帧后，要决定正确的路径，将该帧转送到相应的目的局域网站点。根据路径选择算法的不同，可将网桥分为透明网桥和源路由网桥。</p>
<h5 id="透明网桥（选择的不是最佳路由"><a href="#透明网桥（选择的不是最佳路由" class="headerlink" title="透明网桥（选择的不是最佳路由)"></a>透明网桥（选择的不是最佳路由)</h5><p>透明网桥以混杂方式工作，它接收与之连接的所有LAN传送的每一帧。到达帧的路由选择过程取决于源LAN和目的LAN:①如果源LAN和目的LAN相同,那么丢弃该帧;②如果源LAN和目的LAN不同，那么转发该帧;③如果目的LAN未知，那么扩散该帧。</p>
<p>当网桥刚连接到以太网时，其转发表是空的，网桥按照自学习算法处理收到的帧。该算法的基本思想是:若从站A发出的帧从某端口进入网桥，那么从这个端口出发沿相反方向一定可把一个帧传送到站A。所以网桥每收到一个帧，就记下其源地址和进入网桥的端口，作为转发表中的一个项目（源地址、进入的接口和时间)。在建立转发表时，把帧首部中的源地址写在“地址”一栏的下面。在转发帧时，则根据收到的帧首部中的目的地址来转发。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入端口当作转发端口。网桥就是在这样的转发过程中逐渐将其转发表建立起来的。</p>
<p>为了避免转发的帧在网络中不断地“兜圈子”，透明网桥使用了一种生成树算法（无环)，以确保每个源到每个目的地只有唯一的路径。生成树使得整个扩展局域网在逻辑上形成树形结构，所以工作时逻辑上没有环路，但生成树一般不是最佳路由。</p>
<h5 id="源路由网桥（选择的是最佳路由"><a href="#源路由网桥（选择的是最佳路由" class="headerlink" title="源路由网桥（选择的是最佳路由)"></a>源路由网桥（选择的是最佳路由)</h5><p>在源路由网桥中，路由选择由发送数据帧的源站负责，网桥只根据数据真正的路由信息对帧进行接收和转发。</p>
<p>源路由网桥对主机是不透明的，主机必须知道网桥的亦佐o连按到哪个网权上。p出远开口发送帧的源站负责，那么源站如何知道应当选择什么样的路由呢?为了找到取住的路出，源项女广播方式向目的站发送一个发现帧（Discovery Frame）作为探测之用。源路出的T从过任Ni人未知路径前，源站要先发送一个发现帧;途中的每个网桥都转发此明，取资该尺境队中从少白途径到达目的站;目的站也将一一发送应答帧;每个应答帧将逋过原路在伛凹，迷红的内.2r1LH己的标志记录在应答帧中;源站选择出一个最佳路由。以后，凡从这个源站向该目的站发送的帧的首部，都必须携带这一路由信息。</p>
<p>此外，发送帧还可以帮助源站确定整个网络可以通过的帧的最大长度。由于发现帧的数量指数式增加，可能会使网络严重拥塞。</p>
<h5 id="两种网桥的比较"><a href="#两种网桥的比较" class="headerlink" title="两种网桥的比较"></a>两种网桥的比较</h5><p>使用源路由网桥可以利用最佳路由。若在两个以太网之间使用并联的源路由网桥，则还可使通信量较平均地分配给每个网桥。采用透明网桥时，只能使用生成树，而使用生成树一般并不能保证所用的路由是最佳的，也不能在不同的链路中进行负载均衡。</p>
<blockquote>
<p>注意:透明网桥和源路由网桥中提到的最佳路由并不是经过路由器最少的路由，而可以是发送帧往返时间最短的路由，这样才能真正地进行负载平衡，因为往返时间长说明中间某个路由器可能超载了，所以不走这条路，换个往返时间短的路走。</p>
</blockquote>
<h4 id="局域网交换机及其工作原理"><a href="#局域网交换机及其工作原理" class="headerlink" title="局域网交换机及其工作原理"></a>局域网交换机及其工作原理</h4><h5 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h5><p>桥接器的主要限制是在任一时刻通常只能执行一个帧的转发操作，于是出现了局域网交换机，又称以太网交换机。从本质上说，以太网交换机是一个多端口的网桥，它工作在数据链路层。交换机能经济地将网络分成小的冲突域，为每个工作站提供更高的带宽。</p>
<p>以太网交换机对工作站是透明的，因此管理开销低廉，简化了网络结点的增加、移动和网络变化的操作。利用以太网交换机还可以方便地实现虚拟局域网（Virtual LAN，VLAN)， $\color{red}{\text{VLAN}}$ 不仅可以隔离 $\color{green}{\text{冲突域}}$ ，而且可以隔离 $\color{green}{\text{广播域}}$ 。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>以太网交换机的原理是，它检测从以太端口来的数据帧的源和目的地的MAC(介质访问层)地址，然后与系统内部的动态查找表进行比较，若数据帧的MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>以太网交换机的特点如下:</p>
<p>1）以太网交换机的每个端口都直接与单台主机相连（普通网桥的端口往往连接到以太网的一个网段)，并且一般都工作在 $\color{green}{\text{全双工}}$ 方式。</p>
<p>2）以太网交换机能同时连通许多对端口，使每对相互通信的主机都能像独占通信媒体那样无碰撞地传输数据。</p>
<p>3）以太网交换机也是一种即插即用设备（和透明网桥一样)，其内部的帧的转发表也是通过自学习算法自动地逐渐建立起来的。</p>
<p>4）以太网交换机由于使用了专用的交换结构芯片，因此交换速率较高。</p>
<p>5)以太网交换机独占传输媒体的带宽。</p>
<p>对于传统10Mb/s的共享式以太网，若共有N个用户，则每个用户占有的平均带宽只有总带宽(10Mb/s）的1/N。在使用以太网交换机时，虽然在每个端口到主机的带宽还是10Mb/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此拥有N个端口的交换机的总容量为N×1OMb/s。这正是交换机的最大优点。</p>
<p>以太网交换机一般都具有多种速率的端口，例如可以具有10Mb/s、100Mb/s和 1Gb/s的端口的各种组合,因此大大方便了各种不同情况的用户。</p>
<h5 id="两种交换模式"><a href="#两种交换模式" class="headerlink" title="两种交换模式"></a>两种交换模式</h5><p>目前，以太网交换机主要采用两种交换模式，即直通式和存储转发式。</p>
<p>1） $\color{green}{\text{直通式交换机}}$ 只检查帧的目的地址，这使得帧在接收后几乎能马上被传出去。这种方式速度快，但缺乏智能性和安全性，也无法支持具有不同速率的端口的交换。</p>
<p>2） $\color{green}{\text{存储转发式交换机}}$ 先将接收到的帧缓存到高速缓存器中，并检查数据是否正确，确认无误后通过查找表转换成输出端口将该帧发送出去。如果发现帧有错，那么就将其丢弃。存储转发式的优点是可靠性高，并能支持不同速率端口间的转换，缺点是延迟较大。</p>
<h3 id="本章小结及疑难点"><a href="#本章小结及疑难点" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="“链路”和“数据链路”有何区别-“电路接通”-与“数据链路接通”有何区别"><a href="#“链路”和“数据链路”有何区别-“电路接通”-与“数据链路接通”有何区别" class="headerlink" title="“链路”和“数据链路”有何区别?“电路接通” 与“数据链路接通”有何区别?"></a>“链路”和“数据链路”有何区别?“电路接通” 与“数据链路接通”有何区别?</h4><p>所谓 $\color{green}{\text{链路}}$ （Link)，是指从一个结点到相邻结点的一段物理线路，其中间没有其他任何的交换结点。在进行数据通信时，两台计算机之间的通信路径往往要经过许多段这样的链路。可见,链路只是一条路径的组成部分。</p>
<p>$\color{green}{\text{数据链路}}$ （Data Link）则是另一个概念。因为在一条线路上传送数据时，除必须有一条物理线路外，还必须有一些通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。有时也把链路分为物理链路和逻辑链路。物理链路就是指上面所说的链路，逻辑链路就是上面的数据链路，即物理链路加上必要的通信协议。</p>
<p>“电路接通”表示链路两端的结点交换机已经开机，物理连接已经能够传送比特流，但数据传输并不可靠，在物理连接基础上，再建立数据链路连接，才能说“数据链路接通”。此后，由于数据链路连接具有检测、确认和重传功能，才使得不太可靠的物理链路变成可靠的数据链路，进行可靠的数据传输。当数据链路断开连接时，物理电路连接不一定跟着断开连接。</p>
<h4 id="在停止-等待协议中，确认帧为什么不需要序号（如用ACKO和-ACK1"><a href="#在停止-等待协议中，确认帧为什么不需要序号（如用ACKO和-ACK1" class="headerlink" title="在停止-等待协议中，确认帧为什么不需要序号（如用ACKO和 ACK1) ?"></a>在停止-等待协议中，确认帧为什么不需要序号（如用ACKO和 ACK1) ?</h4><p>在停止-等待协议中，发送方每发送一帧，都需要在收到接收方的确认帧后，才能进行下一帧的发送，而发送方收到的确认帧也一定是自己刚刚发出去的数据帧的确认帧，无须加序号标记。</p>
<h4 id="说明用-n-比特进行编号时，若接收窗口的大小为1，则只有在发送窗口的大小-W-T-leq-2-n-1-时，连续ARQ协议才能正确运行。"><a href="#说明用-n-比特进行编号时，若接收窗口的大小为1，则只有在发送窗口的大小-W-T-leq-2-n-1-时，连续ARQ协议才能正确运行。" class="headerlink" title="说明用 $n$ 比特进行编号时，若接收窗口的大小为1，则只有在发送窗口的大小 $W_T \leq 2^n-1$ 时，连续ARQ协议才能正确运行。"></a>说明用 $n$ 比特进行编号时，若接收窗口的大小为1，则只有在发送窗口的大小 $W_T \leq 2^n-1$ 时，连续ARQ协议才能正确运行。</h4><p>举一个具体的例子进行说明。例如用3比特可编出8个不同的序号，因而发送窗口的最大值似乎应为8。但实际上，设置发送窗口为8将使协议在某些情况下无法工作。现在我们就来说明这一点。</p>
<p>设发送窗口 $W_T$ = 8，发送端发送完0~7号共8个数据帧。因发送窗口已满，发送暂停。假定这8个数据帧均已正确到达接收端，并且对每个数据帧，接收端都发送出确认帧。下面考虑两种不同的情况。</p>
<p>第一种情况是:所有确认帧都正确到达了发送端，因而发送端接着又发送8个新的数据帧,其编号应是0～7。注意，序号是循环使用的。因此序号虽然相同，但8个帧都是新的帧。</p>
<p>第二种情况是:所有确认帧都丢失了。经过一段由超时计时器控制的时间后，发送端重传这8个旧的数据帧，其编号仍为0～7。</p>
<p>于是，当接收端第二次收到编号为0~7的8个数据帧时，就无法判定这是8个新的数据帧还是8个重传的旧数据帧。</p>
<p>因此，将发送窗口设置为8显然是不行的。</p>
<h4 id="证明-对于选择重传协议，若有-n-比特进行编号，则接收窗口的最大值为-W-R-leq-2-n-1-。"><a href="#证明-对于选择重传协议，若有-n-比特进行编号，则接收窗口的最大值为-W-R-leq-2-n-1-。" class="headerlink" title="证明:对于选择重传协议，若有 $n$ 比特进行编号，则接收窗口的最大值为 $W_R \leq 2^{n-1}$ 。"></a>证明:对于选择重传协议，若有 $n$ 比特进行编号，则接收窗口的最大值为 $W_R \leq 2^{n-1}$ 。</h4><p>设发送窗口大小为 $W_T$ 。因为 $W_T$ + $W_R \leq 2^n$， $W_T=W_R$ ，WR取最大值 $2^n/2$ = $2^{n-1}$ 。</p>
<p>注意，如果题目没有特别说明，那么一般情况下选择重传协议的发送窗口和接收窗口的大小是相等的。大家试想一下，SR协议中接收窗口值大于1，接收窗口要等到接收范围内所有帧收到才能更新，发送窗口要等接收窗口更新后才会更新，那么发送窗口比接收窗口多出来的那部分窗口就没有意义了。</p>
<ul>
<li>选择重传协议窗口大小的计算：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011617742/article/details/50387670">参考文献</a></li>
</ul>
<h4 id="数据链路层使用PPP协议或CSMA-CD协议时，既然不保证可靠传输，为什么要对所传输的帧进行差错检验"><a href="#数据链路层使用PPP协议或CSMA-CD协议时，既然不保证可靠传输，为什么要对所传输的帧进行差错检验" class="headerlink" title="数据链路层使用PPP协议或CSMA/CD协议时，既然不保证可靠传输，为什么要对所传输的帧进行差错检验?"></a>数据链路层使用PPP协议或CSMA/CD协议时，既然不保证可靠传输，为什么要对所传输的帧进行差错检验?</h4><p>当数据链路层使用PPP协议或CSMA/CD协议时，在数据链路层的接收端对所传输的帧进行差错检验是为了不将已发现有差错的帧（不管是什么原因造成的）接收下来。如果在接收端不进行差错检测，那么接收端上交给主机的帧就可能包括在传输中出』左销队的帐A什沿有传输差端主机是没有用处的。换言之，接收端进行差错检测的目的是:“上交主机的帧都是没有传输差错的，有差错的都已经丢弃了”，或者更加严格地说:“我们以很接近于1的概率认为，凡是上交主机的帧都是没有传输差错的”。</p>
<h4 id="为什么PPP协议不使用帧的编号和确认机制来实现可靠传输"><a href="#为什么PPP协议不使用帧的编号和确认机制来实现可靠传输" class="headerlink" title="为什么PPP协议不使用帧的编号和确认机制来实现可靠传输?"></a>为什么PPP协议不使用帧的编号和确认机制来实现可靠传输?</h4><p>PPP不使用序号和确认机制是出于以下考虑:</p>
<p>若使用能够实现可靠传输的数据链路层协议（如 HDLC)，开销就会增大。当数据链路层出现差错的概率不大时，使用比较简单的PPP较为合理。</p>
<p>在因特网环境下，PPP的信息字段放入的数据是IP数据报。假定我们采用了能实现可靠传输但十分复杂的数据链路层协议，当数据帧在路由器中从数据链路层上升到网络层后，仍有可能因网络拥塞而被丢弃。因此，数据链路层的可靠传输并不能保证网络层的传输也是可靠的。</p>
<p>PPP在帧格式中有帧校验序列FCS字段。对于每个收到的帧，PPP都要使用硬件进行CRC检验。若发现有差错，则丢弃该帧（一定不能把有差错的帧交给上一层)。端到端的差错控制最后由高层协议负责。因此，PPP可以保证无差错接收。</p>
<h4 id="两台计算机通过计算机网络传输一个文件时，有两种可行的确认策略。第一种是由发送端将文件分割成分组，接收端逐个确认分组-但就整体而言，文件并没有得到确认。第二种策略是接收端不确认单个分组，而是当文件全部收到后，对整个文件予以接收确认。试比较这两种方式的优缺点，以及它们各自适用的场合。"><a href="#两台计算机通过计算机网络传输一个文件时，有两种可行的确认策略。第一种是由发送端将文件分割成分组，接收端逐个确认分组-但就整体而言，文件并没有得到确认。第二种策略是接收端不确认单个分组，而是当文件全部收到后，对整个文件予以接收确认。试比较这两种方式的优缺点，以及它们各自适用的场合。" class="headerlink" title="两台计算机通过计算机网络传输一个文件时，有两种可行的确认策略。第一种是由发送端将文件分割成分组，接收端逐个确认分组;但就整体而言，文件并没有得到确认。第二种策略是接收端不确认单个分组，而是当文件全部收到后，对整个文件予以接收确认。试比较这两种方式的优缺点，以及它们各自适用的场合。"></a>两台计算机通过计算机网络传输一个文件时，有两种可行的确认策略。第一种是由发送端将文件分割成分组，接收端逐个确认分组;但就整体而言，文件并没有得到确认。第二种策略是接收端不确认单个分组，而是当文件全部收到后，对整个文件予以接收确认。试比较这两种方式的优缺点，以及它们各自适用的场合。</h4><p>在计算机网络中，数据的传输过程可能会引起数据的丢失、出错等，因此一个可靠的传输需要一定的差错控制机制，确认是实现差错控制的一个辅助手段。上面的两种确认策略都是可行的,但它们的性能取决于所应用的网络环境。</p>
<p>具体地说，当网络传输可靠性较低且分组容易丢失时，第一种策略即对每个分组逐一确认较好，此时仅需重传丢失或出错的分组。如果网络的传输可靠性较高，那么在不发生差错的情况下,即使仅对整个文件进行一次确认，从而减少了确认的次数，节省了网络带宽和网络资源;不过有单个分组丢失或出错，也需要重传整个文件。</p>
<h4 id="局域网、广域网和因特网之间的关系总结。"><a href="#局域网、广域网和因特网之间的关系总结。" class="headerlink" title="局域网、广域网和因特网之间的关系总结。"></a>局域网、广域网和因特网之间的关系总结。</h4><p>为方便理解，可将广域网视为一个大的局域网，专业地讲，就是通过交换机连接多个局域网，组成更大的局域网，即广域网。因此，广域网仍然是一个网络。而因特网是多个网络之间的互联，即因特网由大局域网（广域网）和小局域网共同通过路由器相连。因此局域网可以通过广域网与另一个相隔很远的局域网进行通信。</p>
<h4 id="IEEE-802局域网参考模型与OSI参考模型有何异同之处"><a href="#IEEE-802局域网参考模型与OSI参考模型有何异同之处" class="headerlink" title="IEEE 802局域网参考模型与OSI参考模型有何异同之处?"></a>IEEE 802局域网参考模型与OSI参考模型有何异同之处?</h4><p>局域网的体系结构只有OSI 参考模型的下两层（物理层和数据链路层)，而没有第三层以上的层次。即使是下两层，由于局域网是共享广播信道，而且产品的种类繁多，涉及多种媒体访问方法，所以两者存在明显的差别。</p>
<p>在局域网中，与OSI参考模型的物理层相同的是:该层负责物理连接并在媒体上传输比特流,主要任务是描述传输媒体接口的一些特性。在局域网中，数据链路层的主要作用与OSI参考模型的数据链路层相同:都通过一些数据链路层协议，在不可靠的传输信道上实现可靠的数据传输;负责帧的传送与控制，但在局域网中，由于各站共享网络公共信道，因此数据链路层必须具有媒体访问控制功能（如何分配信道、如何避免或解决信道争用)。又由于局域网采用的拓扑结构与传输媒体多种多样，相应的媒体访问控制方法也有多种，因此在数据链路功能中应该将与传输媒体有关的部分和无关的部分分开。这样，IEEE 802局域网参考模型中的数据链路层就划分为两个子层:媒体访问控制（MAC)子层和逻辑链路控制（LLC)子层。</p>
<p>与OSI参考模型不同的是:在IEEE 802局域网参考模型中没有网络层。局域网中，在任意两个结点之间只有唯一的一条链路，不需要进行路由选择和流量控制，所以在局域网中不单独设置网络层。</p>
<p>由上面的分析可知，局域网的参考模型只相当于OSI参考模型的最低两层，且两者的物理层和数据链路层之间也有很大差别。在 IEEE 802系列标准中，各个子标准的物理层和媒体访问控制(MAC)子层是有区别的，而逻辑链路控制（LLC）子层是相同的，也就是说，LLC子层实际上是高层协议与任何一种 MAC子层之间的标准接口。</p>
<h4 id="在IEEE802-3标准以太网中，为什么说如果有冲突，那么冲突一定发生在冲突窗口内-或者说一个帧如果在冲突窗口内没有发生冲突，那么该帧就不会再发生冲突"><a href="#在IEEE802-3标准以太网中，为什么说如果有冲突，那么冲突一定发生在冲突窗口内-或者说一个帧如果在冲突窗口内没有发生冲突，那么该帧就不会再发生冲突" class="headerlink" title="在IEEE802.3标准以太网中，为什么说如果有冲突，那么冲突一定发生在冲突窗口内?或者说一个帧如果在冲突窗口内没有发生冲突，那么该帧就不会再发生冲突?"></a>在IEEE802.3标准以太网中，为什么说如果有冲突，那么冲突一定发生在冲突窗口内?或者说一个帧如果在冲突窗口内没有发生冲突，那么该帧就不会再发生冲突?</h4><p>结点发送数据时，先侦听信道是否有载波，如果有，表示信道忙，那么继续侦听，直至检测到空闲为止;一个数据帧在从结点A向最远的结点传输的过程中，如果有其他结点也正在发送数据，那么此时就会发生冲突，冲突后的信号需要经过冲突窗口时间后传回结点A，结点A会检测到冲突，所以说如果有冲突，那么一定发生在冲突窗口内，如果在冲突窗口内没有发生冲突，之后如果其他结点再要发送数据，那么就会侦听到信道忙，而不会发送数据，从而不会再发生冲突。</p>
<h4 id="一个以太网的速率从10Mb-s升级到100Mb-s，满足CSMA-CD冲突条件。为使其正常工作，需做哪些调整-为什么"><a href="#一个以太网的速率从10Mb-s升级到100Mb-s，满足CSMA-CD冲突条件。为使其正常工作，需做哪些调整-为什么" class="headerlink" title="一个以太网的速率从10Mb/s升级到100Mb/s，满足CSMA/CD冲突条件。为使其正常工作，需做哪些调整?为什么?"></a>一个以太网的速率从10Mb/s升级到100Mb/s，满足CSMA/CD冲突条件。为使其正常工作，需做哪些调整?为什么?</h4><p>由于10BASE-T 要比10BASE2和10BASE5的优越性更明显，因此所有快速以太网系统都使用集线器(Hub)，而不使用同轴电缆。100BASE-T MAC 与10Mb/s的经典以太网MAC几乎一样,唯一不同的参数就是帧际间隙时间，10Mb/s 以太网是9.6 $\mu$ s(最小值)，快速以太网（100Mb/s)是0.96 $\mu$ s(最小值)。另外，为了维持最小分组尺寸不变，需要减小最大冲突域直径。所有这些调整的主要原因是速率提高到了原来以太网的10倍。</p>
<h4 id="HDLC协议是PPP协议的基础，它使用位填充来实现透明传输。但PPP协议却使用字符填充而不使用位填充，为什么"><a href="#HDLC协议是PPP协议的基础，它使用位填充来实现透明传输。但PPP协议却使用字符填充而不使用位填充，为什么" class="headerlink" title="HDLC协议是PPP协议的基础，它使用位填充来实现透明传输。但PPP协议却使用字符填充而不使用位填充，为什么?"></a>HDLC协议是PPP协议的基础，它使用位填充来实现透明传输。但PPP协议却使用字符填充而不使用位填充，为什么?</h4><p>PPP被明确地设计成以软件形式实现，而不像HDLC协议那样几乎总以硬件形式实现。对于软件实现，完全用字节操作比用单个位操作简单得多。此外，PPP被设计成与调制解调器一道使用，而调制解调器是以一个字节而非一个比特为单元接收和发送数据的。</p>
<h4 id="假定连接到透明网桥上的一台计算机把-一个数据帧发给网络上的一个不存在的设备，网桥将如何处理这个帧"><a href="#假定连接到透明网桥上的一台计算机把-一个数据帧发给网络上的一个不存在的设备，网桥将如何处理这个帧" class="headerlink" title="假定连接到透明网桥上的一台计算机把-一个数据帧发给网络上的一个不存在的设备，网桥将如何处理这个帧?"></a>假定连接到透明网桥上的一台计算机把-一个数据帧发给网络上的一个不存在的设备，网桥将如何处理这个帧?</h4><p>网桥不知道网络上是否存在该设备，它只知道在其转发表中没有这个设备的MAC地址。因此，当网桥收到这个目的地址未知的帧时，它将扩散该帧，即把该帧发送到所连接的除输入网段外的所有其他网段。</p>
<h4 id="关于冲突域（碰撞域）和广播域辨析。"><a href="#关于冲突域（碰撞域）和广播域辨析。" class="headerlink" title="关于冲突域（碰撞域）和广播域辨析。"></a>关于冲突域（碰撞域）和广播域辨析。</h4><p>一块网卡发送信息时，只要有可能和另一块网卡冲突，那么这些可能冲突的网卡就构成冲突域。一块网卡发出一个广播时，能收到这个广播的所有网卡的集合称为一个广播域。一般来说，-一个网段就是一个冲突域，一个局域网就是一个广播域。</p>
<h4 id="关于物理层、数据链路层、网络层设备对于隔离冲突域和广播域的总结。"><a href="#关于物理层、数据链路层、网络层设备对于隔离冲突域和广播域的总结。" class="headerlink" title="关于物理层、数据链路层、网络层设备对于隔离冲突域和广播域的总结。"></a>关于物理层、数据链路层、网络层设备对于隔离冲突域和广播域的总结。</h4><details><summary>图片详情</summary><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20211004113302.png" alt="找不到图片(Image not found)" onerror="this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20211004113302.png';" /></details>

<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bakari/archive/2012/09/08/2677086.html">冲突域和广播域的区别</a></li>
</ul>
<h4 id="与传统共享式局域网相比，使用局域网交换机的交换式局域网为什么能改善网络的性能和服务质量"><a href="#与传统共享式局域网相比，使用局域网交换机的交换式局域网为什么能改善网络的性能和服务质量" class="headerlink" title="与传统共享式局域网相比，使用局域网交换机的交换式局域网为什么能改善网络的性能和服务质量?"></a>与传统共享式局域网相比，使用局域网交换机的交换式局域网为什么能改善网络的性能和服务质量?</h4><p>传统共享式局域网的核心设备是集线器，而交换式局域网的核心是以太网交换机。在使用共享式集线器的传统局域网中，在任何时刻只能有一个结点能够通过共享通信信道发送数据;在使用交换机的交换式局域网中，交换机可以在它的多个端口之间建立多个并发连接，从而实现结点之间数据的并发传输，有效地改善网络性能和服务质量。</p>
<h4 id="试分析中继器、集线器、网桥和交换机这四种网络互联设备的区别与联系。"><a href="#试分析中继器、集线器、网桥和交换机这四种网络互联设备的区别与联系。" class="headerlink" title="试分析中继器、集线器、网桥和交换机这四种网络互联设备的区别与联系。"></a>试分析中继器、集线器、网桥和交换机这四种网络互联设备的区别与联系。</h4><p>这四种设备都是用于互联、扩展局域网的连接设备，但它们工作的层次和实现的功能不同。</p>
<p>$\color{green}{\text{中继器}}$ 工作在物理层，用来连接两个速率相同且数据链路层协议也相同的网仅，共力肥足们除数字信号在基带传输中由于经过一长段电缆而造成的失具和装减，便史信亏的波形个’独度o到从需的要求;其原理是信号再生。</p>
<p>$\color{green}{\text{集线器}}$ （Hub）也工作在物理层，相当于一个多接口的中继器，它可将多个结点连接成一个共享式的局域网，但任何时刻都只能有一个结点通过公共信道发送数据。</p>
<p>$\color{green}{\text{网桥}}$ 工作在数据链路层，可以互联不同的物理层、不同的MAC子层及不同速率的以太网。网桥具有过滤帧及存储转发帧的功能，可以隔离冲突域，但不能隔离广播域。</p>
<p>$\color{green}{\text{交换机}}$ 工作在数据链路层，相当于一个多端口的网桥，是父换式同域网的核心仅备。匕叶端口之间建立多个并发连接，实现多个结点之间的并发传输。因此，父换机的母个项口结点所白用的带宽不会因为端口结点数目的增加而减少，且整个交换机的忌带苋会阻看项口给点的增加增加。交换机一般工作在全双工方式，有的局域网交换机采用存储转发万式进仃转反，也有的父换机采用直通交换方式（即在收到帧的同时立即按帧的目的 MAC地址状疋以似的将及作，心不必先缓存再处理)。另外，利用交换机可以实现虚拟局域网（VLAN)，VLAN不仅可以隔离冲突域，而且可以隔离广播域。</p>
<h4 id="交换机和网桥的不同之处。"><a href="#交换机和网桥的不同之处。" class="headerlink" title="交换机和网桥的不同之处。"></a>交换机和网桥的不同之处。</h4><p>尽管交换机也称多端口网桥，但两者仍有许多不同之处。主要包括以下3点:</p>
<p>1）网桥的端口一般连接局域网，而交换机的端口一般直接与局域网的主机相连。</p>
<p>2）交换机允许多对计算机同时通信，而网桥仅允许每个网段上的计算机同时通信。</p>
<p>3）网桥采用存储转发进行转发，而以太网交换机还可以采用直通方式进行转发，且以太网交换机采用了专用的交换结构芯片，转发速度比网桥快。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%80%83%E7%A0%94/" rel="tag"># 考研</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/24/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ch2-%E7%89%A9%E7%90%86%E5%B1%82/" rel="prev" title="王道-计算机网络-ch2-物理层">
      <i class="fa fa-chevron-left"></i> 王道-计算机网络-ch2-物理层
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/24/%E7%8E%8B%E9%81%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-ch4-%E7%BD%91%E7%BB%9C%E5%B1%82/" rel="next" title="王道-计算机网络-ch4-网络层">
      王道-计算机网络-ch4-网络层 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      



      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%8B%E9%81%93"><span class="nav-text">王道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-text">数据链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">数据链路层的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="nav-text">为网络层提供服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E7%AE%A1%E7%90%86"><span class="nav-text">链路管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A7%E5%AE%9A%E7%95%8C%E3%80%81%E5%B8%A7%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93"><span class="nav-text">帧定界、帧同步与透明传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6"><span class="nav-text">差错控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%B8%A7"><span class="nav-text">组帧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-text">字符计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E7%9A%84%E9%A6%96%E5%B0%BE%E5%AE%9A%E7%95%8C%E7%AC%A6%E6%B3%95"><span class="nav-text">字符填充的首尾定界符法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E7%9A%84%E9%A6%96%E5%B0%BE%E6%A0%87%E5%BF%97%E6%B3%95"><span class="nav-text">零比特填充的首尾标志法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95"><span class="nav-text">违规编码法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-1"><span class="nav-text">差错控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E9%94%99%E7%BC%96%E7%A0%81"><span class="nav-text">检错编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A0%E9%94%99%E7%BC%96%E7%A0%81"><span class="nav-text">纠错编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6"><span class="nav-text">流量控制与可靠传输机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6"><span class="nav-text">流量控制、可靠传输与滑动窗口机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%B8%A7%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="nav-text">单帧滑动窗口与停止-等待协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%B8%A7%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%90%8E%E9%80%80N%E5%B8%A7%E5%8D%8F%E8%AE%AE%EF%BC%88GBN"><span class="nav-text">多帧滑动窗口与后退N帧协议（GBN)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%B8%A7%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AE-SR"><span class="nav-text">多帧滑动窗口与选择重传协议(SR)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">介质访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">信道划分介质访问控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">随机访问介质访问控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9A%E4%BB%A4%E7%89%8C%E4%BC%A0%E9%80%92%E5%8D%8F%E8%AE%AE"><span class="nav-text">*轮询访问介质访问控制：令牌传递协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="nav-text">局域网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">局域网的基本概念和体系结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B8%8EIEEE-802-3"><span class="nav-text">以太网与IEEE 802.3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IEEE-802-11"><span class="nav-text">IEEE 802.11</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E7%8E%AF%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">令牌环网的基本原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91"><span class="nav-text">广域网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">广域网的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PPP%E5%8D%8F%E8%AE%AE"><span class="nav-text">PPP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HDLC%E5%8D%8F%E8%AE%AE"><span class="nav-text">*HDLC协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="nav-text">数据链路层设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E6%A1%A5%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">*网桥的概念及其基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%8F%8A%E5%85%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">局域网交换机及其工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93%E5%8F%8A%E7%96%91%E9%9A%BE%E7%82%B9"><span class="nav-text">本章小结及疑难点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%9C%E9%93%BE%E8%B7%AF%E2%80%9D%E5%92%8C%E2%80%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E2%80%9D%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB-%E2%80%9C%E7%94%B5%E8%B7%AF%E6%8E%A5%E9%80%9A%E2%80%9D-%E4%B8%8E%E2%80%9C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E6%8E%A5%E9%80%9A%E2%80%9D%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="nav-text">“链路”和“数据链路”有何区别?“电路接通” 与“数据链路接通”有何区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E4%B8%AD%EF%BC%8C%E7%A1%AE%E8%AE%A4%E5%B8%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81%E5%BA%8F%E5%8F%B7%EF%BC%88%E5%A6%82%E7%94%A8ACKO%E5%92%8C-ACK1"><span class="nav-text">在停止-等待协议中，确认帧为什么不需要序号（如用ACKO和 ACK1) ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E%E7%94%A8-n-%E6%AF%94%E7%89%B9%E8%BF%9B%E8%A1%8C%E7%BC%96%E5%8F%B7%E6%97%B6%EF%BC%8C%E8%8B%A5%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%B8%BA1%EF%BC%8C%E5%88%99%E5%8F%AA%E6%9C%89%E5%9C%A8%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E5%A4%A7%E5%B0%8F-W-T-leq-2-n-1-%E6%97%B6%EF%BC%8C%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E6%89%8D%E8%83%BD%E6%AD%A3%E7%A1%AE%E8%BF%90%E8%A1%8C%E3%80%82"><span class="nav-text">说明用 $n$ 比特进行编号时，若接收窗口的大小为1，则只有在发送窗口的大小 $W_T \leq 2^n-1$ 时，连续ARQ协议才能正确运行。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%81%E6%98%8E-%E5%AF%B9%E4%BA%8E%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AE%EF%BC%8C%E8%8B%A5%E6%9C%89-n-%E6%AF%94%E7%89%B9%E8%BF%9B%E8%A1%8C%E7%BC%96%E5%8F%B7%EF%BC%8C%E5%88%99%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%BA-W-R-leq-2-n-1-%E3%80%82"><span class="nav-text">证明:对于选择重传协议，若有 $n$ 比特进行编号，则接收窗口的最大值为 $W_R \leq 2^{n-1}$ 。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BD%BF%E7%94%A8PPP%E5%8D%8F%E8%AE%AE%E6%88%96CSMA-CD%E5%8D%8F%E8%AE%AE%E6%97%B6%EF%BC%8C%E6%97%A2%E7%84%B6%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AF%B9%E6%89%80%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B8%A7%E8%BF%9B%E8%A1%8C%E5%B7%AE%E9%94%99%E6%A3%80%E9%AA%8C"><span class="nav-text">数据链路层使用PPP协议或CSMA&#x2F;CD协议时，既然不保证可靠传输，为什么要对所传输的帧进行差错检验?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88PPP%E5%8D%8F%E8%AE%AE%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%B8%A7%E7%9A%84%E7%BC%96%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-text">为什么PPP协议不使用帧的编号和确认机制来实现可靠传输?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%BF%87%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%8F%AF%E8%A1%8C%E7%9A%84%E7%A1%AE%E8%AE%A4%E7%AD%96%E7%95%A5%E3%80%82%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%98%AF%E7%94%B1%E5%8F%91%E9%80%81%E7%AB%AF%E5%B0%86%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2%E6%88%90%E5%88%86%E7%BB%84%EF%BC%8C%E6%8E%A5%E6%94%B6%E7%AB%AF%E9%80%90%E4%B8%AA%E7%A1%AE%E8%AE%A4%E5%88%86%E7%BB%84-%E4%BD%86%E5%B0%B1%E6%95%B4%E4%BD%93%E8%80%8C%E8%A8%80%EF%BC%8C%E6%96%87%E4%BB%B6%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%BE%97%E5%88%B0%E7%A1%AE%E8%AE%A4%E3%80%82%E7%AC%AC%E4%BA%8C%E7%A7%8D%E7%AD%96%E7%95%A5%E6%98%AF%E6%8E%A5%E6%94%B6%E7%AB%AF%E4%B8%8D%E7%A1%AE%E8%AE%A4%E5%8D%95%E4%B8%AA%E5%88%86%E7%BB%84%EF%BC%8C%E8%80%8C%E6%98%AF%E5%BD%93%E6%96%87%E4%BB%B6%E5%85%A8%E9%83%A8%E6%94%B6%E5%88%B0%E5%90%8E%EF%BC%8C%E5%AF%B9%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6%E4%BA%88%E4%BB%A5%E6%8E%A5%E6%94%B6%E7%A1%AE%E8%AE%A4%E3%80%82%E8%AF%95%E6%AF%94%E8%BE%83%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E5%90%88%E3%80%82"><span class="nav-text">两台计算机通过计算机网络传输一个文件时，有两种可行的确认策略。第一种是由发送端将文件分割成分组，接收端逐个确认分组;但就整体而言，文件并没有得到确认。第二种策略是接收端不确认单个分组，而是当文件全部收到后，对整个文件予以接收确认。试比较这两种方式的优缺点，以及它们各自适用的场合。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E3%80%81%E5%B9%BF%E5%9F%9F%E7%BD%91%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93%E3%80%82"><span class="nav-text">局域网、广域网和因特网之间的关系总结。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IEEE-802%E5%B1%80%E5%9F%9F%E7%BD%91%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%B8%8EOSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="nav-text">IEEE 802局域网参考模型与OSI参考模型有何异同之处?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8IEEE802-3%E6%A0%87%E5%87%86%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A6%82%E6%9E%9C%E6%9C%89%E5%86%B2%E7%AA%81%EF%BC%8C%E9%82%A3%E4%B9%88%E5%86%B2%E7%AA%81%E4%B8%80%E5%AE%9A%E5%8F%91%E7%94%9F%E5%9C%A8%E5%86%B2%E7%AA%81%E7%AA%97%E5%8F%A3%E5%86%85-%E6%88%96%E8%80%85%E8%AF%B4%E4%B8%80%E4%B8%AA%E5%B8%A7%E5%A6%82%E6%9E%9C%E5%9C%A8%E5%86%B2%E7%AA%81%E7%AA%97%E5%8F%A3%E5%86%85%E6%B2%A1%E6%9C%89%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%A5%E5%B8%A7%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%86%8D%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81"><span class="nav-text">在IEEE802.3标准以太网中，为什么说如果有冲突，那么冲突一定发生在冲突窗口内?或者说一个帧如果在冲突窗口内没有发生冲突，那么该帧就不会再发生冲突?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E9%80%9F%E7%8E%87%E4%BB%8E10Mb-s%E5%8D%87%E7%BA%A7%E5%88%B0100Mb-s%EF%BC%8C%E6%BB%A1%E8%B6%B3CSMA-CD%E5%86%B2%E7%AA%81%E6%9D%A1%E4%BB%B6%E3%80%82%E4%B8%BA%E4%BD%BF%E5%85%B6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%EF%BC%8C%E9%9C%80%E5%81%9A%E5%93%AA%E4%BA%9B%E8%B0%83%E6%95%B4-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-text">一个以太网的速率从10Mb&#x2F;s升级到100Mb&#x2F;s，满足CSMA&#x2F;CD冲突条件。为使其正常工作，需做哪些调整?为什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HDLC%E5%8D%8F%E8%AE%AE%E6%98%AFPPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%8C%E5%AE%83%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%A1%AB%E5%85%85%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93%E3%80%82%E4%BD%86PPP%E5%8D%8F%E8%AE%AE%E5%8D%B4%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%A1%AB%E5%85%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-text">HDLC协议是PPP协议的基础，它使用位填充来实现透明传输。但PPP协议却使用字符填充而不使用位填充，为什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%87%E5%AE%9A%E8%BF%9E%E6%8E%A5%E5%88%B0%E9%80%8F%E6%98%8E%E7%BD%91%E6%A1%A5%E4%B8%8A%E7%9A%84%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%8A-%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%B8%A7%E5%8F%91%E7%BB%99%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E8%AE%BE%E5%A4%87%EF%BC%8C%E7%BD%91%E6%A1%A5%E5%B0%86%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA%E5%B8%A7"><span class="nav-text">假定连接到透明网桥上的一台计算机把-一个数据帧发给网络上的一个不存在的设备，网桥将如何处理这个帧?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%86%B2%E7%AA%81%E5%9F%9F%EF%BC%88%E7%A2%B0%E6%92%9E%E5%9F%9F%EF%BC%89%E5%92%8C%E5%B9%BF%E6%92%AD%E5%9F%9F%E8%BE%A8%E6%9E%90%E3%80%82"><span class="nav-text">关于冲突域（碰撞域）和广播域辨析。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E5%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87%E5%AF%B9%E4%BA%8E%E9%9A%94%E7%A6%BB%E5%86%B2%E7%AA%81%E5%9F%9F%E5%92%8C%E5%B9%BF%E6%92%AD%E5%9F%9F%E7%9A%84%E6%80%BB%E7%BB%93%E3%80%82"><span class="nav-text">关于物理层、数据链路层、网络层设备对于隔离冲突域和广播域的总结。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E5%85%B1%E4%BA%AB%E5%BC%8F%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9B%B8%E6%AF%94%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E4%BA%A4%E6%8D%A2%E5%BC%8F%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%94%B9%E5%96%84%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F"><span class="nav-text">与传统共享式局域网相比，使用局域网交换机的交换式局域网为什么能改善网络的性能和服务质量?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%95%E5%88%86%E6%9E%90%E4%B8%AD%E7%BB%A7%E5%99%A8%E3%80%81%E9%9B%86%E7%BA%BF%E5%99%A8%E3%80%81%E7%BD%91%E6%A1%A5%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%BF%99%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%E8%AE%BE%E5%A4%87%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%E3%80%82"><span class="nav-text">试分析中继器、集线器、网桥和交换机这四种网络互联设备的区别与联系。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E7%BD%91%E6%A1%A5%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%E3%80%82"><span class="nav-text">交换机和网桥的不同之处。</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">305</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '04b9fe1c5636beb4acc4',
      clientSecret: '8ccb8829887eac219a8fdb018878fd0cf088a7ac',
      repo        : 'gittalk-comment',
      owner       : 'ednow',
      admin       : ['ednow'],
      id          : '8258acba34d5baca4be7d68dd9dd7991',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
