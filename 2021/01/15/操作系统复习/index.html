<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ednow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="学校课本按章学校的课本编排知识布局">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统复习">
<meta property="og:url" content="http://ednow.github.io/2021/01/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="ednow">
<meta property="og:description" content="学校课本按章学校的课本编排知识布局">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120111024.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120111045.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119232042.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119231746.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119232100.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119235243.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120000523.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120001705.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120003218.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120003415.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120005304.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120145926.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120010153.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120115427.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120115721.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120115823.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120120327.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120120340.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120120352.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120120405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135012.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135204.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135320.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135537.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135653.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135759.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135854.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140037.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140137.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140253.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140441.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140603.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140714.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141208.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141340.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141843.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141810.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142051.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142254.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142401.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142629.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142804.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142847.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142913.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143216.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143417.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143516.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143641.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143922.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143701.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143836.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144029.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144057.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144154.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144425.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144554.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144626.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144702.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120145047.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120145110.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120145139.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210118184654.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120111747.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120111936.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112023.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112251.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112330.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112645.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112717.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112757.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119174907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119180524.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119175158.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119180306.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119180742.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119181348.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119181247.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119181812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119183528.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119183745.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119184030.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119184130.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119184320.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119184831.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119185530.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119185635.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119185840.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190148.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190237.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190452.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190543.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190703.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190813.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190934.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191123.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191327.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191549.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191708.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191746.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191624.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200406.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200457.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200811.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200934.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119201245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119201441.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119201530.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119201702.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119202729.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119203605.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119203656.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204143.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204155.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204329.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204703.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204935.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204947.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112941.png">
<meta property="article:published_time" content="2021-01-15T09:18:57.000Z">
<meta property="article:modified_time" content="2021-01-20T07:03:07.610Z">
<meta property="article:author" content="ednow">
<meta property="article:tag" content="占坑">
<meta property="article:tag" content="期末复习">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120111024.png">

<link rel="canonical" href="http://ednow.github.io/2021/01/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>操作系统复习 | ednow</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ednow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://ednow.github.io/2021/01/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ednow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ednow">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统复习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-15 17:18:57" itemprop="dateCreated datePublished" datetime="2021-01-15T17:18:57+08:00">2021-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-20 15:03:07" itemprop="dateModified" datetime="2021-01-20T15:03:07+08:00">2021-01-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="学校课本"><a href="#学校课本" class="headerlink" title="学校课本"></a>学校课本</h1><p>按章学校的课本编排知识布局<br><a id="more"></a></p>
<ul>
<li>本笔记规范遵守条例:<a href="https://ednow.github.io/2021/01/19/%E8%AE%B0%E5%8F%B7%E8%A7%84%E8%8C%83/">记号规范</a></li>
</ul>
<!-- 打了半天字才发现学校的[教材](https://mp.zhizhuma.com/book/ebook.htm?bookId=75225&srcchannel=mp&flip=swipe)有pdf，佛了,当场去世。抄书人抄书魂，冲。 -->
<h2 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h2><p>操作系统提供的三大接口</p>
<ul>
<li>图形接口</li>
<li>命令接口</li>
<li>系统调用<ul>
<li>相当于程序接口</li>
</ul>
</li>
</ul>
<p>库函数是高级语言提供的封装系统调用相关的函数</p>
<h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><h4 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h4><h4 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h4><h5 id="用户环境的观点"><a href="#用户环境的观点" class="headerlink" title="用户环境的观点"></a>用户环境的观点</h5><p>从用户的角度看，<strong>操作系统是用户与计算机硬件系统之间的接口</strong>，用户通过操作系统来使用计算机系统，即用户在操作系统的支持下，能够方便、快捷、安全、可靠地操纵计算机硬件资源，运行自己的程序。<br>用户可通过以下三种方式使用计算机:<br>①直接使用操作系统提供的<strong>键盘命令</strong>或<strong>Shell 命令语言</strong>;<br>②利用鼠标点击窗口中的按钮、菜单等图标，以执行相应的应用程序，如 Windows操作系统的<strong>图形用户接口</strong>;<br>③在应用程序中调用操作系统的内部功能模块，即<strong>系统调用接口</strong>。这些接口为用户开发和运行应用软件提供了便利的环境和手段。</p>
<h5 id="资源管理的观点"><a href="#资源管理的观点" class="headerlink" title="资源管理的观点"></a>资源管理的观点</h5><p>把操作系统看作系统资源的管理者，是目前关于操作系统描述的主要观点。<br>现代计算机系统通常包括各种各样的资源，总体上可分为处理器、存储器、IO设备和文件四类，因此，操作系统的功能就是负责对计算机的这些软、硬件资源进行控制、调度、分配和回收，解决系统中各程序对资源使用请求的冲突，保证各程序都能顺利完成运行。</p>
<h5 id="虚拟机观点"><a href="#虚拟机观点" class="headerlink" title="虚拟机观点"></a>虚拟机观点</h5><p><strong>一台完全无软件的计算机系统称之为裸机</strong>，即使其功能再强，也是难于使用的。<br>如果在裸机上覆盖一层IO设备管理软件，用户便可以利用它所提供的IO命令，方便地进行数据的输入和输出。此时用户所看到的机器将是一台比裸机功能更强、使用更方便的机器，<strong>通常把覆盖了软件的机器称为虚拟机。</strong>如果在IO设备管理软件上再覆盖一层文件管理软件，则用户可利用它提供的文件管理命令，方便地进行文件的存取。如果在文件管理软件上再覆盖一层面向用户的窗口软件，则用户便可在窗口环境下更加方便地使用计算机，形成一台功能更强的虚拟机。</p>
<h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3><h4 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h4><h5 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h5><p>早期的计算机只配备有硬件，没有操作系统，程序的装入、调试以及控制程序的运行都是通过控制台上的开关来实现的，用户也只能使用机器语言进行编程。<br>这种工作方式需要很多人工干预，形成了手工操作慢但处理机快的所谓<strong>人机矛盾</strong>，并且使用不方便。</p>
<h6 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h6><p>在单道批处理系统中，设置了一个能完成作业自动转换工作的程序，该程序被称为监督程序，当操作员把一批作业交给系统后，就由监督程序控制这一批作业的自动运行。</p>
<h6 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h6><p>在20世纪60年代中期引入了多道程序设计技术，形成了多道批处理系统。其基本思想是<strong>把用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”</strong>;然后由作业调度程序按一定的算法从后备队列中选择若干个作业同时装入内存，在管理程序的控制下交替执行，共享CPU和系统中的其他各种资源，每当正在运行的程序因某种原因(如等待IO操作的完成)不能继续运行时，CPU 立即转去执行另一道程序</p>
<h5 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h5><p>分时系统具有多路性、独立性、及时性和交互性特征，而<strong>交互性是其最重要的特征之一</strong>。</p>
<h5 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h5><h6 id="实时系统与分时系统都具有多路性"><a href="#实时系统与分时系统都具有多路性" class="headerlink" title="实时系统与分时系统都具有多路性"></a>实时系统与分时系统都具有多路性</h6><p>分时系统按照分时原则为多个终端用户服务;而实时控制系统的多路性则主要表现在经常对多路的现场信息进行采集以及对多个对象或多个执行机构进行控制。</p>
<h6 id="实时系统与分时系统都具有独立性"><a href="#实时系统与分时系统都具有独立性" class="headerlink" title="实时系统与分时系统都具有独立性"></a>实时系统与分时系统都具有独立性</h6><p>每个终端用户在向分时系统提出服务请求时，是彼此独立的操作，互不干扰;而在实时控制系统中信息的采集和对象的控制，也互不干扰。</p>
<h6 id="实时系统与分时系统都要求及时性"><a href="#实时系统与分时系统都要求及时性" class="headerlink" title="实时系统与分时系统都要求及时性"></a>实时系统与分时系统都要求及时性</h6><p>实时系统是以控制对象所要求的开始截止时间或完成截止时间来确定其及时性的，一般为秒级、百毫秒级直至毫秒级，甚至有的要低于100微秒。而分时系统的及时性是以用户所要求的响应时间来确定的，一般为秒级，实时系统要求的及时性更高。</p>
<h6 id="实时系统与分时系统都具有交互性"><a href="#实时系统与分时系统都具有交互性" class="headerlink" title="实时系统与分时系统都具有交互性"></a>实时系统与分时系统都具有交互性</h6><p>实时系统的交互仅限于访问系统中某些特定的专用服务程序;而分时系统则能向终端用户提供数据处理、资源共享等多种服务，分时系统的交互性是其主要特征。</p>
<h6 id="实时系统与分时系统都要求可靠性"><a href="#实时系统与分时系统都要求可靠性" class="headerlink" title="实时系统与分时系统都要求可靠性"></a>实时系统与分时系统都要求可靠性</h6><p>分时系统要求系统可靠，而实时系统要求系统高可靠度，因为实时系统的任何差错都可能带来巨大的经济损失甚至无法预料的灾难性后果。因此，实时系统往往采取多级容错措施来保证系统的<strong>高可靠性</strong>。</p>
<h5 id="微机操作系统"><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h5><p>Linux,Windows</p>
<h5 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h5><h6 id="网络通信管理"><a href="#网络通信管理" class="headerlink" title="网络通信管理"></a>网络通信管理</h6><p>主要负责实现网络中计算机之间的通信。</p>
<h6 id="网络资源管理"><a href="#网络资源管理" class="headerlink" title="网络资源管理"></a>网络资源管理</h6><p>对网络中共享的软硬件资源实施有效的管理，保证用户方便、正确地使用这些资源，提高资源的利用率。</p>
<h6 id="网络安全管理"><a href="#网络安全管理" class="headerlink" title="网络安全管理"></a>网络安全管理</h6><p>提供网络资源访问的安全措施，保证系统中共享资源的安全性。</p>
<h6 id="提供网络服务"><a href="#提供网络服务" class="headerlink" title="提供网络服务"></a>提供网络服务</h6><p>包括文件传输服务、打印服务、电子邮件服务等。</p>
<h5 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h5><p>此外，分布在系统中各个站点上的软、硬件资源，可供全系统中的所有用户共享，并以透明的方式访问它们，用户看到的不是多个分散的处理单元，而是一个功能强大的计算机系统。</p>
<h5 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h5><p>嵌入式操作系统具有微小、实时、专业、可靠、易裁剪等优点。</p>
<h3 id="操作系统的特征和功能"><a href="#操作系统的特征和功能" class="headerlink" title="操作系统的特征和功能"></a>操作系统的特征和功能</h3><h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><h5 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h5><h5 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h5><h5 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h5><h5 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h5><h4 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h4><h5 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h5><h5 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h5><h5 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h5><h5 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h5><h5 id="提供用户接口"><a href="#提供用户接口" class="headerlink" title="提供用户接口"></a>提供用户接口</h5><h6 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h6><p>操作系统向用户提供一组键盘操作命令。用户从键盘上输入命令，命令解释程序接收并解释这些命令，然后调用操作系统内部的相应程序，完成相应的功能。</p>
<h6 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h6><p>操作系统内核与应用程序之间的接口称为应用程序接口，是为应用程序在执行中访问系统资源而设置的，通常由一组系统调用组成，每一个系统调用都是一个能完成特定功能的子程序。系统调用只能在程序中调用，不能直接作为命令从键盘上输入执行。</p>
<h6 id="图形接口"><a href="#图形接口" class="headerlink" title="图形接口"></a>图形接口</h6><p>这是为了方便用户使用操作系统而提供的图形化操作界面。用户利用鼠标等交互设备，通过操作窗口、菜单、图标等图形用户界面工具，可以直观、方便、高效地使用系统服务和各种应用程序及实用工具，而不必像使用命令接口那样去记住命令名及格式。</p>
<h3 id="操作系统用户接口"><a href="#操作系统用户接口" class="headerlink" title="操作系统用户接口"></a>操作系统用户接口</h3><h4 id="三种"><a href="#三种" class="headerlink" title="三种"></a>三种</h4><h5 id="命令接口-Command-Line-lnterface，CLI"><a href="#命令接口-Command-Line-lnterface，CLI" class="headerlink" title="命令接口(Command Line lnterface，CLI)"></a>命令接口(Command Line lnterface，CLI)</h5><h5 id="程序接口-Application-Programming-Interface，API"><a href="#程序接口-Application-Programming-Interface，API" class="headerlink" title="程序接口(Application Programming Interface，API)"></a>程序接口(Application Programming Interface，API)</h5><h5 id="图形接口-GraphicalUser-Interface，GUI"><a href="#图形接口-GraphicalUser-Interface，GUI" class="headerlink" title="图形接口(GraphicalUser Interface，GUI)"></a>图形接口(GraphicalUser Interface，GUI)</h5><h3 id="操作系统内核结构"><a href="#操作系统内核结构" class="headerlink" title="操作系统内核结构"></a>操作系统内核结构</h3><h4 id="三种-1"><a href="#三种-1" class="headerlink" title="三种"></a>三种</h4><h5 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h5><ul>
<li>整体结构模型又称为单体结构模型或无结构模型。</li>
<li>在整体内核结构模型中，没有明确定义和划分操作系统的结构，整个内核是由一组函数集合构成的，函数之间可以任意相互调用</li>
<li>例如 CP/M、MS-DOS、Linux系统以及早期的Unix系统等。</li>
<li>优点<ul>
<li>应用程序和底层硬件之间的接口简单直接</li>
<li>系统效率较高</li>
<li>具有良好的运行性能</li>
</ul>
</li>
<li>缺点<ul>
<li>模块独立性差</li>
<li>调用关系复杂，修改引入的变化可能影响到其他模块，后续系统的维护和扩充变得很困难</li>
</ul>
</li>
<li>Linux内核引入动态模块机制加以改进</li>
</ul>
<h5 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h5><ul>
<li>层次结构力求模块之间的调用清晰有序，减少各个模块之间的互相调用和互相依赖，特别是可能出现的循环调用问题</li>
<li>层次结构模型中，各层之间的模块只能单向依赖或单向调用，最底层(第0层)与低层硬件交互，而高层(第N层)为应用程序和用户提供接口。</li>
<li>每层都是利用较低层所提供的功能实现的，并且只有相邻层之间才能通信。</li>
<li>优点<ul>
<li>层次结构的各层相对独立</li>
<li>把整体问题分解为若干简单问题在不同层次上解决，将复杂操作系统分解为功能相对单一的许多层次</li>
<li>组织结构和相互依赖关系清晰明了</li>
<li>简化了系统的设计和实现</li>
<li>易于对操作系统增加或者替换一层而不影响其他层次</li>
<li>保持接口一致</li>
<li>易于维护、修改和扩充。</li>
</ul>
</li>
<li>缺点<ul>
<li>令系统开销增加而效率降低</li>
<li>层次的定义并不是一件容易的事情，各层次包含的内容难于确定。</li>
</ul>
</li>
<li>分层操作系统有VAX/VMS和 Unix等。</li>
</ul>
<h3 id="典型操作系统介绍"><a href="#典型操作系统介绍" class="headerlink" title="典型操作系统介绍"></a>典型操作系统介绍</h3><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><h3 id="本章习题"><a href="#本章习题" class="headerlink" title="本章习题"></a>本章习题</h3><h2 id="第二章-操作系统硬件基础"><a href="#第二章-操作系统硬件基础" class="headerlink" title="第二章 操作系统硬件基础"></a>第二章 操作系统硬件基础</h2><p>只有第三小节是重点</p>
<h3 id="处理器计算"><a href="#处理器计算" class="headerlink" title="处理器计算"></a>处理器计算</h3><h4 id="处理器指令"><a href="#处理器指令" class="headerlink" title="处理器指令"></a>处理器指令</h4><h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><h4 id="处理器特权级"><a href="#处理器特权级" class="headerlink" title="处理器特权级"></a>处理器特权级</h4><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><h4 id="高速缓冲寄存器"><a href="#高速缓冲寄存器" class="headerlink" title="高速缓冲寄存器"></a>高速缓冲寄存器</h4><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><h4 id="非易失性存储"><a href="#非易失性存储" class="headerlink" title="非易失性存储"></a>非易失性存储</h4><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><h3 id="中断和时钟"><a href="#中断和时钟" class="headerlink" title="中断和时钟"></a>中断和时钟</h3><h4 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h4><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><h5 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h5><p>它是一种用户在<strong>程序</strong>一级<strong>请求操作系统内核完成某种功能服务的过程调用</strong>，每种操作系统都会提供多达几百种的系统调用，每一个系统调用都是完成某种特定内核功能的一个函数，比如大家熟悉的读磁盘操作read()、终端显示printf()等，这些系统调用表面上看起来与一般的过程调用(比如三角函数 cos(O))完全相同，但实际上有很大的区别:一般的过程调用，其调用程序与被调用过程运行在相同的状态——系统态或用户态，所以可直接由调用程序转向被调用过程;而系统调用则是调用程序运行在用户态，被调用过程运行在系统态，因而不允许由调用程序直接转向被调用过程，需要通过中断及陷入机制，先由用户态转换到系统态，经内核分析检查后，才能转向相应的内核被调用过程执行。</p>
<h5 id="系统调用号、系统调用服务例程及系统调用入口表"><a href="#系统调用号、系统调用服务例程及系统调用入口表" class="headerlink" title="系统调用号、系统调用服务例程及系统调用入口表"></a>系统调用号、系统调用服务例程及系统调用入口表</h5><ul>
<li>每种操作系统都会提供几百种系统调用，为了唯一的标识每一个系统调用，系统为每个系统调用都赋予了一个唯一的编号，称为系统调用号</li>
<li>用户程序是<strong>使用系统调用号</strong>而不是系统调用名称来告诉系统到底是要执行哪个系统调用</li>
<li>每个系统调用都会完成操作系统内核的某项服务功能，具体是由一个特定的内核函数来实现的，称为系统调用服务例程。</li>
<li>系统为了能快速地根据用户进程请求的系统调用号找到它所对应的服务例程，设置了一张系统调用入口表，用于关联系统调用号及其对应服务例程的入口地址，每个系统调用占一表项</li>
</ul>
<h5 id="系统调用号及参数的传递"><a href="#系统调用号及参数的传递" class="headerlink" title="系统调用号及参数的传递"></a>系统调用号及参数的传递</h5><p>Linux是利用一组寄存器来传递参数的,在x86-32系统上，EBX/ECX/EDX/ESIEDI按顺序依次存放前五个参数，因此每个参数的长度不能超出寄存器长度(即32位)，且参数个数不能超过<strong>五个</strong>，若某系统调用确实需要六个及以上的参数时，则只能用一个单独的寄存器指向进程地址空间中这些参数值所在的一个<strong>内存区</strong></p>
<h5 id="bigstar-系统调用处理流程"><a href="#bigstar-系统调用处理流程" class="headerlink" title="$\bigstar$ 系统调用处理流程"></a>$\bigstar$ 系统调用处理流程</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120111024.png" alt="系统调用处理流程-1"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120111045.png" alt="系统调用处理流程-2"></p>
<h4 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h4><h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h3><h3 id="本章习题-1"><a href="#本章习题-1" class="headerlink" title="本章习题"></a>本章习题</h3><h2 id="第三章-进程管理"><a href="#第三章-进程管理" class="headerlink" title="第三章 进程管理"></a>第三章 进程管理</h2><h3 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h3><h4 id="进程的并发执行及特征"><a href="#进程的并发执行及特征" class="headerlink" title="进程的并发执行及特征"></a>进程的并发执行及特征</h4><h5 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h5><p>空闲等待时间减少，提高了资源利用率和系统吞吐量</p>
<h5 id="程序并发执行的特征"><a href="#程序并发执行的特征" class="headerlink" title="程序并发执行的特征"></a>程序并发执行的特征</h5><h6 id="间断性"><a href="#间断性" class="headerlink" title="间断性"></a>间断性</h6><p>表现出“执行-暂停-执行”的间断性活动规律</p>
<h6 id="失去封闭性而导致程序运行结果出现不可再现性"><a href="#失去封闭性而导致程序运行结果出现不可再现性" class="headerlink" title="失去封闭性而导致程序运行结果出现不可再现性"></a>失去封闭性而导致程序运行结果出现不可再现性</h6><h6 id="静态程序结构不能支持并发运行的实现"><a href="#静态程序结构不能支持并发运行的实现" class="headerlink" title="静态程序结构不能支持并发运行的实现"></a>静态程序结构不能支持并发运行的实现</h6><h4 id="进程管理功能"><a href="#进程管理功能" class="headerlink" title="进程管理功能"></a>进程管理功能</h4><h5 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h5><h5 id="进程互斥与同步"><a href="#进程互斥与同步" class="headerlink" title="进程互斥与同步"></a>进程互斥与同步</h5><h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><h4 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a>进程的定义和特征</h4><h5 id="进程的定义和特征-1"><a href="#进程的定义和特征-1" class="headerlink" title="进程的定义和特征"></a>进程的定义和特征</h5><h6 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h6><h6 id="并发性-1"><a href="#并发性-1" class="headerlink" title="并发性"></a>并发性</h6><h6 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h6><h6 id="异步性-1"><a href="#异步性-1" class="headerlink" title="异步性"></a>异步性</h6><h5 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h5><ul>
<li>进程映像是进程的实体组成<ul>
<li>程序段</li>
<li>数据集</li>
<li>PCB：通过进程控制块（PCB）描述进程的状态信息、本身属性、对资源的占用及调度信息等</li>
<li>栈  <ul>
<li>系统在创建进程的时候会为其建立两个栈<ul>
<li>用户栈</li>
<li>系统栈</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="进程与程序的区别和联系"><a href="#进程与程序的区别和联系" class="headerlink" title="进程与程序的区别和联系"></a>进程与程序的区别和联系</h5><h6 id="程序是静态概念，进程是动态的"><a href="#程序是静态概念，进程是动态的" class="headerlink" title="程序是静态概念，进程是动态的"></a>程序是静态概念，进程是动态的</h6><ul>
<li>程序是静态概念，本身可以作为软件资源长期保存</li>
<li>进程是程序的一次执行过程，是动态的，有一定的生命周期<h6 id="进程是调度的基本单位，程序不能参与并发执行"><a href="#进程是调度的基本单位，程序不能参与并发执行" class="headerlink" title="进程是调度的基本单位，程序不能参与并发执行"></a>进程是调度的基本单位，程序不能参与并发执行</h6></li>
<li>进程是一个能独立运行的单位，是系统进行资源分配和调度的基本单位，能与其他进程并发执行，而程序因其自身不能描述并发运行过程中的动态信息，所以无法参与并发运行</li>
</ul>
<h6 id="程序和进程并非是一对一的关系"><a href="#程序和进程并非是一对一的关系" class="headerlink" title="程序和进程并非是一对一的关系"></a>程序和进程并非是一对一的关系</h6><ul>
<li>一个程序可由多个进程共享</li>
<li>一个进程在其执行过程中又可顺序地执行多个程序</li>
</ul>
<h4 id="进程状态与转换"><a href="#进程状态与转换" class="headerlink" title="进程状态与转换"></a>进程状态与转换</h4><h5 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h5><h6 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h6><h6 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h6><h6 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119232042.png" alt="进程三种状态及转换"></p>
<h5 id="创建状态和终止状态"><a href="#创建状态和终止状态" class="headerlink" title="创建状态和终止状态"></a>创建状态和终止状态</h5><h6 id="创建状态"><a href="#创建状态" class="headerlink" title="创建状态"></a>创建状态</h6><p>正在被创建，但还没有创建完成，尚未加入就绪队列时的状态，此时进程还不能参与CPU调度</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119231746.png" alt="进程五种状态及转换"></p>
<h6 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h6><p>当前运行进程完成自己的工作后正常结束，或是运行中出现了无法克服的错误(如地址越界、使用非法指令等)而被异常终止时，将被系统强制结束，进入终止状态。</p>
<h4 id="Linux进程状态解析"><a href="#Linux进程状态解析" class="headerlink" title="Linux进程状态解析"></a>Linux进程状态解析</h4><h5 id="state"><a href="#state" class="headerlink" title="state"></a>state</h5><p>表示进程生命周期的各种状态</p>
<h6 id="TASK-RUNNING"><a href="#TASK-RUNNING" class="headerlink" title="TASK_RUNNING"></a>TASK_RUNNING</h6><p>可运行状态。处于该状态的进程要么正在CPU上运行，要么位于就绪队列中等待CPU 调度运行。</p>
<h6 id="TASK-INTERRUPTIBLE"><a href="#TASK-INTERRUPTIBLE" class="headerlink" title="TASK_INTERRUPTIBLE"></a>TASK_INTERRUPTIBLE</h6><p>可中断睡眠状态。因为等待某事件发生而阻塞睡眠的状态。当所等待的事件发生时，或者有其他异步信号到达时，该进程将被唤醒。</p>
<h6 id="TASK-UNINTERRUPTIBLE"><a href="#TASK-UNINTERRUPTIBLE" class="headerlink" title="TASK_UNINTERRUPTIBLE"></a>TASK_UNINTERRUPTIBLE</h6><p>不可中断睡眠状态。与TASK_INTERRUPTIBLE类似，但不响应异步信号，只能被wakeup()(唤醒函数)显式唤醒。</p>
<h6 id="TASK-STOPPED"><a href="#TASK-STOPPED" class="headerlink" title="TASK_STOPPED"></a>TASK_STOPPED</h6><p>暂停状态。当进程收到SIGSTOP(暂停执行信号)、SIGTSTP(暂停执行信号)、SIGTTIN(暂停执行信号)或SIGTTOU(暂停执行信号)信号时进入暂停状态，不可被调度运行;之后收到SIGCONT(让一个暂停进程继续执行的信号)信号时恢复到可运行状态。</p>
<h6 id="TASK-TRACED"><a href="#TASK-TRACED" class="headerlink" title="TASK_TRACED"></a>TASK_TRACED</h6><p>跟踪状态。进程被调试器暂停下来，等待跟踪它的进程对其进行相关处理，例如执行ptrace()(跟踪函数)系统调用。</p>
<h6 id="TASK-DEAD"><a href="#TASK-DEAD" class="headerlink" title="TASK_DEAD"></a>TASK_DEAD</h6><p>终止状态。进程在退出过程中所处的状态，进程所占用的资源将被回收，很快将要被系统彻底销毁。</p>
<h6 id="TASK-WAKEKILL"><a href="#TASK-WAKEKILL" class="headerlink" title="TASK_WAKEKILL"></a>TASK_WAKEKILL</h6><p>可响应致命信号的不可中断睡眠状态。这是 Linux内核引入的一种新状态，其属性与TASK_UNINTERRUPTIBLE相似，但是可以响应致命信号。</p>
<h5 id="exit-state"><a href="#exit-state" class="headerlink" title="exit_state"></a>exit_state</h5><p>表示进程终止过程中的状态,</p>
<h6 id="EXIT-ZOMBIE"><a href="#EXIT-ZOMBIE" class="headerlink" title="EXIT_ZOMBIE"></a>EXIT_ZOMBIE</h6><ul>
<li>僵尸状态。</li>
<li>进程已终止，除了task_struct结构以及内核堆栈以外，其余所有资源已被系统回收，等待父进程调用wait()系列函数收集它的相关统计信息，如运行时间等。</li>
</ul>
<h6 id="EXIT-DEAD"><a href="#EXIT-DEAD" class="headerlink" title="EXIT_DEAD"></a>EXIT_DEAD</h6><p>进程的最终状态，表示父进程已经通过wait()系列函数完成其相关信息的收集，或者父进程已设置SIGCHLD(子进程结束时，向父进程发送的信号)信号的handler(处理函数)为SIG_IGN(不处理)，之后将很快被彻底销毁。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令(ps命令是显式系统中进程的情况)捕捉到。</p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119232100.png" alt="Linux的进程状态图"></p>
<h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><p>进程控制块(Process Control Block，PCB)是进程映像的重要组成部分，其中记录了用于描述进程情况及控制进程运行所需要的全部信息，<strong>是进程动态特性的集中反映</strong>。</p>
<h5 id="进程标识信息"><a href="#进程标识信息" class="headerlink" title="进程标识信息"></a>进程标识信息</h5><h6 id="进程标识符"><a href="#进程标识符" class="headerlink" title="进程标识符"></a>进程标识符</h6><p>系统中的每个进程都有区别于其他进程的唯一标识符，以标识一个进程，可以用字符串或编号表示。系统为方便跟踪管理进程，创建进程时会为新进程分配一个整数编号，称为进程的内部标识符(pid)，通常是进程的创建序号;另外某些系统为方便用户对进程的访问，会为进程设置一个由字母、数字组成的字符串作为外部标识符，它是由创建者提供的。</p>
<h6 id="用户标识符"><a href="#用户标识符" class="headerlink" title="用户标识符"></a>用户标识符</h6><p>每个进程都隶属于某个用户或用户组，以便于资源共享和保护。</p>
<h6 id="家族关系"><a href="#家族关系" class="headerlink" title="家族关系"></a>家族关系</h6><p>多个进程之间会互成家族关系，如该进程的父进程、兄弟进程、子进程等，通常也会记录在PCB 中。</p>
<h5 id="进程调度信息"><a href="#进程调度信息" class="headerlink" title="进程调度信息"></a>进程调度信息</h5><p>是与进程调度有关的一组信息</p>
<h6 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h6><p>说明进程当前所处的状态，如前面介绍的就绪状态、运行状态、阻塞状态等，只有处于就绪状态的进程才能参与CPU调度。</p>
<h6 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h6><p>是系统进行CPU调度的重要依据，通常用一个整数数字表示。优先级高的进程会优先获得CPU运行。</p>
<h6 id="其他调度相关信息"><a href="#其他调度相关信息" class="headerlink" title="其他调度相关信息"></a>其他调度相关信息</h6><p>通常与系统的进程调度算法有关，比如进程在就绪队列中等待CPU的时间、进程已执行的时间总和、进程到运行结束还需要的CPU运行时间等。</p>
<h6 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h6><p>进程能够继续执行前需等待的事件，即进程阻塞的原因。</p>
<h5 id="进程现场信息"><a href="#进程现场信息" class="headerlink" title="进程现场信息"></a>进程现场信息</h5><p>当前运行进程因某种原因(如时间片到或等待某事件的发生等)而暂停运行时，需记录其断点处的运行环境信息，以便以后能从断点处恢复运行。主要是由处理器中各寄存器的内容组成</p>
<h6 id="通用寄存器内容"><a href="#通用寄存器内容" class="headerlink" title="通用寄存器内容"></a>通用寄存器内容</h6><p>又称为用户可见寄存器，是用户程序可以访问的一组寄存器，可用于传送和暂存数据、参与算术逻辑运算、保存运算结果等。大多数处理器有8~32个通用寄存器，而RISC(精简指令集计算机)类处理器中通用寄存器数量较多，可超过100个。</p>
<h6 id="指令计数器的值"><a href="#指令计数器的值" class="headerlink" title="指令计数器的值"></a>指令计数器的值</h6><p>其中存放了进程将要执行的下一条指令的地址。</p>
<h6 id="程序状态字PSW"><a href="#程序状态字PSW" class="headerlink" title="程序状态字PSW"></a>程序状态字PSW</h6><p>其中包含CPU运行状态信息，如条件码、中断允许/禁止标志、处理器特权级、任务嵌套标志等。</p>
<h6 id="栈指针"><a href="#栈指针" class="headerlink" title="栈指针"></a>栈指针</h6><p>每个进程都有一到两个与之相关联的栈(用户栈或内核栈)，用于保存过程调用的参数及返回地址、系统调用的参数及调用地址以及为局部变量分配存储空间等。</p>
<h5 id="进程控制信息"><a href="#进程控制信息" class="headerlink" title="进程控制信息"></a>进程控制信息</h5><p>是控制和管理进程所需要的相关信息</p>
<h6 id="进程的程序和数据在内存或外存的地址。"><a href="#进程的程序和数据在内存或外存的地址。" class="headerlink" title="进程的程序和数据在内存或外存的地址。"></a>进程的程序和数据在内存或外存的地址。</h6><h6 id="进程同步信息"><a href="#进程同步信息" class="headerlink" title="进程同步信息"></a>进程同步信息</h6><p>进程运行过程中与其他进程之间发生的各种制约关系。</p>
<h6 id="进程通信信息"><a href="#进程通信信息" class="headerlink" title="进程通信信息"></a>进程通信信息</h6><p>记录进程运行过程中与其他进程之间发生的信息交换情况。</p>
<h6 id="资源管理信息"><a href="#资源管理信息" class="headerlink" title="资源管理信息"></a>资源管理信息</h6><p>描述进程运行过程中资源占有情况，如使用CPU的统计时间、内存占用情况、IO设备使用情况、打开的文件记录等等。</p>
<h6 id="链接指针"><a href="#链接指针" class="headerlink" title="链接指针"></a>链接指针</h6><p>系统为有效管理数量众多的PCB，通常将其组织成相关的队列，某个进程的PCB可能会同时处于多个队列中，如一个就绪进程，其PCB一定在某个就绪队列中，也同时在其父进程的子进程队列中。</p>
<h3 id="进程控制-1"><a href="#进程控制-1" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><h5 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h5><p>进程图是用于描述进程家族关系的有向树，图中的节点代表进程,<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119235243.png" alt="进程图"></p>
<h5 id="引起进程创建的典型事件"><a href="#引起进程创建的典型事件" class="headerlink" title="引起进程创建的典型事件"></a>引起进程创建的典型事件</h5><h6 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h6><p>批处理系统中，提交给系统的作业通常存放在磁盘上，当作业调度程序按一定算法调度某个作业进入内存运行时，必须为该作业创建进程，分配必要的资源，并插入就绪队列。</p>
<h6 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h6><p>交互式系统中，用户从终端登录系统成功时，系统将为该终端用户创建一个进程，如Linux中的 shell进程，负责接收并解释执行用户输入的命令。</p>
<h6 id="提供特定服务"><a href="#提供特定服务" class="headerlink" title="提供特定服务"></a>提供特定服务</h6><p>比如用户进程要求打印一个文件，则系统会创建一个打印进程来完成该请求，用户不必等待打印工作结束就可以继续做其他的事情。</p>
<h6 id="应用请求"><a href="#应用请求" class="headerlink" title="应用请求"></a>应用请求</h6><p>比如一个文件服务器进程，当它监听到某个客户发来的文件下载请求时，可创建一个子进程来完成客户的文件下载请求，而它自己可继续监听其他客户的请求，提高对客户的响应速度。</p>
<h5 id="进程创建原语"><a href="#进程创建原语" class="headerlink" title="进程创建原语"></a>进程创建原语</h5><p>步骤</p>
<h6 id="为新进程申请一个尚未被使用的pid和一个空白PCB。"><a href="#为新进程申请一个尚未被使用的pid和一个空白PCB。" class="headerlink" title="为新进程申请一个尚未被使用的pid和一个空白PCB。"></a>为新进程申请一个尚未被使用的pid和一个空白PCB。</h6><h6 id="为新进程分配必要的资源"><a href="#为新进程分配必要的资源" class="headerlink" title="为新进程分配必要的资源"></a>为新进程分配必要的资源</h6><p>比如建立进程地址空间，为其分配内存空间设置堆栈、存放程序、数据，此外还有文件、I/O设备以及初始时间片长度等。这些资源或者从系统分配，或者从父进程继承或共享。</p>
<h6 id="初始化新进程的PCB"><a href="#初始化新进程的PCB" class="headerlink" title="初始化新进程的PCB"></a>初始化新进程的PCB</h6><p>填入相关信息，如 pid，进程名、父进程标识符、处理器初始状态、进程状态、进程优先级、进程要执行程序的入口地址、进程同步信息、进程地址空间信息、资源分配情况等。</p>
<h6 id="将新进程状态置为就绪状态"><a href="#将新进程状态置为就绪状态" class="headerlink" title="将新进程状态置为就绪状态"></a>将新进程状态置为就绪状态</h6><p>插入就绪队列，等待CPU 调度。</p>
<h4 id="进程撤销"><a href="#进程撤销" class="headerlink" title="进程撤销"></a>进程撤销</h4><h5 id="引起进程撤销的典型事件"><a href="#引起进程撤销的典型事件" class="headerlink" title="引起进程撤销的典型事件"></a>引起进程撤销的典型事件</h5><h6 id="正常结束而撤销"><a href="#正常结束而撤销" class="headerlink" title="正常结束而撤销"></a>正常结束而撤销</h6><h6 id="异常终止而撤销"><a href="#异常终止而撤销" class="headerlink" title="异常终止而撤销"></a>异常终止而撤销</h6><h6 id="应外界干预而撤销"><a href="#应外界干预而撤销" class="headerlink" title="应外界干预而撤销"></a>应外界干预而撤销</h6><p>①操作员或操作系统干预。比如系统发生了死锁，为解除死锁需要撤销一部分死锁进程;或者某进程进入死循环，也需要操作员来撤销它。<br>②父进程请求。当子进程完成父进程指派的工作后，父进程可以请求系统撤销该子进程。<br>③当父进程被撤销时，系统或自动撤销其所有的子孙进程。</p>
<h5 id="进程撤销原语"><a href="#进程撤销原语" class="headerlink" title="进程撤销原语"></a>进程撤销原语</h5><h4 id="进程阻塞与唤醒"><a href="#进程阻塞与唤醒" class="headerlink" title="进程阻塞与唤醒"></a>进程阻塞与唤醒</h4><h5 id="引起进程阻塞和唤醒的典型事件"><a href="#引起进程阻塞和唤醒的典型事件" class="headerlink" title="引起进程阻塞和唤醒的典型事件"></a>引起进程阻塞和唤醒的典型事件</h5><h6 id="请求资源失败"><a href="#请求资源失败" class="headerlink" title="请求资源失败"></a>请求资源失败</h6><h6 id="等待某种操作的完成"><a href="#等待某种操作的完成" class="headerlink" title="等待某种操作的完成"></a>等待某种操作的完成</h6><h6 id="前驱进程尚未完成"><a href="#前驱进程尚未完成" class="headerlink" title="前驱进程尚未完成"></a>前驱进程尚未完成</h6><h6 id="进程无新工作可做"><a href="#进程无新工作可做" class="headerlink" title="进程无新工作可做"></a>进程无新工作可做</h6><h5 id="进程阻塞原语"><a href="#进程阻塞原语" class="headerlink" title="进程阻塞原语"></a>进程阻塞原语</h5><h5 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h5><h4 id="Linux进程管理"><a href="#Linux进程管理" class="headerlink" title="Linux进程管理"></a>Linux进程管理</h4><ul>
<li>fork():<strong>创建一个普通进程，调用一次返回两次:在子进程中返回0，在父进程中返回子进程的pid。</strong></li>
<li>vfork():子进程能共享父进程的地址空间，且父进程会一直阻塞，直到子进程调用exit()终止运行或调用exec()加载另一个可执行文件，即子进程优先运行。</li>
<li>clone():不同于前面两个，它接受一个指向某函数的指针和该函数的参数，刚创建的子进程将马上执行该函数。clone()允许子进程有选择性地继承父进程的资源，因此通常用它来创建线程。</li>
</ul>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h4><h5 id="并发进程间的间接制约关系与进程互斥"><a href="#并发进程间的间接制约关系与进程互斥" class="headerlink" title="并发进程间的间接制约关系与进程互斥"></a>并发进程间的间接制约关系与进程互斥</h5><h6 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h6><p>系统中某些资源一次只允许一个进程使用，这类资源称为临界资源</p>
<h6 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h6><p>Hoare和 Hansen于1972年提出了临界区的概念:每个进程中访问临界资源的那段代码称为临界区。<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120000523.png" alt="临界区"></p>
<h6 id="同步机制应遵循的原则"><a href="#同步机制应遵循的原则" class="headerlink" title="同步机制应遵循的原则"></a>同步机制应遵循的原则</h6><ul>
<li><p>空闲让进<br>当没有进程处于临界区时，相应的临界资源为空闲状态，因而应允许任何一个请求进入临界区的进程立即进入自己的临界区,以有效利用资源。</p>
</li>
<li><p>忙则等待<br>当已有进程进入临界区时，表示相应的临界资源正被访问，因而所有其他试图进入相关临界区的进程必须等待，以保证诸进程互斥访问临界资源。</p>
</li>
<li><p>有限等待<br>对要求访问临界资源的进程，应保证该进程能在有限的时间内进入自己的临界区，以免陷入“永远等待”状态。</p>
</li>
<li><p>让权等待<br>当进程不能进入临界区时，应立即释放CPU，以免CPU陷入“忙等”状态，以提高CPU利用率。</p>
</li>
</ul>
<h5 id="并发进程间的直接制约关系与进程同步"><a href="#并发进程间的直接制约关系与进程同步" class="headerlink" title="并发进程间的直接制约关系与进程同步"></a>并发进程间的直接制约关系与进程同步</h5><p>进程同步实际上就是相互合作的进程在某些关键点上相互等待和互通信息。</p>
<h4 id="进程同步机制及应用"><a href="#进程同步机制及应用" class="headerlink" title="进程同步机制及应用"></a>进程同步机制及应用</h4><h5 id="利用硬件方法解决进程互斥问题"><a href="#利用硬件方法解决进程互斥问题" class="headerlink" title="利用硬件方法解决进程互斥问题"></a>利用硬件方法解决进程互斥问题</h5><h6 id="禁止中断"><a href="#禁止中断" class="headerlink" title="禁止中断"></a>禁止中断</h6><h6 id="利用专用机器指令解决进程互斥问题"><a href="#利用专用机器指令解决进程互斥问题" class="headerlink" title="利用专用机器指令解决进程互斥问题"></a>利用专用机器指令解决进程互斥问题</h6><ul>
<li>TSL指令</li>
<li>Swap指令<ul>
<li>违反让权等待</li>
<li>产生饥饿现象</li>
</ul>
</li>
</ul>
<h5 id="利用软件方法解决进程互斥问题"><a href="#利用软件方法解决进程互斥问题" class="headerlink" title="利用软件方法解决进程互斥问题"></a>利用软件方法解决进程互斥问题</h5><h6 id="不正确的软件算法"><a href="#不正确的软件算法" class="headerlink" title="不正确的软件算法"></a>不正确的软件算法</h6><ul>
<li>既然不正确就不做笔记了</li>
</ul>
<h6 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h6><h6 id="面包店算法"><a href="#面包店算法" class="headerlink" title="面包店算法"></a>面包店算法</h6><h5 id="利用锁机制解决进程互斥问题"><a href="#利用锁机制解决进程互斥问题" class="headerlink" title="利用锁机制解决进程互斥问题"></a>利用锁机制解决进程互斥问题</h5><h5 id="利用信号量机制解决进程互斥与同步问题"><a href="#利用信号量机制解决进程互斥与同步问题" class="headerlink" title="利用信号量机制解决进程互斥与同步问题"></a>利用信号量机制解决进程互斥与同步问题</h5><h6 id="整型信号量机制"><a href="#整型信号量机制" class="headerlink" title="整型信号量机制"></a>整型信号量机制</h6><p>P/V两个原语操作:Р操作源于荷兰语Proberen(测试)，V操作源于荷兰语Verhogen(增加)，但后来的系统中通常称Р操作为down()或wait()，称V操作为up()或signal()，在本书中使用wait(和 signal()表示这两个原语操作。</p>
<ul>
<li>p = wait</li>
<li>v = signal</li>
</ul>
<h6 id="记录型信号量机制"><a href="#记录型信号量机制" class="headerlink" title="记录型信号量机制"></a>记录型信号量机制</h6><h6 id="信号量集机制"><a href="#信号量集机制" class="headerlink" title="信号量集机制"></a>信号量集机制</h6><h6 id="利用信号量机制实现进程的互斥"><a href="#利用信号量机制实现进程的互斥" class="headerlink" title="利用信号量机制实现进程的互斥"></a>利用信号量机制实现进程的互斥</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120001705.png" alt="利用信号量机制实现进程的互斥"></p>
<h4 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h4><h5 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h5><h5 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h5><h5 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h5><h5 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h5><h4 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h4><h5 id="管程定义"><a href="#管程定义" class="headerlink" title="管程定义"></a>管程定义</h5><ul>
<li>管程是一种需要编译器支持的进程同步机制</li>
<li>Hansen给出的管程定义是:“一个管程定义了一个数据结构和能为并发进程(在该数据结构上)所执行的一组操作，这组操作能同步进程和改变管程中的数据”。<ul>
<li>“数据结构”是对系统中各种共享软硬件资源的抽象描述，</li>
<li>针对该数据结构所定义的一组操作则用来实现进程间的同步及各进程对该共享资源所需进行的多种不同操作。</li>
</ul>
</li>
<li>管程是一个软件模块<ul>
<li>①管程的名字</li>
<li>②局部于管程的共享数据结构的说明</li>
<li>③对该数据结构进行操作的一组过程，每个过程完成进程对上述数据结构的某种操作</li>
<li>④对局部于管程的共享数据结构进行初始化的代码。管程的语法结构描述如下:</li>
</ul>
</li>
<li>特征<ul>
<li>局部于管程的数据结构只能被管程内的过程访问，任何外部过程不能访问;而管程内的过程也只能访问该管程内部的数据结构。</li>
<li>一个进程若想访问管程内的数据结构(共享资源)，只能通过调用管程内的某个过程实现间接访问。</li>
<li>任一时刻，管程中只能有一个活跃进程，即只能有一个进程在管程中执行管程的某个过程，其他任何调用管程的进程都将被阻塞，直到管程变成可用，这一特性使管程能有效地实现互斥。</li>
</ul>
</li>
</ul>
<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><h5 id="利用管程机制解决生产者-消费者问题"><a href="#利用管程机制解决生产者-消费者问题" class="headerlink" title="利用管程机制解决生产者-消费者问题"></a>利用管程机制解决生产者-消费者问题</h5><h4 id="Linux同步机制解析"><a href="#Linux同步机制解析" class="headerlink" title="Linux同步机制解析"></a>Linux同步机制解析</h4><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="进程调度的基本概念"><a href="#进程调度的基本概念" class="headerlink" title="进程调度的基本概念"></a>进程调度的基本概念</h4><h5 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h5><h6 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h6><ul>
<li>高级调度又称作业调度或长程调度</li>
<li>任务是根据系统的资源情况，按照一定的原则从外存上的后备队列中选择若干个作业调入内存</li>
<li>高级调度的运行频率较低，通常是以<strong>分钟</strong>甚至是<strong>小时为计时单位</strong>。</li>
<li>考虑两个问题<ul>
<li>第一，选择多少个作业进入内存。</li>
<li>第二，选择哪些作业进入内存。</li>
</ul>
</li>
</ul>
<h6 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h6><ul>
<li>低级调度通常称为进程调度，有时也称短程调度<br>任务是决定就绪队列中的哪个进程获得处理器，然后由分派程序把处理器分配给该进程，并为它恢复运行现场，让其运行。</li>
<li>进程调度的运行频率很高，通常是<strong>十几毫秒</strong>就要运行一次，因而其调度算法也备受关注。</li>
<li>它是系统中最基本的一种调度，进程只有通过进程调度才能获得处理器运行，现代操作系统都具有进程调度功能。</li>
</ul>
<h6 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h6><ul>
<li>中程调度。引入中级调度的主要目的是为了提高内存利用率和系统吞吐量。</li>
<li>当内存紧张时，就将那些暂时不能运行的进程(如处于阻塞状态的进程)换出到外存，回收其内存空间给别的进程，通常称此时的进程状态为挂起状态;当内存空间较充裕时，又从外存选择若干具备运行条件的挂起进程换入到内存。</li>
<li>中级调度其实就是存储器管理中的对换功能，故又称为<strong>对换调度</strong></li>
<li>发生的频率一般是<strong>几秒钟</strong>一次。</li>
<li>当存储管理机制中引入虚拟存储技术后，进程在内外存之间交换的内容通常是<strong>其部分代码或数据</strong>，而不是整个进程映像。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120003218.png" alt="三种调度的关系"></p>
<h5 id="进程调度功能"><a href="#进程调度功能" class="headerlink" title="进程调度功能"></a>进程调度功能</h5><h6 id="排队程序"><a href="#排队程序" class="headerlink" title="排队程序"></a>排队程序</h6><h6 id="分派程序"><a href="#分派程序" class="headerlink" title="分派程序"></a>分派程序</h6><h6 id="上下文切换程序"><a href="#上下文切换程序" class="headerlink" title="上下文切换程序"></a>上下文切换程序</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120003415.png" alt="调度模块的功能"></p>
<h5 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h5><h6 id="非抢占方式"><a href="#非抢占方式" class="headerlink" title="非抢占方式"></a>非抢占方式</h6><ul>
<li>优点是<ul>
<li>实现简单且</li>
<li>系统开销小</li>
</ul>
</li>
<li>缺点<ul>
<li>不能保证紧迫型任务(如实时进程)得到及时处理。</li>
</ul>
</li>
</ul>
<h6 id="抢占方式"><a href="#抢占方式" class="headerlink" title="抢占方式"></a>抢占方式</h6><p>剥夺的原则可以是优先级、时间片或进程还需要的运行时间等，如在<strong>实时系统中常采用优先级原则</strong>，而在<strong>分时系统中通常采用时间片原则</strong>。</p>
<ul>
<li>优点<ul>
<li>可以防止一个进程长期占用CPU</li>
<li>为系统中的全体进程提供更好的服务</li>
</ul>
</li>
<li>缺点<ul>
<li>系统开销比非抢占方式大，因为进程调度和切换的频率更高。</li>
</ul>
</li>
</ul>
<h5 id="进程调度时机"><a href="#进程调度时机" class="headerlink" title="进程调度时机"></a>进程调度时机</h5><h6 id="当前运行进程已完成所有工作任务而结束，或者由于某种错误而被终止运行。"><a href="#当前运行进程已完成所有工作任务而结束，或者由于某种错误而被终止运行。" class="headerlink" title="当前运行进程已完成所有工作任务而结束，或者由于某种错误而被终止运行。"></a>当前运行进程已完成所有工作任务而结束，或者由于某种错误而被终止运行。</h6><h6 id="当前运行进程因需要等待某事件的发生而转变成阻塞状态，如等待IO操作的完成，或执行信号量的wait-操作时因条件不满足而被阻塞等。"><a href="#当前运行进程因需要等待某事件的发生而转变成阻塞状态，如等待IO操作的完成，或执行信号量的wait-操作时因条件不满足而被阻塞等。" class="headerlink" title="当前运行进程因需要等待某事件的发生而转变成阻塞状态，如等待IO操作的完成，或执行信号量的wait()操作时因条件不满足而被阻塞等。"></a>当前运行进程因需要等待某事件的发生而转变成阻塞状态，如等待IO操作的完成，或执行信号量的wait()操作时因条件不满足而被阻塞等。</h6><h6 id="在分时系统中，当前运行进程时间片用完。"><a href="#在分时系统中，当前运行进程时间片用完。" class="headerlink" title="在分时系统中，当前运行进程时间片用完。"></a>在分时系统中，当前运行进程时间片用完。</h6><h6 id="采用基于优先级的抢占方式调度，当就绪队列中出现优先级更高的就绪进程时。"><a href="#采用基于优先级的抢占方式调度，当就绪队列中出现优先级更高的就绪进程时。" class="headerlink" title="采用基于优先级的抢占方式调度，当就绪队列中出现优先级更高的就绪进程时。"></a>采用基于优先级的抢占方式调度，当就绪队列中出现优先级更高的就绪进程时。</h6><h6 id="系统完成系统调用或中断处理后，在返回到用户态之前，通常会产生一次调度时机。"><a href="#系统完成系统调用或中断处理后，在返回到用户态之前，通常会产生一次调度时机。" class="headerlink" title="系统完成系统调用或中断处理后，在返回到用户态之前，通常会产生一次调度时机。"></a>系统完成系统调用或中断处理后，在返回到用户态之前，通常会产生一次调度时机。</h6><h5 id="选择进程调度方式及调度算法应考虑的因素"><a href="#选择进程调度方式及调度算法应考虑的因素" class="headerlink" title="选择进程调度方式及调度算法应考虑的因素"></a>选择进程调度方式及调度算法应考虑的因素</h5><h6 id="系统设计目标"><a href="#系统设计目标" class="headerlink" title="系统设计目标"></a>系统设计目标</h6><ul>
<li>批处理系统应尽量提高各种资源，(尤其是CPU)的利用率、增加系统吞吐量及缩短作业的平均周转时间</li>
<li>交互式系统应能及时响应各用户的请求，让它们获得均衡的响应时间，尤其当系统中有大量进程并发运行时，应使每个用户感觉不到明显的延迟</li>
<li>实时系统必须保证各实时任务能得到及时、可靠的处理网络系统应使各网络用户方便、快速、安全地共享网络资源。<h6 id="调度的公平性"><a href="#调度的公平性" class="headerlink" title="调度的公平性"></a>调度的公平性</h6>一方面系统要考虑不同类型的进程应具有不同的优先级，保证紧迫型任务得到优先调度;另一方面也要尽量使系统中每个进程都能相对公平地共享CPU及其他系统资源，避免某些低优先级进程的任务完成时间被无限期地推迟。</li>
</ul>
<h6 id="资源的均衡利用"><a href="#资源的均衡利用" class="headerlink" title="资源的均衡利用"></a>资源的均衡利用</h6><h6 id="合理的系统开销"><a href="#合理的系统开销" class="headerlink" title="合理的系统开销"></a>合理的系统开销</h6><h5 id="调度性能的评价指标"><a href="#调度性能的评价指标" class="headerlink" title="调度性能的评价指标"></a>调度性能的评价指标</h5><h6 id="CPU的利用率"><a href="#CPU的利用率" class="headerlink" title="CPU的利用率"></a>CPU的利用率</h6><h6 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h6><h6 id="周转时间和带权周转时间"><a href="#周转时间和带权周转时间" class="headerlink" title="周转时间和带权周转时间"></a>周转时间和带权周转时间</h6><p><strong>周转时间是指从作业提交给系统到作业处理完成所经历的时间</strong>，是评价批处理系统调度性能的重要指标之一，包括作业在外存后备队列中等待进入内存的时间、进程在就绪队列中等待CPU调度的时间、在CPU上执行的时间、在阻塞队列中等待IO完成或等待其他事件发生的时间之和。一组作业周转时间的平均值称为该组作业的平均周转时间。<br>带权周转时间在评价系统调度性能时，会同时考虑作业的周转时间及其要求服务时间，<strong>它是作业的周转时间与要求服务时间的比值</strong>，能更准确地反映用户的感受。</p>
<h6 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h6><p>是指从用户提交一个请求开始，到系统首次对该请求产生响应为止的时间间隔，是评价<strong>交互式系统</strong>调度性能的一个非常重要的指标。</p>
<h6 id="对截止时间的保证"><a href="#对截止时间的保证" class="headerlink" title="对截止时间的保证"></a>对截止时间的保证</h6><p>实时系统中的<strong>实时任务</strong>通常都对应一个截止时间，系统能否保证各实时任务在截止时间完成是评价实时系统调度性能的一个很关键的指标。</p>
<h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><h5 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h5><ul>
<li>先来先服务调度算法(First-Come，First-Served，FCFS)是一种最简单的调度算法，可同时用于作业调度及进程调度。</li>
</ul>
<h5 id="短作业优先调度算法"><a href="#短作业优先调度算法" class="headerlink" title="短作业优先调度算法"></a>短作业优先调度算法</h5><ul>
<li>短作业优先调度算法(Shortest-Job-First，SJF)对作业调度和进程调度都适用</li>
<li>SJF 算法能获得最短的平均周转时间。</li>
<li>缺点<ul>
<li>实现上有问题</li>
<li>不公平的调度算法</li>
<li>没有考虑任务的紧迫程度</li>
</ul>
</li>
</ul>
<h5 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h5><ul>
<li>高响应比优先调度算法(Highest Response Ratio First,HRRF)在调度时既考虑作业(进程)的要求服务时间，同时也会考虑它们在后备队列或就绪队列中的等待时间。</li>
</ul>
<h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><ul>
<li>缺点<ul>
<li>计算优先级有系统开销</li>
<li>不能保证紧迫型任务得到及时处理</li>
</ul>
</li>
</ul>
<h5 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h5><p>时间片长度需要考虑的因素</p>
<ul>
<li>系统的响应时间。</li>
<li>就绪进程的数量。<br>就绪进程越多，为获得较满意的响应时间，时间片应适当缩短。(3)进程调度及上下文切换的时间开销。目前的切换开销一般在10 us左右，而常用的时间片长度是几十毫秒，因此切换时间只占时间片的很小部分。</li>
<li>CPU运行指令的速度。<br>CPU运行速度越快，时间片可适当缩短。</li>
</ul>
<h5 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h5><h6 id="每个队列有自己独立的调度算法"><a href="#每个队列有自己独立的调度算法" class="headerlink" title="每个队列有自己独立的调度算法"></a>每个队列有自己独立的调度算法</h6><p>比如实时进程队列采用<strong>抢占方式的优先级</strong>调度算法，系统进程队列采用非抢占方式的优先级调度算法<br>交互式进程队列采用<strong>时间片轮转调度算法</strong><br>批处理进程采用先来先服务调度算法或短作业优先调度算法等</p>
<h6 id="各队列之间的优先级不同"><a href="#各队列之间的优先级不同" class="headerlink" title="各队列之间的优先级不同"></a>各队列之间的优先级不同</h6><h6 id="进程所在队列固定"><a href="#进程所在队列固定" class="headerlink" title="进程所在队列固定"></a>进程所在队列固定</h6><p>系统根据进程的属性，如进程类型、优先级等，将进程永久地分配到一个固定队列中，即只要该进程处于就绪状态，就一定位于最初所分配的就绪队列中。</p>
<ul>
<li>优点<ul>
<li>实现简单</li>
<li>调度开销小</li>
</ul>
</li>
<li>缺点<ul>
<li>不够灵活且低优先级队列中的进程容易产生“饥饿”现象。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120005304.png" alt="多级队列调度算法"></p>
<h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>Unix采用<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120145926.png" alt="多级反馈"></p>
<h6 id="设置多个就绪队列"><a href="#设置多个就绪队列" class="headerlink" title="设置多个就绪队列"></a>设置多个就绪队列</h6><h6 id="各队列内部按时间片轮转算法进行调度"><a href="#各队列内部按时间片轮转算法进行调度" class="headerlink" title="各队列内部按时间片轮转算法进行调度"></a>各队列内部按时间片轮转算法进行调度</h6><h6 id="各队列之间采用抢占式优先级算法调度"><a href="#各队列之间采用抢占式优先级算法调度" class="headerlink" title="各队列之间采用抢占式优先级算法调度"></a>各队列之间采用抢占式优先级算法调度</h6><h4 id="Linux调度算法解析"><a href="#Linux调度算法解析" class="headerlink" title="Linux调度算法解析"></a>Linux调度算法解析</h4><p>CFS调度器</p>
<h3 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h3><ul>
<li>一些通信原语之类的？感觉不是很难</li>
</ul>
<h4 id="进程通信类型"><a href="#进程通信类型" class="headerlink" title="进程通信类型"></a>进程通信类型</h4><h4 id="消息缓冲队列通信机制"><a href="#消息缓冲队列通信机制" class="headerlink" title="消息缓冲队列通信机制"></a>消息缓冲队列通信机制</h4><h4 id="Linux进程通信机制"><a href="#Linux进程通信机制" class="headerlink" title="Linux进程通信机制"></a>Linux进程通信机制</h4><h3 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h3><h4 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h4><h5 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h5><p>综上所述，若系统中存在一组进程(两个或两个以上)，且它们中的每一个都无限等待被该组进程中另一进程所占用的且永远无法释放的资源,那么这种现象就称为进程“死锁”，或说这一组进程处于“死锁”状态。</p>
<h5 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h5><h6 id="竞争资源"><a href="#竞争资源" class="headerlink" title="竞争资源"></a>竞争资源</h6><p>资源的分类</p>
<ul>
<li>可重用资源<ul>
<li>一次只能被一个进程安全地使用，且使用后资源不会减少。</li>
<li>一个可重用资源被某进程释放后，可立即分配给其他进程再次使用</li>
<li>如系统中的处理器、主存、辅存、各种外设等硬件资源，以及文件、数据库和信号量等各种软件资源。</li>
</ul>
</li>
<li>消耗性资源<ul>
<li>被进程使用以及使用后就消失的资源</li>
<li>如中断、信号、消息等。</li>
</ul>
</li>
<li>可重用资源又可进一步分为<ul>
<li>可剥夺资源<ul>
<li>可剥夺资源是指状态可以被保存和恢复的资源</li>
<li>这类资源若已经分配给某进程且还没有被使用完毕，则系统可以根据需要强制性地剥夺该进程对这个资源的使用权并分配给其他进程，这种剥夺不会对该进程的运行造成有害影响</li>
<li>如处理器、主存等。如分时系统中当前运行进程时间片到时即便没有运行完成，系统也会把处理器分配给另外一个就绪进程执行。</li>
</ul>
</li>
<li>不可剥夺资源<ul>
<li>不可剥夺资源是指若该类资源被分配给某进程使用，则必须等到该进程使用完毕主动归还给系统后才能再次分配给其他进程，如果强制剥夺，则会对当前使用进程造成有害影响</li>
<li>如绘图仪、打印机、磁带机、文件、数据库、队列等。多个进程对可剥夺资源的竞争不会引起死锁，但对不可剥夺资源的竞争则可能导致<strong>死锁</strong>的发生.</li>
</ul>
</li>
</ul>
</li>
<li>多个进程在竞争消耗性资源时也可能引起死锁。</li>
</ul>
<h6 id="进程推进顺序不当"><a href="#进程推进顺序不当" class="headerlink" title="进程推进顺序不当"></a>进程推进顺序不当</h6><h5 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h5><h6 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h6><p>某个资源在一段时间内只能由一个进程占用，一旦将其分配给某进程后，必须等待该进程使用完成且主动释放它之后，才能再次分配给其他进程使用。</p>
<h6 id="占有且等待条件"><a href="#占有且等待条件" class="headerlink" title="占有且等待条件"></a>占有且等待条件</h6><p>进程已占有至少一个资源，又申请新的资源，由于该资源已被分配给别的进程，则该进程阻塞，但它在等待新资源时，仍继续占有已分到的资源。</p>
<h6 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h6><p>一个进程所占有的不可剥夺资源在它使用完之前，系统不能强行剥夺，只能由该进程使用完之后主动释放。</p>
<h6 id="循环等待条件"><a href="#循环等待条件" class="headerlink" title="循环等待条件"></a>循环等待条件</h6><p>系统中若干进程之间对资源的占有和请求形成了循环等待的关系，此时环路中的每个进程都已经占有一些资源，同时又在等待其相邻进程所占有的资源。<br>由于这四个条件是由 Edward G.Coffman，Jr.于 1971年首次提出的，因此又称为Coffman条件。<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120010153.png" alt="循环等待条件示意图"></p>
<h5 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h5><h6 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h6><p>进程申请资源或系统分配资源时必须遵循某些预先设置的限制条件，以破坏产生死锁的四个必要条件的一个或几个，防止死锁发生。该方法容易实现，但由于严格限制了系统资源的分配和使用，造成资源利用率较低。</p>
<h6 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h6><p>该方法并不事先采取各种限制措施去破坏产生死锁的必要条件，而是在进行资源分配的过程中，用某种方法防止系统进入<strong>不安全状态</strong>，从而避免发生死锁。所谓不安全状态，是指有可能导致系统发生死锁的状态。这种方法所加限制条件较预防死锁策略少，可获得相对较高的资源利用率和系统吞吐量。</p>
<h6 id="检测和解除死锁"><a href="#检测和解除死锁" class="headerlink" title="检测和解除死锁"></a>检测和解除死锁</h6><p>该方法不采取任何限制性措施，进行资源分配时也不检查分配的安全性，只要系统有空闲资源就可以分配，它允许系统在运行过程中产生死锁。但系统中会设置死锁检测机构，及时地检测出系统是否出现死锁，并确定与死锁有关的进程和资源;一旦检测到系统已出现死锁，立即采取相应的措施解除死锁。这种方法没有限制条件，能最大限度地利用资源，但实现难度也最大。</p>
<h4 id="预防死锁-1"><a href="#预防死锁-1" class="headerlink" title="预防死锁"></a>预防死锁</h4><h5 id="破坏占有且等待条件"><a href="#破坏占有且等待条件" class="headerlink" title="破坏占有且等待条件"></a>破坏占有且等待条件</h5><h5 id="破坏不可剥夺条件"><a href="#破坏不可剥夺条件" class="headerlink" title="破坏不可剥夺条件"></a>破坏不可剥夺条件</h5><h5 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h5><h4 id="避免死锁-1"><a href="#避免死锁-1" class="headerlink" title="避免死锁"></a>避免死锁</h4><h5 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h5><p>安全状态定义:设系统中有n个进程，若存在一个进程序列$<P_1，P_2，…，P_i，…，P_n>$。使得进程$P_i$(i= 1，2，…，n)以后还需要的资源可以通过系统现有空闲资源加上所有P_j($j<i$)已占有的资源来满足，则称此时系统处于安全状态，进程序列$<P_1，P_2，…，P_i，…，P_n>$<br>称为<strong>安全序列</strong>，因为各进程至少可以按照安全序列中的顺序依次执行完成。<br>若某时刻系统处于安全状态，则它的安全序列可能不止一个，只要能找到其中的一个，就可判断当前系统是处于<strong>安全状态</strong>;反之，若一个安全序列都找不到，则称当前系统处于<strong>不安全状态</strong>。<br>系统进入不安全状态后虽然<strong>未必一定会发生死锁</strong>，但已经存在死锁的可能性了。</p>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><h5 id="bigstar-银行家算法举例"><a href="#bigstar-银行家算法举例" class="headerlink" title="$\bigstar$ 银行家算法举例"></a>$\bigstar$ 银行家算法举例</h5><p>看慕课的视频</p>
<h4 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h4><h5 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h5><h5 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h5><h5 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h5><h5 id="死锁检测时机"><a href="#死锁检测时机" class="headerlink" title="死锁检测时机"></a>死锁检测时机</h5><h5 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h5><h3 id="线程机制"><a href="#线程机制" class="headerlink" title="线程机制"></a>线程机制</h3><ul>
<li>重要的线程模型有哪些？</li>
</ul>
<h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><h5 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h5><p>作为调度和执行的基本单位，不再是资源分配与拥有的单位，减少管理开销，且降低通信机制及同步机制的复杂度;而对资源分配与拥有的基本单位，又不进行频繁地切换处理，以减少CPU切换开销。</p>
<h5 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h5><ul>
<li>在引入线程的操作系统中，线程是隶属于进程的一个实体，是比进程更小的一个运行单位。</li>
<li>一个进程可以有一个或多个线程,这些<strong>线程共享该进程所拥有的资源</strong>,如地址空间(代码、数据及文件)、大部分管理信息(子进程、定时器、信号等)以及IO设备等</li>
<li>同时每个线程也有自己的一些必不可少的资源:<ul>
<li>①一个线程 ID，用以唯一地标识线程。</li>
<li>②一组寄存器集合:表示线程运行时的处理器状态，包括程序计数器、程序状态字、通用寄存器、栈指针等。</li>
<li>③两个栈:一个用户栈与一个内核栈，分别供线程在用户态及内核态下运行时使用。</li>
<li>④一个私有存储区:存放线程很少的私有数据。如全局变量errno，当某个线程的系统调用失败返回时，其错误码存放在errno中，若进程中所有线程都共享该变量，则必然会造成混乱。</li>
<li>⑤线程控制块TCB:存放线程的管理信息，如线程ID、寄存器的值、线程状态、调度优先级、相关统计信息、信号掩码等。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120115427.png" alt="线程与进程的资源关系图"></p>
<h5 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h5><h5 id="多线程的应用"><a href="#多线程的应用" class="headerlink" title="多线程的应用"></a>多线程的应用</h5><h4 id="线程的实现机制"><a href="#线程的实现机制" class="headerlink" title="线程的实现机制"></a>线程的实现机制</h4><h5 id="用户级线程ULT-User-LevelThreads"><a href="#用户级线程ULT-User-LevelThreads" class="headerlink" title="用户级线程ULT(User LevelThreads)"></a>用户级线程ULT(User LevelThreads)</h5><p>用户级线程是在用户空间中实现的。在这种方式下，线程的创建、撤销、切换、同步、通信以及线程状态的转换等操作全部由支持线程的一组应用程序代码完成，该组代码称为<strong>线程库</strong>(又称为<strong>运行时系统</strong>)，运行在用户空间。<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120115721.png" alt="用户级线程"></p>
<ul>
<li>优点<ul>
<li>线程切换速度快</li>
<li>调度算法可以是应用程序专用的</li>
<li>用户级线程可运行在任何操作系统上，不管该系统是否支持线程机制</li>
</ul>
</li>
<li>存在的问题<ul>
<li>线程系统调用的阻塞问题。<ul>
<li>在典型的操作系统中，许多系统调用都会引起阻塞。当一个用户级线程执行系统调用时，会引起整个进程的阻塞，因为操作系统会把这次系统调用看成是整个进程的行为。</li>
</ul>
</li>
<li>纯用户级线程机制不能利用多处理器的优势。</li>
</ul>
</li>
</ul>
<h5 id="内核级线程KLT-Kernel-LevelThreads"><a href="#内核级线程KLT-Kernel-LevelThreads" class="headerlink" title="内核级线程KLT(Kernel LevelThreads)"></a>内核级线程KLT(Kernel LevelThreads)</h5><ul>
<li>内核级线程是在内核空间实现的。</li>
<li>在这种方式下，线程的创建、撤销、调度切换、通信、同步以及线程状态的转换等操作全部由系统内核完成。</li>
<li>在内核中有一个进程表记录系统中所有进程的信息，同时有一个线程表，记录系统中每个线程的情况。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120115823.png" alt="内核级线程"></p>
<ul>
<li>优点<ul>
<li>线程执行系统调用时，仅阻塞调用线程本身，不必阻塞整个进程，进程中其他线程仍然可以获得CPU运行。</li>
<li>在多处理器环境下，一个进程中的多个线程可以同时在多个CPU上并行执行,提高了进程的执行速度。</li>
<li>操作系统内核本身可以采用多线程机制，从而提高系统的运行效率。</li>
</ul>
</li>
<li>缺点<ul>
<li>开销大</li>
</ul>
</li>
</ul>
<h5 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h5><h6 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h6><p>该模型把多个用户级线程(通常属于一个进程)映射到一个内核级线程上，如图3-56所示。对用户级线程的管理是由线程库在用户空间进行的，仅当它们需要访问内核时，才将其映射到一个内核级线程上，且每次只允许一个用户级线程进行映射。</p>
<ul>
<li>优点<ul>
<li>线程管理开销小</li>
<li>效率高</li>
</ul>
</li>
<li>缺点<ul>
<li>但如果一个线程因执行系统调用而阻塞，将导致整个进程阻塞</li>
<li>因为任一时刻只有一个线程能访问内核，所以多个线程不能并行运行在多个处理器上。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120120327.png" alt="多对一线程机制"></p>
<h6 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h6><p>该模型把一个用户级线程映射到一个内核级线程上，如图3-57所示。这样，当某个线程因执行系统调用而阻塞时，不会导致整个进程阻塞，其他线程可继续运行;此外，在多处理器环境中，也允许多个线程同时在多个处理器上并行运行。但一对一模型要求每创建一个用户级线程就必须为其建立对应的内核级线程，<strong>开销较大</strong>，因此往往要限制系统中的线程数量。Linux、Windows 家族、OS/2、Solaris 9及更高的版本就采用的这种模型。<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120120340.png" alt="一对一线程模型"></p>
<h6 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h6><p><strong>该模型把多个用户级线程映射到较少或同样数量的内核级线程上</strong>，如图3-58所示。<strong>内核级线程的数量可随应用程序的特点及机器配置而变化</strong>，比如多处理器系统中可设置更多的内核级线程。多对多模型克服了前面两种模型的缺点，程序员可以根据需要创建多个用户级线程，当一个线程执行系统调用被阻塞时，内核可调度另一个线程来运行。IRIX、HP-Unix、Tru64 Unix等操作系统在实现多对多模型时进行了一些改进:既可把多个用户级线程映射到较少或同样数量的内核级线程上，又允许将一个用户级线程绑定到某个内核级线程上，从而保证该用户级线程能随时访问内核。<br>许多实现多对多模型的系统在用户级线程与内核级线程之间设置了一级中间结构，通常是<strong>轻量级进程(LWP)</strong>，如图3-59所示。LWP可共享所属进程的资源，同时还有自己的资源:TCB(记录线程ID、优先级、状态、寄存器值、与之相连的内核级线程的指针等)、栈、私有存储区等，保存在进程地址空间中，因此LWP对用户进程是可见的。每个LWP都与一个内核级线程相连，该内核级线程能被操作系统调度到CPU上运行。对于用户空间的线程库，LWP表现为线程库可以调度用户级线程到其上运行的虚拟处理器。这样，用户级线程可以通过LWP访问内核，不过内核只能看到内核级线程与用户进程中的LWP，不知道用户级线程的存在。当用户级线程不需要访问内核时，其管理工作全部由线程库完成;而当要访问内核时，必须由线程库为其分配一个LWP，借助LWP完成内核访问工作，如执行一个系统调用。如果内核级线程阻塞(如等待一次IO操作的完成)，则与之相连的LWP也阻塞，进而使与该LWP相连的用户级线程也阻塞。为使进程中的多个用户级线程能同时访问内核，可在进程中设置多个LWP(考虑到系统开销,数量也不能太多),组成“LWP池”，让这些线程多路复用LWP，这样当一个LWP阻塞时，其他LWP还能继续工作，从而提高系统的并行性。当然，也允许一些完成紧迫型任务的用户级线程“绑定”到LWP池中一个固定的LWP上，保证这些线程及时访问内核，但会增加系统开销。<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120120352.png" alt="多对多线程模型"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120120405.png" alt="LWP的多对多模型"></p>
<h4 id="Linux线程机制"><a href="#Linux线程机制" class="headerlink" title="Linux线程机制"></a>Linux线程机制</h4><h3 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h3><ul>
<li>考点基本在信号量上(大题)</li>
<li>银行家算法</li>
</ul>
<h3 id="本章习题-2"><a href="#本章习题-2" class="headerlink" title="本章习题"></a>本章习题</h3><h4 id="考研辅导书2021版本"><a href="#考研辅导书2021版本" class="headerlink" title="考研辅导书2021版本"></a>考研辅导书2021版本</h4><h5 id="线程的描述"><a href="#线程的描述" class="headerlink" title="线程的描述"></a>线程的描述</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135012.png" alt="线程的描述-题目及答案"></p>
<h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p>线程是处理机调度的基本单位，当然可以独立执行程序，A对;线程没有自己独立的地址空间，它共享其所属进程的空间，B错;进程可以创建多个线程，C错;与进程之间线程的通信可以直接通过它们共享的存储空间，D错。</p>
<h5 id="进程的状态可能性"><a href="#进程的状态可能性" class="headerlink" title="进程的状态可能性"></a>进程的状态可能性</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135204.png" alt="进程的状态可能性-题目及答案"></p>
<h6 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h6><p>选项B错在优先级分静态和动态两种，动态优先级是根据运行情况而随时调整的。选项C错在系统发生死锁时有可能进程全部都处于阻塞态，或无进程任务，CPU空闲。选项D错在进程申请处理器得不到满足咐就处于就绪态，等待处理器的调度。</p>
<h5 id="管理进程的方法"><a href="#管理进程的方法" class="headerlink" title="管理进程的方法"></a>管理进程的方法</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135320.png" alt="管理进程的方法-题目及答案"></p>
<h6 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h6><p>在进程的整个生命周期中，系统总是通过其 PCB对进程进行控制。也就是说，系统是根据进程的PCB而非任何其他因素来感知到进程存在的，PCB是进程存在的唯一标志。同时PCB常驻内存。A和D选项的内容都包含在进程PCB中。</p>
<ul>
<li>容易选D</li>
</ul>
<h5 id="就绪队列中进程的数量"><a href="#就绪队列中进程的数量" class="headerlink" title="就绪队列中进程的数量"></a>就绪队列中进程的数量</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135511.png" alt="就绪队列中进程的数量-题目及答案"></p>
<h6 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h6><p>不可能出现这样﹒种情况。总处理器系统的10个进程都处于就绪态，但9个处于就绪态、I个正在运行是可能存在的。还要想到，可能{0个进程都处于阻塞态。</p>
<h5 id="进程状态改变的数量"><a href="#进程状态改变的数量" class="headerlink" title="进程状态改变的数量"></a>进程状态改变的数量</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135537.png" alt="进程状态改变的数量-题目及答案"></p>
<h6 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h6><p>由于打印机独占资源，当一个进程释放打印机后，另一个等待打印机的进程就可能从阻塞态转到就绪态。<br>当然，也存在一个进程执行完毕后巾运行态转为结束态时释放打印机的情况，但这并不是由于释放打印机引起的，相反是因为运行完成才释放了打印机。</p>
<ul>
<li>容易选D</li>
</ul>
<h5 id="bigtriangledown-就绪态的特点"><a href="#bigtriangledown-就绪态的特点" class="headerlink" title="$\bigtriangledown$ 就绪态的特点"></a>$\bigtriangledown$ 就绪态的特点</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135653.png" alt="就绪态的特点-题目及答案"></p>
<h5 id="进程执行的特点"><a href="#进程执行的特点" class="headerlink" title="进程执行的特点"></a>进程执行的特点</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135759.png" alt="进程执行的特点-题目及答案"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120135854.png" alt="进程执行的特点-题目及答案2"></p>
<h6 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h6><p>A和B都说得太绝对，进程之间有可能具有相关性,也有可能是相互独立的。C错在.“同时”</p>
<h5 id="多对一线程方式的特点"><a href="#多对一线程方式的特点" class="headerlink" title="多对一线程方式的特点"></a>多对一线程方式的特点</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140037.png" alt="多对一线程方式的特点-题目及答案"></p>
<h6 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h6><ul>
<li>注意多是指用户级线程</li>
</ul>
<h5 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140137.png" alt="线程与进程-题目及答案"></p>
<h6 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h6><p>进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位，它包括PCB、程序和数据以及执行栈区，仅仅说进程是在多程序环境下的完整程序是不合适的，因为程序是静态的，它以文件形式存放于计算机硬盘内，而进程是动态的。</p>
<h5 id="选择新进程的时机"><a href="#选择新进程的时机" class="headerlink" title="选择新进程的时机"></a>选择新进程的时机</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140253.png" alt="选择新进程的时机-题目及答案"></p>
<h6 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h6><p>这道题实际上问的是，哪种情况下不从运行态转换成共他状态</p>
<h5 id="bigtriangledown-数据结构存放的位置"><a href="#bigtriangledown-数据结构存放的位置" class="headerlink" title="$\bigtriangledown$ 数据结构存放的位置"></a>$\bigtriangledown$ 数据结构存放的位置</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140441.png" alt="数据结构存放的位置-题目及答案"></p>
<h6 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h6><p>C语言编写的程序在使用内存时一般分为三个段,它们一般是i正文段(即代码和赋值数据段)、数据堆段和数据栈段。二进制代码和常量存放在正文段，动态分配的存储区在数据堆段，临时使用的变量在数据栈段。由此，我们可以确定全局赋值变量在正文段赋值数括段，木赋值的局部变量和实参传递在栈段，动态内存分配在堆段，常量在正文段，进程的优先级只能在. PCB 内。</p>
<h5 id="PCB中的内容"><a href="#PCB中的内容" class="headerlink" title="PCB中的内容"></a>PCB中的内容</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140603.png" alt="PCB中的内容-题目及答案"></p>
<h6 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h6><p>进程实体主要是代码、数据和 PCB。因此，要清楚了解PCB内所含的数据结构内容主要有四大类:进程标志信息、进程控制信息、进程资源信息、CPU现场信息。出上述可知，全局变量与PCB无关，它只与用户代码有关。</p>
<h5 id="就绪队列对CPU的影响"><a href="#就绪队列对CPU的影响" class="headerlink" title="就绪队列对CPU的影响"></a>就绪队列对CPU的影响</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140714.png" alt="就绪队列对CPU的影响-题目及答案"></p>
<h6 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h6><p>由进程的状态图（见图2.1）可以看出，进程的就绪数日越多，争夺CPU的进程就越多，但只要就绪队列不为空，CPU就总是可以调度进程运行，保持繁忙。这与就绪进程的数日没有关系，除非就绪队列为空，此时CPU进入等待态，导致CPU的效率下降。</p>
<h5 id="bigstar-IO设备与进程"><a href="#bigstar-IO设备与进程" class="headerlink" title="$\bigstar$ IO设备与进程"></a>$\bigstar$ IO设备与进程</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120140839.png" alt="IO设备与进程-题目及答案"></p>
<h6 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h6><p>由于是单处理器，在某·时刻只有-一个进程能获得处理器资源，所以是某一时间段内并发运行。此外，也正是因为CPU和IO设备的并行运行，才使各进程能并发执行。</p>
<ul>
<li>在第五章的时候也出现过类似的题？找出来</li>
</ul>
<h5 id="bigtriangledown-进程控制使用"><a href="#bigtriangledown-进程控制使用" class="headerlink" title="$\bigtriangledown$ 进程控制使用"></a>$\bigtriangledown$ 进程控制使用</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141007.png" alt="进程控制使用-题目及答案"></p>
<h6 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h6><p>对进程的管理和控制功能是通过执行各种原语来实现的，如创建原语等。</p>
<h5 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141208.png" alt="进程与线程-题目及答案"></p>
<h6 id="解析-14"><a href="#解析-14" class="headerlink" title="解析"></a>解析</h6><p>在引入线程后，进程依然是资源分配的基本单位，线程是调度的基本单位，同一进程中的各个线程共享进程的地址空间。在用户级线程中，有关线程管理的所有工.作都由应用程序完成，无须内核的干预，内核意识不到线程的存在。</p>
<h5 id="管道的描述"><a href="#管道的描述" class="headerlink" title="管道的描述"></a>管道的描述</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141340.png" alt="管道的描述-题目及答案"></p>
<h6 id="解析-15"><a href="#解析-15" class="headerlink" title="解析"></a>解析</h6><p>管道实际上是一种固定大小的缓冲区，管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户、单独构成的一种文件系统，并且只存在于内存中。它类似于通信中半双工倍道的进程通信机制，一个管道可以实现双向的数据传输，而同一时刻只能最多有一个方向的传输，不能两个方向同时进行。管道的容量大小通常为内存上的一页，它的大小并不受磁盘容量大小的限制。当管道满时，进程在写管道会被阻塞，而当管道空时，进程在读管道会被阻塞，因此选C。</p>
<ul>
<li>D怎么说？</li>
</ul>
<h5 id="进程唤醒有关的事件"><a href="#进程唤醒有关的事件" class="headerlink" title="进程唤醒有关的事件"></a>进程唤醒有关的事件</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141843.png" alt="进程唤醒有关的事件-题目及答案"></p>
<h6 id="解析-16"><a href="#解析-16" class="headerlink" title="解析"></a>解析</h6><p>当被阻塞进程等待的某资源（不包括处理机）可用时，进程将会被唤醒。IO 结束后，等待该EO结束而被阻塞的有关进程会被唤醒，Ⅰ正确;某进程退出临界区后，<strong>之前因需要进入该临界区而被阻塞的有关进程会被唤醒</strong>，II正确;当前进程的时间片用完后进入就绪队列等待重新调度，优先级最高的进程获得处理机资源从就绪态变成执行态，Ⅲ错误。</p>
<h5 id="线程的描述-1"><a href="#线程的描述-1" class="headerlink" title="线程的描述"></a>线程的描述</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120141810.png" alt="线程的描述-题目及答案"></p>
<h6 id="解析-17"><a href="#解析-17" class="headerlink" title="解析"></a>解析</h6><p>应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口，内核为进程及其内部的每个线程维护上下文信息，调度也是在内核中由操作系统完成的，A正确。在多线程模型中，用户级线程和内核级线程的连接方式分为多对一、一对一、多对多，“操作系统为每个用户线程建立一个线程控制块”属于一对-一模型，B错误。用户级线程的切换可以在用户空间完成，内核级线程的切换需要操作系统帮助进行调度，因此用户级线程的切换效率更高，C止确。用户级线程的管理工作可以只在用户空间中进行，因此可以在不支持内核级线程的操作系统上实现，D正确。</p>
<h5 id="bigtriangledown-时间片轮转的目的"><a href="#bigtriangledown-时间片轮转的目的" class="headerlink" title="$\bigtriangledown$ 时间片轮转的目的"></a>$\bigtriangledown$ 时间片轮转的目的</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142051.png" alt="时间片轮转的目的-题目及答案"></p>
<h6 id="解析-18"><a href="#解析-18" class="headerlink" title="解析"></a>解析</h6><ul>
<li>奇妙的表达</li>
</ul>
<h5 id="有利于IO繁忙调度的算法"><a href="#有利于IO繁忙调度的算法" class="headerlink" title="有利于IO繁忙调度的算法"></a>有利于IO繁忙调度的算法</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142254.png" alt="有利于短作业调度的算法-题目及答案"></p>
<h6 id="解析-19"><a href="#解析-19" class="headerlink" title="解析"></a>解析</h6><p>先来先服务（FCFS）调度算法是一种最简单的调度算法，在作业调度中采用该算法时，每次调度从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。<br>FCFS 调度算法比较有利于长作业，而不利于短作业。所谓CPU繁忙型的作业，是指该类作业需要大量的CPU时间进行讣算，而很少请求IO操作。T/O繁忙型的作业是指CPU处理时，需频繁地请求IO操作。所以CPU繁忙型作业更接近于长作业。答案选择B选项。</p>
<h5 id="调度方式的选择"><a href="#调度方式的选择" class="headerlink" title="调度方式的选择"></a>调度方式的选择</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142401.png" alt="调度方式的选择-题目及答案"></p>
<h6 id="解析-20"><a href="#解析-20" class="headerlink" title="解析"></a>解析</h6><p>照顾短作业用户，选择短作业优先调度算法;照顾紧急作业用户，即选择优先级高的作业优先调度，采用基于优先级的剥夺调度算法;实现人机交互，要保证每个作业都能在·定时间内轮到，采用时间片轮转法;使各种作业用户满意，要处理多级反馈，所以选择多级反馈队列调度算法。</p>
<h5 id="优先级的设置"><a href="#优先级的设置" class="headerlink" title="优先级的设置"></a>优先级的设置</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142511.png" alt="优先级的设置-题目及答案"></p>
<h6 id="解析-21"><a href="#解析-21" class="headerlink" title="解析"></a>解析</h6><p>为了合理地设置进程优先级，应综合考虑进程的CPU时间和T/O时间。对于优先级调度算法，一般来说，I/O型作业的优先权高于计算型作业的优先权，这是由于IO操作需要及时完成，它没有办法长时间地保存所要输入/输出的数据，所以考虑到系统资源利用率，要选择IO繁忙型作业有更高的优先级。</p>
<h5 id="bigtriangledown-相应比的计算"><a href="#bigtriangledown-相应比的计算" class="headerlink" title="$\bigtriangledown$ 相应比的计算"></a>$\bigtriangledown$ 相应比的计算</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142658.png" alt="相应比的计算-题目及答案"></p>
<h6 id="解析-22"><a href="#解析-22" class="headerlink" title="解析"></a>解析</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142629.png" alt="相应比的计算-解析"></p>
<h5 id="绝对可抢占的算法"><a href="#绝对可抢占的算法" class="headerlink" title="绝对可抢占的算法"></a>绝对可抢占的算法</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142804.png" alt="绝对可抢占的算法-题目及答案"></p>
<h6 id="解析-23"><a href="#解析-23" class="headerlink" title="解析"></a>解析</h6><p>时间片轮转算法是按固定的时间配额来运行的，时间一到，不管是否完成，当前的进程必须撤下，调度新的进程，因此它是由时间配额决定的、是绝对可抢占的。而优先级算法和短进程优先算法都可分为抢占式和不可抢占式。</p>
<h5 id="bigstar-SJF的计算题"><a href="#bigstar-SJF的计算题" class="headerlink" title="$\bigstar$ SJF的计算题"></a>$\bigstar$ SJF的计算题</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142847.png" alt="SJF的计算题-题目及答案"></p>
<h6 id="解析-24"><a href="#解析-24" class="headerlink" title="解析"></a>解析</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120142913.png" alt="SJF的计算题-解析"></p>
<ul>
<li>?所以我哪里算错了。?</li>
<li><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143216.png" alt="my soiluition"></li>
</ul>
<h5 id="多道批处理"><a href="#多道批处理" class="headerlink" title="多道批处理"></a>多道批处理</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143417.png" alt="多道批处理-题目及答案"></p>
<h6 id="解析-25"><a href="#解析-25" class="headerlink" title="解析"></a>解析</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143516.png" alt="多道批处理-解析"></p>
<h5 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143641.png" alt="并发执行-题目及答案"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143922.png" alt="并发执行-题目及答案2"></p>
<h6 id="解析-26"><a href="#解析-26" class="headerlink" title="解析"></a>解析</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143701.png" alt="并发执行-解析"></p>
<ul>
<li>少加了一个2，冷静做题哥哥</li>
</ul>
<h5 id="bigtriangledown-对短作业不利的算法"><a href="#bigtriangledown-对短作业不利的算法" class="headerlink" title="$\bigtriangledown$ 对短作业不利的算法"></a>$\bigtriangledown$ 对短作业不利的算法</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120143836.png" alt="对短作业不利的算法-题目及答案"></p>
<h6 id="解析-27"><a href="#解析-27" class="headerlink" title="解析"></a>解析</h6><p>先来先服务调度算法中，若一个长进程（作业）先到达系统，则会使后面的许多短进程〈作业）等待很长的时间，因此对短进程（作业）不利。</p>
<h5 id="bigstar-总结大礼包"><a href="#bigstar-总结大礼包" class="headerlink" title="$\bigstar$ 总结大礼包"></a>$\bigstar$ 总结大礼包</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144029.png" alt="总结大礼包-题目及答案"></p>
<h6 id="解析-28"><a href="#解析-28" class="headerlink" title="解析"></a>解析</h6><p>短进程优先调度算法具有最短的平均周转时间。平均周转时间=各进程周转时问之和/进程数。因为每个进程的执行时间都是固定的，所以变化的是等待时间，只有短进程优先算法能最小化等待时间。<br>下表总结了几种常见进程调度算法的特点，读者要在理解的基础上掌握。<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144057.png" alt="总结大礼包-解析"></p>
<h5 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144154.png" alt="杂-题目及答案"></p>
<h6 id="解析-29"><a href="#解析-29" class="headerlink" title="解析"></a>解析</h6><p>Ⅰ选项正确，分时系统中，响应时间与时间片和用户数成正比。I选项正确。II选项错误，中断向量本身是用于存放中断服务例行程序的入口地址，因此中断向量地址就应是该入口地址的地址。IV选项错误，中断由硬件保护并完成，主要是为了保证系统运行可靠、正确。提高处理速度也是一个好处，但不是主要目的。综上分析，III、Ⅳ选项错误。</p>
<h5 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144425.png" alt="处理机调度-题目及答案"></p>
<h6 id="解析-30"><a href="#解析-30" class="headerlink" title="解析"></a>解析</h6><p>选项A、B、D显然属于可以进行处理机调度的情况。对于选项C，当进程处于临界区时，说明进程正在古用处理机，只要不破坏临界资源的使用规则，就不会影响处理机的调度。比如，通常访问的临界资源可能是慢速的外设（如打印机)，若在进程访问打印机时，不能进行处理机调度，则系统的性能将非常差。</p>
<h5 id="不产生饥饿"><a href="#不产生饥饿" class="headerlink" title="不产生饥饿"></a>不产生饥饿</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144554.png" alt="不产生饥饿-题目及答案"></p>
<h6 id="解析-31"><a href="#解析-31" class="headerlink" title="解析"></a>解析</h6><p>响应比=(等待时间＋执行时间)/执行时间。高响应比优先算法在等待时间相同的情况下，作业执行时间越短，响应比越高，满足短任务优先。随着长作业等待时间的增加，响应比会变大，执行机会也会增大，因此不会发生饥饿现象。先来先服务和时间片轮转不符合短任务优先非抢占式短任务优先会产生饥饿现象。</p>
<h5 id="优先级调度-考研真题"><a href="#优先级调度-考研真题" class="headerlink" title="优先级调度-考研真题"></a>优先级调度-考研真题</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144626.png" alt="优先级调度-考研真题-题目及答案"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120144702.png" alt="优先级调度-考研真题-题目及答案2"></p>
<h6 id="解析-32"><a href="#解析-32" class="headerlink" title="解析"></a>解析</h6><p>由优先权可知，进程的执行顺序为$P_2 \rightarrow P_3 \rightarrow P_1$,<br>$p_3$的周转时间为$1＋15＋24= 40\mu s$;<br>$P_2$的周转时间为$18＋1＋24+1 +36 = 80\mu s$;<br>$P_1$的周转时间为$30+1+24+1+36+1+12= 105\mu s$<br>平均周转时间为(40+ 80+ 105)/3= 225/3= 75us，因此选D。</p>
<ul>
<li>注意加上切换开销！</li>
</ul>
<h5 id="二级反馈队列"><a href="#二级反馈队列" class="headerlink" title="二级反馈队列"></a>二级反馈队列</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120145047.png" alt="二级反馈队列-题目及答案"></p>
<h6 id="解析-33"><a href="#解析-33" class="headerlink" title="解析"></a>解析</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120145110.png" alt="二级反馈队列-解析1"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120145139.png" alt="二级反馈队列-解析2"></p>
<h2 id="第四章-内存管理"><a href="#第四章-内存管理" class="headerlink" title="第四章 内存管理"></a>第四章 内存管理</h2><ul>
<li>分页系统<ul>
<li>地址运算的本质：页号+页内偏移量</li>
</ul>
</li>
<li>可变分区的内存分配算法<ul>
<li>首次适应算法</li>
<li>最佳适应算法</li>
<li>最坏适应算法</li>
</ul>
</li>
</ul>
<h3 id="存储器管理概述"><a href="#存储器管理概述" class="headerlink" title="存储器管理概述"></a>存储器管理概述</h3><h4 id="多级存储器体系"><a href="#多级存储器体系" class="headerlink" title="多级存储器体系"></a>多级存储器体系</h4><p>计算机的存储系统包括寄存器，Cache，主存，辅助存储器，可移动存储器和网络存储器等层次 </p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210118184654.png" alt="计算机的存储系统"></p>
<center >计算机的存储系统</center>

<h4 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h4><h5 id="内存的分配与回收"><a href="#内存的分配与回收" class="headerlink" title="内存的分配与回收"></a>内存的分配与回收</h5><h5 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h5><h5 id="内存的保护和共享"><a href="#内存的保护和共享" class="headerlink" title="内存的保护和共享"></a>内存的保护和共享</h5><h5 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h5><h4 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h4><ul>
<li>连接装入的定义是什么样的(t逻辑地址形成的过程)</li>
</ul>
<h5 id="根据链接工作进行的时机"><a href="#根据链接工作进行的时机" class="headerlink" title="根据链接工作进行的时机"></a>根据链接工作进行的时机</h5><h6 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h6><h6 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h6><h6 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h6><h5 id="根据地址映射进行的时机"><a href="#根据地址映射进行的时机" class="headerlink" title="根据地址映射进行的时机"></a>根据地址映射进行的时机</h5><h6 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h6><ul>
<li>将地址加载装入到某个指定地址开始的一段内存空间，该地址是在编译时就已经确定的</li>
<li>装入和运行过程中都不能改变这个起始地址，因为模块中所有的地址都是基于这个起始地址进行编译的</li>
<li>无需进行地址映射，一般适合用于烧写驻留在设备中的固件程序之类的情况</li>
</ul>
<h6 id="静态重定位装入"><a href="#静态重定位装入" class="headerlink" title="静态重定位装入"></a>静态重定位装入</h6><ul>
<li>可以加载到内存中任意合适位置</li>
<li>装入内存时，将逻辑地址统一为物理空间中的实际物理地址</li>
<li>一旦装入内存就不能再移动位置</li>
</ul>
<h6 id="动态重定位装入"><a href="#动态重定位装入" class="headerlink" title="动态重定位装入"></a>动态重定位装入</h6><ul>
<li>装入时依然使用逻辑地址，当真正执行指令时再将指令本身或指令中操作数的逻辑地址转换为物理地址</li>
</ul>
<h3 id="连续存储器管理方式"><a href="#连续存储器管理方式" class="headerlink" title="连续存储器管理方式"></a>连续存储器管理方式</h3><p>为进程分配一段连续的物理内存空间，也就是将<strong>一维线性连续的虚地址空间</strong>映射到<strong>一维线性连续的实地址空间</strong>的方法。</p>
<h4 id="固定分区方式"><a href="#固定分区方式" class="headerlink" title="固定分区方式"></a>固定分区方式</h4><p>特点</p>
<ul>
<li>每个分区只能装入一个程序</li>
</ul>
<p>分配和回收的算法</p>
<ul>
<li>分区分配表</li>
<li>对应的分配回收算法</li>
</ul>
<p>缺点</p>
<ul>
<li>可以容纳的并发进程的最大数量固定(分区数量和分区位置固定)</li>
<li>分区内部空间可能存在浪费</li>
<li>可容纳的进程最大尺度固定</li>
<li>容易产生内部碎片(分区内的碎片)</li>
</ul>
<h4 id="可变分区方式"><a href="#可变分区方式" class="headerlink" title="可变分区方式"></a>可变分区方式</h4><p><strong>特点</strong></p>
<ul>
<li>根据进程需求分配大小合适的空间</li>
</ul>
<p><strong>分配和回收的算法</strong></p>
<ul>
<li>空闲分区链</li>
<li>对应的分配回收算法</li>
</ul>
<h5 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h5><h6 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h6><p>要求空闲分区链按各空闲分区起始地址递增的顺序链接。每次分配时，总是从第一个空闲分区开始查找。<br><strong>优点</strong></p>
<ul>
<li>便于在高端内存留下较大的连续内存空间以满足空间需求大的进程(算法倾向于多分配使用低端内存区域)</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>容易产生外部碎片</li>
</ul>
<p>改进：循环首次适应，但不容易满足大进程的需求</p>
<h6 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h6><p><strong>优点</strong></p>
<ul>
<li>能最大限度地保留大的空闲分区</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>非常容易产生外部碎片</li>
</ul>
<h6 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h6><p><strong>特点</strong><br>增大余下空间的可利用率</p>
<h5 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h5><h6 id="上邻接"><a href="#上邻接" class="headerlink" title="上邻接"></a>上邻接</h6><h6 id="下邻接"><a href="#下邻接" class="headerlink" title="下邻接"></a>下邻接</h6><h6 id="上下邻接"><a href="#上下邻接" class="headerlink" title="上下邻接"></a>上下邻接</h6><h6 id="无邻接"><a href="#无邻接" class="headerlink" title="无邻接"></a>无邻接</h6><h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h3><ul>
<li><strong>是一维线性的地址空间</strong></li>
</ul>
<h4 id="分页存储管理基本原理"><a href="#分页存储管理基本原理" class="headerlink" title="分页存储管理基本原理"></a>分页存储管理基本原理</h4><h5 id="页与页框"><a href="#页与页框" class="headerlink" title="页与页框"></a>页与页框</h5><ul>
<li>分页存储器管理是将内存物理空间和程序逻辑空间分成大小相等的块(512B~8KB),一般是$2^k B$大小,具体大小是由cpu的硬件机构决定的。</li>
<li>逻辑空间中的块称为页面(page),物理空间的块称为物理块，或者页框和帧(frame)。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120111747.png" alt="分页系统示意图"></p>
<h5 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h5><ul>
<li>是一维线性的地址空间</li>
<li>地址映射公式<ul>
<li>逻辑地址A，页面大小L</li>
<li>页号$P=\lfloor A/L \rfloor$</li>
<li>页内地址$d = A \quad mod \quad L$</li>
</ul>
</li>
</ul>
<h5 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h5><ul>
<li>系统为每个进程设置一张页号到物理块号的映射表，称为页表</li>
<li>页表的表项PTE(Page Table Entry),由页号和物理块号组成。</li>
<li>页表存储在<strong>内存</strong>中，只存储物理块号，页号不占用存储空间</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120111936.png" alt="页表示意图"></p>
<h5 id="地址映射与越界保护"><a href="#地址映射与越界保护" class="headerlink" title="地址映射与越界保护"></a>地址映射与越界保护</h5><ul>
<li>根据页表查询到物理块号F之后，物理地址就是A’ = F $\times$ L + d</li>
<li>地址映射经历两次除法（得到页号,得到页内偏移量），一次乘法(得到物理块起始地址)，一次加法(加上块内偏移量)</li>
<li>通常由地址映射机构完成</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112023.png" alt="地址映射机制4-9"></p>
<h5 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h5><p>一个高速缓冲存储器，也称为联想储存器TBL(Translation Lookaside Buffer)<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112112.png" alt="带快表的分页系统映射机制4-10"></p>
<h4 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h4><ul>
<li>为进程的页表另外设置一张目录表(用以记录存放进程页表的物理块号)，也叫<strong>外部页表</strong>，或<strong>一级页表</strong>，进程自身的页表陈为<strong>二级页表</strong></li>
<li>由于多级页表占用空间大，所以操作系统仅将顶级页表存储再内存中</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112251.png" alt="多级页表的机构"></p>
<h3 id="分段存储管理基本方式"><a href="#分段存储管理基本方式" class="headerlink" title="分段存储管理基本方式"></a>分段存储管理基本方式</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="段"><a href="#段" class="headerlink" title="段"></a>段</h5><ul>
<li>划分的依据是有逻辑意义的一组相关信息，称为段(segment)</li>
<li>每个段都有一个字符串标识符和一个唯一的编号，称为段名和段号</li>
</ul>
<h5 id="逻辑地址结构-1"><a href="#逻辑地址结构-1" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h5><ul>
<li>分段的逻辑地址空间是二维的非线性地址空间</li>
<li>段内地址d的最大位数决定了段的最大长度,而不是长度</li>
<li>段号S的位数决定了一个进程的段的最大数量</li>
</ul>
<h5 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h5><ul>
<li>段表记录了各个段在内存中的起始地址(段基址)和段长</li>
<li>进程的段表放在内存中</li>
<li>段表的内存起始地址和长度保存在进程的PCB中</li>
</ul>
<h5 id="地址映射与越界保护-1"><a href="#地址映射与越界保护-1" class="headerlink" title="地址映射与越界保护"></a>地址映射与越界保护</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112330.png" alt="分段系统映射机制4-15"></p>
<h5 id="段共享与保护"><a href="#段共享与保护" class="headerlink" title="段共享与保护"></a>段共享与保护</h5><h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><p>段页式存储管理首先将进程按逻辑信息分为若干段，然后每个段再按系统规定的页面大小划分为若干页面<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112645.png" alt="段页式存储管理方式-1"><br>因此每个进程的段表只有一张，页表则有多张。<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112717.png" alt="段页式存储管理方式-2"><br>地址映射机构<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112757.png" alt="段页式存储管理方式-3"></p>
<h3 id="虚拟存储系统"><a href="#虚拟存储系统" class="headerlink" title="虚拟存储系统"></a>虚拟存储系统</h3><h4 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h4><p>虚拟存储器(Virtual Memory)是指具有<strong>请求调入功能和置换功能</strong>，能够利用外存储器的空余空间从逻辑上对内存容量进行扩充的存储系统</p>
<ul>
<li>虚拟存储器的特征是什么<h5 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h5><h6 id="将程序装入的一次性或者整体性改为多次性"><a href="#将程序装入的一次性或者整体性改为多次性" class="headerlink" title="将程序装入的一次性或者整体性改为多次性"></a>将程序装入的一次性或者整体性改为多次性</h6><h6 id="将进程的驻留性改为置换性"><a href="#将进程的驻留性改为置换性" class="headerlink" title="将进程的驻留性改为置换性"></a>将进程的驻留性改为置换性</h6><h5 id="三种实现方式"><a href="#三种实现方式" class="headerlink" title="三种实现方式"></a>三种实现方式</h5><h6 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h6>本书的重点<h6 id="请求分段"><a href="#请求分段" class="headerlink" title="请求分段"></a>请求分段</h6><h6 id="请求段页"><a href="#请求段页" class="headerlink" title="请求段页"></a>请求段页</h6></li>
</ul>
<h4 id="请求分页储存管理方式"><a href="#请求分页储存管理方式" class="headerlink" title="请求分页储存管理方式"></a>请求分页储存管理方式</h4><p>请求分页需要使用带有缺页中断机构的地址映射机构实现逻辑地址到物理地址</p>
<h5 id="页表-1"><a href="#页表-1" class="headerlink" title="页表"></a>页表</h5><p>需要增加字段，供页面调入调出时参考</p>
<h6 id="状态位P"><a href="#状态位P" class="headerlink" title="状态位P"></a>状态位P</h6><p>表示页面是否在内存中，若不在内存，则产生缺页中断，也成为存在位</p>
<h6 id="访问字段A"><a href="#访问字段A" class="headerlink" title="访问字段A"></a>访问字段A</h6><p>记录页面被访问的情况，依据所采用的页面置换算法，可能是被访问次数或者未访问时间，供页面置换时参考</p>
<h6 id="修改位M"><a href="#修改位M" class="headerlink" title="修改位M"></a>修改位M</h6><p>标记内存是否被修改，如果没被修改就不用写回外存，减少页面置换时间</p>
<h6 id="外存地址"><a href="#外存地址" class="headerlink" title="外存地址"></a>外存地址</h6><p>记录页面在外村上的地址，通常是物理块号，供调入页面时参考</p>
<h5 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h5><h5 id="地址映射机构"><a href="#地址映射机构" class="headerlink" title="地址映射机构"></a>地址映射机构</h5><h5 id="抖动-颠簸-thrashing"><a href="#抖动-颠簸-thrashing" class="headerlink" title="抖动/颠簸(thrashing)"></a>抖动/颠簸(thrashing)</h5><h5 id="工作集-work-set"><a href="#工作集-work-set" class="headerlink" title="工作集(work set)"></a>工作集(work set)</h5><p>某段时间间隔内，进程实际要访问的页面集合</p>
<h5 id="页面置换策略"><a href="#页面置换策略" class="headerlink" title="页面置换策略"></a>页面置换策略</h5><h5 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h5><h6 id="最佳置换算法-Optimal-OPT"><a href="#最佳置换算法-Optimal-OPT" class="headerlink" title="最佳置换算法(Optimal,OPT)"></a>最佳置换算法(Optimal,OPT)</h6><h6 id="先进先出置换算法-First-In-First-Out-FIFO"><a href="#先进先出置换算法-First-In-First-Out-FIFO" class="headerlink" title="先进先出置换算法(First In First Out,FIFO)"></a>先进先出置换算法(First In First Out,FIFO)</h6><ul>
<li>Belady现象(Belady’s Anomaly)<ul>
<li>物理块增大时，缺页率不增反减</li>
</ul>
</li>
<li><del>记忆方法：一进一出</del></li>
</ul>
<h6 id="最近最久未使用置换算法-Least-Recently-Used-LRU"><a href="#最近最久未使用置换算法-Least-Recently-Used-LRU" class="headerlink" title="最近最久未使用置换算法(Least Recently Used,LRU)"></a>最近最久未使用置换算法(Least Recently Used,LRU)</h6><h6 id="最近最少使用置换算法-Least-Frequently-Used-LFU"><a href="#最近最少使用置换算法-Least-Frequently-Used-LFU" class="headerlink" title="最近最少使用置换算法(Least Frequently Used, LFU)"></a>最近最少使用置换算法(Least Frequently Used, LFU)</h6><h6 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h6><ul>
<li>用最小的开销获得接近LRU算法的性能</li>
<li>CLOCK算法选择将最近未使用的页面置换出去，因此又称NRU算法。</li>
</ul>
<h6 id="页面缓冲思想"><a href="#页面缓冲思想" class="headerlink" title="页面缓冲思想"></a>页面缓冲思想</h6><h3 id="Linux内存管理机制"><a href="#Linux内存管理机制" class="headerlink" title="Linux内存管理机制"></a>Linux内存管理机制</h3><h4 id="Linux的物理内存空间管理"><a href="#Linux的物理内存空间管理" class="headerlink" title="Linux的物理内存空间管理"></a>Linux的物理内存空间管理</h4><h4 id="Linux虚拟地址空间管理"><a href="#Linux虚拟地址空间管理" class="headerlink" title="Linux虚拟地址空间管理"></a>Linux虚拟地址空间管理</h4><h3 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a>本章小结</h3><p>注意</p>
<ul>
<li>一个地址指向一个字节，所以B不用转成b(例题4-5)，感觉是因为c语言的最小基本类型是一个字节</li>
</ul>
<p>题型</p>
<ul>
<li>地址映射的计算题</li>
<li>得到内存时间的计算题</li>
<li>多级页表的设计</li>
<li>页面置换算法</li>
</ul>
<h3 id="本章习题-3"><a href="#本章习题-3" class="headerlink" title="本章习题"></a>本章习题</h3><h4 id="考研辅导书"><a href="#考研辅导书" class="headerlink" title="考研辅导书"></a>考研辅导书</h4><h5 id="逻辑地址的产生"><a href="#逻辑地址的产生" class="headerlink" title="逻辑地址的产生"></a>逻辑地址的产生</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119174907.png" alt="逻辑地址的产生-题目"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119180524.png" alt="逻辑地址的产生-题目选项"></p>
<h6 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h6><p>链接</p>
<h6 id="解析-34"><a href="#解析-34" class="headerlink" title="解析"></a>解析</h6><p>编泽后的程序需要经过链接才能装载，而链接后形成的目标程序中的地址也就是逻辑地址。以C语言为例:C程序经过预处理→编译→汇编→链接产生了可执行文件，其中链接的前一步是产生可重定位的二进制目标文件。C语言采用源文件独立编译的方法,如程序main.c, file1.c, file2.c,file1.h, file2.h在链接的前一步生成了main.o , file1.o, file2.o,这些目标模块的逻辑地址都从0开始,但只是相对于该模块的逻辑地址。链接器将这三个文件、libc和其库文件链接成一个可执行文件。链接阶段主要完成重定位，形成整个程序的完整逻辑地址空间。读者区分逻辑地址结构和表项结  </p>
<p>例如，file1.o的逻辑地址为0~1023，main.o 的逻辑地址为0~1023，假设链接时将file1.o链接在main.o之后，则链接之后file1.o对应的逻辑地址应为1024~2047，整个过程如下图所示。  </p>
<p>要注意审题，若题目是“完成该变换过程的阶段是”则可以选D。<br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119175158.png" alt="逻辑地址的产生-解析"></p>
<ul>
<li>$\bigtriangledown$注意:区分<strong>编译后形成的逻辑地址和链接后形成的最终逻辑地址</strong>。</li>
</ul>
<h5 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119180306.png" alt="交换技术-题目"></p>
<h6 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h6><p>B:I/O操作</p>
<h6 id="解析-35"><a href="#解析-35" class="headerlink" title="解析"></a>解析</h6><p>进程正在进行I/O操作时不能换出主存，否则其IO数据区将被新换入的进程占用，导致错误。不过可以在操作系统中开辟IO缓冲区，将数据从外设输入或将数据输出到外设的IO活动在系统缓冲区中进行，这时系统缓冲区与外设I/O时，进程交换不受限制.</p>
<h5 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119180742.png" alt="覆盖技术题目"></p>
<h6 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h6><p>A.节省主存空间</p>
<h6 id="解析-36"><a href="#解析-36" class="headerlink" title="解析"></a>解析</h6><p>覆盖和交换的提出就是为了解决主存空间不足的问题，但不是在物理上扩充主存，只是将暂时不用的部分换出主存，以节省空间，从而在逻辑上扩充主存。<br>$\blacktriangleright$？覆盖技术学校的课本有讲吗</p>
<ul>
<li>把程序划分为若干个功能独立的程序段，这些程序段不会同时被CPU执行，且让他们共享同一个主存区。当前没有被CPU执行的程序段放在外存，需要执行时，从外存调入主存。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/laining/p/7641778.html">参考资料</a></li>
</ul>
<h5 id="最佳适配算法"><a href="#最佳适配算法" class="headerlink" title="最佳适配算法"></a>最佳适配算法</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119181348.png" alt="最佳适配算法-题目"></p>
<h6 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h6><p>B.9MB</p>
<h6 id="解析-37"><a href="#解析-37" class="headerlink" title="解析"></a>解析</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119181247.png" alt="最佳适配算法-解析"></p>
<h5 id="分区合并"><a href="#分区合并" class="headerlink" title="分区合并"></a>分区合并</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119181812.png" alt="分区合并-题目"></p>
<h6 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h6><p>D．有上邻空闲区也有下邻空闲区</p>
<h6 id="解析-38"><a href="#解析-38" class="headerlink" title="解析"></a>解析</h6><p>将上邻空闲区、下邻空闲区和回收区合并为一个空闲区，因此空闲区数反而减少了一个。面仅有.上邻空闲区或下邻空闲区时，空闲区数并不减少。</p>
<h5 id="动态重定向"><a href="#动态重定向" class="headerlink" title="动态重定向"></a>动态重定向</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119183528.png" alt="动态重定向-题目"></p>
<h6 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h6><p>D、执行过程</p>
<h6 id="解析-39"><a href="#解析-39" class="headerlink" title="解析"></a>解析</h6><ul>
<li>静态装入是指在编程阶段就把物理地址计算好。</li>
<li>可重定位是指在装入时把逻辑地址转换成物理地址，但装入后不能改变</li>
<li>动态重定位是指在执行时再决定装入的地址并装入，装入后有可能会换出，所以同一个模块在内存中的物理地址是可能改变的。<ul>
<li>动态重定位是指在作业运行过程中执行到一条访存指令时，再把逻辑地址转换为主存中的物理地址，实际中是通过硬件地址转换机制实现的。</li>
</ul>
</li>
</ul>
<h5 id="外部碎片和内部碎片"><a href="#外部碎片和内部碎片" class="headerlink" title="外部碎片和内部碎片"></a>外部碎片和内部碎片</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119183745.png" alt="外部碎片和内部碎片-题目"></p>
<h6 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h6><p>B.分段式存储管理</p>
<h6 id="解析-40"><a href="#解析-40" class="headerlink" title="解析"></a>解析</h6><p>分页式存储管理有内部碎片，分段式存储管理有外部碎片，固定分区存储管理方式有内部碎片，段页式存储管理方式有内部碎片。</p>
<h5 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119184030.png" alt="内存保护-题目"></p>
<h6 id="答案-7"><a href="#答案-7" class="headerlink" title="答案"></a>答案</h6><p>B、内存保护</p>
<h6 id="解析-41"><a href="#解析-41" class="headerlink" title="解析"></a>解析</h6><p>多进程的执行遒过内存保护文现互不干扰，如页式管理中有页地址越界保护，段式管理中有段地址越界保护。</p>
<h5 id="物理地址空间的大小"><a href="#物理地址空间的大小" class="headerlink" title="物理地址空间的大小"></a>物理地址空间的大小</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119184130.png" alt="物理地址空间的大小-题目"></p>
<h6 id="答案-8"><a href="#答案-8" class="headerlink" title="答案"></a>答案</h6><p>c.不能确定</p>
<h6 id="解析-42"><a href="#解析-42" class="headerlink" title="解析"></a>解析</h6><p>页表和段表同样存储在内存中，系统提供给用户的物理地址空间为总空问大小减去页表或段表的长度。由于页表和段表的长度不能确定，所以捉供给用户的物理地址空间大小也不能确定。</p>
<h5 id="页表的起始地址"><a href="#页表的起始地址" class="headerlink" title="页表的起始地址"></a>页表的起始地址</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119184320.png" alt="页表的起始地址-题目"></p>
<h6 id="答案-9"><a href="#答案-9" class="headerlink" title="答案"></a>答案</h6><p>D.寄存器</p>
<h6 id="解析-43"><a href="#解析-43" class="headerlink" title="解析"></a>解析</h6><p>页表的功能由一组专门的存储器实现，其始址放在页表基址寄存器（PTBR)中。这样才能满足在地址变换时能够较快地完成逻辑地址和物理地址之间的转换。</p>
<ul>
<li>注意存放在pcb中的是段表</li>
</ul>
<h5 id="分段的时机"><a href="#分段的时机" class="headerlink" title="分段的时机"></a>分段的时机</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119184831.png" alt="分段的时机-题目"></p>
<h6 id="答案-10"><a href="#答案-10" class="headerlink" title="答案"></a>答案</h6><p>B.用户编程</p>
<h6 id="解析-44"><a href="#解析-44" class="headerlink" title="解析"></a>解析</h6><p>分段是指在用户编程时，将程序按照逻辑划分为几个逻辑段。</p>
<h5 id="可重入程序"><a href="#可重入程序" class="headerlink" title="可重入程序"></a>可重入程序</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119185530.png" alt="可重入程序-题目"></p>
<h6 id="答案-11"><a href="#答案-11" class="headerlink" title="答案"></a>答案</h6><p>D.减少对换数量</p>
<h6 id="解析-45"><a href="#解析-45" class="headerlink" title="解析"></a>解析</h6><p>可重入程序主要是通过共享来使用同―块存储空问的，或通过动态链接的方式将所需的程序段映射到相关进程中去，其最大的优点是减少了对程序段的调入/调出，因此减少了对换数量。</p>
<h5 id="动态分区的创建时间"><a href="#动态分区的创建时间" class="headerlink" title="动态分区的创建时间"></a>动态分区的创建时间</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119185635.png" alt="动态分区的创建时间-题目"></p>
<h6 id="答案-12"><a href="#答案-12" class="headerlink" title="答案"></a>答案</h6><p>A、在作业装入时</p>
<h6 id="解析-46"><a href="#解析-46" class="headerlink" title="解析"></a>解析</h6><p>动态分区时，在系统启动后，除操作系统占据-部分内存外，其余所有内存空间是一个大空闲区，称为自由空间。若作业申请内存，则从空闲区中划出一个与作业需求量相适应的分区分配给该作业，将作业创建为进程，在作业运行完毕后，再收回释放的分区。</p>
<h5 id="外存兑换区的主要目标"><a href="#外存兑换区的主要目标" class="headerlink" title="外存兑换区的主要目标"></a>外存兑换区的主要目标</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119185840.png" alt="外存兑换区的主要目标-题目"></p>
<h6 id="答案-13"><a href="#答案-13" class="headerlink" title="答案"></a>答案</h6><p>D.提高换入、换出速度</p>
<h6 id="解析-47"><a href="#解析-47" class="headerlink" title="解析"></a>解析</h6><p>操作系统在内存管理中为了提高内存的利用率，引入了覆盖和交换技术，即在较小的内存空间中采用重复使用的方法来节省存储空间，但它付出的代价是需耍消耗更多的处理器时间，因此实际上是种以时伺换空间的技术。为此，从节省处理器时问来讲，换入、换出速度越快，付出的时间代价就越小，反之就越大，大到一定程度时，覆盖和交换技术就没有意义。</p>
<h5 id="最佳适应算法-1"><a href="#最佳适应算法-1" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190148.png" alt="最佳适应算法-题目"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190237.png" alt="最佳适应算法-题目2"></p>
<h6 id="答案-14"><a href="#答案-14" class="headerlink" title="答案"></a>答案</h6><p>B.3,500K, 80KB</p>
<h6 id="解析-48"><a href="#解析-48" class="headerlink" title="解析"></a>解析</h6><p>回收始址为60K、大小为140KB的分区时，它与表中第‘个分区和第四个分区合并，成为始址为20K、大小为380KB的分区，剩余3个空闲分区。在回收内存后，算法会对空闲分区链按分区大小由小到大进行排序，表中的第二个分区排第一，所以选择B。</p>
<ul>
<li><strong>注意要排序</strong></li>
</ul>
<h5 id="选择页面大小"><a href="#选择页面大小" class="headerlink" title="选择页面大小"></a>选择页面大小</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190452.png" alt="选择页面大小-题目"></p>
<h6 id="答案-15"><a href="#答案-15" class="headerlink" title="答案"></a>答案</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190543.png" alt="选择页面大小-答案"></p>
<h6 id="解析-49"><a href="#解析-49" class="headerlink" title="解析"></a>解析</h6><p>页面大，用于管理页面的页表就少，但是页内碎片会比较大;页面小，用丁管理页面的页表就大，但是页内碎片小。通过适当的计算可以获得较佳的页面大小和较小的系统开销。</p>
<h5 id="主存储器的单位"><a href="#主存储器的单位" class="headerlink" title="主存储器的单位"></a>主存储器的单位</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190703.png" alt="主存储器的单位-题目"></p>
<h6 id="答案-16"><a href="#答案-16" class="headerlink" title="答案"></a>答案</h6><p>B.以字节或字为单位</p>
<h6 id="解析-50"><a href="#解析-50" class="headerlink" title="解析"></a>解析</h6><p>这里是指<strong>主存的访问</strong>，不是主存的分配。对主存的访问是以字节或字为单位的。例如，在页式管理中，不仅要知道块号，而且要知道页内偏移。</p>
<h5 id="段式分配访问内存"><a href="#段式分配访问内存" class="headerlink" title="段式分配访问内存"></a>段式分配访问内存</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190813.png" alt="段式分配访问内存-题目"></p>
<h6 id="答案-17"><a href="#答案-17" class="headerlink" title="答案"></a>答案</h6><p>C.2 </p>
<h6 id="解析-51"><a href="#解析-51" class="headerlink" title="解析"></a>解析</h6><p>在段式分配巾，取一次数据时先从内存查找段表，再拼成物理地址后访问内存，共需要2次内存访问。</p>
<h5 id="段页式分配访问内存的次数"><a href="#段页式分配访问内存的次数" class="headerlink" title="段页式分配访问内存的次数"></a>段页式分配访问内存的次数</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119190934.png" alt="段页式分配访问内存的次数-题目"></p>
<h6 id="答案-18"><a href="#答案-18" class="headerlink" title="答案"></a>答案</h6><p>B.3</p>
<h6 id="解析-52"><a href="#解析-52" class="headerlink" title="解析"></a>解析</h6><p>在段页式分配中，取—次数据时先从内存查找段表，再访问内存查找相应的页表，最后拼成理地址,后访问内有，共需要3次内存访问、</p>
<h5 id="段页式的思想"><a href="#段页式的思想" class="headerlink" title="段页式的思想"></a>段页式的思想</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191123.png" alt="段页式的思想-题目"></p>
<h6 id="答案-19"><a href="#答案-19" class="headerlink" title="答案"></a>答案</h6><p>B．用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间</p>
<h6 id="解析-53"><a href="#解析-53" class="headerlink" title="解析"></a>解析</h6><p>段页式存储管理兼有页式管理和段式管理的优点，采用分段方法来分配和管理用户地址空间，采用分页方法来管理物理存储空间。但它的开销要比段式和页式管理的开销大。</p>
<h5 id="页式存储的表述"><a href="#页式存储的表述" class="headerlink" title="页式存储的表述"></a>页式存储的表述</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191327.png" alt="页式存储的表述-题目"></p>
<h6 id="答案-20"><a href="#答案-20" class="headerlink" title="答案"></a>答案</h6><p>C.仅Ⅰ</p>
<h6 id="解析-54"><a href="#解析-54" class="headerlink" title="解析"></a>解析</h6><p>Ⅰ正确:关闭TLB后，每当访问一条指令或存取―个操作数时都要先访问页表（内存中)，得到物理地址后，再访问一次内存进行相应操作。ⅠⅠ错误:记住，凡是分区固定的都会产生内部碎片，而无外部碎片。Ⅲ错误:页式存储管理对于用户是透明的。Ⅳ错误:静态重定位是在程序运行之前由装配程序完成的，必须分配其要求的全部连续内存空间。而页式存储管理方案是将程序离散地分成若干页(块)，从而可以将程序装入不连续的内存空间，显然静态重定位不能满足其要求。</p>
<h5 id="bigstar-二级分页存储管理"><a href="#bigstar-二级分页存储管理" class="headerlink" title="$\bigstar$ 二级分页存储管理"></a>$\bigstar$ 二级分页存储管理</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191549.png" alt="二级分页存储管理-题目"></p>
<h6 id="答案-21"><a href="#答案-21" class="headerlink" title="答案"></a>答案</h6><p>A.081H,101H</p>
<h6 id="解析-55"><a href="#解析-55" class="headerlink" title="解析"></a>解析</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191708.png" alt="二级分页存储管理-解析1"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191746.png" alt="二级分页存储管理-解析2"></p>
<ul>
<li>很容易就选成了C，注意要高位补0</li>
</ul>
<h5 id="最容易产生内存碎片"><a href="#最容易产生内存碎片" class="headerlink" title="最容易产生内存碎片"></a>最容易产生内存碎片</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119191624.png" alt="最容易产生内存碎片-题目"></p>
<h6 id="答案-22"><a href="#答案-22" class="headerlink" title="答案"></a>答案</h6><p>c.最佳适应算法</p>
<h6 id="解析-56"><a href="#解析-56" class="headerlink" title="解析"></a>解析</h6><p>最佳适应算法总是匹配与当前大小要求最接近的空闲分区，但是大多数情况下空闲分区的大小不可能完全和当前要求的大小相等，几乎每次分配内存都会产生很小的难以利用的内存块，所以最佳适应算法最容易产生最多的内存碎片，C正确。</p>
<h5 id="bigstar-答案未知"><a href="#bigstar-答案未知" class="headerlink" title="$\bigstar$ 答案未知"></a>$\bigstar$ 答案未知</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200406.png" alt="答案未知-题目"></p>
<h6 id="答案-23"><a href="#答案-23" class="headerlink" title="答案"></a>答案</h6><!-- ![答案未知-答案]() -->
<h6 id="解析-57"><a href="#解析-57" class="headerlink" title="解析"></a>解析</h6><!-- ![答案未知-解析]() -->
<h5 id="bigtriangledown-中断次数"><a href="#bigtriangledown-中断次数" class="headerlink" title="$\bigtriangledown$ 中断次数"></a>$\bigtriangledown$ 中断次数</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200457.png" alt="中断次数-题目"></p>
<h6 id="答案-24"><a href="#答案-24" class="headerlink" title="答案"></a>答案</h6><p>B.减少</p>
<h6 id="解析-58"><a href="#解析-58" class="headerlink" title="解析"></a>解析</h6><p>在请求分页存储器中，由于页面尺寸增大，存放程序需要的页帧数就会减少，因此缺页中断的次数也会减少。</p>
<h5 id="bigtriangledown-缺页时的操作"><a href="#bigtriangledown-缺页时的操作" class="headerlink" title="$\bigtriangledown$ 缺页时的操作"></a>$\bigtriangledown$ 缺页时的操作</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200811.png" alt="缺页时的操作-题目1"><br><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200820.png" alt="缺页时的操作-题目2"></p>
<h6 id="答案-25"><a href="#答案-25" class="headerlink" title="答案"></a>答案</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119200934.png" alt="缺页时的操作-答案"></p>
<h6 id="解析-59"><a href="#解析-59" class="headerlink" title="解析"></a>解析</h6><p>用户进程访问内存时缺页，会发生缺页中断。发生缺页中断时，系统执行的操作可能是置换页面或分配内存。系统内没有越界错误，不会进行越界出错处理。</p>
<ul>
<li>容易选D</li>
</ul>
<h5 id="最少的缺页次数"><a href="#最少的缺页次数" class="headerlink" title="最少的缺页次数"></a>最少的缺页次数</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119201245.png" alt="最少的缺页次数-题目"></p>
<h6 id="答案-26"><a href="#答案-26" class="headerlink" title="答案"></a>答案</h6><p>C.$n$</p>
<h6 id="解析-60"><a href="#解析-60" class="headerlink" title="解析"></a>解析</h6><p>无论采用什么页面置换算法，每种页面第一次访问时不可能在内存中，必然发生缺页，所以缺页次数大于等于n。</p>
<h5 id="bigtriangledown-虚拟存储器的最大容量"><a href="#bigtriangledown-虚拟存储器的最大容量" class="headerlink" title="$\bigtriangledown$ 虚拟存储器的最大容量"></a>$\bigtriangledown$ 虚拟存储器的最大容量</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119201441.png" alt="虚拟存储器的最大容量-题目"></p>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119201530.png" alt="虚拟存储器的最大容量-题目2"></p>
<h5 id="抖动的原因"><a href="#抖动的原因" class="headerlink" title="抖动的原因"></a>抖动的原因</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119201702.png" alt="抖动的原因-题目"></p>
<h6 id="答案-27"><a href="#答案-27" class="headerlink" title="答案"></a>答案</h6><p>D.页面置换算法不合理</p>
<h6 id="解析-61"><a href="#解析-61" class="headerlink" title="解析"></a>解析</h6><p>内存抖动是指频繁地引起主存页面淘汰后又立即调入，调入后又很快淘汰的现象。这是由页面置换算法不合理引起的一种现象，是页面置换算法应当尽量避免的。</p>
<ul>
<li>容易选A</li>
</ul>
<h5 id="bigstar-地址空间的计算"><a href="#bigstar-地址空间的计算" class="headerlink" title="$\bigstar$ 地址空间的计算"></a>$\bigstar$ 地址空间的计算</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119202729.png" alt="地址空间的计算-题目及答案"></p>
<h6 id="解析-62"><a href="#解析-62" class="headerlink" title="解析"></a>解析</h6><p>页面大小为4KB，因此页内偏移为12位。系统采用48位.虚拟地址，因此虚页号48-12=36位。采用多级页表时，最高级页表项不能超出一页大小;每页能容纳的页表项数为4KB/8B=512=2，36/9=4，因此应采用4级页表，最高级页表项正好占据·页空间，所以本题选择C。</p>
<h5 id="bigtriangledown-提高性能"><a href="#bigtriangledown-提高性能" class="headerlink" title="$\bigtriangledown$ 提高性能"></a>$\bigtriangledown$ 提高性能</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119203605.png" alt="提高性能-题目及答案"></p>
<h6 id="解析-63"><a href="#解析-63" class="headerlink" title="解析"></a>解析</h6><p>用于交换空间的磁盘利用率已达97.7%，其他设备的利用率为5%，CPU的利用率为20%说明在任务作业不多的情况下交换操作非常频繁，因此判断物理内存严重短缺。</p>
<h5 id="bigtriangledown-提高cpu资源利用率"><a href="#bigtriangledown-提高cpu资源利用率" class="headerlink" title="$\bigtriangledown$ 提高cpu资源利用率"></a>$\bigtriangledown$ 提高cpu资源利用率</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119203656.png" alt="提高cpu资源利用率-题目及答案"></p>
<h6 id="解析-64"><a href="#解析-64" class="headerlink" title="解析"></a>解析</h6><p>Ⅰi正确:增大内存的容量。增大内存可使每个程序得到更多的页面，能减少缺页率，进而减少换入/换出过程，可提高CPU的利用率。Ⅱ错误:增大磁盘交换区的容量。因为系统实际已处于频繁的换入/换出过程中，不是因为磁盘交换区容量不够，因此增人磁盘交换区的容量无用。II止.确:减少多道程序的度数。可以提高CPU的利用率，因为从给定的条件知道磁盘交换区的利用率为99.7%，说明系统现在已经处于频繁的换入/换出过程中，可减少主存中的程序。Ⅳ错误:增加多道程序的度数。系统处于频繁的换入/换出过程中，再增加主存中的用户进程数，只能导致系统的换入/换出更频繁，使性能更差。V错误:使用更快速的磁盘交换区。因为系统现在处于频繁的换入/换出过程中，即使采用更快的磁盘交换区，其换入/换出频率也不会改变，因此没用。VI错误:使用更快速的CPU。系统处于频繁的换入/换出过程中，CPU处于空闲状态，利用率不高，提高CPU的速度无济于事。综上分析:I、II可以改进CPU的利用率。</p>
<h5 id="bigstar-Clock算法"><a href="#bigstar-Clock算法" class="headerlink" title="$\bigstar$ Clock算法"></a>$\bigstar$ Clock算法</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204143.png" alt="Clock算法-题目及答案"></p>
<h6 id="解析-65"><a href="#解析-65" class="headerlink" title="解析"></a>解析</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204155.png" alt="Clock算法-解析"></p>
<h5 id="请求分页的组合"><a href="#请求分页的组合" class="headerlink" title="请求分页的组合"></a>请求分页的组合</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204329.png" alt="请求分页的组合-题目及答案"></p>
<h6 id="解析-66"><a href="#解析-66" class="headerlink" title="解析"></a>解析</h6><p>对各进程进行固定分配时页面数不变，不可能出现全局置换。而A、B、D是现代操作系统中常见的3种策略。</p>
<ul>
<li>他这里的全局应该就是整个内存</li>
</ul>
<h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204703.png" alt="工作集-题目及答案"></p>
<h6 id="解析-67"><a href="#解析-67" class="headerlink" title="解析"></a>解析</h6><p>在任-时刻t，都存在…个集合，它包含所有最近k次(该题窗口大小为6)内存访问所访问过的页面。这个集合w{k, t)就是工作集。题中最近6次访问的页面分别为6,0,3,2,3,2，去除重复的页面，形成的工作集为{6,0,3,2}。</p>
<h5 id="LRU计算题"><a href="#LRU计算题" class="headerlink" title="LRU计算题"></a>LRU计算题</h5><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204935.png" alt="LRU计算题-题目及答案"></p>
<h6 id="解析-68"><a href="#解析-68" class="headerlink" title="解析"></a>解析</h6><p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210119204947.png" alt="LRU计算题-解析"></p>
<ul>
<li>放松心情做题，标记清楚</li>
</ul>
<h2 id="第五章-设备管理"><a href="#第五章-设备管理" class="headerlink" title="第五章 设备管理"></a>第五章 设备管理</h2><ul>
<li>目标<ul>
<li>提供与系统其他部分的简单、统一的接口，方便设备使用</li>
<li>优化I/O操作，提高设备与CPU之间以及各种设备之间的并行性，从而提交CPU和设备的利用率</li>
</ul>
</li>
</ul>
<h3 id="设备管理的功能"><a href="#设备管理的功能" class="headerlink" title="设备管理的功能"></a>设备管理的功能</h3><ul>
<li>设备分配</li>
<li>缓冲管理</li>
<li>设备处理</li>
</ul>
<h3 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h3><h4 id="设备的分类"><a href="#设备的分类" class="headerlink" title="设备的分类"></a>设备的分类</h4><ul>
<li>传输速率<ul>
<li>高速设备（每秒传输几百万个字节以上）<ul>
<li>磁盘</li>
<li>光盘</li>
<li>优盘</li>
</ul>
</li>
<li>中速设备（每秒传输几千字节到几十万个字节）<ul>
<li>打印机</li>
<li>扫描仪</li>
</ul>
</li>
<li>低速设备（每秒传输几个字节到几百个字节）<ul>
<li>鼠标</li>
<li>键盘</li>
</ul>
</li>
</ul>
</li>
<li>信息交换单位<ul>
<li>块设备<ul>
<li>特点：传输速率高、可寻址及一般采用DMA方式</li>
<li>磁盘、优盘</li>
</ul>
</li>
<li>字符设备<ul>
<li>特点：传输速率低，不可寻址，一般采用中断驱动方式</li>
<li>交互式终端</li>
<li>打印机</li>
</ul>
</li>
</ul>
</li>
<li>设备共享属性分类<ul>
<li>独占设备</li>
<li>共享设备</li>
<li>虚拟设备</li>
</ul>
</li>
<li>工作特性<ul>
<li>存储设备<ul>
<li>优盘，磁盘，光盘，存储卡</li>
</ul>
</li>
<li>I/O设备<ul>
<li>键盘，显示器，打印机，扫描仪，绘图仪</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h4><p>设备控制器的功能</p>
<ul>
<li>接收和识别命令</li>
<li>数据交换</li>
<li>地址识别</li>
<li>数据缓冲</li>
<li>识别和报告设备的状态</li>
<li>差错控制</li>
</ul>
<h4 id="设备控制器的组成"><a href="#设备控制器的组成" class="headerlink" title="设备控制器的组成"></a>设备控制器的组成</h4><ul>
<li>设备控制器与处理器的接口<ul>
<li>数据缓冲的数据寄存器</li>
<li>设备状态的状态寄存器</li>
<li>保存cpu发来的命令以及各种参数的命令寄存器</li>
</ul>
</li>
<li>设备控制器与设备的接口</li>
<li>I/O逻辑<ul>
<li>用于实现对设备的控制</li>
</ul>
</li>
</ul>
<h4 id="I-O通道"><a href="#I-O通道" class="headerlink" title="I/O通道"></a>I/O通道</h4><ul>
<li>通道类型<ul>
<li>字节多路通道（低速设备）<ul>
<li>以时分复用的方式执行几个通道程序</li>
</ul>
</li>
<li>数组选择通道（高速设备）<ul>
<li>一次只执行一个通道程序</li>
</ul>
</li>
<li>数组多路通道<ul>
<li>时分复用的方式执行多个通道程序</li>
</ul>
</li>
</ul>
</li>
<li>通道程序<ul>
<li>操作码（读，写，控制）</li>
<li>内存地址</li>
<li>计数<ul>
<li>指明本条通道指令所要操作数据的字节数</li>
</ul>
</li>
<li>通道程序结束位P<ul>
<li>P=1表示本指令时通道程序的最后一条指令，表明该通道程序的结束</li>
</ul>
</li>
<li>记录结束标志R。<ul>
<li>R=0表示该通道指令与下一条指令所处理的数据同属一个记录</li>
<li>R=1表示该通道指令时处理某记录的最后一条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="I-O系统结构"><a href="#I-O系统结构" class="headerlink" title="I/O系统结构"></a>I/O系统结构</h4><ul>
<li>总线型I/O系统结构</li>
<li>通道型I/O系统结构</li>
</ul>
<h3 id="输入输出控制方式"><a href="#输入输出控制方式" class="headerlink" title="输入输出控制方式"></a>输入输出控制方式</h3><p>尽量减少CPU对I/O控制的干预</p>
<ul>
<li>程序直接控制方式</li>
<li>中断驱动控制方式<ul>
<li>每传一个字符都要中断</li>
</ul>
</li>
<li>直接存储器存取方式（DMA）<ul>
<li>在I/O设备和主存之间建立一条直接数据通路</li>
</ul>
</li>
<li>通道控制方式<ul>
<li>CPU<ul>
<li>根据本次I/O请求的要求组织通道程序并存放在内存中</li>
<li>发出启动I/O指令，启动相应的通道工作</li>
<li>启动成功后，CPU立即返回执行其他任务</li>
</ul>
</li>
<li>通道程序<ul>
<li>从内存中取出通道程序</li>
<li>依次执行其中的通道指令</li>
<li>控制设备执行输入输出操作</li>
<li>当通道程序执行完成，即数据传送结束时，通道向CPU发中断请求，</li>
</ul>
</li>
<li>CPU<ul>
<li>接收到中断信号后响应中断</li>
<li>执行相应的中断处理程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h3><ul>
<li>目的<ul>
<li>缓和CPU与I/O设备间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽CPU对中断响应时间的限制</li>
<li>提高CPU与I/O设备之间的并行性</li>
</ul>
</li>
</ul>
<h4 id="缓冲的实现机制"><a href="#缓冲的实现机制" class="headerlink" title="缓冲的实现机制"></a>缓冲的实现机制</h4><p>c（处理时间）<br>M（传送时间）<br>T（输入时间）</p>
<ul>
<li>单缓冲<ul>
<li>处理每一块数据的处理时间表示为Max（C,T）+ M</li>
</ul>
</li>
<li>双缓冲<ul>
<li>处理每一块数据的处理时间表示为Max（（T+M）,C）$\approx$ Max（T,C）</li>
</ul>
</li>
<li>循环缓冲</li>
<li>缓冲池</li>
</ul>
<h3 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I/O软件"></a>I/O软件</h3><h4 id="I-O软件的层次模型"><a href="#I-O软件的层次模型" class="headerlink" title="I/O软件的层次模型"></a>I/O软件的层次模型</h4><ul>
<li>用户进程</li>
<li>独立于设备的软件</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
<li>硬件</li>
</ul>
<h4 id="独立于设备的软件"><a href="#独立于设备的软件" class="headerlink" title="独立于设备的软件"></a>独立于设备的软件</h4><ul>
<li>设备独立性（设备无关性）<ul>
<li>用户的应用程序独立于具体使用的物理设备</li>
</ul>
</li>
</ul>
<h4 id="独立与设备的软件功能"><a href="#独立与设备的软件功能" class="headerlink" title="独立与设备的软件功能"></a>独立与设备的软件功能</h4><p>独立于设备的软件的基本任务是实现所有设备都需要的共性功能，并且向用户级软件提供一组统一的使用接口</p>
<ul>
<li>对设备命名</li>
<li>提供设备保护，防止无权限的用户春去设备</li>
<li>提供与设备无关的逻辑块</li>
<li>实现缓冲技术</li>
<li>出错处理</li>
</ul>
<h4 id="设备驱动程序的基本概念"><a href="#设备驱动程序的基本概念" class="headerlink" title="设备驱动程序的基本概念"></a>设备驱动程序的基本概念</h4><h5 id="设备驱动程序的功能"><a href="#设备驱动程序的功能" class="headerlink" title="设备驱动程序的功能"></a>设备驱动程序的功能</h5><h6 id="接收由独立于设备的软件发来的命令和参数"><a href="#接收由独立于设备的软件发来的命令和参数" class="headerlink" title="接收由独立于设备的软件发来的命令和参数"></a>接收由独立于设备的软件发来的命令和参数</h6><h6 id="检查用户I-O请求的合法性"><a href="#检查用户I-O请求的合法性" class="headerlink" title="检查用户I/O请求的合法性"></a>检查用户I/O请求的合法性</h6><h6 id="发出I-O命令"><a href="#发出I-O命令" class="headerlink" title="发出I/O命令"></a>发出I/O命令</h6><h6 id="及时响应由设备控制器发来的中断请求，调用相关的中断处理程序进行处理"><a href="#及时响应由设备控制器发来的中断请求，调用相关的中断处理程序进行处理" class="headerlink" title="及时响应由设备控制器发来的中断请求，调用相关的中断处理程序进行处理"></a>及时响应由设备控制器发来的中断请求，调用相关的中断处理程序进行处理</h6><h6 id="对于具有通道结构的系统，还需要根据用户的I-O请求构造通道程序"><a href="#对于具有通道结构的系统，还需要根据用户的I-O请求构造通道程序" class="headerlink" title="对于具有通道结构的系统，还需要根据用户的I/O请求构造通道程序"></a>对于具有通道结构的系统，还需要根据用户的I/O请求构造通道程序</h6><h5 id="设备驱动程序的特点"><a href="#设备驱动程序的特点" class="headerlink" title="设备驱动程序的特点"></a>设备驱动程序的特点</h5><h6 id="驱动程序是实现独立于设备的软件和设备控制器之间通信与转换的程序"><a href="#驱动程序是实现独立于设备的软件和设备控制器之间通信与转换的程序" class="headerlink" title="驱动程序是实现独立于设备的软件和设备控制器之间通信与转换的程序"></a>驱动程序是实现独立于设备的软件和设备控制器之间通信与转换的程序</h6><h6 id="驱动程序与设备控制器以及I-O设备的硬件特性紧密相关，常用的I-O驱动方式是终端驱动和DMA方式"><a href="#驱动程序与设备控制器以及I-O设备的硬件特性紧密相关，常用的I-O驱动方式是终端驱动和DMA方式" class="headerlink" title="驱动程序与设备控制器以及I/O设备的硬件特性紧密相关，常用的I/O驱动方式是终端驱动和DMA方式"></a>驱动程序与设备控制器以及I/O设备的硬件特性紧密相关，常用的I/O驱动方式是终端驱动和DMA方式</h6><h6 id="由于驱动程序与硬件紧密相关，因而其中一部分代码必须用汇编语言编写"><a href="#由于驱动程序与硬件紧密相关，因而其中一部分代码必须用汇编语言编写" class="headerlink" title="由于驱动程序与硬件紧密相关，因而其中一部分代码必须用汇编语言编写"></a>由于驱动程序与硬件紧密相关，因而其中一部分代码必须用汇编语言编写</h6><h6 id="驱动程序应允许可重入"><a href="#驱动程序应允许可重入" class="headerlink" title="驱动程序应允许可重入"></a>驱动程序应允许可重入</h6><h5 id="设备处理方式"><a href="#设备处理方式" class="headerlink" title="设备处理方式"></a>设备处理方式</h5><h6 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h6><h6 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h6><h6 id="不设置专门的进程，而只为各类设备设置相应的设备驱动程序，供用户或系统进程调用。"><a href="#不设置专门的进程，而只为各类设备设置相应的设备驱动程序，供用户或系统进程调用。" class="headerlink" title="不设置专门的进程，而只为各类设备设置相应的设备驱动程序，供用户或系统进程调用。"></a>不设置专门的进程，而只为各类设备设置相应的设备驱动程序，供用户或系统进程调用。</h6><p>这种方式目前用的比较多</p>
<h5 id="设备驱动程序的处理过程"><a href="#设备驱动程序的处理过程" class="headerlink" title="设备驱动程序的处理过程"></a>设备驱动程序的处理过程</h5><h6 id="将抽象要求转换为具体要求"><a href="#将抽象要求转换为具体要求" class="headerlink" title="将抽象要求转换为具体要求"></a>将抽象要求转换为具体要求</h6><h6 id="对服务请求进行校验"><a href="#对服务请求进行校验" class="headerlink" title="对服务请求进行校验"></a>对服务请求进行校验</h6><h6 id="检查设备的状态"><a href="#检查设备的状态" class="headerlink" title="检查设备的状态"></a>检查设备的状态</h6><h6 id="传送必要的参数"><a href="#传送必要的参数" class="headerlink" title="传送必要的参数"></a>传送必要的参数</h6><h6 id="启动I-O设备"><a href="#启动I-O设备" class="headerlink" title="启动I/O设备"></a>启动I/O设备</h6><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><h4 id="设备分配的数据结构"><a href="#设备分配的数据结构" class="headerlink" title="设备分配的数据结构"></a>设备分配的数据结构</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="设备控制表表（DCT）"><a href="#设备控制表表（DCT）" class="headerlink" title="设备控制表表（DCT）"></a>设备控制表表（DCT）</h6><p>记录设备的特性及与设备控制器连接的情况</p>
<ul>
<li>Device control table</li>
</ul>
<h6 id="控制器控制表（CODT）"><a href="#控制器控制表（CODT）" class="headerlink" title="控制器控制表（CODT）"></a>控制器控制表（CODT）</h6><p>每个设备控制器配置一张控制器控制表，记录控制器的使用状态及与通道的连接状况等</p>
<ul>
<li>Controller Control Table</li>
</ul>
<h6 id="通道控制表（CHCT）"><a href="#通道控制表（CHCT）" class="headerlink" title="通道控制表（CHCT）"></a>通道控制表（CHCT）</h6><p>每个通道配置一张设备控制表，记录通道的使用状态</p>
<ul>
<li>Channel Control Table</li>
</ul>
<h6 id="系统设备表（设备类表）-SDT"><a href="#系统设备表（设备类表）-SDT" class="headerlink" title="系统设备表（设备类表）(SDT)"></a>系统设备表（设备类表）(SDT)</h6><p>整个系统一张</p>
<ul>
<li>System Device Table</li>
</ul>
<h4 id="设备分配过程"><a href="#设备分配过程" class="headerlink" title="设备分配过程"></a>设备分配过程</h4><p>一共三个步骤</p>
<h5 id="设备分配过程-1"><a href="#设备分配过程-1" class="headerlink" title="设备分配过程"></a>设备分配过程</h5><h6 id="分配设备"><a href="#分配设备" class="headerlink" title="分配设备"></a>分配设备</h6><h6 id="分配控制器"><a href="#分配控制器" class="headerlink" title="分配控制器"></a>分配控制器</h6><h6 id="分配通道"><a href="#分配通道" class="headerlink" title="分配通道"></a>分配通道</h6><h3 id="SPOOLing系统"><a href="#SPOOLing系统" class="headerlink" title="SPOOLing系统"></a>SPOOLing系统</h3><ul>
<li>组成<ul>
<li>输入井和输出井（在磁盘上）</li>
<li>预输入程序和缓输出程序</li>
<li>井管理程序</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210120112941.png" alt="spooling系统的组成"></p>
<h3 id="Linux字符设备驱动程序"><a href="#Linux字符设备驱动程序" class="headerlink" title="Linux字符设备驱动程序"></a>Linux字符设备驱动程序</h3><p>感觉应该不是考试重点，也没做对应的实验</p>
<h4 id="Linux字符设备驱动程序基础"><a href="#Linux字符设备驱动程序基础" class="headerlink" title="Linux字符设备驱动程序基础"></a>Linux字符设备驱动程序基础</h4><h4 id="字符驱动程序设计"><a href="#字符驱动程序设计" class="headerlink" title="字符驱动程序设计"></a>字符驱动程序设计</h4><h4 id="字符驱动程序举例"><a href="#字符驱动程序举例" class="headerlink" title="字符驱动程序举例"></a>字符驱动程序举例</h4><h3 id="Linux中断处理机制"><a href="#Linux中断处理机制" class="headerlink" title="Linux中断处理机制"></a>Linux中断处理机制</h3><h4 id="Linux中断处理机制概述"><a href="#Linux中断处理机制概述" class="headerlink" title="Linux中断处理机制概述"></a>Linux中断处理机制概述</h4><h4 id="中断服务例程的注册和注销"><a href="#中断服务例程的注册和注销" class="headerlink" title="中断服务例程的注册和注销"></a>中断服务例程的注册和注销</h4><h4 id="上半部的处理过程"><a href="#上半部的处理过程" class="headerlink" title="上半部的处理过程"></a>上半部的处理过程</h4><h4 id="下半部的实现机制"><a href="#下半部的实现机制" class="headerlink" title="下半部的实现机制"></a>下半部的实现机制</h4><h3 id="本章小结-4"><a href="#本章小结-4" class="headerlink" title="本章小结"></a>本章小结</h3><ul>
<li>通道是一种特殊的处理器，所以属于硬件技术。SPOOLing、缓冲池、内存覆盖都是在内存的基础上通过软件实现的。</li>
<li>汁算机系统为每台设备确定一个编号以使区.分和识别设备，这个确定的编号称为设备的绝对号。</li>
<li>通道控制设备控制器、设备控制器控制设备工作。对于同一组输入输出命令，三者不能并行工作。</li>
<li>将系统调用参数翻译成设备操作命令的工作由设备无关的操作系统软件完成</li>
</ul>
<h3 id="本章习题-4"><a href="#本章习题-4" class="headerlink" title="本章习题"></a>本章习题</h3><h4 id="缓冲机制"><a href="#缓冲机制" class="headerlink" title="缓冲机制"></a>缓冲机制</h4><p>如果算的是下面，要加上上面，反之亦然(单缓冲双缓冲的计算题目)</p>
<h2 id="第六章-文件系统"><a href="#第六章-文件系统" class="headerlink" title="第六章 文件系统"></a>第六章 文件系统</h2><ul>
<li>从用户的观点看主要关心<ul>
<li>文件由什么组成</li>
<li>如何命名</li>
<li>如何保护文件</li>
<li>能进行哪些操作</li>
</ul>
</li>
<li>从操作系统的观点看主要关心<ul>
<li>文件目录是怎样实现的</li>
<li>怎样管理存储空间</li>
<li>如何实现文件的按名存取及文件的共享与保护</li>
</ul>
</li>
<li>文件的概念<ul>
<li>文件是具有符号名的，在逻辑上有完整意义的一组相关信息项的有序集合</li>
</ul>
</li>
<li>Linux系统的文件名区分大小写字符。而MS-DOS和windows系列的操作系统不区分大小写</li>
<li>从操作系统的角度看<ul>
<li>文件存储空间的管理<ul>
<li>主要任务是为每个文件分配合适的外存空间，提高外存的利用率和文件的存取速度</li>
</ul>
</li>
<li>文件目录管理<ul>
<li>文件系统最<strong>基本的功能</strong>就是实现文件的“按名存取“</li>
</ul>
</li>
<li>文件地址映射</li>
<li>文件读写管理</li>
<li>文件共享和保护</li>
</ul>
</li>
</ul>
<h3 id="文件的组织结构"><a href="#文件的组织结构" class="headerlink" title="文件的组织结构"></a>文件的组织结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><ul>
<li>面向用户的文件组织结构和构造方式</li>
<li>有结构的文件<ul>
<li>顺序文件</li>
<li>索引文件<ul>
<li>索引表:每条逻辑记录占一个表项，每个表项内容存放记录的关键字，长度和起始位置</li>
</ul>
</li>
<li>索引顺序文件</li>
<li>直接文件和散列文件</li>
</ul>
</li>
<li>无结构文件（流式文件）</li>
</ul>
<h4 id="物理结构（存储结构或物理文件）"><a href="#物理结构（存储结构或物理文件）" class="headerlink" title="物理结构（存储结构或物理文件）"></a>物理结构（存储结构或物理文件）</h4><ul>
<li>存储介质上的组织方式</li>
<li>连续文件<ul>
<li>优点<ul>
<li>顺序存取速度快</li>
<li>方便地实现文件的随机存取</li>
</ul>
</li>
<li>缺点<ul>
<li>对存储文件要求有连续的存储空间</li>
<li>容易产生磁盘碎片，降低磁盘存储空间的利用率</li>
<li>不方便文件的动态增长（不利于文件的扩展）</li>
<li>如果使用拼接技术来消除碎片，又要消耗大量的系统时间</li>
</ul>
</li>
</ul>
</li>
<li>链接文件<ul>
<li>隐式链接<ul>
<li>缺点<ul>
<li>只能对文件进行顺序存取</li>
<li>效率低（如果希望存取一个文件的某个磁盘块，及必须从该文件的第一个盘块开始读取，才能找到指定磁盘块的位置）</li>
<li>可靠性差（如果文件中某个磁盘块出现故障，将导致该文件的后续盘块指针丢失）</li>
</ul>
</li>
</ul>
</li>
<li>显式链接（FAT）<ul>
<li>目录项填入文件名，起始盘块号，文件长度</li>
<li>优点<ul>
<li>提高检索速度（查找FAT是在内存而非磁盘中进行的）</li>
<li>实现随机存取（一个文件的全部盘块号都集中保存在fat中）</li>
</ul>
</li>
<li>缺点<ul>
<li>随即存取的效率会降低（FAT较大时）</li>
<li>FAT占据较大的内存空间（FAT较大时）</li>
</ul>
</li>
</ul>
</li>
<li>总优点<ul>
<li>消除磁盘的碎片，提高了磁盘存储空间的利用率</li>
<li>使文件很容易实现动态增长</li>
</ul>
</li>
</ul>
</li>
<li>索引文件<ul>
<li>单级索引</li>
<li>多级索引</li>
<li>混合索引（Uinx system V）</li>
</ul>
</li>
</ul>
<h3 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h3><ul>
<li>功能<ul>
<li>实现”按名存取“</li>
<li>提高目录的索引速度</li>
<li>允许文件重名</li>
<li>允许文件共享</li>
</ul>
</li>
<li>文件控制块<ul>
<li>基本信息<ul>
<li>文件名</li>
<li>用户名</li>
<li>文件类型</li>
<li>文件的物理地址</li>
<li>文件长度</li>
<li>文件的逻辑结构和物理结构</li>
</ul>
</li>
<li>存取控制信息</li>
<li>使用信息</li>
</ul>
</li>
<li>索引节点的引入</li>
<li>文件的目录结构</li>
</ul>
<h3 id="文件目录管理-1"><a href="#文件目录管理-1" class="headerlink" title="文件目录管理"></a>文件目录管理</h3><h4 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h4><ul>
<li>文件系统通常把一组文件的目录项组织成一个独立的文件，这个全部由文件目录项组成的文件称为目录文件</li>
<li>结构形式<ul>
<li>单级目录结构</li>
<li>两级目录结构<ul>
<li>主文件目录（Master File Directory，MFD）</li>
<li>用户文件目录（User File Directory。UFD）</li>
</ul>
</li>
<li>多级目录结构</li>
</ul>
</li>
<li>目录检索技术<ul>
<li>线性检索法</li>
<li>Hash方法</li>
</ul>
</li>
</ul>
<h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><ul>
<li>空闲表法</li>
<li>空闲块链表法</li>
<li>位示图<ul>
<li>n代表每行的列数，b是盘块号</li>
<li>b = n(i-1) + j</li>
<li>行号 i=(b-1) DIV n + 1</li>
<li>列号 j=(b-1) MOD n + 1</li>
</ul>
</li>
<li>成组链接法</li>
</ul>
<h3 id="文件共享和文件保护"><a href="#文件共享和文件保护" class="headerlink" title="文件共享和文件保护"></a>文件共享和文件保护</h3><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><ul>
<li>基于索引节点的共享方式</li>
<li>利用符号链接实现文件共享</li>
</ul>
<h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><h5 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h5><h6 id="批量备份"><a href="#批量备份" class="headerlink" title="批量备份"></a>批量备份</h6><h6 id="同步备份"><a href="#同步备份" class="headerlink" title="同步备份"></a>同步备份</h6><h5 id="文件访问保护"><a href="#文件访问保护" class="headerlink" title="文件访问保护"></a>文件访问保护</h5><h6 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h6><h6 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h6><h6 id="设置文件访问写权限"><a href="#设置文件访问写权限" class="headerlink" title="设置文件访问写权限"></a>设置文件访问写权限</h6><h5 id="设置文件访问写权限的方法"><a href="#设置文件访问写权限的方法" class="headerlink" title="设置文件访问写权限的方法"></a>设置文件访问写权限的方法</h5><h6 id="访问控制矩阵"><a href="#访问控制矩阵" class="headerlink" title="访问控制矩阵"></a>访问控制矩阵</h6><p>矩阵形式，行为用户，列为对象</p>
<h6 id="访问控制表"><a href="#访问控制表" class="headerlink" title="访问控制表"></a>访问控制表</h6><p>按对象划分，一个对象一张表</p>
<h6 id="用户权限表"><a href="#用户权限表" class="headerlink" title="用户权限表"></a>用户权限表</h6><p>按用户划分，一个用户一张表</p>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>如何优化磁盘调度算法以改善磁盘访问速度是操作系统的重要任务之一</p>
<h4 id="磁盘管理概述"><a href="#磁盘管理概述" class="headerlink" title="磁盘管理概述"></a>磁盘管理概述</h4><ul>
<li>数据的组织和格式<ul>
<li>CHS(Cyliner/Head/Sector)柱面号，磁头号，扇区号</li>
<li>LBA（logical block addressing）<ul>
<li>L（一个磁盘的柱面数），M(磁头数)，N（扇区数），第i柱面，j磁头，k扇区对应的LBA扇区号为<ul>
<li>LBA = （i*M*N）+ j*N + k-1</li>
</ul>
</li>
<li>已知LBA，对应的柱面号i，磁头号j，扇区号k为<ul>
<li>i = int(LBA/(M*N))</li>
<li>J = [LBA mod (M*N)]/N</li>
<li>k = [LBA mod (M*N)] mod N + 1</li>
</ul>
</li>
<li>磁盘的容量<ul>
<li>磁头数 $\times$ 柱面数 $\times$ 扇区数 $\times$ 每扇区字节数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>磁盘访问时间<ul>
<li>寻道时间$T_s$（是机械运动，影响最大）<ul>
<li>m磁头每移动一条磁道所需要的时间(与磁盘驱动器的速度相关)，n寻道距离(移动的磁道数，是影响$T_s$的主要参数)，s（启动磁臂的时间）</li>
<li>$T_s = m \centerdot n + s$</li>
</ul>
</li>
<li>旋转延迟时间$T_r$<ul>
<li>r磁盘旋转的速度，（旋转延迟时间是欲访问扇区旋转到磁头下面所需要的时间，与磁盘旋转速度有直接关系，可粗略的仍未是磁盘旋转半周的时间）</li>
<li>$T_r = \dfrac{1}{r} \div 2 = \dfrac{1}{2r}$</li>
</ul>
</li>
<li>传输时间$T_t$<ul>
<li>b要读写的字节数，r磁盘的旋转速度，N一个磁道上的字节数，（把数据从磁盘读出或向磁盘写入所需要的时间，他与磁盘的转速以及要读/写的字节数有关）</li>
<li>$T_t = \dfrac{b}{rN}$</li>
</ul>
</li>
<li>总的磁盘访问时间$T_a$<ul>
<li>访问时间$T_a$ = 寻道时间$T_s$ + 旋转延迟时间$T_r$ + 传输时间$T_t$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><h4 id="移臂调度"><a href="#移臂调度" class="headerlink" title="移臂调度"></a>移臂调度</h4><h5 id="先来先服务（First-Come-First-Served，FCFS）算法"><a href="#先来先服务（First-Come-First-Served，FCFS）算法" class="headerlink" title="先来先服务（First Come First Served，FCFS）算法"></a>先来先服务（First Come First Served，FCFS）算法</h5><ul>
<li>优点<ul>
<li>公平且实现简单</li>
<li>不会产生饥饿现象</li>
</ul>
</li>
<li>缺点<ul>
<li>寻道时间比较长（未对寻道进行优化）<!-- ###### 测试5级标题 -->
</li>
</ul>
</li>
</ul>
<h5 id="最短寻道时间优先-ShortestSeekTimeFirst-SSTF-算法"><a href="#最短寻道时间优先-ShortestSeekTimeFirst-SSTF-算法" class="headerlink" title="最短寻道时间优先(ShortestSeekTimeFirst,SSTF)算法"></a>最短寻道时间优先(ShortestSeekTimeFirst,SSTF)算法</h5><ul>
<li>概念<ul>
<li>总是选择与当前磁道（磁头所在的磁道）距离最近的磁道访问请求</li>
</ul>
</li>
<li>缺点<ul>
<li>不公平</li>
<li>不能保证平均寻道距离最短</li>
<li>产生饥饿（可能会使某些远离当前磁道的I/O请求长度得不到服务）</li>
<li>影响磁盘的机械寿命（完全不考虑磁头当前的移动方向，可能会导致磁头频繁地改变移动方向而影响磁盘的机械寿命）</li>
</ul>
</li>
</ul>
<h5 id="扫描（SCAN）算法-电梯算法"><a href="#扫描（SCAN）算法-电梯算法" class="headerlink" title="扫描（SCAN）算法(电梯算法)"></a>扫描（SCAN）算法(电梯算法)</h5><ul>
<li>概念<ul>
<li>确定下一条要访问的磁道时，既照顾磁头当前的移动方向，又考虑当前磁道的距离，总是从磁头当前移动方向上，选择与当前磁道距离最近的磁道访问请求，如果磁头移动方向无访问请求时，就改变磁头的移动方向，从方向再选择</li>
</ul>
</li>
</ul>
<h5 id="循环扫描（Circular-SCAN，CSCAN）算法"><a href="#循环扫描（Circular-SCAN，CSCAN）算法" class="headerlink" title="循环扫描（Circular SCAN，CSCAN）算法"></a>循环扫描（Circular SCAN，CSCAN）算法</h5><ul>
<li>规定磁头的单向移动，当磁头完成最里层磁道访问请求时，立即返回最外面的磁道，循环扫描</li>
</ul>
<h5 id="N-Step-SCAN算法"><a href="#N-Step-SCAN算法" class="headerlink" title="N-Step-SCAN算法"></a>N-Step-SCAN算法</h5><ul>
<li>将当前的磁盘请求队列分为若干长度为N的子队列，磁盘调度将按FSFS算法依次处理这些子队列，而在处理每个子队列时又采用SCAN算法</li>
</ul>
<h5 id="FSCAN（FairSCAN）算法"><a href="#FSCAN（FairSCAN）算法" class="headerlink" title="FSCAN（FairSCAN）算法"></a>FSCAN（FairSCAN）算法</h5><ul>
<li>分成两个队列，一个就绪，一个运行</li>
</ul>
<h4 id="旋转调度"><a href="#旋转调度" class="headerlink" title="旋转调度"></a>旋转调度</h4><p>当一条磁道上，有多个扇区访问请求时，确定扇区访问顺序，以减少旋转延迟时间</p>
<h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><ul>
<li>linux的用户权限<ul>
<li>rwx</li>
<li>所有者-用户组-其他人</li>
</ul>
</li>
<li>最外层的磁道号为0号，由外到内增加</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>文件目录项和文件控制块的区别</li>
<li>目录文件和文件目录项的区别</li>
<li>硬链接和复制文件的区别是什么</li>
<li>linux是几级索引</li>
</ul>
<h3 id="考研书的题目"><a href="#考研书的题目" class="headerlink" title="考研书的题目"></a>考研书的题目</h3><ul>
<li>一个文件对应一个索引节点，索引节点的总数只能说明有多少个文件。</li>
</ul>
<h1 id="考研书题目"><a href="#考研书题目" class="headerlink" title="考研书题目"></a>考研书题目</h1><h3 id="2018-2019-1-OS-A-pdf"><a href="#2018-2019-1-OS-A-pdf" class="headerlink" title="2018-2019-1 OS A.pdf"></a>2018-2019-1 OS A.pdf</h3><ul>
<li>做题总结<ul>
<li><ul>
<li>[x] CFS调度器需要看</li>
</ul>
</li>
<li>文件系统，设备管理的选择题要看</li>
<li>注意点<ul>
<li>计算题有可能算错，43理所当然的认为是40</li>
</ul>
</li>
</ul>
</li>
<li>9.以下关于Linux的CFS 调度器的说法，正确的是（)<br>A. CFS调度器的基本思想是系统尽可能让所有就绪进程平均分配CPU的运行时间<br>B.CFS 调度器在选择下一个运行进程时，总是选择权重最大的进程参与运行<br>c．在CFS调度器中，nice值为0的进程，其虚拟运行时间等于其实际运行时间<br>D.为提高调度时的效率，CFS 调度器将其就绪队列设置为双向链表<br><strong>A错在了哪里？</strong></li>
</ul>
<h2 id="misc-1"><a href="#misc-1" class="headerlink" title="misc"></a>misc</h2><ul>
<li>注意不要看错选项</li>
<li>注意不要算错数（结果不要想当然，数据不要抄错）</li>
<li><p>什么是原语？<br>&lt;!— ### 刷题标记规范</p>
</li>
<li><p>圈圈表示不太懂需要注意</p>
</li>
<li>三角表示重点有点迷糊需要反复看</li>
<li>五角星表示完全不是很懂，而且还是重点 —&gt;</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8D%A0%E5%9D%91/" rel="tag"># 占坑</a>
              <a href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="tag"># 期末复习</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/01/test/" rel="prev" title="test">
      <i class="fa fa-chevron-left"></i> test
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/15/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/" rel="next" title="计网复习">
      计网复习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E6%A0%A1%E8%AF%BE%E6%9C%AC"><span class="nav-text">学校课本</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="nav-text">第一章 操作系统引论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">什么是操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="nav-text">计算机系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">操作系统的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%8E%AF%E5%A2%83%E7%9A%84%E8%A7%82%E7%82%B9"><span class="nav-text">用户环境的观点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E8%A7%82%E7%82%B9"><span class="nav-text">资源管理的观点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%82%E7%82%B9"><span class="nav-text">虚拟机观点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-text">操作系统的发展与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95"><span class="nav-text">操作系统的发展</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C%E9%98%B6%E6%AE%B5"><span class="nav-text">手工操作阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-text">单道批处理系统</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-text">多道批处理系统</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">分时操作系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">实时操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E9%83%BD%E5%85%B7%E6%9C%89%E5%A4%9A%E8%B7%AF%E6%80%A7"><span class="nav-text">实时系统与分时系统都具有多路性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E9%83%BD%E5%85%B7%E6%9C%89%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="nav-text">实时系统与分时系统都具有独立性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E9%83%BD%E8%A6%81%E6%B1%82%E5%8F%8A%E6%97%B6%E6%80%A7"><span class="nav-text">实时系统与分时系统都要求及时性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E9%83%BD%E5%85%B7%E6%9C%89%E4%BA%A4%E4%BA%92%E6%80%A7"><span class="nav-text">实时系统与分时系统都具有交互性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E9%83%BD%E8%A6%81%E6%B1%82%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-text">实时系统与分时系统都要求可靠性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AE%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">微机操作系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">网络操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%AE%A1%E7%90%86"><span class="nav-text">网络通信管理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-text">网络资源管理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86"><span class="nav-text">网络安全管理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%90%E4%BE%9B%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1"><span class="nav-text">提供网络服务</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">分布式操作系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">嵌入式操作系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="nav-text">操作系统的特征和功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-text">操作系统的特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7"><span class="nav-text">并发性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%80%A7"><span class="nav-text">共享性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%80%A7"><span class="nav-text">虚拟性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%80%A7"><span class="nav-text">异步性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">操作系统的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86"><span class="nav-text">处理器管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="nav-text">存储器管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-text">设备管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-text">文件管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E4%BE%9B%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="nav-text">提供用户接口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3"><span class="nav-text">命令接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">程序接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E6%8E%A5%E5%8F%A3"><span class="nav-text">图形接口</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="nav-text">操作系统用户接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D"><span class="nav-text">三种</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%8E%A5%E5%8F%A3-Command-Line-lnterface%EF%BC%8CCLI"><span class="nav-text">命令接口(Command Line lnterface，CLI)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3-Application-Programming-Interface%EF%BC%8CAPI"><span class="nav-text">程序接口(Application Programming Interface，API)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E6%8E%A5%E5%8F%A3-GraphicalUser-Interface%EF%BC%8CGUI"><span class="nav-text">图形接口(GraphicalUser Interface，GUI)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="nav-text">操作系统内核结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D-1"><span class="nav-text">三种</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-text">整体结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">层次结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D"><span class="nav-text">典型操作系统介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-text">本章小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B9%A0%E9%A2%98"><span class="nav-text">本章习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80"><span class="nav-text">第二章 操作系统硬件基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%A1%E7%AE%97"><span class="nav-text">处理器计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="nav-text">处理器指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%89%B9%E6%9D%83%E7%BA%A7"><span class="nav-text">处理器特权级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">高速缓冲寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-text">内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E6%A0%88"><span class="nav-text">堆栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98"><span class="nav-text">磁盘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8"><span class="nav-text">非易失性存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-text">局部性原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F"><span class="nav-text">中断和时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-text">中断和异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">什么是系统调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%85%A5%E5%8F%A3%E8%A1%A8"><span class="nav-text">系统调用号、系统调用服务例程及系统调用入口表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7%E5%8F%8A%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-text">系统调用号及参数的传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigstar-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">$\bigstar$ 系统调用处理流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F"><span class="nav-text">系统时钟</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-1"><span class="nav-text">本章小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B9%A0%E9%A2%98-1"><span class="nav-text">本章习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">第三章 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">进程的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%8F%8A%E7%89%B9%E5%BE%81"><span class="nav-text">进程的并发执行及特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="nav-text">程序的并发执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-text">程序并发执行的特征</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%97%B4%E6%96%AD%E6%80%A7"><span class="nav-text">间断性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%B1%E5%8E%BB%E5%B0%81%E9%97%AD%E6%80%A7%E8%80%8C%E5%AF%BC%E8%87%B4%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%87%BA%E7%8E%B0%E4%B8%8D%E5%8F%AF%E5%86%8D%E7%8E%B0%E6%80%A7"><span class="nav-text">失去封闭性而导致程序运行结果出现不可再现性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E4%B8%8D%E8%83%BD%E6%94%AF%E6%8C%81%E5%B9%B6%E5%8F%91%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">静态程序结构不能支持并发运行的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="nav-text">进程管理功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="nav-text">进程互斥与同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">进程通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6"><span class="nav-text">调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">进程的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="nav-text">进程的定义和特征</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81-1"><span class="nav-text">进程的定义和特征</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%80%A7"><span class="nav-text">动态性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7-1"><span class="nav-text">并发性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="nav-text">独立性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%80%A7-1"><span class="nav-text">异步性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F"><span class="nav-text">进程映像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-text">进程与程序的区别和联系</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%98%AF%E9%9D%99%E6%80%81%E6%A6%82%E5%BF%B5%EF%BC%8C%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%8A%A8%E6%80%81%E7%9A%84"><span class="nav-text">程序是静态概念，进程是动态的</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%98%AF%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%EF%BC%8C%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%83%BD%E5%8F%82%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="nav-text">进程是调度的基本单位，程序不能参与并发执行</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%B9%B6%E9%9D%9E%E6%98%AF%E4%B8%80%E5%AF%B9%E4%B8%80%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">程序和进程并非是一对一的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-text">进程状态与转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="nav-text">进程的三种基本状态</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"><span class="nav-text">就绪状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="nav-text">运行状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="nav-text">阻塞状态</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E5%92%8C%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="nav-text">创建状态和终止状态</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81"><span class="nav-text">创建状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="nav-text">终止状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%90"><span class="nav-text">Linux进程状态解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#state"><span class="nav-text">state</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#TASK-RUNNING"><span class="nav-text">TASK_RUNNING</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TASK-INTERRUPTIBLE"><span class="nav-text">TASK_INTERRUPTIBLE</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TASK-UNINTERRUPTIBLE"><span class="nav-text">TASK_UNINTERRUPTIBLE</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TASK-STOPPED"><span class="nav-text">TASK_STOPPED</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TASK-TRACED"><span class="nav-text">TASK_TRACED</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TASK-DEAD"><span class="nav-text">TASK_DEAD</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TASK-WAKEKILL"><span class="nav-text">TASK_WAKEKILL</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exit-state"><span class="nav-text">exit_state</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#EXIT-ZOMBIE"><span class="nav-text">EXIT_ZOMBIE</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#EXIT-DEAD"><span class="nav-text">EXIT_DEAD</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-text">进程控制块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E4%BF%A1%E6%81%AF"><span class="nav-text">进程标识信息</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">进程标识符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">用户标识符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%B6%E6%97%8F%E5%85%B3%E7%B3%BB"><span class="nav-text">家族关系</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%BF%A1%E6%81%AF"><span class="nav-text">进程调度信息</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">进程优先级</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-text">其他调度相关信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-text">事件</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8E%B0%E5%9C%BA%E4%BF%A1%E6%81%AF"><span class="nav-text">进程现场信息</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9"><span class="nav-text">通用寄存器内容</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%80%BC"><span class="nav-text">指令计数器的值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AD%97PSW"><span class="nav-text">程序状态字PSW</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88%E6%8C%87%E9%92%88"><span class="nav-text">栈指针</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF"><span class="nav-text">进程控制信息</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E6%88%96%E5%A4%96%E5%AD%98%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82"><span class="nav-text">进程的程序和数据在内存或外存的地址。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BF%A1%E6%81%AF"><span class="nav-text">进程同步信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%BF%A1%E6%81%AF"><span class="nav-text">进程通信信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%BF%A1%E6%81%AF"><span class="nav-text">资源管理信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%8C%87%E9%92%88"><span class="nav-text">链接指针</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-1"><span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%BE"><span class="nav-text">进程图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BA%8B%E4%BB%B6"><span class="nav-text">引起进程创建的典型事件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="nav-text">作业调度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95"><span class="nav-text">用户登录</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%90%E4%BE%9B%E7%89%B9%E5%AE%9A%E6%9C%8D%E5%8A%A1"><span class="nav-text">提供特定服务</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E8%AF%B7%E6%B1%82"><span class="nav-text">应用请求</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%8E%9F%E8%AF%AD"><span class="nav-text">进程创建原语</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%94%B3%E8%AF%B7%E4%B8%80%E4%B8%AA%E5%B0%9A%E6%9C%AA%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84pid%E5%92%8C%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%99%BDPCB%E3%80%82"><span class="nav-text">为新进程申请一个尚未被使用的pid和一个空白PCB。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E6%96%B0%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-text">为新进程分配必要的资源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84PCB"><span class="nav-text">初始化新进程的PCB</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%86%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%BD%AE%E4%B8%BA%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"><span class="nav-text">将新进程状态置为就绪状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%92%A4%E9%94%80"><span class="nav-text">进程撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E6%92%A4%E9%94%80%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BA%8B%E4%BB%B6"><span class="nav-text">引起进程撤销的典型事件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E7%BB%93%E6%9D%9F%E8%80%8C%E6%92%A4%E9%94%80"><span class="nav-text">正常结束而撤销</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2%E8%80%8C%E6%92%A4%E9%94%80"><span class="nav-text">异常终止而撤销</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BA%94%E5%A4%96%E7%95%8C%E5%B9%B2%E9%A2%84%E8%80%8C%E6%92%A4%E9%94%80"><span class="nav-text">应外界干预而撤销</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%92%A4%E9%94%80%E5%8E%9F%E8%AF%AD"><span class="nav-text">进程撤销原语</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="nav-text">进程阻塞与唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BA%8B%E4%BB%B6"><span class="nav-text">引起进程阻塞和唤醒的典型事件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%E5%A4%B1%E8%B4%A5"><span class="nav-text">请求资源失败</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E6%9F%90%E7%A7%8D%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%8C%E6%88%90"><span class="nav-text">等待某种操作的完成</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%8D%E9%A9%B1%E8%BF%9B%E7%A8%8B%E5%B0%9A%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="nav-text">前驱进程尚未完成</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%97%A0%E6%96%B0%E5%B7%A5%E4%BD%9C%E5%8F%AF%E5%81%9A"><span class="nav-text">进程无新工作可做</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD"><span class="nav-text">进程阻塞原语</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92"><span class="nav-text">进程唤醒</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">Linux进程管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">进程同步的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%97%B4%E6%8E%A5%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-text">并发进程间的间接制约关系与进程互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="nav-text">临界资源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%BA%94%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-text">同步机制应遵循的原则</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">并发进程间的直接制约关系与进程同步</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-text">进程同步机制及应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="nav-text">利用硬件方法解决进程互斥问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E4%B8%AD%E6%96%AD"><span class="nav-text">禁止中断</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%B8%93%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="nav-text">利用专用机器指令解决进程互斥问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="nav-text">利用软件方法解决进程互斥问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%97%E6%B3%95"><span class="nav-text">不正确的软件算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="nav-text">Peterson算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%A2%E5%8C%85%E5%BA%97%E7%AE%97%E6%B3%95"><span class="nav-text">面包店算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E9%94%81%E6%9C%BA%E5%88%B6%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="nav-text">利用锁机制解决进程互斥问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-text">利用信号量机制解决进程互斥与同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-text">整型信号量机制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-text">记录型信号量机制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="nav-text">信号量集机制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5"><span class="nav-text">利用信号量机制实现进程的互斥</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-text">经典进程同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">生产者-消费者问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-text">哲学家进餐问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">读者-写者问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98"><span class="nav-text">理发师问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="nav-text">管程机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">管程定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">利用管程机制解决生产者-消费者问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="nav-text">Linux同步机制解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">进程调度的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-text">调度的层次</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-text">高级调度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-text">低级调度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-text">中级调度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8A%9F%E8%83%BD"><span class="nav-text">进程调度功能</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%92%E9%98%9F%E7%A8%8B%E5%BA%8F"><span class="nav-text">排队程序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E6%B4%BE%E7%A8%8B%E5%BA%8F"><span class="nav-text">分派程序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%A8%8B%E5%BA%8F"><span class="nav-text">上下文切换程序</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-text">进程调度方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F"><span class="nav-text">非抢占方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F"><span class="nav-text">抢占方式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="nav-text">进程调度时机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B%E5%B7%B2%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E4%BB%BB%E5%8A%A1%E8%80%8C%E7%BB%93%E6%9D%9F%EF%BC%8C%E6%88%96%E8%80%85%E7%94%B1%E4%BA%8E%E6%9F%90%E7%A7%8D%E9%94%99%E8%AF%AF%E8%80%8C%E8%A2%AB%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C%E3%80%82"><span class="nav-text">当前运行进程已完成所有工作任务而结束，或者由于某种错误而被终止运行。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B%E5%9B%A0%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E6%9F%90%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E7%94%9F%E8%80%8C%E8%BD%AC%E5%8F%98%E6%88%90%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81%EF%BC%8C%E5%A6%82%E7%AD%89%E5%BE%85IO%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%8C%E6%88%90%EF%BC%8C%E6%88%96%E6%89%A7%E8%A1%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84wait-%E6%93%8D%E4%BD%9C%E6%97%B6%E5%9B%A0%E6%9D%A1%E4%BB%B6%E4%B8%8D%E6%BB%A1%E8%B6%B3%E8%80%8C%E8%A2%AB%E9%98%BB%E5%A1%9E%E7%AD%89%E3%80%82"><span class="nav-text">当前运行进程因需要等待某事件的发生而转变成阻塞状态，如等待IO操作的完成，或执行信号量的wait()操作时因条件不满足而被阻塞等。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B%E6%97%B6%E9%97%B4%E7%89%87%E7%94%A8%E5%AE%8C%E3%80%82"><span class="nav-text">在分时系统中，当前运行进程时间片用完。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%87%87%E7%94%A8%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F%E8%B0%83%E5%BA%A6%EF%BC%8C%E5%BD%93%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E4%B8%AD%E5%87%BA%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E6%9B%B4%E9%AB%98%E7%9A%84%E5%B0%B1%E7%BB%AA%E8%BF%9B%E7%A8%8B%E6%97%B6%E3%80%82"><span class="nav-text">采用基于优先级的抢占方式调度，当就绪队列中出现优先级更高的就绪进程时。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%88%90%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%88%96%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%90%8E%EF%BC%8C%E5%9C%A8%E8%BF%94%E5%9B%9E%E5%88%B0%E7%94%A8%E6%88%B7%E6%80%81%E4%B9%8B%E5%89%8D%EF%BC%8C%E9%80%9A%E5%B8%B8%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%B8%80%E6%AC%A1%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA%E3%80%82"><span class="nav-text">系统完成系统调用或中断处理后，在返回到用户态之前，通常会产生一次调度时机。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%E5%8F%8A%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%BA%94%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-text">选择进程调度方式及调度算法应考虑的因素</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="nav-text">系统设计目标</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text">调度的公平性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%9A%84%E5%9D%87%E8%A1%A1%E5%88%A9%E7%94%A8"><span class="nav-text">资源的均衡利用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%88%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BC%80%E9%94%80"><span class="nav-text">合理的系统开销</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%80%A7%E8%83%BD%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="nav-text">调度性能的评价指标</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CPU%E7%9A%84%E5%88%A9%E7%94%A8%E7%8E%87"><span class="nav-text">CPU的利用率</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-text">系统吞吐量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4%E5%92%8C%E5%B8%A6%E6%9D%83%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="nav-text">周转时间和带权周转时间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="nav-text">响应时间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-text">对截止时间的保证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">先来先服务调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">短作业优先调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">高响应比优先调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">优先级调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">时间片轮转调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">多级队列调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E9%98%9F%E5%88%97%E6%9C%89%E8%87%AA%E5%B7%B1%E7%8B%AC%E7%AB%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">每个队列有自己独立的调度算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%84%E9%98%9F%E5%88%97%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8D%E5%90%8C"><span class="nav-text">各队列之间的优先级不同</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%89%80%E5%9C%A8%E9%98%9F%E5%88%97%E5%9B%BA%E5%AE%9A"><span class="nav-text">进程所在队列固定</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">多级反馈队列调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97"><span class="nav-text">设置多个就绪队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%84%E9%98%9F%E5%88%97%E5%86%85%E9%83%A8%E6%8C%89%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%B0%83%E5%BA%A6"><span class="nav-text">各队列内部按时间片轮转算法进行调度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%84%E9%98%9F%E5%88%97%E4%B9%8B%E9%97%B4%E9%87%87%E7%94%A8%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95%E8%B0%83%E5%BA%A6"><span class="nav-text">各队列之间采用抢占式优先级算法调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="nav-text">Linux调度算法解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-1"><span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%B1%BB%E5%9E%8B"><span class="nav-text">进程通信类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%BC%93%E5%86%B2%E9%98%9F%E5%88%97%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">消息缓冲队列通信机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">Linux进程通信机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-text">进程死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">死锁的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">死锁的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">产生死锁的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%E8%B5%84%E6%BA%90"><span class="nav-text">竞争资源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A8%E8%BF%9B%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%BD%93"><span class="nav-text">进程推进顺序不当</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">产生死锁的必要条件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="nav-text">互斥条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%A0%E6%9C%89%E4%B8%94%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-text">占有且等待条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="nav-text">不可剥夺条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-text">循环等待条件</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-text">处理死锁的基本方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-text">预防死锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81"><span class="nav-text">检测和解除死锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81-1"><span class="nav-text">预防死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E5%8D%A0%E6%9C%89%E4%B8%94%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-text">破坏占有且等待条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="nav-text">破坏不可剥夺条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="nav-text">破坏循环等待条件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81-1"><span class="nav-text">避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="nav-text">安全状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-text">银行家算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigstar-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="nav-text">$\bigstar$ 银行家算法举例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="nav-text">死锁的检测与解除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="nav-text">资源分配图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="nav-text">死锁定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="nav-text">死锁检测算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E6%97%B6%E6%9C%BA"><span class="nav-text">死锁检测时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="nav-text">死锁的解除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="nav-text">线程机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">线程的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">线程的引入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">线程与进程的比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">多线程的应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">线程的实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8BULT-User-LevelThreads"><span class="nav-text">用户级线程ULT(User LevelThreads)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8BKLT-Kernel-LevelThreads"><span class="nav-text">内核级线程KLT(Kernel LevelThreads)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F"><span class="nav-text">组合方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="nav-text">多对一模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="nav-text">一对一模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B"><span class="nav-text">多对多模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="nav-text">Linux线程机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-2"><span class="nav-text">本章小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B9%A0%E9%A2%98-2"><span class="nav-text">本章习题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%80%83%E7%A0%94%E8%BE%85%E5%AF%BC%E4%B9%A62021%E7%89%88%E6%9C%AC"><span class="nav-text">考研辅导书2021版本</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-text">线程的描述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%AF%E8%83%BD%E6%80%A7"><span class="nav-text">进程的状态可能性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-1"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">管理进程的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-2"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-text">就绪队列中进程的数量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-3"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-text">进程状态改变的数量</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-4"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E5%B0%B1%E7%BB%AA%E6%80%81%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">$\bigtriangledown$ 就绪态的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">进程执行的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-5"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">多对一线程方式的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-6"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-text">线程与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-7"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-text">选择新进程的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-8"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E6%94%BE%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">$\bigtriangledown$ 数据结构存放的位置</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-9"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PCB%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-text">PCB中的内容</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-10"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%B1%E7%BB%AA%E9%98%9F%E5%88%97%E5%AF%B9CPU%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">就绪队列对CPU的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-11"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigstar-IO%E8%AE%BE%E5%A4%87%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-text">$\bigstar$ IO设备与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-12"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%BD%BF%E7%94%A8"><span class="nav-text">$\bigtriangledown$ 进程控制使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-13"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-14"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-text">管道的描述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-15"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92%E6%9C%89%E5%85%B3%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="nav-text">进程唤醒有关的事件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-16"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0-1"><span class="nav-text">线程的描述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-17"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-text">$\bigtriangledown$ 时间片轮转的目的</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-18"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E5%88%A9%E4%BA%8EIO%E7%B9%81%E5%BF%99%E8%B0%83%E5%BA%A6%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">有利于IO繁忙调度的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-19"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">调度方式的选择</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-20"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">优先级的设置</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-21"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E7%9B%B8%E5%BA%94%E6%AF%94%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-text">$\bigtriangledown$ 相应比的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-22"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%9D%E5%AF%B9%E5%8F%AF%E6%8A%A2%E5%8D%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">绝对可抢占的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-23"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigstar-SJF%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A2%98"><span class="nav-text">$\bigstar$ SJF的计算题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-24"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86"><span class="nav-text">多道批处理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-25"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="nav-text">并发执行</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-26"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E5%AF%B9%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%B8%8D%E5%88%A9%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">$\bigtriangledown$ 对短作业不利的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-27"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigstar-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%A4%BC%E5%8C%85"><span class="nav-text">$\bigstar$ 总结大礼包</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-28"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%82"><span class="nav-text">杂</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-29"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-text">处理机调度</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-30"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E4%BA%A7%E7%94%9F%E9%A5%A5%E9%A5%BF"><span class="nav-text">不产生饥饿</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-31"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-%E8%80%83%E7%A0%94%E7%9C%9F%E9%A2%98"><span class="nav-text">优先级调度-考研真题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-32"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="nav-text">二级反馈队列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-33"><span class="nav-text">解析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">第四章 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-text">存储器管理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB"><span class="nav-text">多级存储器体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="nav-text">存储器管理功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-text">内存的分配与回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-text">地址映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%85%B1%E4%BA%AB"><span class="nav-text">内存的保护和共享</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85"><span class="nav-text">内存扩充</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="nav-text">程序的装入和链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E9%93%BE%E6%8E%A5%E5%B7%A5%E4%BD%9C%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-text">根据链接工作进行的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">静态链接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">装入时动态链接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-text">运行时动态链接</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-text">根据地址映射进行的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5"><span class="nav-text">绝对装入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5"><span class="nav-text">静态重定位装入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5"><span class="nav-text">动态重定位装入</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">连续存储器管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F"><span class="nav-text">固定分区方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F"><span class="nav-text">可变分区方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-text">分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-text">首次适应算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-text">最佳适应算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-text">最坏适应算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-text">回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8A%E9%82%BB%E6%8E%A5"><span class="nav-text">上邻接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8B%E9%82%BB%E6%8E%A5"><span class="nav-text">下邻接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E9%82%BB%E6%8E%A5"><span class="nav-text">上下邻接</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A0%E9%82%BB%E6%8E%A5"><span class="nav-text">无邻接</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">分页存储管理基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E4%B8%8E%E9%A1%B5%E6%A1%86"><span class="nav-text">页与页框</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-text">逻辑地址结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-text">页表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E8%B6%8A%E7%95%8C%E4%BF%9D%E6%8A%A4"><span class="nav-text">地址映射与越界保护</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8"><span class="nav-text">快表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%BA%A7%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-text">两级和多级页表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E6%96%B9%E5%BC%8F"><span class="nav-text">分段存储管理基本方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5"><span class="nav-text">段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84-1"><span class="nav-text">逻辑地址结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E8%A1%A8"><span class="nav-text">段表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E8%B6%8A%E7%95%8C%E4%BF%9D%E6%8A%A4-1"><span class="nav-text">地址映射与越界保护</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="nav-text">段共享与保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">段页式存储管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="nav-text">虚拟存储系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">虚拟存储器的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B9%E5%8F%98"><span class="nav-text">改变</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%86%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%80%E6%AC%A1%E6%80%A7%E6%88%96%E8%80%85%E6%95%B4%E4%BD%93%E6%80%A7%E6%94%B9%E4%B8%BA%E5%A4%9A%E6%AC%A1%E6%80%A7"><span class="nav-text">将程序装入的一次性或者整体性改为多次性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%86%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%A9%BB%E7%95%99%E6%80%A7%E6%94%B9%E4%B8%BA%E7%BD%AE%E6%8D%A2%E6%80%A7"><span class="nav-text">将进程的驻留性改为置换性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">三种实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5"><span class="nav-text">请求分页</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5"><span class="nav-text">请求分段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%AE%B5%E9%A1%B5"><span class="nav-text">请求段页</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%82%A8%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">请求分页储存管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8-1"><span class="nav-text">页表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%BD%8DP"><span class="nav-text">状态位P</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%AD%97%E6%AE%B5A"><span class="nav-text">访问字段A</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E4%BD%8DM"><span class="nav-text">修改位M</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%96%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="nav-text">外存地址</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="nav-text">缺页中断机构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E6%9C%BA%E6%9E%84"><span class="nav-text">地址映射机构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8-%E9%A2%A0%E7%B0%B8-thrashing"><span class="nav-text">抖动&#x2F;颠簸(thrashing)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86-work-set"><span class="nav-text">工作集(work set)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="nav-text">页面置换策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-Optimal-OPT"><span class="nav-text">最佳置换算法(Optimal,OPT)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-First-In-First-Out-FIFO"><span class="nav-text">先进先出置换算法(First In First Out,FIFO)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-Least-Recently-Used-LRU"><span class="nav-text">最近最久未使用置换算法(Least Recently Used,LRU)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-Least-Frequently-Used-LFU"><span class="nav-text">最近最少使用置换算法(Least Frequently Used, LFU)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%B6%E9%92%9F-CLOCK-%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">时钟(CLOCK)置换算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%86%B2%E6%80%9D%E6%83%B3"><span class="nav-text">页面缓冲思想</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">Linux内存管理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-text">Linux的物理内存空间管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-text">Linux虚拟地址空间管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-3"><span class="nav-text">本章小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B9%A0%E9%A2%98-3"><span class="nav-text">本章习题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%80%83%E7%A0%94%E8%BE%85%E5%AF%BC%E4%B9%A6"><span class="nav-text">考研辅导书</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-text">逻辑地址的产生</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-34"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="nav-text">交换技术</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-1"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-35"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="nav-text">覆盖技术</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-2"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-36"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-text">最佳适配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-3"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-37"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%90%88%E5%B9%B6"><span class="nav-text">分区合并</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-4"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-38"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">动态重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-5"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-39"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E5%92%8C%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87"><span class="nav-text">外部碎片和内部碎片</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-6"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-40"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-text">内存保护</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-7"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-41"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-text">物理地址空间的大小</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-8"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-42"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80"><span class="nav-text">页表的起始地址</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-9"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-43"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-text">分段的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-10"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-44"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E7%A8%8B%E5%BA%8F"><span class="nav-text">可重入程序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-11"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-45"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4"><span class="nav-text">动态分区的创建时间</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-12"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-46"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E5%AD%98%E5%85%91%E6%8D%A2%E5%8C%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87"><span class="nav-text">外存兑换区的主要目标</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-13"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-47"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95-1"><span class="nav-text">最佳适应算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-14"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-48"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F"><span class="nav-text">选择页面大小</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-15"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-49"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8D%95%E4%BD%8D"><span class="nav-text">主存储器的单位</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-16"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-50"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E5%88%86%E9%85%8D%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98"><span class="nav-text">段式分配访问内存</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-17"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-51"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%88%86%E9%85%8D%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-text">段页式分配访问内存的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-18"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-52"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%9A%84%E6%80%9D%E6%83%B3"><span class="nav-text">段页式的思想</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-19"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-53"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E8%A1%A8%E8%BF%B0"><span class="nav-text">页式存储的表述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-20"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-54"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigstar-%E4%BA%8C%E7%BA%A7%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-text">$\bigstar$ 二级分页存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-21"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-55"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%AE%B9%E6%98%93%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-text">最容易产生内存碎片</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-22"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-56"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigstar-%E7%AD%94%E6%A1%88%E6%9C%AA%E7%9F%A5"><span class="nav-text">$\bigstar$ 答案未知</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-23"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-57"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E4%B8%AD%E6%96%AD%E6%AC%A1%E6%95%B0"><span class="nav-text">$\bigtriangledown$ 中断次数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-24"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-58"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E7%BC%BA%E9%A1%B5%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">$\bigtriangledown$ 缺页时的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-25"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-59"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B0%91%E7%9A%84%E7%BC%BA%E9%A1%B5%E6%AC%A1%E6%95%B0"><span class="nav-text">最少的缺页次数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-26"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-60"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F"><span class="nav-text">$\bigtriangledown$ 虚拟存储器的最大容量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">抖动的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AD%94%E6%A1%88-27"><span class="nav-text">答案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-61"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigstar-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-text">$\bigstar$ 地址空间的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-62"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD"><span class="nav-text">$\bigtriangledown$ 提高性能</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-63"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigtriangledown-%E6%8F%90%E9%AB%98cpu%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87"><span class="nav-text">$\bigtriangledown$ 提高cpu资源利用率</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-64"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bigstar-Clock%E7%AE%97%E6%B3%95"><span class="nav-text">$\bigstar$ Clock算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-65"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-text">请求分页的组合</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-66"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="nav-text">工作集</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-67"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LRU%E8%AE%A1%E7%AE%97%E9%A2%98"><span class="nav-text">LRU计算题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-68"><span class="nav-text">解析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-text">第五章 设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">设备管理的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="nav-text">输入输出系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">设备的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">设备控制器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">设备控制器的组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E9%80%9A%E9%81%93"><span class="nav-text">I&#x2F;O通道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-text">I&#x2F;O系统结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">输入输出控制方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86"><span class="nav-text">缓冲管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">缓冲的实现机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E8%BD%AF%E4%BB%B6"><span class="nav-text">I&#x2F;O软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B"><span class="nav-text">I&#x2F;O软件的层次模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E4%BA%8E%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="nav-text">独立于设备的软件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E4%B8%8E%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8A%9F%E8%83%BD"><span class="nav-text">独立与设备的软件功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">设备驱动程序的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-text">设备驱动程序的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E7%94%B1%E7%8B%AC%E7%AB%8B%E4%BA%8E%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8F%91%E6%9D%A5%E7%9A%84%E5%91%BD%E4%BB%A4%E5%92%8C%E5%8F%82%E6%95%B0"><span class="nav-text">接收由独立于设备的软件发来的命令和参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%94%A8%E6%88%B7I-O%E8%AF%B7%E6%B1%82%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7"><span class="nav-text">检查用户I&#x2F;O请求的合法性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%91%E5%87%BAI-O%E5%91%BD%E4%BB%A4"><span class="nav-text">发出I&#x2F;O命令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%8A%E6%97%B6%E5%93%8D%E5%BA%94%E7%94%B1%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8F%91%E6%9D%A5%E7%9A%84%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86"><span class="nav-text">及时响应由设备控制器发来的中断请求，调用相关的中断处理程序进行处理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%85%B7%E6%9C%89%E9%80%9A%E9%81%93%E7%BB%93%E6%9E%84%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E7%9A%84I-O%E8%AF%B7%E6%B1%82%E6%9E%84%E9%80%A0%E9%80%9A%E9%81%93%E7%A8%8B%E5%BA%8F"><span class="nav-text">对于具有通道结构的系统，还需要根据用户的I&#x2F;O请求构造通道程序</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">设备驱动程序的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%AE%9E%E7%8E%B0%E7%8B%AC%E7%AB%8B%E4%BA%8E%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%92%8C%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="nav-text">驱动程序是实现独立于设备的软件和设备控制器之间通信与转换的程序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BB%A5%E5%8F%8AI-O%E8%AE%BE%E5%A4%87%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%89%B9%E6%80%A7%E7%B4%A7%E5%AF%86%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%9A%84I-O%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F%E6%98%AF%E7%BB%88%E7%AB%AF%E9%A9%B1%E5%8A%A8%E5%92%8CDMA%E6%96%B9%E5%BC%8F"><span class="nav-text">驱动程序与设备控制器以及I&#x2F;O设备的硬件特性紧密相关，常用的I&#x2F;O驱动方式是终端驱动和DMA方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%B1%E4%BA%8E%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%A1%AC%E4%BB%B6%E7%B4%A7%E5%AF%86%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%9B%A0%E8%80%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%BF%85%E9%A1%BB%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99"><span class="nav-text">由于驱动程序与硬件紧密相关，因而其中一部分代码必须用汇编语言编写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BA%94%E5%85%81%E8%AE%B8%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="nav-text">驱动程序应允许可重入</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">设备处理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#TODO"><span class="nav-text">TODO</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TODO-1"><span class="nav-text">TODO</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8D%E8%AE%BE%E7%BD%AE%E4%B8%93%E9%97%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E8%80%8C%E5%8F%AA%E4%B8%BA%E5%90%84%E7%B1%BB%E8%AE%BE%E5%A4%87%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%BA%94%E7%9A%84%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BE%9B%E7%94%A8%E6%88%B7%E6%88%96%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%E3%80%82"><span class="nav-text">不设置专门的进程，而只为各类设备设置相应的设备驱动程序，供用户或系统进程调用。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-text">设备驱动程序的处理过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%86%E6%8A%BD%E8%B1%A1%E8%A6%81%E6%B1%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B7%E4%BD%93%E8%A6%81%E6%B1%82"><span class="nav-text">将抽象要求转换为具体要求</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E6%9C%8D%E5%8A%A1%E8%AF%B7%E6%B1%82%E8%BF%9B%E8%A1%8C%E6%A0%A1%E9%AA%8C"><span class="nav-text">对服务请求进行校验</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E8%AE%BE%E5%A4%87%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">检查设备的状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%A0%E9%80%81%E5%BF%85%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">传送必要的参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8I-O%E8%AE%BE%E5%A4%87"><span class="nav-text">启动I&#x2F;O设备</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D"><span class="nav-text">设备分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">设备分配的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E8%A1%A8%E8%A1%A8%EF%BC%88DCT%EF%BC%89"><span class="nav-text">设备控制表表（DCT）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8%EF%BC%88CODT%EF%BC%89"><span class="nav-text">控制器控制表（CODT）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E8%A1%A8%EF%BC%88CHCT%EF%BC%89"><span class="nav-text">通道控制表（CHCT）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%A1%A8%EF%BC%88%E8%AE%BE%E5%A4%87%E7%B1%BB%E8%A1%A8%EF%BC%89-SDT"><span class="nav-text">系统设备表（设备类表）(SDT)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-text">设备分配过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B-1"><span class="nav-text">设备分配过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E8%AE%BE%E5%A4%87"><span class="nav-text">分配设备</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">分配控制器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E9%80%9A%E9%81%93"><span class="nav-text">分配通道</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPOOLing%E7%B3%BB%E7%BB%9F"><span class="nav-text">SPOOLing系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">Linux字符设备驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80"><span class="nav-text">Linux字符设备驱动程序基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">字符驱动程序设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B8%BE%E4%BE%8B"><span class="nav-text">字符驱动程序举例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">Linux中断处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="nav-text">Linux中断处理机制概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E6%B3%A8%E9%94%80"><span class="nav-text">中断服务例程的注册和注销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E5%8D%8A%E9%83%A8%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-text">上半部的处理过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">下半部的实现机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-4"><span class="nav-text">本章小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B9%A0%E9%A2%98-4"><span class="nav-text">本章习题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%9C%BA%E5%88%B6"><span class="nav-text">缓冲机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">第六章 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-text">文件的组织结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">逻辑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%88%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%88%96%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6%EF%BC%89"><span class="nav-text">物理结构（存储结构或物理文件）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="nav-text">文件目录管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86-1"><span class="nav-text">文件目录管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-text">文件目录结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-text">文件存储空间管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E5%92%8C%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="nav-text">文件共享和文件保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-text">文件共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="nav-text">文件保护</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD"><span class="nav-text">文件备份</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E5%A4%87%E4%BB%BD"><span class="nav-text">批量备份</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%A4%87%E4%BB%BD"><span class="nav-text">同步备份</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E4%BF%9D%E6%8A%A4"><span class="nav-text">文件访问保护</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="nav-text">口令保护</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4"><span class="nav-text">加密保护</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%86%99%E6%9D%83%E9%99%90"><span class="nav-text">设置文件访问写权限</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%86%99%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">设置文件访问写权限的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9F%A9%E9%98%B5"><span class="nav-text">访问控制矩阵</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E8%A1%A8"><span class="nav-text">访问控制表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%A1%A8"><span class="nav-text">用户权限表</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="nav-text">磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-text">磁盘管理概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">磁盘调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E8%87%82%E8%B0%83%E5%BA%A6"><span class="nav-text">移臂调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88First-Come-First-Served%EF%BC%8CFCFS%EF%BC%89%E7%AE%97%E6%B3%95"><span class="nav-text">先来先服务（First Come First Served，FCFS）算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-ShortestSeekTimeFirst-SSTF-%E7%AE%97%E6%B3%95"><span class="nav-text">最短寻道时间优先(ShortestSeekTimeFirst,SSTF)算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%EF%BC%88SCAN%EF%BC%89%E7%AE%97%E6%B3%95-%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95"><span class="nav-text">扫描（SCAN）算法(电梯算法)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%EF%BC%88Circular-SCAN%EF%BC%8CCSCAN%EF%BC%89%E7%AE%97%E6%B3%95"><span class="nav-text">循环扫描（Circular SCAN，CSCAN）算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#N-Step-SCAN%E7%AE%97%E6%B3%95"><span class="nav-text">N-Step-SCAN算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FSCAN%EF%BC%88FairSCAN%EF%BC%89%E7%AE%97%E6%B3%95"><span class="nav-text">FSCAN（FairSCAN）算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E8%B0%83%E5%BA%A6"><span class="nav-text">旋转调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#misc"><span class="nav-text">misc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-text">问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%83%E7%A0%94%E4%B9%A6%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="nav-text">考研书的题目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%A0%94%E4%B9%A6%E9%A2%98%E7%9B%AE"><span class="nav-text">考研书题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2018-2019-1-OS-A-pdf"><span class="nav-text">2018-2019-1 OS A.pdf</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#misc-1"><span class="nav-text">misc</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ednow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ednow</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '04b9fe1c5636beb4acc4',
      clientSecret: '8ccb8829887eac219a8fdb018878fd0cf088a7ac',
      repo        : 'gittalk-comment',
      owner       : 'ednow',
      admin       : ['ednow'],
      id          : '467a5842e2bda33b2b6db145288e5fe5',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
